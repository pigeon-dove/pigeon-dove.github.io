<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2023-04-23小红书春招算法题</title>
    <url>//post/11408/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>原文地址：<a href="https://xuedongyun.cn/post/11408/">https://xuedongyun.cn/post/11408/</a></p>
<h2 id="第一题-小红的数组增值"><a href="#第一题-小红的数组增值" class="headerlink" title="第一题: 小红的数组增值"></a>第一题: 小红的数组增值</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><strong>时间限制:</strong> 3000MS<br><strong>内存限制:</strong> 589824KB<br><strong>题目描述:</strong><br>小红拿到了一个数组，她准备不断进行如下操作<br>1、若a_0=0，则直接删除a_0，并将数组其余的所有元素向左移动来填补空缺。<br>2、否则在数组的未尾添加a_0个a_0-1，然后使得a_0减1。<br>小红想知道，从开始进行操作直到数组为空，她一共进行了多少次操作？答案请对10^9+7取模。<br><strong>输入描述</strong></p>
<blockquote>
<p>第一行输入一个正整数n，代表数组的长度。<br>第二行输入n个正整数a_i，代表数组的元素。<br>1 &lt;= n &lt;= 10^5<br>1 &lt;= a_i &lt;= 10^5</p>
</blockquote>
<p><strong>输出描述</strong></p>
<blockquote>
<p>一个整数，代表操作的次数对10^9+7取模的值。</p>
</blockquote>
<p><strong>样例输入</strong></p>
<blockquote>
<p>2</p>
<p>1 2</p>
</blockquote>
<p><strong>样例输出</strong></p>
<blockquote>
<p>13</p>
</blockquote>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>这道题暴力肯定会超时，我们不妨分析一下将数组中一个数彻底消除需要多少步。设数的值为n，将其完全消除需要dp[n]步。n经过1步，变为n+1个n-1。现在有状态转移方程：</p>
<p><code>dp[n] = (n+1)dp[n-1]+1</code></p>
<p>最后对数组中所有值求和即可</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="number">1_000_000_000</span> + <span class="number">7</span>;</span><br><span class="line">Integer[] ints = <span class="keyword">new</span> <span class="title class_">Integer</span>[]{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">maxValue</span> <span class="operator">=</span> Stream.of(ints).max(Integer::compareTo).get();</span><br><span class="line"><span class="type">long</span>[] dp = <span class="keyword">new</span> <span class="title class_">long</span>[maxValue+<span class="number">1</span>];</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= maxValue; i++) {</span><br><span class="line">    dp[i] = ((i + <span class="number">1</span>) * dp[i - <span class="number">1</span>] + <span class="number">1</span>) % MOD;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (Integer i : ints) {</span><br><span class="line">    result += dp[i];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure></div>



<h2 id="第三题-小红的字符串权值"><a href="#第三题-小红的字符串权值" class="headerlink" title="第三题: 小红的字符串权值"></a>第三题: 小红的字符串权值</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><strong>时间限制:</strong> 3000MS<br><strong>内存限制:</strong> 589824KB<br><strong>题目描述:</strong><br>小红很喜欢’red”字符串，她定义一个字符串的美丽度为: 该字符串包含的”red”子序列的数量。注意子序列是可以不连续的，例<br>如”rreed”包含了4个”red”子序列，因此美丽度为4。<br>小红定义一个字符串的权值为: 该字符用所有连续子串的美丽度之和。例如，”redd”的权值为3，因为它包含了一个”red”连续子串，美<br>丽度为1，包含了一个”redd”连续子串，美丽度为2，其它连续子串的美丽度都为0。<br>小红想知道，长度为n的、仅由字符’r、’e’、’d”构成的所有字符串(共有3个字符串)的权值之和是多少？答案请对10^9+7取模。<br><strong>输入描述</strong></p>
<blockquote>
<p>一个正整数<br>1&lt;= n &lt;= 1000</p>
</blockquote>
<p><strong>输出描述</strong></p>
<blockquote>
<p>长度为n的、仅由字符’r、’e’、’d’构成的所有字符串的权值之和。</p>
</blockquote>
<p><strong>样例输入</strong></p>
<blockquote>
<p>3</p>
</blockquote>
<p><strong>样例输出</strong></p>
<blockquote>
<p>1</p>
</blockquote>
<p><strong>提示</strong></p>
<blockquote>
<p>说明: </p>
<p>长度为3的字符串，仅有”red”权值为1，其余字符串权值为0</p>
</blockquote>
<h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>这道题有一点绕，刚开始可能理不太清除。我们简单来理理: </p>
<ul>
<li>美丽度: 是一个字符串的属性。即包含”red”子序列的数量(子序列可以<strong>不连续</strong>)</li>
<li>权重: 也是一个字符串的属性。即字符串所有<strong>连续</strong>子序列的”美丽度”之合</li>
</ul>
<p>现在我们要求的是: 给定长度n的字符串，所有排列组合可能的”权值”之和。毋庸置疑，这种计算量的题目必定是用动态规划做的。下面分享一下我的做法，我们可以将问题拆分为若干个子问题: </p>
<p><strong>第一步: 给定长度n的字符串，所有排列组合中，会出现多少对”re”(r和e可以不连续)</strong></p>
<p>这可以通过动态规划来求，假设<code>re[n]</code>表示长度为n的字符串，所有排列中”re”(可以不连续)出现的次数。那么<code>re[n+1]</code>其实就是在原有”re”对的基础上，增加之前的r搭配后面的e的组合。因此，可以列出状态转移方程: </p>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="31.403ex" height="2.452ex" role="img" focusable="false" viewBox="0 -833.9 13880.3 1083.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(451,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mo" transform="translate(917,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mi" transform="translate(1195,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(2017.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(3017.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(3517.4,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g><g data-mml-node="mo" transform="translate(4073.2,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(5129,0)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g><g data-mml-node="mo" transform="translate(5851.2,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="mi" transform="translate(6851.4,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(7302.4,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mo" transform="translate(7768.4,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mi" transform="translate(8046.4,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(8646.4,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g><g data-mml-node="mo" transform="translate(9146.7,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(10146.9,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(10969.1,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="msup" transform="translate(11969.3,0)"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(600,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(1378,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></g></g></svg></mjx-container></p>
<blockquote>
<p>解释: </p>
<ul>
<li>因为新增了一位(r，e，d三种可能)，所以原有”re”对的数量会翻三倍</li>
<li>至于前面的”r”搭配后面的”e”的情况，我们只需要看前面长度为n的序列中能产生多少”r”即可。具体来说，前面n位一共有<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="2.279ex" height="1.578ex" role="img" focusable="false" viewBox="0 -675.5 1007.3 697.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g></g></svg></mjx-container>种排列，每种排列包含n个字母。又因为每个字母出现概率均等，因此”r”出现的次数为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.081ex;" xmlns="http://www.w3.org/2000/svg" width="10.299ex" height="1.61ex" role="img" focusable="false" viewBox="0 -675.5 4552.2 711.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g><g data-mml-node="mo" transform="translate(1229.5,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="mi" transform="translate(2229.7,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(3051.9,0)"><path data-c="F7" d="M318 466Q318 500 339 518T386 537Q418 537 438 517T458 466Q458 438 440 417T388 396Q355 396 337 417T318 466ZM56 237T56 250T70 270H706Q721 262 721 250T706 230H70Q56 237 56 250ZM318 34Q318 68 339 86T386 105Q418 105 438 85T458 34Q458 6 440 -15T388 -36Q355 -36 337 -15T318 34Z"></path></g><g data-mml-node="mn" transform="translate(4052.2,0)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g></g></g></svg></mjx-container></li>
</ul>
</blockquote>
<p>现在我们能计算: 给定长度的序列的所有排列中，能找到多少”re”对</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/24/DNK7TwFtbGsR8MC.png" alt="image-20230424141054981"></p>
<p><strong>第二步: 给定长度n的字符串，所有排列组合中，会出现多少组”red”(r，e和d可以不连续)</strong></p>
<p>同样的思路，假设<code>red[n]</code>表示长度为n的字符串，所有排列中”red”(可以不连续)出现的次数。给出状态转移方程: </p>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="30ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 13259.9 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(451,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mi" transform="translate(917,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mo" transform="translate(1437,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mi" transform="translate(1715,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(2537.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(3537.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(4037.4,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g><g data-mml-node="mo" transform="translate(4593.2,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(5649,0)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g><g data-mml-node="mo" transform="translate(6371.2,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="mi" transform="translate(7371.4,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(7822.4,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mi" transform="translate(8288.4,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mo" transform="translate(8808.4,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mi" transform="translate(9086.4,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(9686.4,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g><g data-mml-node="mo" transform="translate(10186.7,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(11186.9,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(11637.9,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mo" transform="translate(12103.9,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mi" transform="translate(12381.9,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(12981.9,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g></g></g></svg></mjx-container></p>
<blockquote>
<p>解释: </p>
<ul>
<li>因为新增了一位(r，e，d三种可能)，所以原有”red”的数量会翻三倍</li>
<li>如果新增一个”d”，会导致前面”re”加上新增的”d”产生新的”red”</li>
</ul>
</blockquote>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/24/mo9JUMTctQEA2L7.png" alt="image-20230424143448006"></p>
<p><strong>第三步: 给定长度n的字符串，所有排列组合，”权重”之和</strong></p>
<p>我们继续用动态规划的思路来做。我们重点关注多了一位后，会导致所有连续子序列的”美丽度”多多少。</p>
<ul>
<li>考虑一: 原有美丽度会多多少</li>
</ul>
<p>我们先什么都不管，只考虑在末尾多了一个字母后，原有的所有连续子序列种”red”会变多多少？很明显，由于多了一个字母(r，e，d三种可能)，原有”美丽度会翻三倍”。</p>
<p><strong>考虑一中新增的美丽度:</strong> <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="8.827ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 3901.4 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g><g data-mml-node="mo" transform="translate(722.2,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="mi" transform="translate(1722.4,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mi" transform="translate(2242.4,0)"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"></path></g><g data-mml-node="mo" transform="translate(2745.4,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mi" transform="translate(3023.4,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(3623.4,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g></g></g></svg></mjx-container></p>
<ul>
<li>考虑二: 现在末尾多了一位，暂时不算它。现在会产生新的连续子序列，导致”美丽度”增加。</li>
</ul>
<p>增加的”美丽度”其实就是长度为1, 2, 3, 4…n这几个连续子序列中“red”产生的。</p>
<blockquote>
<p>举例说明:<code>"red"</code></p>
<p>连续子序列有: “red”(美丽度1)，因此总权重为1。</p>
<p>多一个”r”，变为<code>"redr"</code>，连续子序列有: “red”(美丽度1)，”redr”(美丽度1)，因此总权重为2。</p>
<p>前后虽然”red”没有变多，但是”美丽度”却变多了，导致权重增加。</p>
</blockquote>
<p>举例来说，对于长度为5的，在末尾位置结束的连续子序列，新增美丽度为:  <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="59.338ex" height="2.452ex" role="img" focusable="false" viewBox="0 -833.9 26227.3 1083.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g><g data-mml-node="mo" transform="translate(500,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(889,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">多</text></g><g data-mml-node="mi" transform="translate(1889,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">的</text></g><g data-mml-node="mi" transform="translate(2889,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">一</text></g><g data-mml-node="mi" transform="translate(3889,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">位</text></g><g data-mml-node="mi" transform="translate(4889,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">有</text></g><g data-mml-node="mi" transform="translate(5889,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">三</text></g><g data-mml-node="mi" transform="translate(6889,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">种</text></g><g data-mml-node="mi" transform="translate(7889,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">可</text></g><g data-mml-node="mi" transform="translate(8889,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">能</text></g><g data-mml-node="mo" transform="translate(9889,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(10500.2,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="mi" transform="translate(11500.4,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(11951.4,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mi" transform="translate(12417.4,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mo" transform="translate(12937.4,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mn" transform="translate(13215.4,0)"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"></path></g><g data-mml-node="mo" transform="translate(13715.4,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g><g data-mml-node="mo" transform="translate(14215.7,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="msup" transform="translate(15215.9,0)"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(600,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(1378,0)"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"></path></g></g></g><g data-mml-node="mo" transform="translate(17126.8,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(17515.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">前</text></g><g data-mml-node="mi" transform="translate(18515.8,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(19338.1,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(20338.3,0)"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"></path></g><g data-mml-node="mi" transform="translate(20838.3,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">位</text></g><g data-mml-node="mi" transform="translate(21838.3,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">随</text></g><g data-mml-node="mi" transform="translate(22838.3,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">便</text></g><g data-mml-node="mi" transform="translate(23838.3,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">排</text></g><g data-mml-node="mi" transform="translate(24838.3,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">列</text></g><g data-mml-node="mo" transform="translate(25838.3,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container> ，最终所有新增量相加即可。</p>
<p><strong>考虑二中新增的美丽度:</strong> <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.663ex;" xmlns="http://www.w3.org/2000/svg" width="19.942ex" height="2.542ex" role="img" focusable="false" viewBox="0 -830.4 8814.2 1123.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="munderover"><g data-mml-node="mo"><path data-c="2211" d="M61 748Q64 750 489 750H913L954 640Q965 609 976 579T993 533T999 516H979L959 517Q936 579 886 621T777 682Q724 700 655 705T436 710H319Q183 710 183 709Q186 706 348 484T511 259Q517 250 513 244L490 216Q466 188 420 134T330 27L149 -187Q149 -188 362 -188Q388 -188 436 -188T506 -189Q679 -189 778 -162T936 -43Q946 -27 959 6H999L913 -249L489 -250Q65 -250 62 -248Q56 -246 56 -239Q56 -234 118 -161Q186 -81 245 -11L428 206Q428 207 242 462L57 717L56 728Q56 744 61 748Z"></path></g><g data-mml-node="mi" transform="translate(1089,477.1) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(1089,-285.4) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(1729.9,0)"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g><g data-mml-node="mo" transform="translate(722.2,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="mi" transform="translate(1722.4,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(2173.4,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mi" transform="translate(2639.4,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mo" transform="translate(3159.4,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mi" transform="translate(3437.4,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(3782.4,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g><g data-mml-node="mo" transform="translate(4282.7,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="msup" transform="translate(5282.9,0)"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(600,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(1378,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></g></g></g></svg></mjx-container></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/24/l6OYoGzXFZLACJb.png" alt="image-20230424150621083"></p>
<ul>
<li>考虑三: 末尾多了一位”d”，与前面”re”新组合为”red”，导致”美丽度增多”</li>
</ul>
<p>和考虑二中思路类似。增加的”美丽度”其实就是长度为1, 2, 3, 4…n这几个连续子序列中“re”产生的。</p>
<p>举例来说，对于长度为5的，在末尾位置结束的连续子序列，新增美丽度为:<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="32.142ex" height="2.452ex" role="img" focusable="false" viewBox="0 -833.9 14206.8 1083.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(451,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mo" transform="translate(917,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mn" transform="translate(1195,0)"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"></path></g><g data-mml-node="mo" transform="translate(1695,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g><g data-mml-node="mo" transform="translate(2195.2,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="msup" transform="translate(3195.4,0)"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(600,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(1378,0)"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"></path></g></g></g><g data-mml-node="mo" transform="translate(5106.4,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(5495.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">前</text></g><g data-mml-node="mi" transform="translate(6495.4,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(7317.6,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(8317.8,0)"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"></path></g><g data-mml-node="mi" transform="translate(8817.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">位</text></g><g data-mml-node="mi" transform="translate(9817.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">随</text></g><g data-mml-node="mi" transform="translate(10817.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">便</text></g><g data-mml-node="mi" transform="translate(11817.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">排</text></g><g data-mml-node="mi" transform="translate(12817.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">列</text></g><g data-mml-node="mo" transform="translate(13817.8,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></p>
<p><strong>考虑三中新增的美丽度:</strong> <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.663ex;" xmlns="http://www.w3.org/2000/svg" width="14.868ex" height="2.542ex" role="img" focusable="false" viewBox="0 -830.4 6571.7 1123.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="munderover"><g data-mml-node="mo"><path data-c="2211" d="M61 748Q64 750 489 750H913L954 640Q965 609 976 579T993 533T999 516H979L959 517Q936 579 886 621T777 682Q724 700 655 705T436 710H319Q183 710 183 709Q186 706 348 484T511 259Q517 250 513 244L490 216Q466 188 420 134T330 27L149 -187Q149 -188 362 -188Q388 -188 436 -188T506 -189Q679 -189 778 -162T936 -43Q946 -27 959 6H999L913 -249L489 -250Q65 -250 62 -248Q56 -246 56 -239Q56 -234 118 -161Q186 -81 245 -11L428 206Q428 207 242 462L57 717L56 728Q56 744 61 748Z"></path></g><g data-mml-node="mi" transform="translate(1089,477.1) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(1089,-285.4) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(1729.9,0)"><g data-mml-node="mi"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(451,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mo" transform="translate(917,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mi" transform="translate(1195,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1540,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g><g data-mml-node="mo" transform="translate(2040.2,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="msup" transform="translate(3040.4,0)"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(600,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(1378,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></g></g></g></svg></mjx-container></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/24/EBY1eRal9qvt5r7.png" alt="image-20230424152217263"></p>
<ul>
<li>最终我们得到状态转移方程</li>
</ul>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.663ex;" xmlns="http://www.w3.org/2000/svg" width="61.012ex" height="2.542ex" role="img" focusable="false" viewBox="0 -830.4 26967.2 1123.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mi" transform="translate(520,0)"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"></path></g><g data-mml-node="mo" transform="translate(1023,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mi" transform="translate(1301,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(2123.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(3123.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(3623.4,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g><g data-mml-node="mo" transform="translate(4179.2,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(5235,0)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g><g data-mml-node="mo" transform="translate(5957.2,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="mi" transform="translate(6957.4,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mi" transform="translate(7477.4,0)"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"></path></g><g data-mml-node="mo" transform="translate(7980.4,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mi" transform="translate(8258.4,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(8858.4,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g><g data-mml-node="mo" transform="translate(9358.7,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="munderover" transform="translate(10358.9,0)"><g data-mml-node="mo"><path data-c="2211" d="M61 748Q64 750 489 750H913L954 640Q965 609 976 579T993 533T999 516H979L959 517Q936 579 886 621T777 682Q724 700 655 705T436 710H319Q183 710 183 709Q186 706 348 484T511 259Q517 250 513 244L490 216Q466 188 420 134T330 27L149 -187Q149 -188 362 -188Q388 -188 436 -188T506 -189Q679 -189 778 -162T936 -43Q946 -27 959 6H999L913 -249L489 -250Q65 -250 62 -248Q56 -246 56 -239Q56 -234 118 -161Q186 -81 245 -11L428 206Q428 207 242 462L57 717L56 728Q56 744 61 748Z"></path></g><g data-mml-node="mi" transform="translate(1089,477.1) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(1089,-285.4) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g><g data-mml-node="mn" transform="translate(12088.8,0)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g><g data-mml-node="mo" transform="translate(12811,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="mi" transform="translate(13811.3,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(14262.3,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mi" transform="translate(14728.3,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mo" transform="translate(15248.3,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mi" transform="translate(15526.3,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(15871.3,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g><g data-mml-node="mo" transform="translate(16371.5,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="msup" transform="translate(17371.7,0)"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(600,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(1378,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g><g data-mml-node="mo" transform="translate(19395.3,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="munderover" transform="translate(20395.5,0)"><g data-mml-node="mo"><path data-c="2211" d="M61 748Q64 750 489 750H913L954 640Q965 609 976 579T993 533T999 516H979L959 517Q936 579 886 621T777 682Q724 700 655 705T436 710H319Q183 710 183 709Q186 706 348 484T511 259Q517 250 513 244L490 216Q466 188 420 134T330 27L149 -187Q149 -188 362 -188Q388 -188 436 -188T506 -189Q679 -189 778 -162T936 -43Q946 -27 959 6H999L913 -249L489 -250Q65 -250 62 -248Q56 -246 56 -239Q56 -234 118 -161Q186 -81 245 -11L428 206Q428 207 242 462L57 717L56 728Q56 744 61 748Z"></path></g><g data-mml-node="mi" transform="translate(1089,477.1) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(1089,-285.4) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(22125.4,0)"><g data-mml-node="mi"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(451,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mo" transform="translate(917,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mi" transform="translate(1195,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1540,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g><g data-mml-node="mo" transform="translate(2040.2,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="msup" transform="translate(3040.4,0)"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(600,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(1378,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></g></g></g></svg></mjx-container></p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">MOD = <span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span></span><br><span class="line">n = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1-&gt;0, 2-&gt;0, 3-&gt;1可以直接返回</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤一</span></span><br><span class="line">re = [<span class="number">0</span>] * n</span><br><span class="line">re[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">re[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line">    re[i] = (<span class="number">3</span>*re[i-<span class="number">1</span>] + <span class="number">3</span>**(i-<span class="number">1</span>) * i) % MOD</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤二</span></span><br><span class="line">red = [<span class="number">0</span>] * n</span><br><span class="line">red[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, n):</span><br><span class="line">    red[i] = (<span class="number">3</span>*red[i-<span class="number">1</span>] + re[i-<span class="number">1</span>]) % MOD</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤三</span></span><br><span class="line">dp = [<span class="number">0</span>] * n</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">dp[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">dp[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, n):</span><br><span class="line">    value = <span class="number">3</span> * dp[i-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, i):</span><br><span class="line">        value += <span class="number">3</span> * red[j] * <span class="number">3</span>**(i - j - <span class="number">1</span>) + re[j] * <span class="number">3</span>**(i - j - <span class="number">1</span>)</span><br><span class="line">        value = value % MOD</span><br><span class="line">    dp[i] = value</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dp)</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="number">1_000_000_000</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">MOD_BIG</span> <span class="operator">=</span> BigInteger.valueOf(MOD);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1-&gt;0, 2-&gt;0, 3-&gt;1可以直接返回</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤1</span></span><br><span class="line"><span class="type">long</span>[] re = <span class="keyword">new</span> <span class="title class_">long</span>[n];</span><br><span class="line">re[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; n; i++) {</span><br><span class="line">    re[i] = (<span class="number">3</span> * re[i - <span class="number">1</span>] + i * BigInteger.valueOf(<span class="number">3</span>).pow(i - <span class="number">1</span>).mod(MOD_BIG).longValue()) % MOD;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤2</span></span><br><span class="line"><span class="type">long</span>[] red = <span class="keyword">new</span> <span class="title class_">long</span>[n];</span><br><span class="line">red[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt; n; i++) {</span><br><span class="line">    red[i] = ((<span class="number">3</span> * red[i - <span class="number">1</span>]) % MOD + re[i - <span class="number">1</span>]) % MOD;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤三</span></span><br><span class="line"><span class="type">long</span>[] dp = <span class="keyword">new</span> <span class="title class_">long</span>[n];</span><br><span class="line">dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt; n; i++) {</span><br><span class="line">    dp[i] = <span class="number">3</span> * dp[i-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; i; j++) {</span><br><span class="line">        dp[i] += ((<span class="number">3</span> * red[j] + re[j]) % MOD) * BigInteger.valueOf(<span class="number">3</span>).pow(i - j - <span class="number">1</span>).mod(MOD_BIG).longValue();</span><br><span class="line">        dp[i] = dp[i] % MOD;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">System.out.println(dp[n - <span class="number">1</span>]);</span><br></pre></td></tr></table></figure></div>

<h3 id="更优解法"><a href="#更优解法" class="headerlink" title="更优解法"></a>更优解法</h3><p>仔细思考后发现一个更优解法。我们之前其实已经能拿到<code>red[i]</code>，那么对于一个长度为n的任意排列的序列来说，其中长度为i的连续序列产生的”美丽度”就应当为：</p>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="25.457ex" height="2.444ex" role="img" focusable="false" viewBox="0 -830.4 11252.1 1080.4"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(451,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mi" transform="translate(917,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mo" transform="translate(1437,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mi" transform="translate(1715,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(2060,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g><g data-mml-node="mo" transform="translate(2560.2,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="msup" transform="translate(3560.4,0)"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(600,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(1378,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g><g data-mml-node="mo" transform="translate(5584,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="mo" transform="translate(6584.2,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(6973.2,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(7795.5,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(8795.7,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(9362.9,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(10363.1,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(10863.1,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></p>
<blockquote>
<p>解释：</p>
<p>长度为i的连续子序列，所有排列中的”美丽度”总和<code>red[i]</code>在上一个解法，我们已详细探讨。</p>
<p>现在，剩下的<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="4.904ex" height="1.681ex" role="img" focusable="false" viewBox="0 -661 2167.4 743"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(822.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(1822.4,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container>个位置一共有<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="4.075ex" height="1.929ex" role="img" focusable="false" viewBox="0 -830.4 1801.3 852.4"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(600,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(1378,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></g></g></svg></mjx-container>种可能</p>
<p>同时，这个长度为i的连续子序列的位置未知，一共有<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="8.801ex" height="1.692ex" role="img" focusable="false" viewBox="0 -666 3889.9 748"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(822.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(1822.4,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(2389.7,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(3389.9,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container>种可能</p>
</blockquote>
<p>我们现在只需要遍历i，最后求和就可以了</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/24/q74jucZEBvAa9XU.png" alt="image-20230424215811928"></p>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">MOD = <span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span></span><br><span class="line">n = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1-&gt;0, 2-&gt;0, 3-&gt;1可以直接返回</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤一</span></span><br><span class="line">re = [<span class="number">0</span>] * n    </span><br><span class="line">re[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line">    re[i] = (<span class="number">3</span>*re[i-<span class="number">1</span>] + <span class="number">3</span>**(i-<span class="number">1</span>) * i) % MOD</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤二</span></span><br><span class="line">red = [<span class="number">0</span>] * n</span><br><span class="line">red[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, n):</span><br><span class="line">    red[i] = (<span class="number">3</span>*red[i-<span class="number">1</span>] + re[i-<span class="number">1</span>]) % MOD</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤三</span></span><br><span class="line">result = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">    result = (result + red[i] * <span class="number">3</span>**(n-i-<span class="number">1</span>) * (n - i)) % MOD</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="number">1_000_000_000</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">MOD_BIG</span> <span class="operator">=</span> BigInteger.valueOf(MOD);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1-&gt;0, 2-&gt;0, 3-&gt;1可以直接返回</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤1</span></span><br><span class="line"><span class="type">long</span>[] re = <span class="keyword">new</span> <span class="title class_">long</span>[n];</span><br><span class="line">re[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; n; i++) {</span><br><span class="line">    re[i] = (<span class="number">3</span> * re[i - <span class="number">1</span>] + i * BigInteger.valueOf(<span class="number">3</span>).pow(i - <span class="number">1</span>).mod(MOD_BIG).longValue()) % MOD;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤2</span></span><br><span class="line"><span class="type">long</span>[] red = <span class="keyword">new</span> <span class="title class_">long</span>[n];</span><br><span class="line">red[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt; n; i++) {</span><br><span class="line">    red[i] = ((<span class="number">3</span> * red[i - <span class="number">1</span>]) % MOD + re[i - <span class="number">1</span>]) % MOD;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤三</span></span><br><span class="line"><span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">    <span class="type">long</span> <span class="variable">temp</span> <span class="operator">=</span> (red[i] * (n - i)) % MOD;</span><br><span class="line">    temp = (temp * BigInteger.valueOf(<span class="number">3</span>).pow(n - i - <span class="number">1</span>).mod(MOD_BIG).longValue()) % MOD;</span><br><span class="line">    result += temp;</span><br><span class="line">    result %= MOD;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>算法题</category>
        <category>动态规划</category>
      </categories>
  </entry>
  <entry>
    <title>JDK8到JDK17新特性</title>
    <url>//post/54344/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>SpringBoot3.0开始强制使用JDK17，想必会迎来一波JDK8到JKD17的更新热潮。本文总结了JDK8-JDK17所有重要的更新内容，以供查阅。</p>
<p>原文地址：<a href="https://xuedongyun.cn/post/54344/">https://xuedongyun.cn/post/54344/</a></p>
<h2 id="带资源的try"><a href="#带资源的try" class="headerlink" title="带资源的try"></a>带资源的try</h2><blockquote>
<p>JDK7新特性</p>
</blockquote>
<ul>
<li>在try的后面可以增加()，括号中可以声明流对象并初始化</li>
<li>try中的代码执行完毕，自动把流对象释放，不用写finally了</li>
</ul>
<blockquote>
<p>说明：</p>
<ul>
<li><p>声明的类必须实现<code>AutoCloseable</code>或<code>Closeable</code>接口，实现了其中的<code>close</code>方法。Java7几乎把所有的资源类都实现了这些接口。</p>
</li>
<li><p>写到括号中的变量默认是final的，无法更改。</p>
</li>
</ul>
</blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">"d:/1.txt"</span>);</span><br><span class="line">    <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fis, <span class="string">"utf-8"</span>);</span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line"></span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">"1.txt"</span>);</span><br><span class="line">    <span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(fos, <span class="string">"gbk"</span>);</span><br><span class="line">    <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(osw);</span><br><span class="line">) {</span><br><span class="line">    String str;</span><br><span class="line">    <span class="keyword">while</span> ((str = br.readLine()) != <span class="literal">null</span>) {</span><br><span class="line">        bw.write(str);</span><br><span class="line">        bw.newLine();</span><br><span class="line">    }</span><br><span class="line">} <span class="keyword">catch</span> (FileNotFoundException e) {</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">} <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>JDK9语法有增强</p>
</blockquote>
<p>此时可以在外部初始化变量，括号中引用外部名称即可，用分号隔开。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">InputStreamReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in);</span><br><span class="line"><span class="type">OutputStreamWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out);</span><br><span class="line"><span class="keyword">try</span> (reader; writer) {</span><br><span class="line">    <span class="comment">// 主要流程</span></span><br><span class="line">} <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><blockquote>
<p>JDK8新特性</p>
</blockquote>
<p>在启动线程时，需要传入一个实现<code>java.lang.Runnable</code>接口的对象，来定义线程中的工作。通常，我们使用匿名内部类来实现。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Hello from thread"</span>);</span><br><span class="line">    }</span><br><span class="line">}).start();</span><br></pre></td></tr></table></figure></div>

<p>但是本质上，我们需要的其实只是一个函数。lambda表达式就是为解决这个问题而出现的。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; com1 = (Integer o1, Integer o2) -&gt; {</span><br><span class="line">    <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型推断：类型可以由编译器推理出来，可以不写</span></span><br><span class="line">Comparator&lt;Integer&gt; com1 = (o1, o2) -&gt; {</span><br><span class="line">    <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>

<h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><ul>
<li>只包含<strong>一个抽象方法</strong>的接口称为函数式接口（当然可以包含其他非抽象方法）</li>
<li>可以用lambda表达式创建接口的对象</li>
<li>可以在接口上标注<code>@FunctionalInterface</code>注解，用于检查是否满足条件</li>
</ul>
<blockquote>
<p>函数式编程思想：</p>
<ul>
<li>函数是一等公民，注重获取结果</li>
</ul>
</blockquote>
<h3 id="内置的函数式接口"><a href="#内置的函数式接口" class="headerlink" title="内置的函数式接口"></a>内置的函数式接口</h3><ul>
<li><p>之前常见的函数式接口</p>
<ul>
<li><code>java.lang.Runnable</code>，方法：<code>public void run()</code></li>
<li><code>java.lang.Iterable&lt;T&gt;</code>，方法：<code>public Iterator&lt;T&gt; iterate()</code></li>
<li><code>java.lang.Comparable&lt;T&gt;</code>，方法：<code>public int compareTo(T t)</code></li>
<li><code>java.util.Comparator&lt;T&gt;</code>，方法：<code>public int compare(T t1, T t2)</code></li>
</ul>
</li>
<li><p>四大核心函数接口</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>函数式接口</th>
<th>称谓</th>
<th>抽象方法</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td><code>Consumer&lt;T&gt;  </code></td>
<td>消费型接口</td>
<td><code>void accept(T t)</code></td>
<td>对类型为T的对象进行操作</td>
</tr>
<tr>
<td><code>Supplier&lt;T&gt;  </code></td>
<td>供给型接口</td>
<td><code>T get()</code></td>
<td>返回类型为T的对象</td>
</tr>
<tr>
<td><code>Function&lt;T, R&gt;  </code></td>
<td>函数型接口</td>
<td><code>R apply(T t)</code></td>
<td>对对象进行操作，返回结果</td>
</tr>
<tr>
<td><code>Predicate&lt;T&gt;  </code></td>
<td>判断型接口</td>
<td><code>boolean test(T t)</code></td>
<td>判断对象是否满足某条件</td>
</tr>
</tbody></table>
<ul>
<li>消费型接口</li>
</ul>
<table>
<thead>
<tr>
<th>函数式接口</th>
<th>抽象方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>BiConsumer&lt;T,U&gt;</code></td>
<td><code>void accept(T t, U u)</code></td>
<td>接收两个对象，用于完成功能</td>
</tr>
<tr>
<td><code>DoubleConsumer</code></td>
<td><code>void accept(double value)</code></td>
<td>接收一个double值</td>
</tr>
<tr>
<td><code>IntConsumer</code></td>
<td><code>void accept(int value)</code></td>
<td>接收一个int值</td>
</tr>
<tr>
<td><code>LongConsumer</code></td>
<td><code>void accept(long value)</code></td>
<td>接收一个long值</td>
</tr>
<tr>
<td><code>ObjDoubleConsumer&lt;T&gt;</code></td>
<td><code>void accept(T t, double value)</code></td>
<td>接收一个对象和一个double值</td>
</tr>
<tr>
<td><code>ObjIntConsumer&lt;T&gt;</code></td>
<td><code>void accept(T t, int value)</code></td>
<td>接收一个对象和一个int值</td>
</tr>
<tr>
<td><code>ObjLongConsumer&lt;T&gt;</code></td>
<td><code>void accept(T t, long value)</code></td>
<td>接收一个对象和一个long值</td>
</tr>
</tbody></table>
<ul>
<li>供给型接口</li>
</ul>
<table>
<thead>
<tr>
<th>接口名</th>
<th>抽象方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>BooleanSupplier</code></td>
<td><code>boolean getAsBoolean()</code></td>
<td>返回一个boolean值</td>
</tr>
<tr>
<td><code>DoubleSupplier</code></td>
<td><code>double getAsDouble()</code></td>
<td>返回一个double值</td>
</tr>
<tr>
<td><code>IntSupplier</code></td>
<td><code>int getAsInt()</code></td>
<td>返回一个int值</td>
</tr>
<tr>
<td><code>LongSupplier</code></td>
<td><code>long getAsLong()</code></td>
<td>返回一个long值</td>
</tr>
</tbody></table>
<ul>
<li>判断型接口</li>
</ul>
<table>
<thead>
<tr>
<th>接口名</th>
<th>抽象方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>BiPredicate&lt;T,U&gt;</code></td>
<td><code>boolean test(T t, U u)</code></td>
<td>接收两个对象</td>
</tr>
<tr>
<td><code>DoublePredicate</code></td>
<td><code>boolean test(double value)</code></td>
<td>接收一个double值</td>
</tr>
<tr>
<td><code>IntPredicate</code></td>
<td><code>boolean test(int value)</code></td>
<td>接收一个int值</td>
</tr>
<tr>
<td><code>LongPredicate</code></td>
<td><code>boolean test(long value)</code></td>
<td>接收一个long值</td>
</tr>
</tbody></table>
<ul>
<li>函数型接口（看套路总结即可）</li>
</ul>
<table>
<thead>
<tr>
<th>接口名</th>
<th>抽象方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>UnaryOperator&lt;T&gt;</code></td>
<td><code>T apply(T t)</code></td>
<td>接收T类型，返回T类型</td>
</tr>
<tr>
<td><code>DoubleFunction&lt;R&gt;</code></td>
<td><code>R apply(double value)</code></td>
<td>接收double，返回R类型</td>
</tr>
<tr>
<td><code>IntFunction&lt;R&gt;</code></td>
<td><code>R apply(int value)</code></td>
<td>接收int，返回R类型</td>
</tr>
<tr>
<td><code>LongFunction&lt;R&gt;</code></td>
<td><code>R apply(long value)</code></td>
<td>接收long，返回类型</td>
</tr>
<tr>
<td><code>ToDoubleFunction&lt;T&gt;</code></td>
<td><code>double applyAsDouble(T value)</code></td>
<td>接收T类型，返回double</td>
</tr>
<tr>
<td><code>ToIntFunction&lt;T&gt;</code></td>
<td><code>int applyAsInt(T value)</code></td>
<td>接收T类型，返回int</td>
</tr>
<tr>
<td><code>ToLongFunction&lt;T&gt;</code></td>
<td><code>long applyAsLong(T value)</code></td>
<td>接收类型T，返回long</td>
</tr>
<tr>
<td><code>DoubleToIntFunction</code></td>
<td><code>int applyAsInt(double value)</code></td>
<td>接收double，返回int</td>
</tr>
<tr>
<td><code>DoubleToLongFunction</code></td>
<td><code>long applyAsLong(double value)</code></td>
<td>接收double，返回long</td>
</tr>
<tr>
<td><code>IntToDoubleFunction</code></td>
<td><code>double applyAsDouble(int value)</code></td>
<td>接收int，返回double</td>
</tr>
<tr>
<td><code>IntToLongFunction</code></td>
<td><code>long applyAsLong(int value)</code></td>
<td>接收int，返回long</td>
</tr>
<tr>
<td><code>LongToDoubleFunction</code></td>
<td><code>double applyAsDouble(long value)</code></td>
<td>接收long，返回double</td>
</tr>
<tr>
<td><code>LongToIntFunction</code></td>
<td><code>int applyAsInt(long value)</code></td>
<td>接收long，返回int</td>
</tr>
<tr>
<td><code>DoubleUnaryOperator</code></td>
<td><code>double applyAsDouble(double operand)</code></td>
<td>接收double，返回double</td>
</tr>
<tr>
<td><code>IntUnaryOperator</code></td>
<td><code>int applyAsInt(int operand)</code></td>
<td>接收int，返回int</td>
</tr>
<tr>
<td><code>LongUnaryOperator</code></td>
<td><code>long applyAsLong(long operand)</code></td>
<td>接收long，返回long</td>
</tr>
<tr>
<td><code>BiFunction&lt;T,U,R&gt;</code></td>
<td><code>R apply(T t, U u)</code></td>
<td>接收T类型和U类型，返回一个R类型</td>
</tr>
<tr>
<td><code>BinaryOperator&lt;T&gt;</code></td>
<td><code>T apply(T t, T u)</code></td>
<td>接收两个T类型，返回T类型</td>
</tr>
<tr>
<td><code>ToDoubleBiFunction&lt;T,U&gt;</code></td>
<td><code>double applyAsDouble(T t, U u)</code></td>
<td>接收T类型和U类型，返回double</td>
</tr>
<tr>
<td><code>ToIntBiFunction&lt;T,U&gt;</code></td>
<td><code>int applyAsInt(T t, U u)</code></td>
<td>接收T类型和U类型，返回int</td>
</tr>
<tr>
<td><code>ToLongBiFunction&lt;T,U&gt;</code></td>
<td><code>long applyAsLong(T t, U u)</code></td>
<td>接收T类型和U类型，返回long</td>
</tr>
<tr>
<td><code>DoubleBinaryOperator</code></td>
<td><code>double applyAsDouble(double left, double right)</code></td>
<td>接收两个double，返回double</td>
</tr>
<tr>
<td><code>IntBinaryOperator</code></td>
<td><code>int applyAsInt(int left, int right)</code></td>
<td>接收两个int，返回int</td>
</tr>
<tr>
<td><code>LongBinaryOperator</code></td>
<td><code>long applyAsLong(long left, long right)</code></td>
<td>接收两个long，返回long</td>
</tr>
</tbody></table>
<blockquote>
<p>命名套路：</p>
<p>Operator：参数返回值类型一致</p>
<p>Fucntion：参数返回值类型不一致</p>
<ul>
<li><p><code>Int</code>-UnaryOperator</p>
</li>
<li><p><code>Int</code>-Function</p>
</li>
<li><p><code>To-Int</code>-Function</p>
</li>
<li><p><code>Double-To-Int</code>-Function</p>
</li>
<li><p><code>Bi</code>-Function</p>
<ul>
<li><code>To-Int-Bi</code>-Function</li>
</ul>
</li>
<li><p><code>Binary</code>-Operator</p>
<ul>
<li><code>Int-Binary-</code>Operator</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="方法引用与构造器引用"><a href="#方法引用与构造器引用" class="headerlink" title="方法引用与构造器引用"></a>方法引用与构造器引用</h2><blockquote>
<p>JDK8新特性</p>
</blockquote>
<p>本质：使用已有方法赋值lambda表达式，只要类型一致就成立</p>
<h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>当要传给lambda体的操作，已经有实现的方法时：</p>
<ul>
<li><code>对象::实例方法</code></li>
<li><code>类::静态方法</code></li>
<li><code>类::实例方法</code></li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Consumer&lt;String&gt; con = System.out::println;</span><br></pre></td></tr></table></figure></div>

<h3 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h3><p>当Lambda表达式是为了创建一个对象，且满足Lambda表达式形参时：</p>
<ul>
<li><code>类名::new</code></li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Supplier&lt;Employee&gt; sup = Employee::<span class="keyword">new</span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="数组构造引用"><a href="#数组构造引用" class="headerlink" title="数组构造引用"></a>数组构造引用</h3><p>当Lambda表达式是为了创建一个数组对象，且满足Lambda表达式形参时：</p>
<ul>
<li><code>数组类型名::new</code></li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Function&lt;Integer,String[]&gt; func = String[]::new;</span><br><span class="line">String[] arr = func.apply(10); // 数组的形参是数组大小</span><br></pre></td></tr></table></figure></div>

<h2 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h2><blockquote>
<p>JDK8新特性</p>
</blockquote>
<ul>
<li>使用Stream API对集合进行操作，就类似于使用SQL执行数据库查询</li>
<li>Stream和Collection的区别<ul>
<li>Collection是一种静态的内存数据结构，核心是数据</li>
<li>Stream是有关计算的，核心是计算</li>
</ul>
</li>
<li>Stream操作流程：创建-&gt;中间操作-&gt;终止操作</li>
</ul>
<h3 id="创建Stream实例"><a href="#创建Stream实例" class="headerlink" title="创建Stream实例"></a>创建Stream实例</h3><p><strong>方法一：通过集合</strong></p>
<p>java8种Collection接口被扩展，提供了两个新的方法</p>
<ul>
<li><code>default Stream&lt;E&gt; stream()</code>: 返回一个顺序流</li>
<li><code>default Stream&lt;E&gt; parallelStream()</code>: 返回一个并行流</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = list.stream();</span><br></pre></td></tr></table></figure></div>

<p><strong>方法二：通过数组</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Arrays.stream(arr); </span><br></pre></td></tr></table></figure></div>

<p><strong>方法三：通过Stream.of()创建</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure></div>

<p><strong>方法四：创建无限流</strong></p>
<p>可以使用<code>Stream.iterate()</code>和<code>Stream.generate()</code>，创建无限流</p>
<ul>
<li>迭代：<code>public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f)</code></li>
<li>生成：<code>public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)</code></li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.iterate(<span class="number">0</span>, x -&gt; x + <span class="number">2</span>);</span><br><span class="line">stream.limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">Stream&lt;Double&gt; stream1 = Stream.generate(Math::random);</span><br><span class="line">stream1.limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure></div>

<h3 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h3><p>除非流水线上除法终止操作，否则中间操作不会执行任何处理。所有操作会一次性全部处理</p>
<ul>
<li><strong>筛选和切片</strong></li>
</ul>
<table>
<thead>
<tr>
<th><strong>方   法</strong></th>
<th><strong>描   述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>filter(Predicatep)</code></td>
<td>接收Lambda，从流中排除某些元素</td>
</tr>
<tr>
<td><code>distinct()</code></td>
<td>筛选，通过流所生成元素的<code>hashCode()</code>和<code>equals()</code>去除重复元素</td>
</tr>
<tr>
<td><code>limit(long maxSize)</code></td>
<td>截断流，使其元素不超过给定数量</td>
</tr>
<tr>
<td><code>skip(long n)</code></td>
<td>跳过元素，返回一个扔掉了前  n 个元素的流。<br>若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补</td>
</tr>
</tbody></table>
<ul>
<li><strong>映射</strong></li>
</ul>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>map(Function f)</code></td>
<td>函数被应用到每个元素上，将其映射成新的元素</td>
</tr>
<tr>
<td><code>mapToDouble(ToDoubleFunction f)</code></td>
<td>函数被应用到每个元素上，产生新的<code>DoubleStream</code></td>
</tr>
<tr>
<td><code>mapToInt(ToIntFunction  f)</code></td>
<td>函数被应用到每个元素上，产生新的<code>IntStream</code></td>
</tr>
<tr>
<td><code>mapToLong(ToLongFunction  f)</code></td>
<td>函数被应用到每个元素上，产生新的<code>LongStream</code></td>
</tr>
<tr>
<td><code>flatMap(Function  f)</code></td>
<td>将流中的每个值都换成另一个流，然后把所有流连接成一个流</td>
</tr>
</tbody></table>
<ul>
<li><strong>排序</strong></li>
</ul>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>sorted()</code></td>
<td>产生一个新流，其中按自然顺序排序</td>
</tr>
<tr>
<td><code>sorted(Comparator com)</code></td>
<td>产生一个新流，其中按比较器顺序排序</td>
</tr>
</tbody></table>
<h3 id="终止操作"><a href="#终止操作" class="headerlink" title="终止操作"></a>终止操作</h3><ul>
<li>匹配和查找</li>
</ul>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>allMatch(Predicate  p)</code></td>
<td>检查是否匹配所有元素</td>
</tr>
<tr>
<td><code>anyMatch(Predicate  p)</code></td>
<td>检查是否至少匹配一个元素</td>
</tr>
<tr>
<td><code>noneMatch(Predicate  p)</code></td>
<td>检查是否没有匹配所有元素</td>
</tr>
<tr>
<td><code>findFirst()</code></td>
<td>返回第一个元素</td>
</tr>
<tr>
<td><code>findAny()</code></td>
<td>返回当前流中的任意元素</td>
</tr>
<tr>
<td><code>count()</code></td>
<td>返回流中元素总数</td>
</tr>
<tr>
<td><code>max(Comparator c)</code></td>
<td>返回流中最大值</td>
</tr>
<tr>
<td><code>min(Comparator c)</code></td>
<td>返回流中最小值</td>
</tr>
<tr>
<td><code>forEach(Consumer c)</code></td>
<td>内部迭代<br>(使用<code>Collection</code>接口需要用户去做迭代，称为外部迭代)</td>
</tr>
</tbody></table>
<ul>
<li>归约</li>
</ul>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>reduce(T identity, BinaryOperator b)</code></td>
<td>带初始值，可以将流中元素反复结合起来，得到一个值。返回<code>T</code></td>
</tr>
<tr>
<td><code>reduce(BinaryOperator b)</code></td>
<td>不带初始值，可以将流中元素反复结合起来，得到一个值。返回<code>Optional&lt;T&gt;</code></td>
</tr>
</tbody></table>
<ul>
<li>收集</li>
</ul>
<table>
<thead>
<tr>
<th><strong>方   法</strong></th>
<th><strong>描   述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>collect(Collector  c)</code></td>
<td>将流转换为其他形式。接收参数：Collector接口的实现</td>
</tr>
</tbody></table>
<p>Collectors类中帮我们实现了很多静态方法，可以帮助我们很方便的实现收集</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td><code>toList</code></td>
<td><code>Collector&lt;T, ?, List&lt;T&gt;&gt;</code></td>
<td>收集到List</td>
<td><code>.stream().collect(Collectors.toList());</code></td>
</tr>
<tr>
<td><code>toSet</code></td>
<td><code>Collector&lt;T, ?, Set&lt;T&gt;&gt;</code></td>
<td>收集到Set</td>
<td><code>.stream().collect(Collectors.toSet());</code></td>
</tr>
<tr>
<td><code>toCollection</code></td>
<td><code>Collector&lt;T, ?, C&gt;</code></td>
<td>收集到创建的集合</td>
<td><code>.stream().collect(Collectors.toCollection(ArrayList::new));</code></td>
</tr>
<tr>
<td><code>counting</code></td>
<td><code>Collector&lt;T, ?, Long&gt;</code></td>
<td>计算元素的个数</td>
<td><code>.stream().collect(Collectors.counting());</code></td>
</tr>
<tr>
<td><code>summingInt</code></td>
<td><code>Collector&lt;T, ?, Integer&gt;</code></td>
<td>对Integer属性求和</td>
<td><code>.stream().collect(Collectors.summingInt(Employee::getSalary));</code></td>
</tr>
<tr>
<td><code>averagingInt</code></td>
<td><code>Collector&lt;T, ?, Double&gt;</code></td>
<td>对Integer属性平均</td>
<td><code>.stream().collect(Collectors.averagingInt(Employee::getSalary));</code></td>
</tr>
<tr>
<td><code>summarizingInt</code></td>
<td><code>Collector&lt;T, ?, IntSummaryStatistics&gt;</code></td>
<td>收集流中Integer属性的统计值。如：平均值</td>
<td><code>.stream().collect(Collectors.summarizingInt(Employee::getSalary));</code></td>
</tr>
<tr>
<td><code>joining</code></td>
<td><code>Collector&lt;CharSequence, ?, String&gt;</code></td>
<td>连接流中每个字符串</td>
<td><code>.stream().map(Employee::getName).collect(Collectors.joining());</code></td>
</tr>
<tr>
<td><code>maxBy</code></td>
<td><code>Collector&lt;T, ?, Optional&lt;T&gt;&gt;</code></td>
<td>根据比较器选择最大值</td>
<td><code>.stream().collect(Collectors.maxBy(comparingInt(Employee::getSalary)));</code></td>
</tr>
<tr>
<td><code>minBy</code></td>
<td><code>Collector&lt;T, ?, Optional&lt;T&gt;&gt;</code></td>
<td>根据比较器选择最小值</td>
<td><code>.stream().collect(Collectors.minBy(comparingInt(Employee::getSalary)));</code></td>
</tr>
<tr>
<td><code>reducing</code></td>
<td><code>Collector&lt;T, ?, Optional&lt;T&gt;&gt;</code></td>
<td>从一个作为累加器的初始值开始，利用<code>BinaryOperator</code>逐个结合，从而归约成单个值</td>
<td><code>.stream().collect(Collectors.reducing(0, Employee::getSalar, Integer::sum));</code></td>
</tr>
<tr>
<td><code>collectingAndThen</code></td>
<td><code>Collector&lt;T,A,R&gt;</code></td>
<td>包裹另一个收集器，对其结果转换函数</td>
<td><code>.stream().collect(Collectors.collectingAndThen(Collectors.toList(), List::size));</code></td>
</tr>
<tr>
<td><code>groupingBy</code></td>
<td><code>Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt;</code></td>
<td>根据某属性值对流分组，属性为K，结果为V</td>
<td><code>.stream().collect(Collectors.groupingBy(Employee::getStatus));</code></td>
</tr>
<tr>
<td><code>partitioningBy</code></td>
<td><code>Collector&lt;T, ?, Map&lt;Boolean, List&lt;T&gt;&gt;&gt;</code></td>
<td>根据true或false进行分区</td>
<td><code>.stream().collect(Collectors.partitioningBy(Employee::getManage));</code></td>
</tr>
</tbody></table>
<h2 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a>Optional类</h2><blockquote>
<p>JDK8新特性</p>
</blockquote>
<p><code>Optional&lt;T&gt;</code> 类<code>java.util.Optional</code> 是一个容器类，它可以保存类型T的值，代表这个值存在。或者仅仅保存null，表示这个值不存在。如果值存在，则isPresent()方法会返回true，调用get()方法会返回该对象。</p>
<ul>
<li>创建Optional类的方法：</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; Optional&lt;T&gt; <span class="title function_">empty</span><span class="params">()</span>;				<span class="comment">// 创建空的Optional实例</span></span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; Optional&lt;T&gt; <span class="title function_">of</span><span class="params">(T value)</span>;			<span class="comment">// 创建Optional实例，value必须非空</span></span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; Optional&lt;T&gt; <span class="title function_">ofNullable</span><span class="params">(T value)</span>;	<span class="comment">// 创建Optional实例，value可以为空，也可能为非空</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>判断Optional容器中是否包含对象：</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">boolean isPresent();	// 判断值是否存在</span><br><span class="line">void ifPresent(Consumer&lt;? super T&gt; consumer) //若值存在，就对它进行Consumer指定的操作</span><br></pre></td></tr></table></figure></div>

<ul>
<li>获取Optional容器的对象</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">T <span class="title function_">get</span><span class="params">()</span>				<span class="comment">// 存在则返回值，否则抛异常</span></span><br><span class="line">T <span class="title function_">orElse</span><span class="params">(T other)</span>	<span class="comment">// 存在则返回值，为空就用指定的默认值</span></span><br><span class="line">T <span class="title function_">orElseGet</span><span class="params">(Supplier&lt;? extends T&gt; other)</span>	<span class="comment">// 存在则返回值，为空就用Supplier接口提供的值</span></span><br><span class="line">T <span class="title function_">orElseThrow</span><span class="params">(Supplier&lt;? extends X&gt; exceptionSupplier)</span> <span class="comment">// 存在则返回值，为空就用抛出你指定的异常类型</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>JDK9-11新增了特性</p>
</blockquote>
<table>
<thead>
<tr>
<th><strong>新增方法</strong></th>
<th><strong>描述</strong></th>
<th><strong>新增的版本</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean isEmpty()</code></td>
<td>判断value是否为空</td>
<td>JDK  11</td>
</tr>
<tr>
<td><code>ifPresentOrElse(Consumer&lt;? super T&gt; action, Runnable emptyAction)</code></td>
<td>非空执行参数1；<br>否则空执行参数2</td>
<td>JDK  9</td>
</tr>
<tr>
<td><code>Optional&lt;T&gt; or(Supplier&lt;? extends Optional&lt;? extends T&gt;&gt; supplier)</code></td>
<td>非空返回对应的Optional；<br>否则返回参数封装的Optional</td>
<td>JDK  9</td>
</tr>
<tr>
<td><code>Stream&lt;T&gt; stream()</code></td>
<td>非空返回仅此value的Stream；<br>否则返回空Stream</td>
<td>JDK  9</td>
</tr>
<tr>
<td><code>T orElseThrow()</code></td>
<td>非空返回value；<br>否则抛异常<br>NoSuchElementException</td>
<td>JDK  10</td>
</tr>
</tbody></table>
<h2 id="可以创建空Stream"><a href="#可以创建空Stream" class="headerlink" title="可以创建空Stream"></a>可以创建空Stream</h2><blockquote>
<p>JDK9新特性</p>
</blockquote>
<p>Java8中Stream不能完全为空，否则会报空指针异常。Java9中的<code>ofNullable</code>方法允许创建一个单元素Stream，可以包含空元素</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以</span></span><br><span class="line">Stream&lt;String&gt; stringStream = Stream.of(<span class="string">"AA"</span>, <span class="string">"BB"</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="type">Long</span> <span class="variable">num</span> <span class="operator">=</span> stringStream.collect(Collectors.counting()); <span class="comment">// 3</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 不可以</span></span><br><span class="line">Stream&lt;String&gt; stringStream = Stream.of(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以</span></span><br><span class="line">Stream&lt;String&gt; stringStream = Stream.ofNullable(<span class="literal">null</span>);</span><br><span class="line"><span class="type">Long</span> <span class="variable">num</span> <span class="operator">=</span> stringStream.collect(Collectors.counting()); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以</span></span><br><span class="line">Stream&lt;String&gt; stringStream = Stream.ofNullable(<span class="string">"AA"</span>);</span><br><span class="line"><span class="type">Long</span> <span class="variable">num</span> <span class="operator">=</span> stringStream.collect(Collectors.counting()); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></div>

<h2 id="iterator终止方式"><a href="#iterator终止方式" class="headerlink" title="iterator终止方式"></a>iterator终止方式</h2><blockquote>
<p>JDK9新特性</p>
</blockquote>
<p>定义了重载的新的iterator方法，可以定义终止条件</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以前需要靠limit</span></span><br><span class="line">Stream.iterate(<span class="number">1</span>,i -&gt; i + <span class="number">1</span>).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在可以定义终止条件</span></span><br><span class="line">Stream.iterate(<span class="number">1</span>,i -&gt; i &lt; <span class="number">100</span>,i -&gt; i + <span class="number">1</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure></div>

<h2 id="jshell命令"><a href="#jshell命令" class="headerlink" title="jshell命令"></a>jshell命令</h2><blockquote>
<p>JDK9新特性</p>
</blockquote>
<ul>
<li>jShell命令是Java的REPL工具（交互式编程环境，read-evaluate-print-loop），可以像python那样一行一行执行</li>
<li>命令行输入<code>jshell</code>即可开始使用</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">jshell</span><br></pre></td></tr></table></figure></div>

<ul>
<li>不是很常用，略过</li>
</ul>
<h2 id="String存储结构和API变更"><a href="#String存储结构和API变更" class="headerlink" title="String存储结构和API变更"></a>String存储结构和API变更</h2><blockquote>
<p>JDK9新特性</p>
</blockquote>
<h3 id="存储结构变化"><a href="#存储结构变化" class="headerlink" title="存储结构变化"></a>存储结构变化</h3><p>产生背景：</p>
<blockquote>
<p>The current implementation of the String class stores characters in a char array, using two bytes (sixteen bits) for each character. Data gathered from many different applications indicates that strings are a major component of heap usage and, moreover, that most String objects contain only Latin-1 characters. Such characters require only one byte of storage, hence half of the space in the internal char arrays of such String objects is going unused.</p>
</blockquote>
<p>使用说明：</p>
<blockquote>
<p>We propose to change the internal representation of the String class from a UTF-16 char array to a byte array plus an encoding-flag field. The new String class will store characters encoded either as ISO-8859-1/Latin-1 (one byte per character), or as UTF-16 (two bytes per character), based upon the contents of the string. The encoding flag will indicate which encoding is used.</p>
</blockquote>
<p>对StringBuilder，StringBuffer等来说也是如此</p>
<blockquote>
<p>String-related classes such as AbstractStringBuilder, StringBuilder, and StringBuffer will be updated to use the same representation, as will the HotSpot VM’s intrinsic string operations.</p>
</blockquote>
<p>结论：String 不用 char[] 来存储，改成了 byte[] 加上编码标记，节约了一些空间</p>
<h3 id="API变化"><a href="#API变化" class="headerlink" title="API变化"></a>API变化</h3><h4 id="新增字符串处理方法"><a href="#新增字符串处理方法" class="headerlink" title="新增字符串处理方法"></a>新增字符串处理方法</h4><blockquote>
<p>JDK11新特性</p>
</blockquote>
<table>
<thead>
<tr>
<th><strong>描述</strong></th>
<th><strong>举例</strong></th>
</tr>
</thead>
<tbody><tr>
<td>判断字符串是否为空白</td>
<td><code>.isBlank()</code></td>
</tr>
<tr>
<td>去除首尾空白</td>
<td><code>.strip()</code></td>
</tr>
<tr>
<td>去除尾部空格</td>
<td><code>.stripTrailing()</code></td>
</tr>
<tr>
<td>去除首部空格</td>
<td><code>.stripLeading()</code></td>
</tr>
<tr>
<td>复制字符串</td>
<td><code>.repeat(3)</code></td>
</tr>
<tr>
<td>字符串按行分为流</td>
<td><code>Stream&lt;String&gt; lines = str.lines();</code></td>
</tr>
</tbody></table>
<h4 id="实现了Constable接口"><a href="#实现了Constable接口" class="headerlink" title="实现了Constable接口"></a>实现了Constable接口</h4><blockquote>
<p>JDK12新特性</p>
</blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, </span><br><span class="line">									Comparable&lt;String&gt;, </span><br><span class="line">									CharSequence, </span><br><span class="line">									Constable, </span><br><span class="line">									ConstantDesc {}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>Constable接口</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Constable定义了方法，用于返回Optianl对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Constable</span> {</span><br><span class="line">	Optional&lt;? <span class="keyword">extends</span> <span class="title class_">ConstantDesc</span>&gt; describeConstable();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>JDK12</code>实现接口的，其实就是用了<code>Optional.of</code></li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Optional&lt;String&gt; <span class="title function_">describeConstable</span><span class="params">()</span> {</span><br><span class="line">	<span class="keyword">return</span> Optional.of(<span class="built_in">this</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;String&gt; optional = str.describeConstable();</span><br></pre></td></tr></table></figure></div>

<h4 id="transform方法"><a href="#transform方法" class="headerlink" title="transform方法"></a>transform方法</h4><blockquote>
<p>JDK12新特性</p>
</blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;R&gt; R <span class="title function_">transform</span><span class="params">(Function&lt;? <span class="built_in">super</span> String, ? extends R&gt; f)</span> {</span><br><span class="line">	<span class="keyword">return</span> f.apply(<span class="built_in">this</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>例代码子：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有一点类似流中的map</span></span><br><span class="line"><span class="string">"foo"</span>.transform(input -&gt; input + <span class="string">" bar"</span>).transform(String::toUpperCase)</span><br></pre></td></tr></table></figure></div>

<h2 id="局部变量类型推断"><a href="#局部变量类型推断" class="headerlink" title="局部变量类型推断"></a>局部变量类型推断</h2><blockquote>
<p>JDK10新特性</p>
</blockquote>
<p>本特性允许开发人员省略通常不必要的类型声明</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 局部变量</span></span><br><span class="line"><span class="type">var</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增强for循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> v : list) {</span><br><span class="line">    System.out.println(v);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通for循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) {</span><br><span class="line">    System.out.println(i);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值类型含复杂泛型结构</span></span><br><span class="line"><span class="comment">//Iterator&lt;Map.Entry&lt;Integer, Student&gt;&gt; iterator = set.iterator();</span></span><br><span class="line"><span class="type">var</span> <span class="variable">iterator</span> <span class="operator">=</span> set.iterator();</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>注意：</p>
<ul>
<li>var不是关键词，而是一个类型名</li>
<li>var不会改变Java是一门静态类型语言的事实。编译器负责推断出结果，将结果写入字节码文件。</li>
</ul>
</blockquote>
<h2 id="文本块"><a href="#文本块" class="headerlink" title="文本块"></a>文本块</h2><blockquote>
<p>JDK13新特性</p>
</blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以前</span></span><br><span class="line"><span class="string">"line1\nline2\nline3\n"</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 现在</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">line1</span></span><br><span class="line"><span class="string">line2</span></span><br><span class="line"><span class="string">line3</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 如果最后不需要换行</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">line1</span></span><br><span class="line"><span class="string">line2</span></span><br><span class="line"><span class="string">line3"""</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>JDK14预览版增加了两个新的语法，JDK15转正</p>
</blockquote>
<ul>
<li><code>\</code>：取消换行</li>
<li><code>\s</code>：表示一个空格</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql2</span> <span class="operator">=</span> <span class="string">"""</span></span><br><span class="line"><span class="string">        SELECT id,NAME,email \</span></span><br><span class="line"><span class="string">        FROM customers\s\</span></span><br><span class="line"><span class="string">        WHERE id &gt; 4 \</span></span><br><span class="line"><span class="string">        ORDER BY email DESC</span></span><br><span class="line"><span class="string">        """</span>;</span><br></pre></td></tr></table></figure></div>

<h2 id="switch表达式"><a href="#switch表达式" class="headerlink" title="switch表达式"></a>switch表达式</h2><blockquote>
<p>JDK12预览版特性，JDK14转正</p>
</blockquote>
<ul>
<li>使用<code>case L -&gt;</code></li>
<li>省略了break语句</li>
<li>可以将多个case合并在一起</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Fruit</span> <span class="variable">fruit</span> <span class="operator">=</span> Fruit.GRAPE;</span><br><span class="line"><span class="keyword">switch</span>(fruit){</span><br><span class="line">    <span class="keyword">case</span> PEAR -&gt; System.out.println(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">case</span> APPLE,MANGO,GRAPE -&gt; System.out.println(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">case</span> ORANGE,PAPAYA -&gt; System.out.println(<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">default</span> -&gt; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">"No Such Fruit:"</span> + fruit);</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>

<ul>
<li>更进一步，还可以处理返回值</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Fruit</span> <span class="variable">fruit</span> <span class="operator">=</span> Fruit.GRAPE;</span><br><span class="line"><span class="type">int</span> <span class="variable">numberOfLetters</span> <span class="operator">=</span> <span class="keyword">switch</span>(fruit){</span><br><span class="line">    <span class="keyword">case</span> PEAR -&gt; <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">case</span> APPLE,MANGO,GRAPE -&gt; <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">case</span> ORANGE,PAPAYA -&gt; <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">default</span> -&gt; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">"No Such Fruit:"</span> + fruit);</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>

<ul>
<li>JDK13中引入了yield语句。switch语句应使用yield，而不是return。return会直接跳出当前方法，而yield只会跳出当前switch块。</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">x</span> <span class="operator">=</span> <span class="string">"3"</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">switch</span> (x) {</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"1"</span> -&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"2"</span> -&gt; <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">default</span> -&gt; {</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>JDK17预览特性：switch的模式匹配</p>
</blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自动完成模式匹配，大大简化代码</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">switch</span> (o) {</span><br><span class="line">    <span class="keyword">case</span> Integer i -&gt; String.format(<span class="string">"int %d"</span>, i);</span><br><span class="line">    <span class="keyword">case</span> Long l    -&gt; String.format(<span class="string">"long %d"</span>, l);</span><br><span class="line">    <span class="keyword">case</span> Double d  -&gt; String.format(<span class="string">"double %f"</span>, d);</span><br><span class="line">    <span class="keyword">case</span> String s  -&gt; String.format(<span class="string">"String %s"</span>, s);</span><br><span class="line">    <span class="keyword">default</span>        -&gt; o.toString();</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>

<h2 id="instanceof的模式匹配"><a href="#instanceof的模式匹配" class="headerlink" title="instanceof的模式匹配"></a>instanceof的模式匹配</h2><blockquote>
<p>JDK14预览版特性，JDK16转正</p>
</blockquote>
<p>实现简洁的类型安全代码。使用该方法，可以减少Java中显示强制转换的数量。</p>
<ul>
<li>旧写法</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) {</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) obj; <span class="comment">//需要强转</span></span><br><span class="line">    str.contains(..);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>现在的写法</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String str) {</span><br><span class="line">    str.contains(..);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="Record"><a href="#Record" class="headerlink" title="Record"></a>Record</h2><blockquote>
<p>JDK14预览版推出，JDK16转正</p>
</blockquote>
<p>用<code>record</code> 声明一个类时，该类将自动拥有以下功能：</p>
<ul>
<li>获取成员变量的简单方法，比如例题中的 name() 和 partner() 。注意区别于我们平常getter()的写法。</li>
<li>一个 equals 方法的实现，执行比较时会比较该类的所有成员属性。</li>
<li>重写 hashCode() 方法。</li>
<li>一个可以打印该类所有成员属性的 toString() 方法。</li>
<li>包含所有参数的构造方法。</li>
</ul>
<p>此外：</p>
<ul>
<li><p>还可以定义静态字段、静态方法、构造器或实例方法。</p>
</li>
<li><p>不能定义实例字段；类不能声明为abstract；不能声明显式的父类等。</p>
</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不可以将record定义的类声明为abstract</span></span><br><span class="line"><span class="comment">//不可以给record定义的类声明显式的父类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">Person</span><span class="params">(String name,Person partner)</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">//还可以声明静态的属性、静态的方法、构造器、实例方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String nation;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">showNation</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">return</span> nation;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span>{</span><br><span class="line">        <span class="built_in">this</span>(name,<span class="literal">null</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getNameInUpperCase</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">return</span> name.toUpperCase();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不可以声明非静态的属性</span></span><br><span class="line">    <span class="comment">// private int id;</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="其它结构变化"><a href="#其它结构变化" class="headerlink" title="其它结构变化"></a>其它结构变化</h2><h3 id="下划线使用的限制"><a href="#下划线使用的限制" class="headerlink" title="下划线使用的限制"></a>下划线使用的限制</h3><blockquote>
<p>JDK9新特性</p>
</blockquote>
<p>现在不允许使用”_”作为变量名</p>
<h3 id="更简化的编译运行程序"><a href="#更简化的编译运行程序" class="headerlink" title="更简化的编译运行程序"></a>更简化的编译运行程序</h3><blockquote>
<p>JDK11新特性</p>
</blockquote>
<p>以前</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">// 编译</span><br><span class="line">javac JavaStack.java</span><br><span class="line"></span><br><span class="line">// 运行</span><br><span class="line">java JavaStack</span><br></pre></td></tr></table></figure></div>

<p>现在</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">java JavaStack.java</span><br></pre></td></tr></table></figure></div>

<h2 id="GC方面新特性"><a href="#GC方面新特性" class="headerlink" title="GC方面新特性"></a>GC方面新特性</h2><ul>
<li>此部分待更新</li>
</ul>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a class="link" href="https://zhuanlan.zhihu.com/p/458509231">https://zhuanlan.zhihu.com/p/458509231 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link" href="https://blog.csdn.net/best_luxi/article/details/122543074/">https://blog.csdn.net/best_luxi/article/details/122543074/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link" href="https://www.bilibili.com/video/BV1PY411e7J6">https://www.bilibili.com/video/BV1PY411e7J6 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>2023阿里灵犀互娱春招算法题</title>
    <url>//post/50833/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>原文地址：<a href="https://xuedongyun.cn/post/50833/">https://xuedongyun.cn/post/50833/</a></p>
<h2 id="怪物砍法"><a href="#怪物砍法" class="headerlink" title="怪物砍法"></a>怪物砍法</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>题目已经找不到了，只能口述。怪物有n滴血，你有k个技能，每个技能能打1, 2, 3, 4, …, k滴落血。假设每个技能都能用无限次，每个回合用一次技能，不限回合数。问恰好能把怪物打死的打法。</p>
<p><strong>输入描述</strong></p>
<blockquote>
<p>输入两个正整数n和k，代表怪物的血量和技能的数量</p>
<p>1 &lt;= n &lt;= 1000</p>
<p>1 &lt;= k &lt;= 100</p>
</blockquote>
<p><strong>输出描述</strong></p>
<blockquote>
<p>一个整数，代表打法的数量对10^9+7取模的值。</p>
</blockquote>
<p><strong>样例输入</strong></p>
<blockquote>
<p>3 2</p>
</blockquote>
<p><strong>样例输出</strong></p>
<blockquote>
<p>3</p>
</blockquote>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>刚开始做这道题，一直在想打法可能会重复，该如何解决重复的问题。后面想到一种二维dp的方法。假设<code>dp(i, j)</code>表示怪物i滴血，j次打死的打法数量，那么有状态转移方程：</p>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.663ex;" xmlns="http://www.w3.org/2000/svg" width="27.732ex" height="2.36ex" role="img" focusable="false" viewBox="0 -750 12257.5 1043.1"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mi" transform="translate(520,0)"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"></path></g><g data-mml-node="mo" transform="translate(1023,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mi" transform="translate(1301,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1646,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g><g data-mml-node="mo" transform="translate(1924,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mi" transform="translate(2202,0)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"></path></g><g data-mml-node="mo" transform="translate(2614,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g><g data-mml-node="mo" transform="translate(3169.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="munder" transform="translate(4225.6,0)"><g data-mml-node="mo"><path data-c="2211" d="M61 748Q64 750 489 750H913L954 640Q965 609 976 579T993 533T999 516H979L959 517Q936 579 886 621T777 682Q724 700 655 705T436 710H319Q183 710 183 709Q186 706 348 484T511 259Q517 250 513 244L490 216Q466 188 420 134T330 27L149 -187Q149 -188 362 -188Q388 -188 436 -188T506 -189Q679 -189 778 -162T936 -43Q946 -27 959 6H999L913 -249L489 -250Q65 -250 62 -248Q56 -246 56 -239Q56 -234 118 -161Q186 -81 245 -11L428 206Q428 207 242 462L57 717L56 728Q56 744 61 748Z"></path></g><g data-mml-node="mi" transform="translate(1089,-285.4) scale(0.707)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g></g><g data-mml-node="mi" transform="translate(5899.6,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mi" transform="translate(6419.6,0)"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"></path></g><g data-mml-node="mo" transform="translate(6922.6,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mi" transform="translate(7200.6,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(7767.8,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(8768.1,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mo" transform="translate(9289.1,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g><g data-mml-node="mo" transform="translate(9567.1,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mi" transform="translate(9845.1,0)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"></path></g><g data-mml-node="mo" transform="translate(10479.3,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(11479.5,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(11979.5,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g></g></g></svg></mjx-container></p>
<p>因为最后一次伤害不同，所以一定不会出现重复的情况。打死一只n滴血的怪物需要的回合数最少为：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.798ex;" xmlns="http://www.w3.org/2000/svg" width="3.964ex" height="2.495ex" role="img" focusable="false" viewBox="0 -750 1752.3 1102.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2308" d="M174 734Q178 746 190 750H298H369Q400 750 411 747T422 730T411 713T372 709Q365 709 345 709T310 710H214V-235Q206 -248 196 -250Q192 -250 189 -249T184 -247T180 -244T178 -241T176 -237T174 -234V734Z"></path></g><g data-mml-node="mfrac" transform="translate(444,0)"><g data-mml-node="mi" transform="translate(220,394) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(247.9,-345) scale(0.707)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><rect width="624.3" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(1308.3,0)"><path data-c="2309" d="M21 717T21 730T32 746T75 750H147H256Q266 742 269 735V-235Q262 -248 251 -250Q247 -250 244 -249T239 -247T235 -244T233 -241T231 -237T229 -234V710H133Q119 710 99 710T71 709Q43 709 32 713Z"></path></g></g></g></svg></mjx-container>，最大为：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 600 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container>。我们只需要将回合数在这个区间的打法求和即可。</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="number">1_000_000_007</span>;</span><br><span class="line"></span><br><span class="line">k = k &gt; n ? n : k;</span><br><span class="line"><span class="type">int</span> <span class="variable">minSkillNum</span> <span class="operator">=</span> (<span class="type">int</span>) Math.ceil(n / k);</span><br><span class="line"><span class="type">int</span> <span class="variable">maxSkillNum</span> <span class="operator">=</span> n;</span><br><span class="line"></span><br><span class="line"><span class="comment">// i滴血，j刀砍死</span></span><br><span class="line"><span class="type">long</span>[][] dp = <span class="keyword">new</span> <span class="title class_">long</span>[n + <span class="number">1</span>][maxSkillNum + <span class="number">1</span>];</span><br><span class="line"><span class="comment">// 1刀砍死</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= k; i++) {</span><br><span class="line">    dp[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 血只有1滴</span></span><br><span class="line">dp[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> Math.max((<span class="type">int</span>) Math.ceil(i / k), <span class="number">2</span>); j &lt;= i; j++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">1</span>; l &lt;= Math.min(k, i-<span class="number">1</span>); l++) {</span><br><span class="line">            dp[i][j] += dp[i - l][j - <span class="number">1</span>];</span><br><span class="line">            dp[i][j] = dp[i][j] % MOD;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> minSkillNum; i &lt;= maxSkillNum; i++) {</span><br><span class="line">    total += dp[n][i];</span><br><span class="line">    total = total % MOD;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">System.out.println(total)</span><br></pre></td></tr></table></figure></div>

<p>算法复杂度：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.798ex;" xmlns="http://www.w3.org/2000/svg" width="15.728ex" height="2.495ex" role="img" focusable="false" viewBox="0 -750 6951.6 1102.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(822.2,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="mo" transform="translate(1822.4,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(2211.4,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mo" transform="translate(2954.7,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mfrac" transform="translate(3954.9,0)"><g data-mml-node="mi" transform="translate(220,394) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(247.9,-345) scale(0.707)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><rect width="624.3" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(4819.2,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(5430.4,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="mi" transform="translate(6430.6,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g></g></g></svg></mjx-container></p>
<h3 id="更优解法"><a href="#更优解法" class="headerlink" title="更优解法"></a>更优解法</h3><p>之前想复杂了，假设<code>dp[i]</code>表示i滴血的打法，那么有状态转移方程：</p>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.663ex;" xmlns="http://www.w3.org/2000/svg" width="19.455ex" height="2.36ex" role="img" focusable="false" viewBox="0 -750 8599.1 1043.1"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mi" transform="translate(520,0)"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"></path></g><g data-mml-node="mo" transform="translate(1023,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mi" transform="translate(1301,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1646,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g><g data-mml-node="mo" transform="translate(2201.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="munder" transform="translate(3257.6,0)"><g data-mml-node="mo"><path data-c="2211" d="M61 748Q64 750 489 750H913L954 640Q965 609 976 579T993 533T999 516H979L959 517Q936 579 886 621T777 682Q724 700 655 705T436 710H319Q183 710 183 709Q186 706 348 484T511 259Q517 250 513 244L490 216Q466 188 420 134T330 27L149 -187Q149 -188 362 -188Q388 -188 436 -188T506 -189Q679 -189 778 -162T936 -43Q946 -27 959 6H999L913 -249L489 -250Q65 -250 62 -248Q56 -246 56 -239Q56 -234 118 -161Q186 -81 245 -11L428 206Q428 207 242 462L57 717L56 728Q56 744 61 748Z"></path></g><g data-mml-node="mi" transform="translate(1089,-285.4) scale(0.707)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g></g><g data-mml-node="mi" transform="translate(4931.6,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mi" transform="translate(5451.6,0)"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"></path></g><g data-mml-node="mo" transform="translate(5954.6,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mi" transform="translate(6232.6,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(6799.8,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(7800.1,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mo" transform="translate(8321.1,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g></g></g></svg></mjx-container></p>
<p>我们只看最后一击即可，因此绝不会重复</p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><blockquote>
<p>一定要考虑怪物0滴血的情况。比如怪物4滴血时，可以用伤害为4的技能一刀打死，此时就会出现加<code>dp[0]</code>的情况</p>
</blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="number">1_000_000_007</span>;</span><br><span class="line"></span><br><span class="line">k = k &gt; n ? n : k;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span>[] dp = <span class="keyword">new</span> <span class="title class_">long</span>[n+<span class="number">1</span>];</span><br><span class="line"><span class="comment">// 怪物0滴血，只有一种砍法</span></span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= k; j++) {</span><br><span class="line">        <span class="keyword">if</span> (i - j &lt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        dp[i] += dp[i - j];</span><br><span class="line">        dp[i] = dp[i] % MOD;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">System.out.println(dp[n]);</span><br></pre></td></tr></table></figure></div>

<p>算法复杂度：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="5.302ex" height="1.595ex" role="img" focusable="false" viewBox="0 -694 2343.4 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(822.2,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="mi" transform="translate(1822.4,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g></g></g></svg></mjx-container></p>
]]></content>
      <categories>
        <category>算法题</category>
        <category>动态规划</category>
      </categories>
  </entry>
  <entry>
    <title>Github Pages使用自定义域名</title>
    <url>//post/56472/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们可以将静态网页部署在Github Pages上，实现个人主页的搭建。Github Pages的默认访问路径为username.github.io，对于访问来说是有一些麻烦的。因此文本将介绍如何购买自己的域名，并借此来访问Github Pages上的网页。</p>
<p>原文地址：<a href="https://xuedongyun.cn/post/56472/">https://xuedongyun.cn/post/56472/</a></p>
<h2 id="简单概念"><a href="#简单概念" class="headerlink" title="简单概念"></a>简单概念</h2><h3 id="域名级数"><a href="#域名级数" class="headerlink" title="域名级数"></a>域名级数</h3><ul>
<li>顶级域名：又名一级域名，如<code>.com</code>, <code>.org</code>, <code>.net</code>等</li>
<li>二级域名：般是指域名注册人选择使用的网上名称，如<code>baidu.com</code>等</li>
<li>三级域名：可以当做是二级域名的子域名，如<code>zhuanlan.zhihu.com</code>等</li>
</ul>
<h3 id="浏览器输入URL后都发生了什么"><a href="#浏览器输入URL后都发生了什么" class="headerlink" title="浏览器输入URL后都发生了什么"></a>浏览器输入URL后都发生了什么</h3><p>我们这里只简单谈谈DNS的解析过程。众所周知，web应用是通过IP+端口的方式进行访问的，其中浏览器默认访问80端口，也即我们需要通过IP地址来唯一确认访问的服务器。但是IP不方便记忆，域名则可以解决这一问题。域名系统（Domain Name System，缩写：DNS）是互联网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。用户在输入网址后，首先要进行的是DNS域名解析，将地址解析为IP地址。具体来说，在输入一个URL后，DNS域名解析过程如下：</p>
<ul>
<li><strong>浏览器</strong>的缓存：先检查浏览器的DNS缓存，没有则调用系统库函数进行查询</li>
<li><strong>操作系统</strong>的缓存：先检查host文件有无指定，没有才检查操作系统的DNS缓存，再没有则向DNS服务器发送查询请求</li>
<li><strong>路由器</strong>的缓存：路由器也有DNS缓存</li>
<li><strong>本地域名服务器</strong>的缓存：通常由运营商提供，没有则进行递归查询</li>
<li><strong>递归查询</strong>如：<code>本地域名服务器</code>会依次查询<code>根域名服务器</code>、<code>顶级域名服务器</code>、<code>权限域名服务器</code></li>
</ul>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/20/sLa8QNCZyPHReck.png" alt="20180505103009749"></p>
<ul>
<li>最终我们的浏览器会收到域名所对应的IP地址</li>
</ul>
<p>后续，浏览器还会进行<code>TCP连接</code>、<code>处理请求</code>、<code>接受响应</code>、<code>渲染页面</code>等流程，这也就是另外的故事了</p>
<h2 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h2><p>目前来说阿里云，腾讯云等平台都可以很方便的购买域名。一般来说<code>.com</code>, <code>.cn</code>后缀会贵一些，如果想便宜一些的，可以购买<code>.top</code>, <code>.xyz</code>, <code>.net</code>等。总的来说一年的费用一般在几元到十几元不等。我个人在<a class="link" href="https://wanwang.aliyun.com/domain">阿里云域名注册 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>处购买xuedongyun.cn，一年的价格大约35元。</p>
<h2 id="配置DNS"><a href="#配置DNS" class="headerlink" title="配置DNS"></a>配置DNS</h2><p>已经在阿里云购买域名后，可以前往阿里云的<a class="link" href="https://wanwang.aliyun.com/domain/dns">云解析DNS <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>处配置DNS的解析记录。</p>
<ul>
<li>进入云解析DNS-&gt;域名解析，添加我们购买的域名，如xuedongyun.cn</li>
<li>点击添加的域名，进入解析设置，点击添加记录</li>
</ul>
<table>
<thead>
<tr>
<th>记录类型</th>
<th>主机记录</th>
<th>记录值</th>
</tr>
</thead>
<tbody><tr>
<td>CNAME（即指向另一个域名）</td>
<td>即域名前缀，如www等。你也可以选择写@，表示不带前缀。</td>
<td>pigeon-dove.github.com</td>
</tr>
</tbody></table>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/20/vVy4UJxRM3fIXZ6.png" alt="image-20230420163705607"></p>
<h2 id="为Github-Pages绑定域名"><a href="#为Github-Pages绑定域名" class="headerlink" title="为Github Pages绑定域名"></a>为Github Pages绑定域名</h2><p>在Github Pages中，点击Settings-&gt;Pages-&gt;Custom domain，将我们注册的域名填进去即可。记得勾选<code>Enforce HTTPS</code>开启HTTPS。等待片刻后我们就可以使用自己的域名访问网站了。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/20/ZgIBSiNEpMu7hXJ.png" alt="image-20230420163846171"></p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a class="link" href="https://zhuanlan.zhihu.com/p/529826545">https://zhuanlan.zhihu.com/p/529826545 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link" href="https://zhuanlan.zhihu.com/p/80551769">https://zhuanlan.zhihu.com/p/80551769 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>工具和应用</category>
        <category>github</category>
      </categories>
      <tags>
        <tag>博客搭建系列</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo踩坑：hexo使用过程中遇到的问题</title>
    <url>//post/9962/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>原文地址：<a href="https://xuedongyun.cn/post/9962/">https://xuedongyun.cn/post/9962/</a></p>
<h2 id="问题一：部署到Github缺少README"><a href="#问题一：部署到Github缺少README" class="headerlink" title="问题一：部署到Github缺少README"></a>问题一：部署到Github缺少README</h2><ul>
<li><code>/source</code>文件夹下的md文件会被渲染为html</li>
</ul>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ul>
<li>在<code>/source</code>文件夹下创建<code>README.md</code>，在配置文件<code>_config.yml</code>中设置过滤项</li>
</ul>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">skip_render:</span> <span class="string">README.md</span></span><br></pre></td></tr></table></figure></div>

<h2 id="问题二：部署导致Custom-domain被清空"><a href="#问题二：部署导致Custom-domain被清空" class="headerlink" title="问题二：部署导致Custom domain被清空"></a>问题二：部署导致Custom domain被清空</h2><ul>
<li>使用hexo-deployer-git插件，每次部署后Custom domain会被清空，无法使用自己的域名访问网页</li>
</ul>
<h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><ul>
<li>在<code>/source</code>文件夹下新建<code>CNAME</code>文件，内容设为Custom domain的值即可</li>
</ul>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a class="link" href="https://blog.maodai.site/2019/05/28/%E7%94%A8Hexo%E5%BB%BA%E7%AB%8BBlog%E6%97%B6%E6%89%80%E7%A2%B0%E5%88%B0%E7%9A%84%E5%90%84%E7%A7%8D%E5%9D%91/">https://blog.maodai.site/2019/05/28/%E7%94%A8Hexo%E5%BB%BA%E7%AB%8BBlog%E6%97%B6%E6%89%80%E7%A2%B0%E5%88%B0%E7%9A%84%E5%90%84%E7%A7%8D%E5%9D%91/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>工具和应用</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>博客搭建系列</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建个人图床</title>
    <url>//post/28873/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在编写markdown文档的过程中，免不了插入一些图片。但是在分享的时候，这些带有图片资源的markdown就显得十分麻烦了。同时我也有写博客的习惯，hexo等用md转前端页面的项目在处理图片时也会遇到各种不舒服的操作。因此搭建自己的图床，让markdown成为真正的纯文本文件是一个不错的选择。个人需要的所有图片都可以放在图床中，使用链接分享。</p>
<p>原文地址：<a href="https://xuedongyun.cn/post/28873/">https://xuedongyun.cn/post/28873/</a></p>
<h2 id="注册SMMS图床服务"><a href="#注册SMMS图床服务" class="headerlink" title="注册SMMS图床服务"></a>注册SMMS图床服务</h2><ul>
<li><p>注册SMMS账号</p>
<ul>
<li><p>海外版地址：<a class="link" href="https://sm.ms/">https://sm.ms/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</li>
<li><p>国内版地址：<a class="link" href="https://smms.app/">https://smms.app/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</li>
</ul>
</li>
<li><p>获取SMMS服务的Token</p>
<ul>
<li>在User-&gt;DashBoard-&gt;API Token中获取</li>
</ul>
</li>
</ul>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/19/W7MOSauNJ1LFf63.png" alt="image-20230419200014848"></p>
<h2 id="下载PicGo作为管理软件"><a href="#下载PicGo作为管理软件" class="headerlink" title="下载PicGo作为管理软件"></a>下载PicGo作为管理软件</h2><ul>
<li>下载地址：<a class="link" href="https://molunerfinn.com/PicGo/">https://molunerfinn.com/PicGo/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>图床设置中选择SM.MS，Token填写我们自己获取的Token，域名写对应的比如<code>smms.app</code>即可</li>
</ul>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/19/XLo2gFydi65PHq4.png" alt="image-20230419200030229"></p>
<h2 id="Typora中配置图片上传服务"><a href="#Typora中配置图片上传服务" class="headerlink" title="Typora中配置图片上传服务"></a>Typora中配置图片上传服务</h2><ul>
<li>在文件-&gt;偏好设置-&gt;图像中设置<ul>
<li>插入图片时，设置为上传图片，并对本地和网络图片都应用上述规则</li>
<li>上传服务器设置为PicGo（app），并填写PicGo的路径</li>
</ul>
</li>
</ul>
<blockquote>
<p>遇到的问题：</p>
<ul>
<li>我在验证图床上传选项的时候，遇到了报错<strong>Error: This image has been blocked, please contact webmaster for more information.</strong></li>
<li>但实际使用并未受到影响，这里无视即可</li>
</ul>
</blockquote>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/19/Djep2mt8PASqOC1.png" alt="image-20230419200100008"></p>
<h2 id="安装图片压缩插件"><a href="#安装图片压缩插件" class="headerlink" title="安装图片压缩插件"></a>安装图片压缩插件</h2><p>SMMS免费账号只给了5GB的可用空间，可以说是寸土寸金了。而我上传的图片以截图为主，“得益于”我的2K和4K显示器，图片大小超过了我的需求，所以我希望上传的图片能自动压缩。之前的很多插件，比如picgo-plugin-compress都已断更很久不可用了。最终我发现tinypng不错。</p>
<ul>
<li><p>在PicGo插件设置中搜索tinypng安装即可（你可能需要先安装node.js）</p>
</li>
<li><p>点击tinypng的设置按钮，选择配置plugin。我们需要使用tinify的API，可以在<a class="link" href="https://tinify.cn/developers">https://tinify.cn/developers <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 获取。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/19/Hk5hmpD3b6dzCsP.png" alt="image-20230419195634238"></p>
</li>
<li><p>现在一切就绪，可以很方便的开始所有的工作了！</p>
</li>
</ul>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a class="link" href="https://zhuanlan.zhihu.com/p/618902329">https://zhuanlan.zhihu.com/p/618902329 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link" href="https://blog.csdn.net/CaptainLJP/article/details/130112298">https://blog.csdn.net/CaptainLJP/article/details/130112298 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>工具和应用</category>
        <category>图床</category>
      </categories>
      <tags>
        <tag>博客搭建系列</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo部署：创建个人博客并部署到github</title>
    <url>//post/46487/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文详细记录使用hexo搭建并部署个人博客的全过程。</p>
<p>原文地址：<a href="https://xuedongyun.cn/post/46487/">https://xuedongyun.cn/post/46487/</a></p>
<h2 id="创建hexo项目"><a href="#创建hexo项目" class="headerlink" title="创建hexo项目"></a>创建hexo项目</h2><ul>
<li>在有node.js环境的情况下，搭建项目</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init blog</span><br><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></div>

<ul>
<li>以开发模式运行，查看博客基本情况</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure></div>

<ul>
<li>至此hexo就已搭建好了，本地4000端口即可访问</li>
</ul>
<h2 id="部署到GithubPage"><a href="#部署到GithubPage" class="headerlink" title="部署到GithubPage"></a>部署到GithubPage</h2><ul>
<li>先在github上新建立一个名为”用户名.github.io”的公开仓库</li>
<li>需要安装一个hexo上传github的插件</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></div>

<ul>
<li>修改hexo配置文件 <code>_config.yml</code>指定仓库</li>
</ul>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/pigeon-dove/pigeon-dove.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>现在你可以很方便的将项目部署到github了，以下是几个常用命令</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">hexo deploy		<span class="comment"># hexo d，部署</span></span><br><span class="line">hexo server		<span class="comment"># hexo s，本地服务器预览</span></span><br><span class="line">hexo generate	<span class="comment"># hexo g，构建项目静态文件，输出到/public</span></span><br><span class="line">hexo clean		<span class="comment"># hexo c，清除构建的静态文件</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>我们可以通过<code>hexo server</code>在本地预览我们的网站</li>
<li>也可以先<code>hexo generate</code>将项目打包到<code>/public</code>目录，再<code>hexo deploy</code>推送到github仓库中</li>
</ul>
<blockquote>
<p>问题：GitHub Page访问404</p>
<ul>
<li>我这里遇到了访问pigeon-dove.github.io报404的问题，最后发现是没有开启GitHub Pages</li>
<li>需要在仓库中点击about旁边的齿轮按钮进入设置，然后在Edit repository details中勾选”Use your GitHub Pages website”</li>
</ul>
</blockquote>
<ul>
<li>现在你可以通过username.github.io访问你的网页了</li>
</ul>
<h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><ul>
<li>我个人是不太喜欢hexo默认主题的样式的，可以前往<a class="link" href="https://hexo.io/themes/">https://hexo.io/themes/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 挑选自己中意的主题</li>
<li>我最终选择了<a class="link" href="https://redefine.ohevan.com/">https://redefine.ohevan.com/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 主题，使用方法也很简单，按照说明进行即可</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">npm install hexo-theme-redefine@latest</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/EvanNotFound/hexo-theme-redefine.git themes/redefine</span><br></pre></td></tr></table></figure></div>

<ul>
<li>按照要求，在项目底层目录创建 <code>_config.redefine.yml</code>配置文件，其中我的配置文件如下</li>
</ul>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 更多配置查看官方文档：https://redefine-docs.ohevan.com/</span></span><br><span class="line"><span class="attr">info:</span></span><br><span class="line">  <span class="attr">title:</span> <span class="string">冬云的博客</span></span><br><span class="line">  <span class="attr">author:</span> <span class="string">布鸽不鸽</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">https://pigeon-dove.github.io</span></span><br><span class="line"><span class="attr">defaults:</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">/images/head.jpg</span></span><br><span class="line">  <span class="attr">favicon:</span> <span class="string">/images/favicon.ico</span></span><br><span class="line"><span class="attr">home_banner:</span></span><br><span class="line">  <span class="attr">title:</span> <span class="string">程序员的个人修养</span></span><br><span class="line">  <span class="attr">subtitle:</span></span><br><span class="line">    <span class="attr">text:</span> [<span class="string">"Hello World!"</span>, <span class="string">"Across the Great Wall we can reach every corner in the world"</span>]</span><br><span class="line">    <span class="attr">typing_speed:</span> <span class="number">50</span></span><br><span class="line">  <span class="attr">image:</span></span><br><span class="line">    <span class="attr">light:</span> <span class="string">/images/bg.jpg</span></span><br><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="attr">start:</span> <span class="number">2022</span><span class="string">/4/19</span> <span class="number">20</span><span class="string">:56:00</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>最后在 <code>_config.yml</code>中配置即可</li>
</ul>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">redefine</span></span><br></pre></td></tr></table></figure></div>

<h2 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h2><ul>
<li>hexo会在 <code>source/_posts</code>中创建md文件</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">"博客标题"</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>使用markdown软件正常写文章即可，个人强烈安利 <code>typora</code>这款软件，写完部署即可</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g	<span class="comment"># 将前端项目生成到/public</span></span><br><span class="line">hexo d	<span class="comment"># 将生成的项目部署到github</span></span><br></pre></td></tr></table></figure></div>

<h2 id="关于图片处理"><a href="#关于图片处理" class="headerlink" title="关于图片处理"></a>关于图片处理</h2><ul>
<li>hexo中一个比较简单的处理图片存储的方式，就是把所有需要的资源放在 <code>/source/images</code>文件夹中，然后在markdown中引用</li>
</ul>
<div class="highlight-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="code"><pre><span class="line">![](<span class="link">/images/image.png</span>)</span><br></pre></td></tr></table></figure></div>

<ul>
<li>但这样显然不方便管理，我们可以在 <code>_config.yml</code>中打开文章资源文件夹功能</li>
</ul>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>这样每次创建文章时，就会有一个和文章一样名字的文件夹。图片放置其中，markdown通过相对路径引用即可</li>
</ul>
<blockquote>
<p>typora中图片自动存储</p>
<ul>
<li>如果你使用typora编辑markdown的话，可以在文件-&gt;偏好设置-&gt;图像中，设置插入图像时复制到指定路径，将路径修改为./${filename}</li>
<li>这样在写文章时，可以很方便的随时粘贴图片</li>
</ul>
</blockquote>
<ul>
<li>此时还有一个问题，typora中图片 <code>![](./name/example.png)</code>需要写前缀，但是hexo中则是 <code>![](./example.png)</code>。当然，其实可以写完文章后搜索，全部替换。但我个人还是更推荐使用图床管理所有的图片，让markdown文件成为纯文本文件。我之前写过一篇图床的相关博客，可以参考：<a href="https://xuedongyun.cn/post/28873/">搭建个人图床</a></li>
</ul>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><ul>
<li>最终看一下部署后的样子吧，博客地址<a class="link" href="https://pigeon-dove.github.io/">https://pigeon-dove.github.io/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/19/jq4WxDdYBmX6R8L.png" alt="image-20230419204623211"></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/19/TehisEYGDmoUZ3K.png" alt="image-20230419204521714"></p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a class="link" href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link" href="https://redefine-docs.ohevan.com/getting-started">https://redefine-docs.ohevan.com/getting-started <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>工具和应用</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>博客搭建系列</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo美化：在redefine主题基础上添加评论功能</title>
    <url>//post/27066/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在我使用hexo搭建个人博客，并使用了redefine主题。但是目前网站的评论功能依然是不可用的状态。因此参考<a class="link" href="https://redefine-docs.ohevan.com/posts/comment">官方文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，我们可以将Waline部署到Vercel上，并使用LeanCloud作为数据库，实现个人评论服务器的搭建。简单来说：Waline是一款简洁、安全的评论系统；Vercel则是一个站点托管平台，和Github Pages类似；LeanCloud则提供了免费云存储服务。</p>
<p>原文地址：<a href="https://xuedongyun.cn/post/27066/">https://xuedongyun.cn/post/27066/</a></p>
<h3 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h3><ul>
<li>搭建hexo博客系统，部署到Github Pages</li>
<li>使用了redefine主题</li>
<li>具体方法可以看我<a class="link" href="https://pigeon-dove.github.io/2023/04/18/hexo_github/">之前的博客 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
<h3 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h3><ul>
<li>搭建hexo博客系统，并部署到Github Pages</li>
<li>为hexo博客启用redefine主题</li>
<li>为redefine添加评论功能<ul>
<li>使用LeanCloud作为数据库</li>
<li>使用Waline作为评论发布/评论管理应用</li>
<li>将Waline部署到Vercel上</li>
<li>为Vercel绑定自己的域名（可选）</li>
</ul>
</li>
</ul>
<h2 id="使用LeanCloud作为数据库"><a href="#使用LeanCloud作为数据库" class="headerlink" title="使用LeanCloud作为数据库"></a>使用LeanCloud作为数据库</h2><ul>
<li>进入<a class="link" href="https://leancloud.app/">LeanCloud国际版 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，注册并登录（国内版需要备案，建议使用国际版）</li>
<li>进入<a class="link" href="https://console.leancloud.app/">控制台 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，选择创建应用，选择免费的开发版，取一个喜欢的名字</li>
</ul>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/20/KAZqEjvzkphrRxW.png" alt="image-20230420103922166"></p>
<ul>
<li>点击刚刚创建应用的设置按钮，进入设置界面，选择“应用凭证”，记录下自己的<code>APP ID</code>,<code>APP Key</code>和 <code>Master Key</code></li>
</ul>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/20/GnWXkP2zL7hAMCO.png" alt="image-20230420104201158"></p>
<ul>
<li>现在服务器部分已准备就绪</li>
</ul>
<h2 id="将Waline部署到Vercel上"><a href="#将Waline部署到Vercel上" class="headerlink" title="将Waline部署到Vercel上"></a>将Waline部署到Vercel上</h2><ul>
<li><p>你可能需要先前往<a class="link" href="https://vercel.com/">Vercel <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>进行注册</p>
</li>
<li><p>点击<a class="link" href="https://vercel.com/new/clone?repository-url=https://github.com/walinejs/waline/tree/main/example">此处 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>可直接跳转至Vercel进行部署</p>
</li>
<li><p>我们按照提示，需要创建Github仓库，Vercel会帮我们自动完成仓库的创建等工作。我们只需要指定仓库的名称即可，这里我起名vercel-waline。等待一小会后会提示部署成功，点击“Go to Dashboard”前往控制台。</p>
</li>
</ul>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/20/PyFkqdGwSm3Z67C.png" alt="image-20230420101917149"></p>
<ul>
<li>我们点击此项目的的Settings-&gt;Environment Variables，添加 <code>LEAN_ID</code>, <code>LEAN_KEY</code> 和 <code>LEAN_MASTER_KEY</code>三个值，对应我们在LeanCloud中获取的三个值</li>
</ul>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/20/xRv1SCGEu9TmHat.png" alt="image-20230420105212414"></p>
<ul>
<li>我们点击顶部的Deployments，选择最新的一次部署右侧的Redeploy重新部署，以便我们的设置生效。等待片刻后页面会跳转，提示我们部署成功。我们点击visit即可跳转到部署好的网站地址，此地址就是我们所需评论服务端的地址。或者，我们也可以在顶部Project选项中看到我们所需的服务端地址。</li>
</ul>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/20/MZSrycbRfj7HhnC.png" alt="image-20230420105734452"></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/20/tfaDcPIlAbYRSvj.png" alt="image-20230420110422498"></p>
<h2 id="为hexo配置评论功能"><a href="#为hexo配置评论功能" class="headerlink" title="为hexo配置评论功能"></a>为hexo配置评论功能</h2><ul>
<li>将刚才拿到的服务端地址填写到hexo项目中，redefine的配置文件中即可</li>
</ul>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">comment:</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">waline:</span></span><br><span class="line">      <span class="attr">serverUrl:</span> <span class="string">https://example.example.com</span> <span class="comment">#你拿到的 serverUrl</span></span><br></pre></td></tr></table></figure></div>

<h2 id="绑定国内域名（解决被墙问题）"><a href="#绑定国内域名（解决被墙问题）" class="headerlink" title="绑定国内域名（解决被墙问题）"></a>绑定国内域名（解决被墙问题）</h2><p>由于vercel.app域名在国内被墙，但是其ip并未被墙，因此我们可以绑定自己的域名，解决国内不能使用的问题</p>
<ul>
<li>你可以去阿里云买一个自己的域名，<a class="link" href="https://wanwang.aliyun.com/?spm">地址 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>在阿里云的<a class="link" href="https://dns.console.aliyun.com/?spm">云解析DNS <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>中，你可以添加自己的域名，再点击进入，选择添加记录。</li>
</ul>
<table>
<thead>
<tr>
<th>记录类型</th>
<th>主机记录</th>
<th>记录值</th>
</tr>
</thead>
<tbody><tr>
<td>CNAME（即指向另一个域名）</td>
<td>即域名前缀，如www等。你也可以选择写@，表示不带前缀。我这里选择写comment</td>
<td>cname.vercel-dns.com</td>
</tr>
</tbody></table>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/20/mpRU6KTE2Qa5bHs.png" alt="image-20230420111451974"></p>
<ul>
<li>前往Vercal，点击顶部的Settings-&gt;Domains进入域名配置页</li>
<li>输入你刚才的域名，如我的comment.xuedongyun.com，点击Add即可</li>
</ul>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/20/dSYJuQH9RO1T5b7.png" alt="image-20230420112420709"></p>
<ul>
<li>现在你可以使用你的域名来访问部署在Vercal上的Waline了<ul>
<li>评论系统：example.yourdomain.com</li>
<li>评论管理：example.yourdomain.com/ui</li>
</ul>
</li>
<li>最后记得去redefine配置文件中使用新的域名</li>
</ul>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a class="link" href="https://redefine-docs.ohevan.com/posts/comment">https://redefine-docs.ohevan.com/posts/comment <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link" href="https://waline.js.org/guide/get-started/">https://waline.js.org/guide/get-started/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>工具和应用</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>博客搭建系列</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL必知必会总结笔记</title>
    <url>//post/16749/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是《MySQL必知必会》的总结笔记，可以用于快速查询MySQL基本操作。其中一些不常用的命令被略过，可以另行学习。<br>原文地址：<a href="https://xuedongyun.cn/post/16749/">https://xuedongyun.cn/post/16749/</a></p>
<h2 id="基本概念梳理"><a href="#基本概念梳理" class="headerlink" title="基本概念梳理"></a>基本概念梳理</h2><p>表（table）</p>
<p>列（column）</p>
<p>行（row）</p>
<p>主键（primary key）</p>
<p>SQL（Structured Query Language）</p>
<h3 id="MySQL简介"><a href="#MySQL简介" class="headerlink" title="MySQL简介"></a>MySQL简介</h3><ul>
<li>一种DBMS（数据库管理系统）</li>
<li>基于客户机-服务器类型</li>
</ul>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>为了连接需要以下信息：</p>
<ul>
<li><p>主机名</p>
</li>
<li><p>端口</p>
</li>
<li><p>用户名</p>
</li>
<li><p>口令</p>
</li>
</ul>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul>
<li>选择数据库</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">USE crashcourse;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>查看数据库</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW DATABASES;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>查看当前数据库的表</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW TABLES;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>查看表的列</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW COLUMNS FROM customers;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">DESCRIBE customers;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>其他命令</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><figcaption><span>STATUS;``` 显示广泛的服务器状态信息</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```SHOW CREATE DATABASE;``` ```SHOW CREATE TABLE;``` 显示创建特定数据库或表的MySQL语句</span><br><span class="line"></span><br><span class="line">```SHOW GRANTS;``` 显示用户的安全权限</span><br><span class="line"></span><br><span class="line">```SHOW ERRORS;``` ```SHOW WARNINGS;``` 显示服务器错误或警告信息</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 检索数据</span><br><span class="line"></span><br><span class="line">- 检索单个列</span><br><span class="line"></span><br><span class="line">```mysql</span><br><span class="line">SELECT prod_name FROM products;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>检索多个列</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_id, prod_name from products;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>检索所有的列</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM products;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>检索不同的行</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT DISTINCT vend_id FROM products;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>限制结果</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_name</span><br><span class="line">FROM products</span><br><span class="line">LIMIT 5;</span><br></pre></td></tr></table></figure></div>

<p>​	只返回前5个</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">LIMIT 5, 5;</span><br></pre></td></tr></table></figure></div>

<p>​	第一个数：开始位置</p>
<p>​	第二个数：检索的行数</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">LIMIT 4 OFFSET 3;</span><br></pre></td></tr></table></figure></div>

<p>​	MySQL 5开始的新语法，等价于<code>LIMIT 3, 4</code></p>
<ul>
<li>完全限定表名，数据库</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT products.prod_name</span><br><span class="line">FROM crashcourse.products</span><br></pre></td></tr></table></figure></div>



<h2 id="排序检索数据"><a href="#排序检索数据" class="headerlink" title="排序检索数据"></a>排序检索数据</h2><ul>
<li>ORDER BY子句</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_name</span><br><span class="line">FROM products</span><br><span class="line">ORDER BY prod_name;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>按多个列排序</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ORDER BY prod_price, prod_name;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>指定排序方向</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ORDER BY prod_price DESC;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ORDER BY prod_price DESC, prod_name;</span><br></pre></td></tr></table></figure></div>

<p>​	默认<code>ASC</code></p>
<h2 id="过滤数据"><a href="#过滤数据" class="headerlink" title="过滤数据"></a>过滤数据</h2><ul>
<li>where子句</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_name, prod_proce</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_price BETWEEN 10 AND 20.5;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>支持的操作符</p>
<ul>
<li><p>=, &lt;&gt;, !=, &gt;, &gt;=, &lt;, &lt;=, BETWEEN</p>
</li>
<li><p>BETWEEN包括两端</p>
</li>
</ul>
</li>
<li><p>空值检查</p>
</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_name</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_price IS NULL</span><br></pre></td></tr></table></figure></div>



<h2 id="数据过滤"><a href="#数据过滤" class="headerlink" title="数据过滤"></a>数据过滤</h2><ul>
<li>AND操作符</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">WHERE vend_id = 1003 AND prod_price &lt;= 10;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>OR操作符</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">WHERE vend_id = 1002 OR vend_id = 1003;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>计算次序：AND&gt;OR, 可以加()解决</li>
<li>IN操作符</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">WHERE vend_id IN (1002, 1003)</span><br></pre></td></tr></table></figure></div>

<ul>
<li>NOT操作符</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">WHERE vend_id NOT IN (1002, 1003)</span><br></pre></td></tr></table></figure></div>



<h2 id="通配符进行过滤"><a href="#通配符进行过滤" class="headerlink" title="通配符进行过滤"></a>通配符进行过滤</h2><ul>
<li><p>LIKE操作符，在where中使用</p>
</li>
<li><p>%表示任何字符，出现任意次数</p>
</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">WHERE prod_name LIKE 'jet%'</span><br></pre></td></tr></table></figure></div>

<ul>
<li>_表示任何字符，次数限定为1</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">WHERE prod_name LIKE 'jet_'</span><br></pre></td></tr></table></figure></div>

<ul>
<li>使用技巧<ul>
<li>其他操作符能达到相同目的，就不要使用通配符</li>
<li>除非绝对必要，尽量不要用在搜索模式的开始处，搜索起来是最慢的</li>
</ul>
</li>
</ul>
<h2 id="使用正则表达式"><a href="#使用正则表达式" class="headerlink" title="使用正则表达式"></a>使用正则表达式</h2><ul>
<li>基本字符匹配</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">WHERE prod_name REGEXP '1000'</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">WHERE prod_name REGEXP '.000'</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>正则表达式只要出现了就会匹配，当然也可以使用^和$定位符来匹配整个列值</p>
</li>
<li><p>正则表达式不区分大小写，可以使用BINARY关键词开启区分大小写</p>
</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">WHERE prod_name REGEXP BINARY 'JetPack .000'</span><br></pre></td></tr></table></figure></div>

<ul>
<li>进行OR搜索</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">WHERE prod_name REGEXP '1000|2000|3000'</span><br></pre></td></tr></table></figure></div>

<ul>
<li>匹配几个字符之一</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">WHERE prod_name REGEXP '[123] ton'</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">WHERE prod_name REGEXP '[1|2|3] ton'</span><br></pre></td></tr></table></figure></div>

<ul>
<li>匹配排除几个字符</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">WHERE prod_name REGEXP '[^123] ton'</span><br></pre></td></tr></table></figure></div>

<ul>
<li>匹配范围</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">WHERE prod_name REGEXP '[1-9] ton'</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">WHERE prod_name REGEXP '1 [a-z]on'</span><br></pre></td></tr></table></figure></div>

<ul>
<li>转义特殊符号<ul>
<li><code>\\-</code> <code>\\.</code> <code>\\\</code>等等</li>
<li>元字符<ul>
<li><code>\\f</code> 换页</li>
<li><code>\\n</code> 换行</li>
<li><code>\\r</code> 回车</li>
<li><code>\\t</code> 制表</li>
<li><code>\\v</code> 纵向制表</li>
</ul>
</li>
<li>使用两个<code>\</code>：MySQL自己转义一个，正则表达式转义另一个</li>
</ul>
</li>
<li>匹配字符类<ul>
<li><code>[:alnum:]</code>：任意字符和字母</li>
<li><code>[:alpha:]</code>：任意字符</li>
<li>更多此处略去</li>
</ul>
</li>
<li>重复元字符<ul>
<li><code>*</code>：0或多</li>
<li><code>+</code>：1或多</li>
<li><code>?</code>：0或1</li>
<li><code>{n}</code>：指定数目</li>
<li><code>{n,}</code>：不少于指定数目</li>
<li><code>{n,m}</code>：指定范围</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">WHERE prod_name REGEXP '\\([0-9] stricks?\\)'</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">WHERE prod_name REGEXP '\\([[:digit:]]{4}\\)'</span><br></pre></td></tr></table></figure></div>

<ul>
<li>定位符<ul>
<li><code>^</code>：文本的开始</li>
<li><code>$</code>：文本的结尾</li>
<li><code>[[:&lt;:]]</code>：词的开始</li>
<li><code>[[:&gt;:]]</code>：词的结束</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">WHERE prod_name REGEXP '^[0-9]{4}'</span><br></pre></td></tr></table></figure></div>

<ul>
<li>使用简单正则表达式测试，返回0或1</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 'hello' REGEXP '[0-9]'</span><br></pre></td></tr></table></figure></div>



<h2 id="创建计算字段"><a href="#创建计算字段" class="headerlink" title="创建计算字段"></a>创建计算字段</h2><ul>
<li>Concat()函数拼接</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT Concat(vend_name, '(', vend_country, ')')</span><br><span class="line">FROM vendors</span><br><span class="line">ORDER BY vend_name;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>Trim(), RTrim(), LTrim()去除空格</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT Concat(vend_name, '(', Trim(vend_country), ')')</span><br><span class="line">FROM vendors</span><br><span class="line">ORDER BY vend_name;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>使用别名</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT Concat(vend_name, '(', Trim(vend_country), ')') AS vend_title</span><br><span class="line">FROM vendors</span><br><span class="line">ORDER BY vend_name;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>执行算术计算</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_id, quantity*item_price as expanded_price</span><br><span class="line">FROM orderitems</span><br><span class="line">WHERE order_num = 20005;</span><br></pre></td></tr></table></figure></div>

<p>支持的基本操作符：+, -, *, /</p>
<h2 id="使用数据处理函数"><a href="#使用数据处理函数" class="headerlink" title="使用数据处理函数"></a>使用数据处理函数</h2><p>函数没有SQL可移植性强</p>
<h3 id="文本处理函数"><a href="#文本处理函数" class="headerlink" title="文本处理函数"></a>文本处理函数</h3><ul>
<li>Left(), Right()<ul>
<li><code>Left('xdy', 2)</code>: 返回’xd’</li>
</ul>
</li>
<li>Length()</li>
<li>Locate()<ul>
<li><code>Locate('dy', 'xdy', 0)</code>: 返回子串第一次出现的位置</li>
</ul>
</li>
<li>Lower(), Upper()</li>
<li>LTrim(), RTrim(), Trim()</li>
<li>SubString()</li>
<li>Soundex()<ul>
<li><code>Soundex(lee) = Soundex(lie)</code>: 函数返回语音表示</li>
</ul>
</li>
</ul>
<h3 id="日期和时间处理函数"><a href="#日期和时间处理函数" class="headerlink" title="日期和时间处理函数"></a>日期和时间处理函数</h3><ul>
<li><p>具体函数略</p>
</li>
<li><p>MySQL日期必须是yyyy-mm-dd的格式</p>
</li>
<li><p>基本的日期选择</p>
</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT cust_id, order_num</span><br><span class="line">FROM orders</span><br><span class="line">WHERE order_date = '2005-09-01'</span><br></pre></td></tr></table></figure></div>

<p>order_date数据类型为datatime, 此时匹配的其实是’2005-09-01 00:00:00’</p>
<p>正确的做法应该是：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">WHERE Date(order_date) = '2005-09-01'</span><br></pre></td></tr></table></figure></div>

<ul>
<li>匹配2005年9月的订单</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">WHERE Date(order_date) BETWEEN '2005-09-01' AND '2005-09-30'</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">WHERE Year(order_date) = 2005 AND Month(order_date) = 9</span><br></pre></td></tr></table></figure></div>

<h3 id="数值处理函数"><a href="#数值处理函数" class="headerlink" title="数值处理函数"></a>数值处理函数</h3><ul>
<li>Abs()</li>
<li>Cos(), Sin(), Tan()</li>
<li>Exp()</li>
<li>Mod()</li>
<li>Pi()</li>
<li>Rand()</li>
<li>Sqrt()</li>
</ul>
<h2 id="汇总数据"><a href="#汇总数据" class="headerlink" title="汇总数据"></a>汇总数据</h2><ul>
<li>AVG()函数</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT AVG(prod_price) AS avg_price</span><br></pre></td></tr></table></figure></div>

<p>AVG()函数只能用于单列，忽略NULL的行</p>
<ul>
<li>COUNT()函数</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT COUNT(*) as num_cust</span><br><span class="line">FROM customers</span><br></pre></td></tr></table></figure></div>

<p>COUNT(*)统计行的数量，不忽略NULL</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT COUNT(cust_email) AS num_cust</span><br><span class="line">FROM customers</span><br></pre></td></tr></table></figure></div>

<p>COUNT(column)统计具有值的行的数量，忽略NULL</p>
<ul>
<li>MAX()函数，忽略NULL</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT MAX(prod_price) AS max_price</span><br></pre></td></tr></table></figure></div>

<ul>
<li>MIN()函数，忽略NULL</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT MIN(prod_price) AS max_price</span><br></pre></td></tr></table></figure></div>

<ul>
<li>SUM()函数，忽略NULL</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT SUM(quantity*item_price) AS total_price</span><br></pre></td></tr></table></figure></div>

<ul>
<li>汇聚不同的值，DISTINCT的使用</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT AVG(DISTINCT prod_price) AS avg_price</span><br></pre></td></tr></table></figure></div>

<p>DISTINCT必须指定列名，<code>COUNT(DISTINCT *)</code>肯定不可以</p>
<ul>
<li>组合聚集函数</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT COUNT(*) AS num_items,</span><br><span class="line">		MIN(prod_price) AS price_min,</span><br><span class="line">		MAX(prod_price) AS price_max,</span><br><span class="line">		AVG(prod_price) AS price_avg</span><br><span class="line">FROM products;</span><br></pre></td></tr></table></figure></div>



<h2 id="分组数据"><a href="#分组数据" class="headerlink" title="分组数据"></a>分组数据</h2><ul>
<li>创建分组</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT vend_id, COUNT(*) as num_prods</span><br><span class="line">FROM products</span><br><span class="line">GROUP BY vend_id;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>GROUP BY的一些规则<ul>
<li>可以包含任意列，能对分组进行细致的嵌套</li>
<li>嵌套时，将在最后的分组上汇总</li>
<li>GROUP BY的列，必须在SELECT中（不能是聚集函数）。如果使用了表达式，GROUP BY中也必须使用表达式，不能使用别名</li>
<li>除聚集函数外，别的列都必须在GROUP BY中出现</li>
<li>分组列中NULL将分为一组</li>
<li>必须在WHERE子句之后</li>
</ul>
</li>
<li>过滤分组</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT cust_id, COUNT(*) AS orders</span><br><span class="line">FROM orders</span><br><span class="line">GROUP BY cust_id</span><br><span class="line">HAVING COUNT(*) &gt;= 2;</span><br></pre></td></tr></table></figure></div>

<p>WHERE过滤行而HAVING过滤分组</p>
<ul>
<li>select子句顺序</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">FROM</span><br><span class="line">WHERE</span><br><span class="line">GROUP BY</span><br><span class="line">HAVING</span><br><span class="line">ORDER BY</span><br><span class="line">LIMIT</span><br></pre></td></tr></table></figure></div>



<h2 id="使用子查询"><a href="#使用子查询" class="headerlink" title="使用子查询"></a>使用子查询</h2><ul>
<li>使用子查询进行过滤</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT cust_id</span><br><span class="line">FROM orders</span><br><span class="line">WHERE order_num IN (SELECT order_num</span><br><span class="line">                   FROM orderitems</span><br><span class="line">                   WHERE prod_id = 'TNT2');</span><br></pre></td></tr></table></figure></div>

<p>子查询一般与<code>IN</code>等操作符一起使用，但也可以用于等于<code>=</code>，不等于<code>&lt;&gt;</code>等等</p>
<ul>
<li>作为计算字段使用子查询</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT cust_name, cust_state, (SELECT COUNT(*) FROM orders WHERE orders.cust_id = customers.cust_id) AS orders</span><br><span class="line">FROM customers</span><br><span class="line">ORDER BY cust_name;</span><br></pre></td></tr></table></figure></div>



<h2 id="联结表"><a href="#联结表" class="headerlink" title="联结表"></a>联结表</h2><p>外键：表的某一列，为其他表的主键</p>
<ul>
<li>创建联结</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT vend_name, prod_name, prod_price</span><br><span class="line">FROM vendors, products</span><br><span class="line">WHERE vendors.vend_id = products.vend_id</span><br><span class="line">ORDER BY vend_name, prod_name</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>没有where语句的话，就返回笛卡尔积了</p>
<p>这种联结方式也叫等值联结，内部联结</p>
</blockquote>
<ul>
<li>可以使用另一种方式</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT vend_name, prod_name, prod_price</span><br><span class="line">FROM vendors INNER JOIN products</span><br><span class="line">ON vendors.vend_id = products.vend_id</span><br></pre></td></tr></table></figure></div>

<ul>
<li>联结多个表</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_name, vend_name, prod_price, quantity</span><br><span class="line">FROM orderitems, products, vendors</span><br><span class="line">WHERE products.vend_id = vendors.vend_id</span><br><span class="line">	AND orderitems.prod_id = products.prod_id</span><br><span class="line">	AND order_num = 20005;</span><br></pre></td></tr></table></figure></div>



<h2 id="创建高级联结"><a href="#创建高级联结" class="headerlink" title="创建高级联结"></a>创建高级联结</h2><ul>
<li>自联结</li>
<li>自然联结</li>
<li>外部联结</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">LEFT OUTER JOIN // 从左边选择全部行</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">RIGHT OUTER JOIN // 从右边选择全部行</span><br></pre></td></tr></table></figure></div>

<ul>
<li>使用带聚集函数的联结</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT customers.cust_name, </span><br><span class="line">	customers.cust_id, </span><br><span class="line">	COUNT(orders.order_num) AS num_order</span><br><span class="line">FROM customers LEFT OUTER JOIN orders</span><br><span class="line">ON customers.cust_id = orders.cust_id</span><br><span class="line">GROUP BY customers.cust_id</span><br></pre></td></tr></table></figure></div>



<h2 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h2><ul>
<li>使用UNION</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT vend_id, prod_id, prod_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_price &lt;= 5</span><br><span class="line">UNION</span><br><span class="line">SELECT vend_id, prod_id, prod_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE vend_id IN (1001, 1002);</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>在这个简单例子下，UNION比WHERE子句更复杂</p>
<p>但对于更复杂的过滤条件，或从多个表中检索数据，使用UNION可能更简单</p>
</blockquote>
<ul>
<li>UNION规则<ul>
<li>两条及以上SELECT语句组成，语句之间用UNION分割</li>
<li>每个查询必须包含相同的列，表达式，或聚集函数（次序未必相同）</li>
<li>列数据类型必须兼容，必须是可以隐式转换的类型</li>
</ul>
</li>
<li>包含或取消重复的行<ul>
<li>UNION 默认去重</li>
<li>UNION ALL 不去重</li>
</ul>
</li>
<li>对组合查询结果排序</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT vend_id, prod_id, prod_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_price &lt;= 5</span><br><span class="line">UNION</span><br><span class="line">SELECT vend_id, prod_id, prod_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE vend_id IN (1001, 1002);</span><br><span class="line">ORDER BY vend_id, prod_id</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>只能在最后排一次</p>
</blockquote>
<h2 id="全文搜索"><a href="#全文搜索" class="headerlink" title="全文搜索"></a>全文搜索</h2><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><ul>
<li>插入完整的行</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO customers</span><br><span class="line">	VALUES(NULL, 'Zhou Jielun', 'Taipei', NULL, NULL);</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>如果某列没有值，必须指定NULL</p>
</blockquote>
<ul>
<li>更安全的做法，指定列</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO customers(cust_name, cust_city)</span><br><span class="line">	VALUES('Zhou Jielun', 'Taipei');</span><br></pre></td></tr></table></figure></div>

<ul>
<li>插入多个行</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 多条语句</span><br><span class="line">INSERT INTO customers(cust_name, cust_city)</span><br><span class="line">	VALUES('Zhou Jielun', 'Taipei');</span><br><span class="line">INSERT INTO customers(cust_name, cust_city)</span><br><span class="line">	VALUES('Wang Feng', 'Beijing');</span><br><span class="line">INSERT INTO customers(cust_name, cust_city)</span><br><span class="line">	VALUES('Yang Miao', 'Shanghai');</span><br><span class="line">	</span><br><span class="line">// 可以组合各条语句</span><br><span class="line">INSERT INTO customers(cust_name, cust_city)</span><br><span class="line">	VALUES('Zhou Jielun', 'Taipei'),('Wang Feng', 'Beijing'),('Yang Miao', 'Shanghai');</span><br></pre></td></tr></table></figure></div>

<ul>
<li>插入检索出的数据</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO customer(cust_id, cust_name, cust_city)</span><br><span class="line">SELECT cust_id, cust_name, cust_city FROM customer_new</span><br></pre></td></tr></table></figure></div>



<h2 id="更新和删除数据"><a href="#更新和删除数据" class="headerlink" title="更新和删除数据"></a>更新和删除数据</h2><ul>
<li>更新行</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE customer</span><br><span class="line">SET cust_city = 'Chongqing'</span><br><span class="line">	cust_email = '432431@gamil.com'</span><br><span class="line">WHERE cust_id = 12345;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>删除行</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE FROM customer</span><br><span class="line">WHERE cust_id = 12345;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>更新和删除的原则<ul>
<li>记得带上WHERE，除非真的希望对所有行进行更改</li>
<li>保证每个表都有主键</li>
<li>操作前先用SELECT测试一下</li>
</ul>
</li>
</ul>
<h2 id="创建和操作表"><a href="#创建和操作表" class="headerlink" title="创建和操作表"></a>创建和操作表</h2><ul>
<li>创建表</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE customers IF NOT EXISTS (</span><br><span class="line">	cust_id		int			NOT NULL	AUTO_INCREMENT,</span><br><span class="line">    cust_name	varchar(50)	NOT NULL,</span><br><span class="line">    cust_city	varchar(50)	NULL DEFAULT 'Beijing',</span><br><span class="line">    PRIMARY KEY (cust_id)</span><br><span class="line">)ENGINE=InnoDB;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>使用NULL值</p>
<ul>
<li>每个表列或是NULL列，或是NOT NULL列，在表的创建时规定</li>
<li>NULL为默认设置</li>
</ul>
</li>
<li><p>主键</p>
<ul>
<li>主键必须唯一</li>
<li>主键可以是多个值的组合</li>
</ul>
</li>
<li><p>AUTO_INCREMENT</p>
<ul>
<li>每个表只能有一个AUTO_INCREMENT</li>
<li>它必须被索引（如，通过使他成为主键）</li>
<li>可以使用last_insert_id()函数获得最后一个AUTO_INCRMENT的值，用于后续</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT last_insert_id()</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>指定默认值</p>
<ul>
<li>尽量只用默认值而不是NULL值</li>
</ul>
</li>
<li><p>引擎</p>
<ul>
<li>InnoDB：可靠的事务处理引擎</li>
<li>MyISAM：性能极高的引擎，支持全文搜索，不支持事务</li>
<li>MEMORY：功能等同于MyISAM，但存储在内存，速度极快，适合临时表</li>
</ul>
</li>
<li><p>更新表</p>
<ul>
<li>理想状态下，表中有数据就不该被更新了</li>
<li>添加列</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE customers</span><br><span class="line">ADD vend_phone VARCHAR(20);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>删除列</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE customers</span><br><span class="line">DROP COLUMN vend_phone;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>删除表</p>
</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE customers</span><br></pre></td></tr></table></figure></div>

<ul>
<li>重命名表</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">RENAME TABLE customer TO customer2</span><br></pre></td></tr></table></figure></div>



<h2 id="使用视图"><a href="#使用视图" class="headerlink" title="使用视图"></a>使用视图</h2><ul>
<li>略</li>
</ul>
<h2 id="使用存储过程"><a href="#使用存储过程" class="headerlink" title="使用存储过程"></a>使用存储过程</h2><ul>
<li>略</li>
</ul>
<h2 id="使用游标"><a href="#使用游标" class="headerlink" title="使用游标"></a>使用游标</h2><ul>
<li>略</li>
</ul>
<h2 id="使用触发器"><a href="#使用触发器" class="headerlink" title="使用触发器"></a>使用触发器</h2><ul>
<li>创建触发器</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TRIGGER newproduct AFTER INSERT ON customers</span><br><span class="line">FOR EACH ROW SELECT 'product added';</span><br></pre></td></tr></table></figure></div>

<blockquote>
<ul>
<li><p>BEFORE触发器失败，后续SQL语句也不会执行</p>
</li>
<li><p>BEFORE触发器或SQL语句失败，AFTER触发器也不会执行</p>
</li>
</ul>
</blockquote>
<ul>
<li>删除触发器</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TRIGGER newproduct</span><br></pre></td></tr></table></figure></div>

<ul>
<li>INSERT触发器</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TRIGGER newproduct AFTER INSERT ON products</span><br><span class="line">FOR EACH ROW SELECT NEW.order_num;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>可引用一个虚拟的表NEW访问被插入的行</p>
<ul>
<li><p>BERFORE INSERT时，允许修改插入的值</p>
</li>
<li><p>对于AUTO_INCREAMENT的列，BERFORE INSERT为0，AFTER INSERT为实际值</p>
</li>
</ul>
</blockquote>
<ul>
<li>DELETE触发器</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TRIGGER newproduct BEFORE DELETE ON orders</span><br><span class="line">FOR EACH ROW</span><br><span class="line">BEGIN</span><br><span class="line">	INSERT INTO archieve_order(prod_id, prod_name)</span><br><span class="line">	VALUES(OLD.prod_id, OLD.prod_name);</span><br><span class="line">END;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<ul>
<li><p>可以引用虚拟的OLD表，访问被删除的值</p>
</li>
<li><p>OLD中的值都是只读的</p>
</li>
<li><p>使用BEGIN END的好处是能容纳多条SQL语句</p>
</li>
</ul>
</blockquote>
<ul>
<li>UPDATE触发器</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TRIGGER updatevendor BEFORE UPDATE ON vendors</span><br><span class="line">FOR EACH ROW </span><br><span class="line">SET NEW.vend_state = Upper(New.vend_state);</span><br></pre></td></tr></table></figure></div>

<blockquote>
<ul>
<li>OLD虚拟表访问修改前的值，NEW虚拟表访问修改后的值</li>
<li>BEFORE UPDATE时，NEW的值可以被更改</li>
<li>OLD中的值都是只读的</li>
</ul>
</blockquote>
<h2 id="管理事务处理"><a href="#管理事务处理" class="headerlink" title="管理事务处理"></a>管理事务处理</h2><ul>
<li>略</li>
</ul>
<h2 id="全球化和本地化"><a href="#全球化和本地化" class="headerlink" title="全球化和本地化"></a>全球化和本地化</h2><p><strong>字符集</strong>：字母和符号的集合</p>
<p><strong>编码</strong>：字符集成员的内部表示</p>
<p><strong>校对</strong>：指定字符如何比较的指令</p>
<ul>
<li>略</li>
</ul>
<h2 id="安全管理"><a href="#安全管理" class="headerlink" title="安全管理"></a>安全管理</h2><p>不应当在日常MySQL中使用root</p>
<ul>
<li>获取用户账号列表</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">USE mysql;</span><br><span class="line">SELECT user FROM user;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">+------------------+</span><br><span class="line">| user             |</span><br><span class="line">+------------------+</span><br><span class="line">| mysql.infoschema |</span><br><span class="line">| mysql.session    |</span><br><span class="line">| mysql.sys        |</span><br><span class="line">| root             |</span><br><span class="line">+------------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></div>

<ul>
<li>创建用户账号</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE USER xdy IDENTIFIED BY 'password';</span><br></pre></td></tr></table></figure></div>

<ul>
<li>重命名用户</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">RENAME USER xdy TO xdy123</span><br></pre></td></tr></table></figure></div>

<ul>
<li>删除用户</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP USER xdy;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>查看赋予用户的权限</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW GRANTS FOR xdy;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---------------------------------+</span><br><span class="line">| Grants for xdy@%                |</span><br><span class="line">+---------------------------------+</span><br><span class="line">| GRANT USAGE ON *.* TO `xdy`@`%` |</span><br><span class="line">+---------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><code>USAGE</code>表示没有任何权限。</p>
</blockquote>
<blockquote>
<p>MySQL的权限：用户名和主机名结合定义，若不指定主机名，用默认主机名%</p>
</blockquote>
<ul>
<li>授予权限（用root用户授予）</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRANT SELECT ON project.* TO xdy;</span><br><span class="line">GRANT SELECT, INSERT ON project.* TO xdy;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>授予该用户在project数据库上所有表的SELECT权限</p>
</blockquote>
<ul>
<li>撤销权限</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">REVOKE SELECT ON project.* FROM xdy</span><br></pre></td></tr></table></figure></div>

<ul>
<li>查看所有的权限</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">show privileges;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>更改密码</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET PASSWORD FOR xdy = Password('newPassword');</span><br></pre></td></tr></table></figure></div>

<h2 id="数据库维护"><a href="#数据库维护" class="headerlink" title="数据库维护"></a>数据库维护</h2><ul>
<li>略</li>
</ul>
<h2 id="改善性能"><a href="#改善性能" class="headerlink" title="改善性能"></a>改善性能</h2><ul>
<li>略</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL基础</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot源码系列（1）：版本仲裁</title>
    <url>//post/63124/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们在使用SpringBoot框架时，依赖项可以不写版本号。这背后是通过SpringBoot的版本仲裁实现的。本文中SpringBoot版本号为2.7.5。</p>
<p>原文地址：<a href="https://xuedongyun.cn/post/63124/">https://xuedongyun.cn/post/63124/</a></p>
<h2 id="版本依赖的位置"><a href="#版本依赖的位置" class="headerlink" title="版本依赖的位置"></a>版本依赖的位置</h2><p>创建SpringBoot项目后，我们可以看到本项目的父项目，为<code>spring-boot-starter-parent</code>。按住Ctrl点击进入</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p><code>spring-boot-starter-parent</code>的父项目为<code>spring-boot-dependencies</code>。进入</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p><code>spring-boot-dependencies</code>中几乎申明了所有常见依赖的版本号，以<code>properties</code>的形式存储。</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">activemq.version</span>&gt;</span>5.16.5<span class="tag">&lt;/<span class="name">activemq.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">antlr2.version</span>&gt;</span>2.7.7<span class="tag">&lt;/<span class="name">antlr2.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">appengine-sdk.version</span>&gt;</span>1.9.98<span class="tag">&lt;/<span class="name">appengine-sdk.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artemis.version</span>&gt;</span>2.19.1<span class="tag">&lt;/<span class="name">artemis.version</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>版本仲裁：</p>
<ul>
<li>父项目声明了常用依赖的版本号，其他依赖无需写版本号（自动版本仲裁）</li>
</ul>
</blockquote>
<h2 id="自定义版本"><a href="#自定义版本" class="headerlink" title="自定义版本"></a>自定义版本</h2><p>直接写明版本号</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.31<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>除开直接写版本号外，还可以在自己项目中利用<code>properties</code>声明版本号</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>8.0.21<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="starter命名规则"><a href="#starter命名规则" class="headerlink" title="starter命名规则"></a>starter命名规则</h2><ul>
<li>starter<ul>
<li>引入某种场景的依赖</li>
<li>官方：spring-boot-starter-*</li>
<li>第三方：*-spring-boot-starter</li>
</ul>
</li>
</ul>
<blockquote>
<p>所有<code>spring-boot-starter-*</code>最基本的依赖都是<code>spring-boot-starter</code></p>
</blockquote>
]]></content>
      <categories>
        <category>java</category>
        <category>SpringBoot</category>
        <category>源码</category>
      </categories>
      <tags>
        <tag>SpringBoot源码系列</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot源码系列（10）：@Async原理</title>
    <url>//post/24765/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在SpringBoot中，我们可以使用异步操作来处理耗时的任务。通常我们需要在想异步执行的方法上标注<code>@Async</code>，然后在主启动类上标注<code>@EnableAsync</code>开启异步功能。关于其应用，可以查看我之前的文章：<a href="https://xuedongyun.cn/post/59240/">SpringBoot中的@Asnyc注解</a>。本文将讨论以下问题：</p>
<ul>
<li><code>@EnableAsync</code>和<code>@Async</code>的原理是什么？</li>
<li>SpringBoot中默认的线程池/执行器是如何被指定的？</li>
<li><code>@Async</code>为什么能通过value属性指定使用的执行器？</li>
</ul>
<p>原文地址：<a href="https://xuedongyun.cn/post/24765/">https://xuedongyun.cn/post/24765/</a></p>
<h2 id="异步处理的原理（-EnableAsync）"><a href="#异步处理的原理（-EnableAsync）" class="headerlink" title="异步处理的原理（@EnableAsync）"></a>异步处理的原理（@EnableAsync）</h2><h3 id="EnableAsync"><a href="#EnableAsync" class="headerlink" title="EnableAsync"></a>EnableAsync</h3><p>我们在主启动类上标注了<code>@EnableAsync</code>注解。该注解通过<code>@Import</code>注解，导入了<code>AsyncConfigurationSelector</code></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(AsyncConfigurationSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAsync { }</span><br></pre></td></tr></table></figure></div>

<h3 id="AsyncConfigurationSelector"><a href="#AsyncConfigurationSelector" class="headerlink" title="AsyncConfigurationSelector"></a>AsyncConfigurationSelector</h3><p>继承关系：<code>ImportSelector</code>&lt;-<code>AdviceModeImportSelector&lt;EnableAsync&gt;</code>&lt;-<code>AsyncConfigurationSelector</code></p>
<p><strong>我们先看一看父类中的方法：</strong></p>
<p>在<code>@Configuration</code>配置类上，使用<code>@Import</code>注解导入一个实现了<code>ImportSelector</code>接口的类时：会根据<code>@Configuration</code>配置类的<code>AnnotationMetadata</code>，返回需要导入到容器中的类的名称</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ImportSelector</span> {</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 根据@Configuration配置类的AnnotationMetadata，返回一个class名称列表，来决定向容器中导入哪些类</span></span><br><span class="line">	String[] selectImports(AnnotationMetadata importingClassMetadata);</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">default</span> Predicate&lt;String&gt; <span class="title function_">getExclusionFilter</span><span class="params">()</span> {</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>而<code>AdviceModeImportSelector&lt;EnableAsync&gt;</code>类，实现了<code>selectImports</code>方法。该方法用于获取<code>@EnableAsync</code>注解中的<code>mode</code>对应的值，并调用<code>selectImports(adviceMode)</code>方法。最终返回需要导入的类。这正是我们<code>AsyncConfigurationSelector</code>实现的方法。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码有删减</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AdviceModeImportSelector</span>&lt;A <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; <span class="keyword">implements</span> <span class="title class_">ImportSelector</span> {</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_ADVICE_MODE_ATTRIBUTE_NAME</span> <span class="operator">=</span> <span class="string">"mode"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">protected</span> String <span class="title function_">getAdviceModeAttributeName</span><span class="params">()</span> {</span><br><span class="line">		<span class="keyword">return</span> DEFAULT_ADVICE_MODE_ATTRIBUTE_NAME;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> String[] selectImports(AnnotationMetadata importingClassMetadata) {</span><br><span class="line">        <span class="comment">// 用于当前类，泛型的具体类型（此处是EnableAsync）</span></span><br><span class="line">		Class&lt;?&gt; annType = GenericTypeResolver.resolveTypeArgument(getClass(), AdviceModeImportSelector.class);</span><br><span class="line">        Assert.state(annType != <span class="literal">null</span>, <span class="string">"..."</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取@Configuration配置类的@EnableAsync的属性</span></span><br><span class="line">		<span class="type">AnnotationAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> AnnotationConfigUtils.attributesFor(importingClassMetadata, annType);</span><br><span class="line">        <span class="keyword">if</span> (attributes == <span class="literal">null</span>) { <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"..."</span>); }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 此处getAdviceModeAttributeName()返回"mode"，@EnableAsync注解的"mode"属性默认值是"PROXY"</span></span><br><span class="line">		<span class="type">AdviceMode</span> <span class="variable">adviceMode</span> <span class="operator">=</span> attributes.getEnum(getAdviceModeAttributeName());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用了selectImports(adviceMode)方法</span></span><br><span class="line">		String[] imports = selectImports(adviceMode);</span><br><span class="line">		<span class="keyword">return</span> imports;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">abstract</span> String[] selectImports(AdviceMode adviceMode);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>此时，我们将向容器中导入<code>ProxyAsyncConfiguration</code></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncConfigurationSelector</span> <span class="keyword">extends</span> <span class="title class_">AdviceModeImportSelector</span>&lt;EnableAsync&gt; {</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">public</span> String[] selectImports(AdviceMode adviceMode) {</span><br><span class="line">		<span class="keyword">switch</span> (adviceMode) {</span><br><span class="line">            <span class="comment">// 向容器中导入ProxyAsyncConfiguration</span></span><br><span class="line">			<span class="keyword">case</span> PROXY:</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[] {ProxyAsyncConfiguration.class.getName()};</span><br><span class="line">			<span class="keyword">case</span> ASPECTJ:</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[] {ASYNC_EXECUTION_ASPECT_CONFIGURATION_CLASS_NAME};</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="ProxyAsyncConfiguration"><a href="#ProxyAsyncConfiguration" class="headerlink" title="ProxyAsyncConfiguration"></a>ProxyAsyncConfiguration</h3><p>继承关系：<code>AbstractAsyncConfiguration</code>&lt;-<code>ProxyAsyncConfiguration</code></p>
<p>导入的<code>ProxyAsyncConfiguration</code>是一个<code>@Configuration</code>配置类，它通过<code>@Bean</code>注入了<code>AsyncAnnotationBeanPostProcessor</code>类。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码有删改</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyAsyncConfiguration</span> <span class="keyword">extends</span> <span class="title class_">AbstractAsyncConfiguration</span> {</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Bean(name = TaskManagementConfigUtils.ASYNC_ANNOTATION_PROCESSOR_BEAN_NAME)</span></span><br><span class="line">	<span class="meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class="line">	<span class="keyword">public</span> AsyncAnnotationBeanPostProcessor <span class="title function_">asyncAdvisor</span><span class="params">()</span> {</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 创建了一个PostProcessor，放到容器中</span></span><br><span class="line">		<span class="type">AsyncAnnotationBeanPostProcessor</span> <span class="variable">bpp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AsyncAnnotationBeanPostProcessor</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置了执行器和错误处理器</span></span><br><span class="line">        bpp.configure(<span class="built_in">this</span>.executor, <span class="built_in">this</span>.exceptionHandler);</span><br><span class="line">        </span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">		<span class="keyword">return</span> bpp;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>在其父类<code>AbstractAsyncConfiguration</code>中，通过<code>@Autowired</code>拿到了容器中实现了<code>AsyncConfigurer</code>的组件（获取了线程池）。<code>this.executor</code>就是在此获取值的。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractAsyncConfiguration</span> <span class="keyword">implements</span> <span class="title class_">ImportAware</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过@Autowired拿到了容器中实现了AsyncConfigurer的组件（获取了线程池）</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">setConfigurers</span><span class="params">(ObjectProvider&lt;AsyncConfigurer&gt; configurers)</span> {</span><br><span class="line">        Supplier&lt;AsyncConfigurer&gt; configurer = SingletonSupplier.of(() -&gt; {</span><br><span class="line">			List&lt;AsyncConfigurer&gt; candidates = configurers.stream().collect(Collectors.toList());</span><br><span class="line">			<span class="keyword">if</span> (CollectionUtils.isEmpty(candidates)) {</span><br><span class="line">                <span class="comment">// 没有就返回空</span></span><br><span class="line">				<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">if</span> (candidates.size() &gt; <span class="number">1</span>) {</span><br><span class="line">                <span class="comment">// 只能有一个实现AsyncConfigurer接口的组件</span></span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">"Only one AsyncConfigurer may exist"</span>);</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">return</span> candidates.get(<span class="number">0</span>);</span><br><span class="line">		});</span><br><span class="line">        </span><br><span class="line">		<span class="comment">// this.executor在此处获取</span></span><br><span class="line">		<span class="built_in">this</span>.executor = adapt(configurer, AsyncConfigurer::getAsyncExecutor);</span><br><span class="line">		<span class="built_in">this</span>.exceptionHandler = adapt(configurer, AsyncConfigurer::getAsyncUncaughtExceptionHandler);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><strong>小结1：</strong>我们可以向容器中放入实现了<code>AsyncConfigurer</code>接口的组件，来向容器中放入线程池</p>
</blockquote>
<h3 id="AsyncAnnotationBeanPostProcessor"><a href="#AsyncAnnotationBeanPostProcessor" class="headerlink" title="AsyncAnnotationBeanPostProcessor"></a>AsyncAnnotationBeanPostProcessor</h3><p>继承关系：<code>BeanFactoryAware</code>&lt;-<code>AbstractBeanFactoryAwareAdvisingPostProcessor</code>&lt;-<code>AsyncAnnotationBeanPostProcessor</code></p>
<p>此时<code>AsyncAnnotationBeanPostProcessor</code>往容器中创建了一个增强器<code>AsyncAnnotationAdvisor</code></p>
<blockquote>
<p>在<code>Spring</code>中，如果<code>Bean</code>实现了<code>BeanNameAware</code> 接口，则会默认调用<code>setBeanFactory</code>方法，获取<code>BeanFactory</code>实例</p>
</blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码有删改</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncAnnotationBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title class_">AbstractBeanFactoryAwareAdvisingPostProcessor</span> {</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> {</span><br><span class="line">		<span class="built_in">super</span>.setBeanFactory(beanFactory);</span><br><span class="line">		<span class="comment">//创建一个增强器</span></span><br><span class="line">		<span class="type">AsyncAnnotationAdvisor</span> <span class="variable">advisor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AsyncAnnotationAdvisor</span>(<span class="built_in">this</span>.executor, <span class="built_in">this</span>.exceptionHandler);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.asyncAnnotationType != <span class="literal">null</span>) {</span><br><span class="line">			advisor.setAsyncAnnotationType(<span class="built_in">this</span>.asyncAnnotationType);</span><br><span class="line">		}</span><br><span class="line">		advisor.setBeanFactory(beanFactory);</span><br><span class="line">		<span class="built_in">this</span>.advisor = advisor;</span><br><span class="line">	}</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(<span class="meta">@Nullable</span> Supplier&lt;Executor&gt; executor, </span></span><br><span class="line"><span class="params">                          <span class="meta">@Nullable</span> Supplier&lt;AsyncUncaughtExceptionHandler&gt; exceptionHandler)</span> {</span><br><span class="line">        </span><br><span class="line">		<span class="built_in">this</span>.executor = executor;</span><br><span class="line">		<span class="built_in">this</span>.exceptionHandler = exceptionHandler;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="AsyncAnnotationAdvisor"><a href="#AsyncAnnotationAdvisor" class="headerlink" title="AsyncAnnotationAdvisor"></a>AsyncAnnotationAdvisor</h3><p>在<code>AsyncAnnotationAdvisor</code>中，创建了增强方法<code>this.advice</code>，它其实也实现了<code>BeanNameAware</code>接口</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码有删改</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncAnnotationAdvisor</span> <span class="keyword">extends</span> <span class="title class_">AbstractPointcutAdvisor</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryAware</span> {</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">AsyncAnnotationAdvisor</span><span class="params">(<span class="meta">@Nullable</span> Supplier&lt;Executor&gt; executor, </span></span><br><span class="line"><span class="params">                                  <span class="meta">@Nullable</span> Supplier&lt;AsyncUncaughtExceptionHandler&gt; exceptionHandler)</span> {</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 增强方法this.advice真实类型：AnnotationAsyncExecutionInterceptor</span></span><br><span class="line">		<span class="built_in">this</span>.advice = buildAdvice(executor, exceptionHandler);</span><br><span class="line">		<span class="built_in">this</span>.pointcut = buildPointcut(asyncAnnotationTypes);</span><br><span class="line">	}</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> Advice <span class="title function_">buildAdvice</span><span class="params">(<span class="meta">@Nullable</span> Supplier&lt;Executor&gt; executor, </span></span><br><span class="line"><span class="params">                                 <span class="meta">@Nullable</span> Supplier&lt;AsyncUncaughtExceptionHandler&gt; exceptionHandler)</span> {</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 拦截器</span></span><br><span class="line">		<span class="type">AnnotationAsyncExecutionInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationAsyncExecutionInterceptor</span>(<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//配置此切面的执行器和异常处理器</span></span><br><span class="line">		interceptor.configure(executor, exceptionHandler);</span><br><span class="line">		<span class="keyword">return</span> interceptor;</span><br><span class="line">	}</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 配置此切面的执行器和异常处理器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(<span class="meta">@Nullable</span> Supplier&lt;Executor&gt; defaultExecutor,</span></span><br><span class="line"><span class="params">			<span class="meta">@Nullable</span> Supplier&lt;AsyncUncaughtExceptionHandler&gt; exceptionHandler)</span> {</span><br><span class="line"></span><br><span class="line">		<span class="built_in">this</span>.defaultExecutor = <span class="keyword">new</span> <span class="title class_">SingletonSupplier</span>&lt;&gt;(defaultExecutor, () -&gt; getDefaultExecutor(<span class="built_in">this</span>.beanFactory));</span><br><span class="line">		<span class="built_in">this</span>.exceptionHandler = <span class="keyword">new</span> <span class="title class_">SingletonSupplier</span>&lt;&gt;(exceptionHandler, SimpleAsyncUncaughtExceptionHandler::<span class="keyword">new</span>);</span><br><span class="line">	}</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 此处this.advice也实现了BeanNameAware接口</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> {</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.advice <span class="keyword">instanceof</span> BeanFactoryAware) {</span><br><span class="line">			((BeanFactoryAware) <span class="built_in">this</span>.advice).setBeanFactory(beanFactory);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="AnnotationAsyncExecutionInterceptor"><a href="#AnnotationAsyncExecutionInterceptor" class="headerlink" title="AnnotationAsyncExecutionInterceptor"></a>AnnotationAsyncExecutionInterceptor</h3><p>继承关系：<code>MethodInterceptor</code>&amp;<code>AsyncExecutionAspectSupport</code>&lt;-<code>AsyncExecutionInterceptor</code>&lt;-<code>AnnotationAsyncExecutionInterceptor</code></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AsyncExecutionAspectSupport</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryAware</span> {</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(<span class="meta">@Nullable</span> Supplier&lt;Executor&gt; defaultExecutor,</span></span><br><span class="line"><span class="params">			<span class="meta">@Nullable</span> Supplier&lt;AsyncUncaughtExceptionHandler&gt; exceptionHandler)</span> {</span><br><span class="line">		<span class="comment">// 拿到了默认的执行器/线程池，</span></span><br><span class="line">		<span class="built_in">this</span>.defaultExecutor = <span class="keyword">new</span> <span class="title class_">SingletonSupplier</span>&lt;&gt;(defaultExecutor, () -&gt; getDefaultExecutor(<span class="built_in">this</span>.beanFactory));</span><br><span class="line">		<span class="built_in">this</span>.exceptionHandler = <span class="keyword">new</span> <span class="title class_">SingletonSupplier</span>&lt;&gt;(exceptionHandler, SimpleAsyncUncaughtExceptionHandler::<span class="keyword">new</span>);</span><br><span class="line">	}</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">protected</span> Executor <span class="title function_">getDefaultExecutor</span><span class="params">(<span class="meta">@Nullable</span> BeanFactory beanFactory)</span> {</span><br><span class="line">		<span class="keyword">if</span> (beanFactory != <span class="literal">null</span>) {</span><br><span class="line">			<span class="keyword">try</span> {</span><br><span class="line">				<span class="comment">// 拿唯一的类型为TaskExecutor的组件</span></span><br><span class="line">				<span class="keyword">return</span> beanFactory.getBean(TaskExecutor.class);</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">catch</span> (NoUniqueBeanDefinitionException ex) {</span><br><span class="line">				<span class="keyword">try</span> {</span><br><span class="line">                    <span class="comment">// 容器里有多个TaskExecutor，拿名字叫"taskExecutor"的，类型为Executor的组件</span></span><br><span class="line">					<span class="keyword">return</span> beanFactory.getBean(DEFAULT_TASK_EXECUTOR_BEAN_NAME, Executor.class);</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) {</span><br><span class="line">				<span class="keyword">try</span> {</span><br><span class="line">                    <span class="comment">// 容器里没有TaskExecutor，拿名字叫"taskExecutor"的，类型为Executor的组件</span></span><br><span class="line">					<span class="keyword">return</span> beanFactory.getBean(DEFAULT_TASK_EXECUTOR_BEAN_NAME, Executor.class);</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>更进一步的，<code>AsyncExecutionInterceptor</code>继续重写了<code>getDefaultExecutor</code>，加入一个新的逻辑：如果没有默认执行器，就用<code>SimpleAsyncTaskExecutor</code></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncExecutionInterceptor</span> <span class="keyword">extends</span> <span class="title class_">AsyncExecutionAspectSupport</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span>, Ordered {</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">protected</span> Executor <span class="title function_">getDefaultExecutor</span><span class="params">(<span class="meta">@Nullable</span> BeanFactory beanFactory)</span> {</span><br><span class="line">        <span class="type">Executor</span> <span class="variable">defaultExecutor</span> <span class="operator">=</span> <span class="built_in">super</span>.getDefaultExecutor(beanFactory);</span><br><span class="line">        <span class="keyword">return</span> (defaultExecutor != <span class="literal">null</span> ? defaultExecutor : <span class="keyword">new</span> <span class="title class_">SimpleAsyncTaskExecutor</span>());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><strong>小结2：若容器中只有一个<code>TaskExecutor</code>组件，其为默认执行器；若不唯一，拿名字叫”taskExecutor”的，类型为<code>Executor</code>的组件。若都不满足，使用<code>SimpleAsyncTaskExecutor</code>作为默认执行器（每次执行被注解方法时，单独创建一个Thread来执行）</strong></p>
</blockquote>
<p>在<code>AsyncExecutionInterceptor</code>中，实现了<code>invoke</code>方法，把原来方法的调用提交到新的线程池执行，从而实现了方法的异步。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码有删改</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncExecutionInterceptor</span> <span class="keyword">extends</span> <span class="title class_">AsyncExecutionAspectSupport</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span>, Ordered {</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AsyncExecutionInterceptor</span><span class="params">(<span class="meta">@Nullable</span> Executor defaultExecutor)</span> {</span><br><span class="line">		<span class="built_in">super</span>(defaultExecutor);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(<span class="keyword">final</span> MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable {</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 决定使用哪个executor</span></span><br><span class="line">        <span class="type">AsyncTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> determineAsyncExecutor(userDeclaredMethod);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 创建task（去执行原来方法）</span></span><br><span class="line">		Callable&lt;Object&gt; task = () -&gt; {</span><br><span class="line">			<span class="keyword">try</span> {</span><br><span class="line">				<span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> invocation.proceed();</span><br><span class="line">				<span class="keyword">if</span> (result <span class="keyword">instanceof</span> Future) {</span><br><span class="line">					<span class="keyword">return</span> ((Future&lt;?&gt;) result).get();</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		};</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 提交到新的线程池执行</span></span><br><span class="line">		<span class="keyword">return</span> doSubmit(task, executor, invocation.getMethod().getReturnType());</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="异步处理的原理（-Async）"><a href="#异步处理的原理（-Async）" class="headerlink" title="异步处理的原理（@Async）"></a>异步处理的原理（@Async）</h2><h3 id="AnnotationAsyncExecutionInterceptor-1"><a href="#AnnotationAsyncExecutionInterceptor-1" class="headerlink" title="AnnotationAsyncExecutionInterceptor"></a>AnnotationAsyncExecutionInterceptor</h3><p>继承关系：<code>MethodInterceptor</code>&amp;<code>AsyncExecutionAspectSupport</code>&lt;-<code>AsyncExecutionInterceptor</code>&lt;-<code>AnnotationAsyncExecutionInterceptor</code></p>
<p>我们继续上面一节的内容，<code>AsyncExecutionAspectSupport</code>中实现了<code>determineAsyncExecutor</code>方法，用于确定使用哪个<code>executor</code></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> AsyncTaskExecutor <span class="title function_">determineAsyncExecutor</span><span class="params">(Method method)</span> {</span><br><span class="line">    <span class="type">AsyncTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="built_in">this</span>.executors.get(method);</span><br><span class="line">    <span class="keyword">if</span> (executor == <span class="literal">null</span>) {</span><br><span class="line">        Executor targetExecutor;</span><br><span class="line">        <span class="comment">// 根据@Async注解的value属性，查找对应类型为Executor的异步执行器</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">qualifier</span> <span class="operator">=</span> getExecutorQualifier(method);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasLength(qualifier)) {</span><br><span class="line">            targetExecutor = findQualifiedExecutor(<span class="built_in">this</span>.beanFactory, qualifier);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 如果没找到，获取defaultExecutor（之前已经获取过了）</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            targetExecutor = <span class="built_in">this</span>.defaultExecutor.get();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (targetExecutor == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        executor = (targetExecutor <span class="keyword">instanceof</span> AsyncListenableTaskExecutor ?</span><br><span class="line">                (AsyncListenableTaskExecutor) targetExecutor : <span class="keyword">new</span> <span class="title class_">TaskExecutorAdapter</span>(targetExecutor));</span><br><span class="line">        <span class="comment">// 缓存，为某个方法指定executor</span></span><br><span class="line">        <span class="built_in">this</span>.executors.put(method, executor);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p><code>AnnotationAsyncExecutionInterceptor</code>中实现了<code>getExecutorQualifier</code>方法</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> String <span class="title function_">getExecutorQualifier</span><span class="params">(Method method)</span> {</span><br><span class="line">    <span class="comment">// 核心：拿到@Async注解标注的value</span></span><br><span class="line">    <span class="type">Async</span> <span class="variable">async</span> <span class="operator">=</span> AnnotatedElementUtils.findMergedAnnotation(method, Async.class);</span><br><span class="line">    <span class="keyword">if</span> (async == <span class="literal">null</span>) {</span><br><span class="line">        async = AnnotatedElementUtils.findMergedAnnotation(method.getDeclaringClass(), Async.class);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> (async != <span class="literal">null</span> ? async.value() : <span class="literal">null</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><strong>小结3：</strong>我们可以通过<code>@Async(value="xxx")</code>来手动指定想要使用的执行器</p>
</blockquote>
<h2 id="SpringBoot中的默认线程池"><a href="#SpringBoot中的默认线程池" class="headerlink" title="SpringBoot中的默认线程池"></a>SpringBoot中的默认线程池</h2><h3 id="TaskExecutionAutoConfiguration"><a href="#TaskExecutionAutoConfiguration" class="headerlink" title="TaskExecutionAutoConfiguration"></a>TaskExecutionAutoConfiguration</h3><p>SpringBoot中的线程池，是通过<code>TaskExecutionAutoConfiguration</code>这个自动配置类加载的。我们来看一下其中的源码。</p>
<ol>
<li><code>taskExecutorBuilder</code>方法用于创建一个构造器</li>
<li>在<code>applicationTaskExecutor</code>方法中，使用该构造器创建了线程池</li>
<li><code>TaskExecutionProperties.class</code>属性类，绑定了所有的属性</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnClass(ThreadPoolTaskExecutor.class)</span></span><br><span class="line"><span class="meta">@AutoConfiguration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(TaskExecutionProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskExecutionAutoConfiguration</span> {</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Bean name of the application {@link TaskExecutor}.</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">APPLICATION_TASK_EXECUTOR_BEAN_NAME</span> <span class="operator">=</span> <span class="string">"applicationTaskExecutor"</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 构造器，用于创建线程池</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">	<span class="keyword">public</span> TaskExecutorBuilder <span class="title function_">taskExecutorBuilder</span><span class="params">(TaskExecutionProperties properties,</span></span><br><span class="line"><span class="params">			ObjectProvider&lt;TaskExecutorCustomizer&gt; taskExecutorCustomizers,</span></span><br><span class="line"><span class="params">			ObjectProvider&lt;TaskDecorator&gt; taskDecorator)</span> {</span><br><span class="line">		TaskExecutionProperties.<span class="type">Pool</span> <span class="variable">pool</span> <span class="operator">=</span> properties.getPool();</span><br><span class="line">		<span class="type">TaskExecutorBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskExecutorBuilder</span>();</span><br><span class="line">		builder = builder.queueCapacity(pool.getQueueCapacity());</span><br><span class="line">		builder = builder.corePoolSize(pool.getCoreSize());</span><br><span class="line">		builder = builder.maxPoolSize(pool.getMaxSize());</span><br><span class="line">		builder = builder.allowCoreThreadTimeOut(pool.isAllowCoreThreadTimeout());</span><br><span class="line">		builder = builder.keepAlive(pool.getKeepAlive());</span><br><span class="line">		<span class="type">Shutdown</span> <span class="variable">shutdown</span> <span class="operator">=</span> properties.getShutdown();</span><br><span class="line">		builder = builder.awaitTermination(shutdown.isAwaitTermination());</span><br><span class="line">		builder = builder.awaitTerminationPeriod(shutdown.getAwaitTerminationPeriod());</span><br><span class="line">		builder = builder.threadNamePrefix(properties.getThreadNamePrefix());</span><br><span class="line">		builder = builder.customizers(taskExecutorCustomizers.orderedStream()::iterator);</span><br><span class="line">		builder = builder.taskDecorator(taskDecorator.getIfUnique());</span><br><span class="line">		<span class="keyword">return</span> builder;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 使用构造器，创建线程池Bean，放到容器中</span></span><br><span class="line">    <span class="comment">// name = {applicationTaskExecutor, taskExecutor}</span></span><br><span class="line">	<span class="meta">@Lazy</span></span><br><span class="line">	<span class="meta">@Bean(name = { APPLICATION_TASK_EXECUTOR_BEAN_NAME,</span></span><br><span class="line"><span class="meta">			AsyncAnnotationBeanPostProcessor.DEFAULT_TASK_EXECUTOR_BEAN_NAME })</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean(Executor.class)</span></span><br><span class="line">	<span class="keyword">public</span> ThreadPoolTaskExecutor <span class="title function_">applicationTaskExecutor</span><span class="params">(TaskExecutorBuilder builder)</span> {</span><br><span class="line">		<span class="keyword">return</span> builder.build();</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="TaskExecutionProperties"><a href="#TaskExecutionProperties" class="headerlink" title="TaskExecutionProperties"></a>TaskExecutionProperties</h3><p>该属性配置类绑定到<code>spring.task.execution</code>，我们可以定制SpringBoot线程池中的基本属性</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码有删改</span></span><br><span class="line"><span class="meta">@ConfigurationProperties("spring.task.execution")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskExecutionProperties</span> {</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Pool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pool</span>();</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Shutdown</span> <span class="variable">shutdown</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Shutdown</span>();</span><br><span class="line">	<span class="keyword">private</span> <span class="type">String</span> <span class="variable">threadNamePrefix</span> <span class="operator">=</span> <span class="string">"task-"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Pool</span> {</span><br><span class="line">		<span class="keyword">private</span> <span class="type">int</span> <span class="variable">queueCapacity</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">		<span class="keyword">private</span> <span class="type">int</span> <span class="variable">coreSize</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">		<span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxSize</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>java</category>
        <category>SpringBoot</category>
        <category>源码</category>
      </categories>
      <tags>
        <tag>SpringBoot源码系列</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot源码系列（2）：SpringBootApplication注解</title>
    <url>//post/50220/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在SpringBoot项目中的主类上标注<code>@SpringBootApplication</code>注解，便可实现基本的自动配置功能。本文通过源码了解其背后的原理。本文中SpringBoot版本号为2.7.5。</p>
<p>原文地址：<a href="https://xuedongyun.cn/post/50220/">https://xuedongyun.cn/post/50220/</a></p>
<h2 id="SpringBootApplication的构成"><a href="#SpringBootApplication的构成" class="headerlink" title="@SpringBootApplication的构成"></a>@SpringBootApplication的构成</h2><p><code>@SpringBootApplication</code>注解是一个复合注解，核心由<code>@SpringBootConfiguration</code>, <code>@EnableAutoConfiguration</code>, <code>@ComponentScan</code>三部分构成。接下来我们分别来看三个核心注解的作用</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">		@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication {</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h3><p>Main类本身也是SpringBoot中的配置类，只不过是核心配置类。<code>@SpringBootConfiguration</code>核心其实就是<code>@Configuration</code></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>	<span class="comment">// 核心</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration {</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h3><p>用于指定扫描的类，Spring中的注解，可以具体看看。此处意义不大，暂且略过</p>
<h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><p>本次最核心的注解，用于开启自动配置。它也是一个复合注解，包含<code>@AutoConfigurationPackage</code>和<code>@Import(AutoConfigurationImportSelector.class)</code>两个部分。我们接下来详细看两个部分的代码。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration {</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="@AutoConfigurationPackage"></a>@AutoConfigurationPackage</h4><p>翻译：自动配置包。我们查看其源码，发现它使用<code>@Import</code>注解为容器导入了<code>Registrar</code>组件。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import(AutoConfigurationPackages.Registrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoConfigurationPackage {</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p><code>AutoConfigurationPackages.Registrar</code>组件为容器导入了一系列组件</p>
<blockquote>
<p>我们这里用到了<code>@Import</code>的高级用法</p>
<ol>
<li><p><code>ImportBeanDefinitionRegistrar</code>接口：允许自动配置类向Spring IoC容器中注册额外的组件</p>
<ul>
<li>通过<code>@Import</code>注解导入类时，若该类实现了此接口，会调用其<code>registerBeanDefinitions</code>方法</li>
</ul>
</li>
<li><p><code>DeterminableImports</code>接口：让Spring Boot在自动配置过程中确定哪些类应该被添加到自动配置类的导入列表中</p>
<ul>
<li>当SpringBoot需要自动配置某个类时，若该类实现了此接口，会调用其<code>determineImports</code>方法，用于确定哪些类应该被添加到自动配置类的导入列表中</li>
</ul>
</li>
</ol>
</blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Registrar</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span>, DeterminableImports {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> {</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        	通过注解元信息，当前获取包名，存到了一个数组里</span></span><br><span class="line"><span class="comment">        	new PackageImports(metadata).getPackageNames().toArray(new String[0]) </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        	第一个参数是BeanDefinitionRegistry对象，用于向IOC容器中注册组件</span></span><br><span class="line"><span class="comment">        	第二个参数是一个字符串数组，存包的全限定名</span></span><br><span class="line"><span class="comment">        	该方法扫描指定的包，将其中组件注册到IOC容器中 </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        register(registry, <span class="keyword">new</span> <span class="title class_">PackageImports</span>(metadata).getPackageNames().toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]));</span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 此处该方法不重要</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Object&gt; <span class="title function_">determineImports</span><span class="params">(AnnotationMetadata metadata)</span> {</span><br><span class="line">        <span class="keyword">return</span> Collections.singleton(<span class="keyword">new</span> <span class="title class_">PackageImports</span>(metadata));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>现在，我们Main类所在包下的所有组件，都被自动导入了</p>
<h4 id="Import-AutoConfigurationImportSelector-class"><a href="#Import-AutoConfigurationImportSelector-class" class="headerlink" title="@Import(AutoConfigurationImportSelector.class)"></a>@Import(AutoConfigurationImportSelector.class)</h4><p>通过@Import注解导入了<code>AutoConfigurationImportSelector</code>类型的Bean。<code>AutoConfigurationImportSelector</code>实现了<code>ImportSelector</code>接口，被用于动态地确定应该导入哪些自动配置类。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 略去一部分代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutoConfigurationImportSelector</span> <span class="keyword">implements</span> <span class="title class_">DeferredImportSelector</span>, BeanClassLoaderAware,</span><br><span class="line">		ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered {</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) {</span><br><span class="line">		<span class="keyword">if</span> (!isEnabled(annotationMetadata)) {</span><br><span class="line">			<span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">		}</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用了getAutoConfigurationEntry</span></span><br><span class="line">		<span class="type">AutoConfigurationEntry</span> <span class="variable">autoConfigurationEntry</span> <span class="operator">=</span> getAutoConfigurationEntry(annotationMetadata);</span><br><span class="line">		<span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">	}</span><br><span class="line">            </span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>继续查看<code>getAutoConfigurationEntry</code>方法</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给容器中批量导入组件</span></span><br><span class="line"><span class="keyword">protected</span> AutoConfigurationEntry <span class="title function_">getAutoConfigurationEntry</span><span class="params">(AnnotationMetadata annotationMetadata)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!isEnabled(annotationMetadata)) {</span><br><span class="line">        <span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">AnnotationAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> getAttributes(annotationMetadata);</span><br><span class="line">    <span class="comment">// 加载了候选的配置</span></span><br><span class="line">    List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">    <span class="comment">// 后续对候选的配置做了一些操作，最后返回</span></span><br><span class="line">    configurations = removeDuplicates(configurations);</span><br><span class="line">    Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">    checkExcludedClasses(configurations, exclusions);</span><br><span class="line">    configurations.removeAll(exclusions);</span><br><span class="line">    configurations = getConfigurationClassFilter().filter(configurations);</span><br><span class="line">    fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AutoConfigurationEntry</span>(configurations, exclusions);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><code>getCandidateConfigurations</code>方法获取了所有的候选配置，通过调试可以大概看到</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">"org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration"</span><br><span class="line">"org.springframework.boot.autoconfigure.aop.AopAutoConfiguration"</span><br><span class="line">"org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration"</span><br><span class="line">"org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration"</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div>
</blockquote>
<p>继续查看<code>getCandidateConfigurations</code>方法。</p>
<ol>
<li>会根据传入的<code>AnnotationMetadata</code>和<code>AnnotationAttributes</code>参数，使用<code>SpringFactoriesLoader</code>工具类，加载所有在<code>META-INF/spring.factories</code>文件中声明的类，并将它们添加到一个<code>List</code>中。</li>
<li>还通过<code>ImportCandidates.load()</code>方法，加载了所有在<code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code>文件中声明的<code>AutoConfiguration</code>类，并将它们也添加到了上述的<code>List</code>中。（最新的标准，推荐使用它）</li>
</ol>
<p>我们简单看看<code>SpringFactoriesLoader.loadFactoryNames</code>的代码实现：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 略去一部分代码</span></span><br><span class="line"><span class="keyword">protected</span> List&lt;String&gt; <span class="title function_">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> {</span><br><span class="line">    <span class="comment">// 可以看到，是通过SpringFactoriesLoader.loadFactoryNames获取的候选列表</span></span><br><span class="line">    List&lt;String&gt; configurations = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(</span><br><span class="line">            SpringFactoriesLoader.loadFactoryNames(</span><br><span class="line">                getSpringFactoriesLoaderFactoryClass(),</span><br><span class="line">                getBeanClassLoader()</span><br><span class="line">            )</span><br><span class="line">    );</span><br><span class="line">    ImportCandidates.load(AutoConfiguration.class, getBeanClassLoader()).forEach(configurations::add);</span><br><span class="line">    Assert.notEmpty(configurations, <span class="string">"..."</span>);</span><br><span class="line">    <span class="keyword">return</span> configurations;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 略去一部分代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryType, <span class="meta">@Nullable</span> ClassLoader classLoader)</span> {</span><br><span class="line">    <span class="keyword">return</span> loadSpringFactories(classLoaderToUse).getOrDefault(factoryTypeName, Collections.emptyList());</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; <span class="title function_">loadSpringFactories</span><span class="params">(ClassLoader classLoader)</span> {</span><br><span class="line">    <span class="comment">// key: 接口名, value: 实现类</span></span><br><span class="line">	Map&lt;String, List&lt;String&gt;&gt; result = cache.get(classLoader);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	从"META-INF/spring.factories"加载文件</span></span><br><span class="line"><span class="comment">    	FACTORIES_RESOURCE_LOCATION = "META-INF/spring.factories"</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Enumeration&lt;URL&gt; urls = classLoader.getResources(FACTORIES_RESOURCE_LOCATION);</span><br><span class="line">    <span class="keyword">while</span> (urls.hasMoreElements()) {</span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> urls.nextElement();</span><br><span class="line">        <span class="type">UrlResource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlResource</span>(url);</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) {</span><br><span class="line">            </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>举例说明：<code>spring-boot-test-autoconfigure</code>的<code>META-INF/spring.factories</code>文件为以下内容，其中内容为：接口名+实现类名</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"># DefaultTestExecutionListenersPostProcessors</span><br><span class="line">org.springframework.boot.test.context.DefaultTestExecutionListenersPostProcessor=\</span><br><span class="line">org.springframework.boot.test.autoconfigure.SpringBootDependencyInjectionTestExecutionListener$PostProcessor</span><br><span class="line"></span><br><span class="line"># Spring Test ContextCustomizerFactories</span><br><span class="line">org.springframework.test.context.ContextCustomizerFactory=\</span><br><span class="line">org.springframework.boot.test.autoconfigure.OverrideAutoConfigurationContextCustomizerFactory,\</span><br><span class="line">org.springframework.boot.test.autoconfigure.actuate.metrics.MetricsExportContextCustomizerFactory,\</span><br><span class="line">org.springframework.boot.test.autoconfigure.filter.TypeExcludeFiltersContextCustomizerFactory,\</span><br><span class="line">org.springframework.boot.test.autoconfigure.properties.PropertyMappingContextCustomizerFactory,\</span><br><span class="line">org.springframework.boot.test.autoconfigure.web.servlet.WebDriverContextCustomizerFactory</span><br><span class="line"></span><br><span class="line"># Test Execution Listeners</span><br><span class="line">org.springframework.test.context.TestExecutionListener=\</span><br><span class="line">org.springframework.boot.test.autoconfigure.restdocs.RestDocsTestExecutionListener,\</span><br><span class="line">org.springframework.boot.test.autoconfigure.web.client.MockRestServiceServerResetTestExecutionListener,\</span><br><span class="line">org.springframework.boot.test.autoconfigure.web.servlet.MockMvcPrintOnlyOnFailureTestExecutionListener,\</span><br><span class="line">org.springframework.boot.test.autoconfigure.web.servlet.WebDriverTestExecutionListener,\</span><br><span class="line">org.springframework.boot.test.autoconfigure.webservices.client.MockWebServiceServerTestExecutionListener</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>2.7.0以后，不推荐将配置写入<code>spring.factories</code>中了，推荐写在<code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code>里</p>
</blockquote>
<h2 id="自动配置类会按需开启"><a href="#自动配置类会按需开启" class="headerlink" title="自动配置类会按需开启"></a>自动配置类会按需开启</h2><p>虽然上述场景中，所有自动配置启动时默认加载全部（<code>xxxAutoConfiguration</code>），但是按照每个类的装配规则（<code>@Conditional</code>），最终还是会按需配置</p>
<p>例如：<code>AopAutoConfiguration</code></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutoConfiguration</span></span><br><span class="line"><span class="comment">// spring.aop.auto = true开启aop</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = "spring.aop", name = "auto", havingValue = "true", matchIfMissing = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AopAutoConfiguration</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存在Advice类，</span></span><br><span class="line">	<span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">	<span class="meta">@ConditionalOnClass(Advice.class)</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AspectJAutoProxyingConfiguration</span> { }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有Advice类，则开启的简单的aop功能</span></span><br><span class="line">	<span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingClass("org.aspectj.weaver.Advice")</span></span><br><span class="line">    <span class="comment">// spring.aop.proxy-target-class = true</span></span><br><span class="line">	<span class="meta">@ConditionalOnProperty(prefix = "spring.aop", name = "proxy-target-class", havingValue = "true", matchIfMissing = true)</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ClassProxyingConfiguration</span> { }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>java</category>
        <category>SpringBoot</category>
        <category>源码</category>
      </categories>
      <tags>
        <tag>SpringBoot源码系列</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot源码系列（7）：返回值处理器</title>
    <url>//post/5854/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在SpringBoot/SpringMVC中，我们在<code>@ResponseBody</code>注解标注的<code>Controller</code>中直接返回对象，即可为请求返回所需类型的返回值（比如json格式）。本文就来谈谈返回值处理器的原理。</p>
<p>原文地址：<a href="https://xuedongyun.cn/post/44248/">https://xuedongyun.cn/post/44248/</a></p>
<h2 id="返回值处理器原理"><a href="#返回值处理器原理" class="headerlink" title="返回值处理器原理"></a>返回值处理器原理</h2><h3 id="RequestMappingHandlerAdapter"><a href="#RequestMappingHandlerAdapter" class="headerlink" title="RequestMappingHandlerAdapter"></a>RequestMappingHandlerAdapter</h3><p>有关参数解析的原理，可以查看我之前的文章：<a href="https://xuedongyun.cn/post/13517/">SpringBoot源码系列（5）：参数解析</a></p>
<p><code>RequestMappingHandlerAdapter</code>执行了<code>handleInternal</code>方法。代码中，主要设置了请求值解析器和返回值解析器，然后调用了<code>invocableMethod.invokeAndHandle</code>进行处理</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码有删改</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> ModelAndView <span class="title function_">invokeHandlerMethod</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">        HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line"></span><br><span class="line">    <span class="type">ServletWebRequest</span> <span class="variable">webRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request, response);</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="type">ServletInvocableHandlerMethod</span> <span class="variable">invocableMethod</span> <span class="operator">=</span> createInvocableHandlerMethod(handlerMethod);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// argumentResolvers：请求值解析器，用于确定目标方法每一个参数值是什么</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.argumentResolvers != <span class="literal">null</span>) {</span><br><span class="line">            invocableMethod.setHandlerMethodArgumentResolvers(<span class="built_in">this</span>.argumentResolvers);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// returnValueHandlers：返回值处理器</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.returnValueHandlers != <span class="literal">null</span>) {</span><br><span class="line">            invocableMethod.setHandlerMethodReturnValueHandlers(<span class="built_in">this</span>.returnValueHandlers);</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="type">ModelAndViewContainer</span> <span class="variable">mavContainer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndViewContainer</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行并处理</span></span><br><span class="line">        invocableMethod.invokeAndHandle(webRequest, mavContainer);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> getModelAndView(mavContainer, modelFactory, webRequest);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="ServletInvocableHandlerMethod"><a href="#ServletInvocableHandlerMethod" class="headerlink" title="ServletInvocableHandlerMethod"></a>ServletInvocableHandlerMethod</h3><p>在<code>RequestMappingHandlerAdapter</code>中，调用了<code>invocableMethod.invokeAndHandle</code>。我们现在查看<code>ServletInvocableHandlerMethod</code>的<code>invokeAndHandle</code>方法</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码有删改</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invokeAndHandle</span><span class="params">(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">        Object... providedArgs)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处已拿到返回对象</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> invokeForRequest(webRequest, mavContainer, providedArgs);</span><br><span class="line">    setResponseStatus(webRequest);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 如果返回为空，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (returnValue == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (isRequestNotModified(webRequest) || </span><br><span class="line">            	getResponseStatus() != <span class="literal">null</span> || </span><br><span class="line">            	mavContainer.isRequestHandled()) {</span><br><span class="line">            disableContentCachingIfNecessary(webRequest);</span><br><span class="line">            mavContainer.setRequestHandled(<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检测返回值里有无一些失败原因等</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.hasText(getResponseStatusReason())) {</span><br><span class="line">        mavContainer.setRequestHandled(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 利用返回值处理器，处理返回值</span></span><br><span class="line">        <span class="built_in">this</span>.returnValueHandlers.handleReturnValue(</span><br><span class="line">                returnValue, getReturnValueType(returnValue), mavContainer, webRequest);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="HandlerMethodReturnValueHandlerComposite"><a href="#HandlerMethodReturnValueHandlerComposite" class="headerlink" title="HandlerMethodReturnValueHandlerComposite"></a>HandlerMethodReturnValueHandlerComposite</h3><p>我们来看<code>this.returnValueHandlers</code>的<code>handleReturnValue</code>方法</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleReturnValue</span><span class="params">(<span class="meta">@Nullable</span> Object returnValue, </span></span><br><span class="line"><span class="params">                              MethodParameter returnType,</span></span><br><span class="line"><span class="params">                              ModelAndViewContainer mavContainer, </span></span><br><span class="line"><span class="params">                              NativeWebRequest webRequest)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 找合适的返回值处理器</span></span><br><span class="line">    <span class="type">HandlerMethodReturnValueHandler</span> <span class="variable">handler</span> <span class="operator">=</span> selectHandler(returnValue, returnType);</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"..."</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 利用找到的返回值处理器进行处理</span></span><br><span class="line">    handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>其中，<code>selectHandler</code>方法选择合适的返回值处理器</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> HandlerMethodReturnValueHandler <span class="title function_">selectHandler</span><span class="params">(<span class="meta">@Nullable</span> Object value, </span></span><br><span class="line"><span class="params">                                                      MethodParameter returnType)</span> {</span><br><span class="line">    <span class="comment">// 此处是用来判断是否是异步返回值的，可以先不管</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isAsyncValue</span> <span class="operator">=</span> isAsyncReturnValue(value, returnType);</span><br><span class="line">    <span class="keyword">for</span> (HandlerMethodReturnValueHandler handler : <span class="built_in">this</span>.returnValueHandlers) {</span><br><span class="line">        <span class="keyword">if</span> (isAsyncValue &amp;&amp; !(handler <span class="keyword">instanceof</span> AsyncHandlerMethodReturnValueHandler)) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历所有返回值处理器，寻找相应处理器</span></span><br><span class="line">        <span class="keyword">if</span> (handler.supportsReturnType(returnType)) {</span><br><span class="line">            <span class="keyword">return</span> handler;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p><code>this.returnValueHandlers</code>一共有15种</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.returnValueHandlers = {ArrayList} size = 15</span><br><span class="line">	0 = {ModelAndViewMethodReturnValueHandler}</span><br><span class="line">	1 = {ModelMethodProcessor}</span><br><span class="line">	2 = {ViewMethodReturnValueHandler}</span><br><span class="line">	3 = {ResponseBodyEmitterReturnValueHandler}</span><br><span class="line">	4 = {StreamingResponseBodyReturnValueHandler}</span><br><span class="line">	5 = {HttpEntityMethodProcessor}</span><br><span class="line">	6 = {HttpHeadersReturnValueHandler}</span><br><span class="line">	7 = {CallableMethodReturnValueHandler)</span><br><span class="line">	8 = {DeferredResultMethodReturnValueHandler}</span><br><span class="line">	9 = {AsyncTaskMethodReturnValueHandler}</span><br><span class="line">	10 = {ServletModelAttributeMethodProcessor}</span><br><span class="line">	11 = (RequestResponseBodyMethodProcessor}</span><br><span class="line">	12 = {ViewNameMethodReturnValueHandler}</span><br><span class="line">	13 = {MapMethodProcessor)</span><br><span class="line">	14 = {ServletModelAttributeMethodProcessor}</span><br></pre></td></tr></table></figure></div>

<p>（例子一）<code>ModelAndViewMethodReturnValueHandler</code>的<code>supportsReturnType</code>方法：判断返回值类型是否继承自<code>ModelAndView</code>（也即返回值能否转为<code>ModelAndView</code>类型）</p>
<p>（例子二）<code>RequestResponseBodyMethodProcessor</code>的<code>supportsReturnType</code>方法：判断类或者方法，有没有加<code>@ResponseBody</code>注解</p>
<h3 id="HandlerMethodReturnValueHandler"><a href="#HandlerMethodReturnValueHandler" class="headerlink" title="HandlerMethodReturnValueHandler"></a>HandlerMethodReturnValueHandler</h3><p>以<code>RequestResponseBodyMethodProcessor</code>为例，查看<code>handler.handleReturnValue</code>方法</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleReturnValue</span><span class="params">(<span class="meta">@Nullable</span> Object returnValue, MethodParameter returnType,</span></span><br><span class="line"><span class="params">                              ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {</span><br><span class="line"></span><br><span class="line">    mavContainer.setRequestHandled(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">ServletServerHttpRequest</span> <span class="variable">inputMessage</span> <span class="operator">=</span> createInputMessage(webRequest);</span><br><span class="line">    <span class="type">ServletServerHttpResponse</span> <span class="variable">outputMessage</span> <span class="operator">=</span> createOutputMessage(webRequest);</span><br><span class="line"></span><br><span class="line">   	<span class="comment">// 消息转换器，进行写出操作，将返回值转换为json</span></span><br><span class="line">    writeWithMessageConverters(returnValue, returnType, inputMessage, outputMessage); <span class="comment">// 步入</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>查看<code>writeWithMessageConverters</code>方法。这里包含“内容协商”的核心原理：浏览器能接收的类型“并上”服务器能提供的类型，使用第一个作为使用的媒体类型。之后第二次遍历<code>messageConverters</code>，寻找支持的<code>Converter</code></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码有删改</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">writeWithMessageConverters</span><span class="params">(<span class="meta">@Nullable</span> T value, </span></span><br><span class="line"><span class="params">                                              MethodParameter returnType,</span></span><br><span class="line"><span class="params">                                              ServletServerHttpRequest inputMessage, 		</span></span><br><span class="line"><span class="params">                                              ServletServerHttpResponse outputMessage)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {</span><br><span class="line"></span><br><span class="line">    Object body;</span><br><span class="line">    Class&lt;?&gt; valueType;</span><br><span class="line">    Type targetType;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 判断返回值是不是字符串类型</span></span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> CharSequence) {</span><br><span class="line">        body = value.toString();</span><br><span class="line">        valueType = String.class;</span><br><span class="line">        targetType = String.class;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        body = value;</span><br><span class="line">        valueType = getReturnValueType(body, returnType);</span><br><span class="line">        targetType = GenericTypeResolver.resolveType(getGenericType(returnType), returnType.getContainingClass());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断返回值是不是资源类型（是不是流数据）</span></span><br><span class="line">    <span class="keyword">if</span> (isResourceType(value, returnType)) {</span><br><span class="line">        <span class="comment">// 调用对流数据的处理方法，响应回去</span></span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// MediaType（媒体类型），牵扯到内容协商</span></span><br><span class="line">    <span class="comment">// 浏览器发请求的时候，在请求头的Accept中告诉服务器能接收的类型</span></span><br><span class="line">    <span class="type">MediaType</span> <span class="variable">selectedMediaType</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 先看看响应头中，有没有已经写好的响应内容类型</span></span><br><span class="line">    <span class="type">MediaType</span> <span class="variable">contentType</span> <span class="operator">=</span> outputMessage.getHeaders().getContentType();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isContentTypePreset</span> <span class="operator">=</span> contentType != <span class="literal">null</span> &amp;&amp; contentType.isConcrete();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果response已经有了写好的响应类型，就直接用</span></span><br><span class="line">    <span class="keyword">if</span> (isContentTypePreset) {</span><br><span class="line">        ...</span><br><span class="line">        selectedMediaType = contentType;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 不然，拿到能接收的媒体类型</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> inputMessage.getServletRequest();</span><br><span class="line">        <span class="comment">// 浏览器能接收的类型</span></span><br><span class="line">        List&lt;MediaType&gt; acceptableTypes = getAcceptableMediaTypes(request); </span><br><span class="line">        <span class="comment">// 服务器能产生的类型（遍历所有MessageConverter，看哪些支持，进而统计媒体类型）</span></span><br><span class="line">        List&lt;MediaType&gt; producibleTypes = getProducibleMediaTypes(request, valueType, targetType); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算最终能使用的媒体类型</span></span><br><span class="line">        List&lt;MediaType&gt; mediaTypesToUse = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (MediaType requestedType : acceptableTypes) {</span><br><span class="line">            <span class="keyword">for</span> (MediaType producibleType : producibleTypes) {</span><br><span class="line">                <span class="keyword">if</span> (requestedType.isCompatibleWith(producibleType)) {</span><br><span class="line">                    mediaTypesToUse.add(getMostSpecificMediaType(requestedType, producibleType));</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        MediaType.sortBySpecificityAndQuality(mediaTypesToUse);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 最终拿到selectedMediaType，比如这里就是"application/json"</span></span><br><span class="line">        <span class="keyword">for</span> (MediaType mediaType : mediaTypesToUse) {</span><br><span class="line">            <span class="keyword">if</span> (mediaType.isConcrete()) {</span><br><span class="line">                selectedMediaType = mediaType;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (mediaType.isPresentIn(ALL_APPLICATION_MEDIA_TYPES)) {</span><br><span class="line">                selectedMediaType = MediaType.APPLICATION_OCTET_STREAM;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (selectedMediaType != <span class="literal">null</span>) {</span><br><span class="line">        selectedMediaType = selectedMediaType.removeQualityValue();</span><br><span class="line">        <span class="comment">// 遍历所有的HttpMessageConverter（消息转换器），看谁能处理。（可以看看这个接口的方法）</span></span><br><span class="line">        <span class="keyword">for</span> (HttpMessageConverter&lt;?&gt; converter : <span class="built_in">this</span>.messageConverters) {</span><br><span class="line">            <span class="type">GenericHttpMessageConverter</span> <span class="variable">genericConverter</span> <span class="operator">=</span> </span><br><span class="line">                (converter <span class="keyword">instanceof</span> GenericHttpMessageConverter ? </span><br><span class="line">                 (GenericHttpMessageConverter&lt;?&gt;) converter : <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (genericConverter != <span class="literal">null</span> ?</span><br><span class="line">                <span class="comment">// GenericHttpMessageConverter由canWrite判断能否使用</span></span><br><span class="line">                ((GenericHttpMessageConverter) converter).canWrite(targetType, </span><br><span class="line">                                                                   valueType, </span><br><span class="line">                                                                   selectedMediaType) :</span><br><span class="line">                <span class="comment">// 这里AbstractHttpMessageConverter的canWrite实际上由support和canWrite组成</span></span><br><span class="line">                converter.canWrite(valueType, selectedMediaType)) {</span><br><span class="line">                body = getAdvice().</span><br><span class="line">                    beforeBodyWrite(body, </span><br><span class="line">                                    returnType, </span><br><span class="line">                                    selectedMediaType,</span><br><span class="line">                                    (Class&lt;? <span class="keyword">extends</span> <span class="title class_">HttpMessageConverter</span>&lt;?&gt;&gt;) converter.getClass(),</span><br><span class="line">                                    inputMessage, outputMessage);</span><br><span class="line">                <span class="keyword">if</span> (body != <span class="literal">null</span>) {</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">theBody</span> <span class="operator">=</span> body;</span><br><span class="line">                    LogFormatUtils.traceDebug(<span class="string">"..."</span>);</span><br><span class="line">                    addContentDispositionHeader(inputMessage, outputMessage);</span><br><span class="line">                    <span class="keyword">if</span> (genericConverter != <span class="literal">null</span>) {</span><br><span class="line">                        <span class="comment">// 用当前转换器，写出去，步入</span></span><br><span class="line">                        genericConverter.write(body, targetType, selectedMediaType, outputMessage);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p><code>this.messageConverters</code>有9个，能否使用的判断由<code>support</code>和<code>canWrite</code>共同决定，下面只考虑了<code>support</code>的部分</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.messageConverters = {ArrayList} size = 9</span><br><span class="line">	0={ByteArrayHttpMessageConverter}			只支持Byte类型</span><br><span class="line">	1={StringHttpMessageConverter}				只支持String类型</span><br><span class="line">	2={StringHttpMessageConverter}				只支持String类型（这两个默认字符集不一样，UTF-8和ISO-8859-1）</span><br><span class="line">	3={ResourceHttpMessageConverter)			只支持返回值为Resource</span><br><span class="line">	4={ResourceRegionHttpMessageConverter}		只支持返回值为ResourceRegion</span><br><span class="line">	5={SourceHttpMessageConverter}				只支持返回值为DOMSource，SAXSource，</span><br><span class="line">															StAXSource，StreamSource，Source</span><br><span class="line">	6={AllEncompassingFormHttpMessageConverter}	只支持返回值为MultiValueMap</span><br><span class="line">	7={MappingJackson2HttpMessageConverter}		直接返回true</span><br><span class="line">	8={MappingJackson2HttpMessageConverter}		直接返回true</span><br></pre></td></tr></table></figure></div>

<h3 id="MappingJackson2HttpMessageConverter"><a href="#MappingJackson2HttpMessageConverter" class="headerlink" title="MappingJackson2HttpMessageConverter"></a>MappingJackson2HttpMessageConverter</h3><p><code>genericConverter.write</code>方法（此处为<code>MappingJackson2HttpMessageConverter</code>），利用底层的<code>jackson</code>包，<code>ObjectMapper</code>转换的</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="keyword">final</span> T t, <span class="meta">@Nullable</span> <span class="keyword">final</span> Type type, <span class="meta">@Nullable</span> MediaType contentType,</span></span><br><span class="line"><span class="params">                        HttpOutputMessage outputMessage)</span> <span class="keyword">throws</span> IOException, HttpMessageNotWritableException {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">HttpHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> outputMessage.getHeaders();</span><br><span class="line">    <span class="comment">// 向头中写入数据，此处为Content-Type=application/json</span></span><br><span class="line">    addDefaultHeaders(headers, t, contentType);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可以步入看看，jackson将对象转json，放入response中的一个outputBuffer中</span></span><br><span class="line">    writeInternal(t, type, outputMessage);</span><br><span class="line">    <span class="comment">// 将Buffer中的内容写出</span></span><br><span class="line">    outputMessage.getBody().flush();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="自定义MessageConverter"><a href="#自定义MessageConverter" class="headerlink" title="自定义MessageConverter"></a>自定义MessageConverter</h2><p>假设我们想自定义一个<code>application/my-type</code>协议，请求将返回的<code>User</code>以name-age的格式返回</p>
<p>我们首先要写一个类，实现<code>HttpMessageConverter</code>，重写<code>canWrite</code>，<code>write</code>，<code>getSupportedMediaTypes</code>方法</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConverter</span> <span class="keyword">implements</span> <span class="title class_">HttpMessageConverter</span>&lt;User&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canRead</span><span class="params">(Class&lt;?&gt; clazz, MediaType mediaType)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canWrite</span><span class="params">(Class&lt;?&gt; clazz, MediaType mediaType)</span> {</span><br><span class="line">        <span class="keyword">return</span> clazz.isAssignableFrom(User.class);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;MediaType&gt; <span class="title function_">getSupportedMediaTypes</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> MediaType.parseMediaTypes(<span class="string">"application/my-type"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">read</span><span class="params">(Class&lt;? extends User&gt; clazz, </span></span><br><span class="line"><span class="params">                     HttpInputMessage inputMessage)</span> </span><br><span class="line">        	<span class="keyword">throws</span> HttpMessageNotReadableException {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(User user, </span></span><br><span class="line"><span class="params">                      MediaType contentType, </span></span><br><span class="line"><span class="params">                      HttpOutputMessage outputMessage)</span> </span><br><span class="line">        	<span class="keyword">throws</span> HttpMessageNotWritableException, IOException {</span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> user.getUserName() + <span class="string">"-"</span> + user.getUserAge();</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">body</span> <span class="operator">=</span> outputMessage.getBody();</span><br><span class="line">        body.write(data.getBytes());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>利用<code>WebMvcConfigurer</code>中的<code>extendMessageConverters</code>方法，我们可以向容器中添加自定义的<code>converter</code></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">extendMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> {</span><br><span class="line">        <span class="type">MyConverter</span> <span class="variable">myConverter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyConverter</span>();</span><br><span class="line">        converters.add(myConverter);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>最后，在我们前端的请求中，我们只需要在请求头指定：Accept=application，即可拿到我们想要的格式</p>
<h2 id="总结和补充"><a href="#总结和补充" class="headerlink" title="总结和补充"></a>总结和补充</h2><ol>
<li>标注了<code>@ResponseBody</code>注解</li>
<li>调用<code>RequestResponseBodyMethodProcessor</code>这个返回值处理器</li>
<li>调用各种<code>MessageConverter</code>进行数据的转换</li>
<li><code>MessageConverter</code>可以支持各种媒体类型数据的操作（读，写）</li>
<li>内容协商找到合适的<code>MessageConverter</code></li>
</ol>
<p>那原本已有的<code>MessageConverter</code>是如何被添加的呢？我们来简单看一看源码：</p>
<p>在<code>WebMvcAutoConfiguration</code>中添加了所有的默认<code>MessageConverter</code></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@Import(EnableWebMvcConfiguration.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties({ WebMvcProperties.class, WebProperties.class })</span></span><br><span class="line"><span class="meta">@Order(0)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WebMvcAutoConfigurationAdapter</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span>, ServletContextAware {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> {</span><br><span class="line">        <span class="built_in">this</span>.messageConvertersProvider.ifAvailable(</span><br><span class="line">            (customConverters) -&gt; converters.addAll(customConverters.getConverters())</span><br><span class="line">        );</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>继续查看，简单列出一下执行过的函数：</p>
<p><code>customConverters.getConverters()</code>-&gt;<code>getDefaultConverters()</code>-&gt;<code>defaultMessageConverters()</code>-&gt;<code>getMessageConverters()</code>-&gt;<code>addDefaultHttpMessageConverters()</code></p>
<p>这里自动为我们添加了很多<code>converter</code></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">addDefaultHttpMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters)</span> {</span><br><span class="line">    messageConverters.add(<span class="keyword">new</span> <span class="title class_">ByteArrayHttpMessageConverter</span>());</span><br><span class="line">    messageConverters.add(<span class="keyword">new</span> <span class="title class_">StringHttpMessageConverter</span>());</span><br><span class="line">    messageConverters.add(<span class="keyword">new</span> <span class="title class_">ResourceHttpMessageConverter</span>());</span><br><span class="line">    messageConverters.add(<span class="keyword">new</span> <span class="title class_">ResourceRegionHttpMessageConverter</span>());</span><br><span class="line">    <span class="keyword">if</span> (!shouldIgnoreXml) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            messageConverters.add(<span class="keyword">new</span> <span class="title class_">SourceHttpMessageConverter</span>&lt;&gt;());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (Error err) {</span><br><span class="line">            <span class="comment">// Ignore when no TransformerFactory implementation is available</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    messageConverters.add(<span class="keyword">new</span> <span class="title class_">AllEncompassingFormHttpMessageConverter</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (romePresent) {</span><br><span class="line">        messageConverters.add(<span class="keyword">new</span> <span class="title class_">AtomFeedHttpMessageConverter</span>());</span><br><span class="line">        messageConverters.add(<span class="keyword">new</span> <span class="title class_">RssChannelHttpMessageConverter</span>());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!shouldIgnoreXml) {</span><br><span class="line">        <span class="keyword">if</span> (jackson2XmlPresent) {</span><br><span class="line">            <span class="type">Jackson2ObjectMapperBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> Jackson2ObjectMapperBuilder.xml();</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.applicationContext != <span class="literal">null</span>) {</span><br><span class="line">                builder.applicationContext(<span class="built_in">this</span>.applicationContext);</span><br><span class="line">            }</span><br><span class="line">            messageConverters.add(<span class="keyword">new</span> <span class="title class_">MappingJackson2XmlHttpMessageConverter</span>(builder.build()));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (jaxb2Present) {</span><br><span class="line">            messageConverters.add(<span class="keyword">new</span> <span class="title class_">Jaxb2RootElementHttpMessageConverter</span>());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (kotlinSerializationJsonPresent) {</span><br><span class="line">        messageConverters.add(<span class="keyword">new</span> <span class="title class_">KotlinSerializationJsonHttpMessageConverter</span>());</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (jackson2Present) {</span><br><span class="line">        <span class="type">Jackson2ObjectMapperBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> Jackson2ObjectMapperBuilder.json();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.applicationContext != <span class="literal">null</span>) {</span><br><span class="line">            builder.applicationContext(<span class="built_in">this</span>.applicationContext);</span><br><span class="line">        }</span><br><span class="line">        messageConverters.add(<span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>(builder.build()));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (gsonPresent) {</span><br><span class="line">        messageConverters.add(<span class="keyword">new</span> <span class="title class_">GsonHttpMessageConverter</span>());</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (jsonbPresent) {</span><br><span class="line">        messageConverters.add(<span class="keyword">new</span> <span class="title class_">JsonbHttpMessageConverter</span>());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (jackson2SmilePresent) {</span><br><span class="line">        <span class="type">Jackson2ObjectMapperBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> Jackson2ObjectMapperBuilder.smile();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.applicationContext != <span class="literal">null</span>) {</span><br><span class="line">            builder.applicationContext(<span class="built_in">this</span>.applicationContext);</span><br><span class="line">        }</span><br><span class="line">        messageConverters.add(<span class="keyword">new</span> <span class="title class_">MappingJackson2SmileHttpMessageConverter</span>(builder.build()));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (jackson2CborPresent) {</span><br><span class="line">        <span class="type">Jackson2ObjectMapperBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> Jackson2ObjectMapperBuilder.cbor();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.applicationContext != <span class="literal">null</span>) {</span><br><span class="line">            builder.applicationContext(<span class="built_in">this</span>.applicationContext);</span><br><span class="line">        }</span><br><span class="line">        messageConverters.add(<span class="keyword">new</span> <span class="title class_">MappingJackson2CborHttpMessageConverter</span>(builder.build()));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>比如其中<code>jackson2Present</code>就是如此判断。这也就是为什么我们导入jackson-xml，就能使用的原因</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">jackson2XmlPresent = ClassUtils.isPresent(<span class="string">"com.fasterxml.jackson.dataformat.xml.XmlMapper"</span>, classLoader);</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>java</category>
        <category>SpringBoot</category>
        <category>源码</category>
      </categories>
      <tags>
        <tag>SpringBoot源码系列</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot源码系列（3）：静态资源配置</title>
    <url>//post/3386/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>WebMvcAutoConfiguration</code>中有一些常用的与静态资源相关的配置项，本文回顾一下其中原理。本文中SpringBoot版本号为2.7.5。</p>
<p>原文地址：<a href="https://xuedongyun.cn/post/3386/">https://xuedongyun.cn/post/3386/</a></p>
<h2 id="静态资源配置原理"><a href="#静态资源配置原理" class="headerlink" title="静态资源配置原理"></a>静态资源配置原理</h2><h3 id="WebMvcAutoConfiguration"><a href="#WebMvcAutoConfiguration" class="headerlink" title="WebMvcAutoConfiguration"></a>WebMvcAutoConfiguration</h3><p>SpringBoot启动会自动加载<code>WebMvcAutoConfiguration</code>类。（具体原因可以查看我之前的博客：<a href="https://xuedongyun.cn/post/50220/">SpringBootApplication注解背后的原理</a>），我们首先看看这个自动配置类生效的条件：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码有删减</span></span><br><span class="line"><span class="meta">@AutoConfiguration(after = { DispatcherServletAutoConfiguration.class, </span></span><br><span class="line"><span class="meta">                            TaskExecutionAutoConfiguration.class,</span></span><br><span class="line"><span class="meta">							ValidationAutoConfiguration.class })</span></span><br><span class="line"><span class="comment">// 典型的Web Servlet应用才生效</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication(type = Type.SERVLET)</span></span><br><span class="line"><span class="comment">// 导了SpringMVC有这些类，生效</span></span><br><span class="line"><span class="meta">@ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class })</span></span><br><span class="line"><span class="comment">// 如果容器中有WebMvcConfigurationSupport类，会全面接管SpringMVC</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</span></span><br><span class="line"><span class="meta">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcAutoConfiguration</span> {</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="WebMvcAutoConfigurationAdapter"><a href="#WebMvcAutoConfigurationAdapter" class="headerlink" title="WebMvcAutoConfigurationAdapter"></a>WebMvcAutoConfigurationAdapter</h3><p><code>WebMvcAutoConfiguration</code>类中，还有一个静态类<code>WebMvcAutoConfigurationAdapter</code>。它还绑定了两个属性类<code>WebMvcProperties</code>和<code>WebProperties</code>，我们可以在配置文件中更改相应配置项的属性，实现对某些功能的自定义</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@Import(EnableWebMvcConfiguration.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties({ WebMvcProperties.class, WebProperties.class })</span></span><br><span class="line"><span class="meta">@Order(0)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WebMvcAutoConfigurationAdapter</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span>, ServletContextAware {</span><br></pre></td></tr></table></figure></div>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = "spring.mvc")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcProperties</span> {}</span><br><span class="line"></span><br><span class="line"><span class="meta">@ConfigurationProperties("spring.web")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebProperties</span> {}</span><br></pre></td></tr></table></figure></div>

<p><code>WebMvcAutoConfigurationAdapter</code>只有一个构造函数，所有值从容器中获取</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">WebMvcAutoConfigurationAdapter</span><span class="params">(</span></span><br><span class="line"><span class="params">    // 两个属性类</span></span><br><span class="line"><span class="params">	WebProperties webProperties,</span></span><br><span class="line"><span class="params">	WebMvcProperties mvcProperties,</span></span><br><span class="line"><span class="params">    // Spring的IOC容器</span></span><br><span class="line"><span class="params">    ListableBeanFactory beanFactory,</span></span><br><span class="line"><span class="params">    // 所有的messageConverter，此处不涉及</span></span><br><span class="line"><span class="params">    ObjectProvider&lt;HttpMessageConverters&gt; messageConvertersProvider,</span></span><br><span class="line"><span class="params">    // 所有的资源自定义器，重点</span></span><br><span class="line"><span class="params">    ObjectProvider&lt;ResourceHandlerRegistrationCustomizer&gt; resourceHandlerRegistrationCustomizerProvider,</span></span><br><span class="line"><span class="params">    // DispathcerServlet能处理的所有路径，此处不涉及</span></span><br><span class="line"><span class="params">    ObjectProvider&lt;DispatcherServletPath&gt; dispatcherServletPath,</span></span><br><span class="line"><span class="params">    // 应用注册的原生Servlet，Filter...此处不涉及</span></span><br><span class="line"><span class="params">    ObjectProvider&lt;ServletRegistrationBean&lt;?&gt;&gt; servletRegistrations</span></span><br><span class="line"><span class="params">)</span> {</span><br><span class="line">	<span class="built_in">this</span>.resourceProperties = webProperties.getResources();</span><br><span class="line">	<span class="built_in">this</span>.mvcProperties = mvcProperties;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>在<code>WebMvcAutoConfigurationAdapter</code>类中，有一些与资源相关的核心方法</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> {</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	可以禁用资源的路径映射，所有静态资源都无法访问</span></span><br><span class="line"><span class="comment">    	spring.web.resources.add-mappings = false</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.resourceProperties.isAddMappings()) {</span><br><span class="line">        logger.debug(<span class="string">"Default resource handling disabled"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	所有/webjars/**的静态资源，都会去classpath:/META-INF/resources/webjars/找</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    addResourceHandler(registry, <span class="string">"/webjars/**"</span>, <span class="string">"classpath:/META-INF/resources/webjars/"</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	staticPathPattern 默认值"/**"</span></span><br><span class="line"><span class="comment">    	staticLocations 默认值 { "classpath:/META-INF/resources/", </span></span><br><span class="line"><span class="comment">    							"classpath:/resources/", </span></span><br><span class="line"><span class="comment">    							"classpath:/static/", </span></span><br><span class="line"><span class="comment">    							"classpath:/public/" }</span></span><br><span class="line"><span class="comment">        所有静态资源请求都会去对应路径找</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    addResourceHandler(registry, <span class="built_in">this</span>.mvcProperties.getStaticPathPattern(), (registration) -&gt; {</span><br><span class="line">        registration.addResourceLocations(<span class="built_in">this</span>.resourceProperties.getStaticLocations());</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.servletContext != <span class="literal">null</span>) {</span><br><span class="line">            <span class="type">ServletContextResource</span> <span class="variable">resource</span> <span class="operator">=</span> </span><br><span class="line">            	<span class="keyword">new</span> <span class="title class_">ServletContextResource</span>(<span class="built_in">this</span>.servletContext, SERVLET_LOCATION);</span><br><span class="line">            registration.addResourceLocations(resource);</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码有删减</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addResourceHandler</span><span class="params">(ResourceHandlerRegistry registry, String pattern,</span></span><br><span class="line"><span class="params">        Consumer&lt;ResourceHandlerRegistration&gt; customizer)</span> {</span><br><span class="line">	...</span><br><span class="line">    <span class="comment">// 比如：可以通过spring.web.cache.period控制缓存的时间</span></span><br><span class="line">    registration.setCachePeriod(getSeconds(<span class="built_in">this</span>.resourceProperties.getCache().getPeriod()));</span><br><span class="line">    registration.setCacheControl(<span class="built_in">this</span>.resourceProperties.getCache().getCachecontrol().toHttpCacheControl());</span><br><span class="line">	registration.setUseLastModified(<span class="built_in">this</span>.resourceProperties.getCache().isUseLastModified());</span><br><span class="line">	...</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>前面提到的配置项</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">add-mappings:</span> <span class="literal">false</span> <span class="comment"># 关闭静态资源的访问</span></span><br><span class="line">      <span class="attr">static-locations:</span> [<span class="string">classpath:/haha/</span>, <span class="string">classpath:/page/</span>] <span class="comment"># 静态资源存放路径</span></span><br><span class="line">      <span class="attr">cache:</span></span><br><span class="line">        <span class="attr">period:</span> <span class="number">3600</span> <span class="comment"># 静态资源缓存时间（秒）</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">static-path-pattern:</span> <span class="string">/resources/**</span> <span class="comment"># 改变静态资源访问路径（便于拦截器放行静态资源）</span></span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>java</category>
        <category>SpringBoot</category>
        <category>源码</category>
      </categories>
      <tags>
        <tag>SpringBoot源码系列</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot源码系列（4）：请求映射</title>
    <url>//post/15349/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在SpringBoot/SpringMVC中，请求映射是一个很重要的概念。众所周知，应用中实际上只有一个DispatcherServlet处理所有请求，再交由对应的处理器来处理。本文中SpringBoot版本号为2.7.5。</p>
<p>原文地址：<a href="https://xuedongyun.cn/post/15349/">https://xuedongyun.cn/post/15349/</a></p>
<h2 id="请求映射原理"><a href="#请求映射原理" class="headerlink" title="请求映射原理"></a>请求映射原理</h2><h3 id="FrameworkServlet"><a href="#FrameworkServlet" class="headerlink" title="FrameworkServlet"></a>FrameworkServlet</h3><p>我们知道在SpringMVC中，所有的请求都交由<code>DispatcherServlet</code>统一处理。首先我们看看<code>DispatcherServlet</code>的继承结构</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">HttpServlet</span><br><span class="line">    HttpServletBean</span><br><span class="line">        FrameworkServlet</span><br><span class="line">            DispatcherServlet</span><br></pre></td></tr></table></figure></div>

<p>在<code>FrameworkServlet</code>的源码中，我们可以看到，<code>doGet</code>，<code>doPost</code>，<code>doPut</code>，<code>doDelete</code>等底层都是调用的<code>processRequest</code>方法</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">        <span class="keyword">throws</span> ServletException, IOException {</span><br><span class="line"></span><br><span class="line">    processRequest(request, response);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p><code>processRequest</code>方法核心在于调用了<code>doService</code>方法</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码有删减</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">			<span class="keyword">throws</span> ServletException, IOException {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        doService(request, response);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h3><p><code>FrameworkServlet</code>并未实现<code>doService</code>方法，但是<code>DispatcherServlet</code>继承了该类，实现了此方法。<code>doService</code>方法核心在于调用了<code>doDispatch</code>方法</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码有删减</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        doDispatch(request, response);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p><code>doDispatch</code>方法中，会根据请求，找到哪个handler（controller）能处理当前请求。随后使用找到的handler处理请求，获得<code>ModelAndView</code></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 决定当前请求的handler</span></span><br><span class="line">    processedRequest = checkMultipart(request);</span><br><span class="line">    mappedHandler = getHandler(processedRequest);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (mappedHandler == <span class="literal">null</span>) {</span><br><span class="line">        noHandlerFound(processedRequest, response);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 这里使用了适配器模式，拿到了HandlerAdapter</span></span><br><span class="line">    <span class="type">HandlerAdapter</span> <span class="variable">ha</span> <span class="operator">=</span> getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 处理后返回ModelAndView</span></span><br><span class="line">    mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>可以看到，最为关键的方法为<code>getHandler</code>方法，确定请求具体的handler，我们查看其源码</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> HandlerExecutionChain <span class="title function_">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.handlerMappings != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">for</span> (HandlerMapping mapping : <span class="built_in">this</span>.handlerMappings) {</span><br><span class="line">            <span class="type">HandlerExecutionChain</span> <span class="variable">handler</span> <span class="operator">=</span> mapping.getHandler(request);</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">return</span> handler;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>这里遍历了<code>handlerMappings</code>，调试可以看到，包含五个</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.handlerMappings = {ArrayList} size = 5</span><br><span class="line">	0 = {RequestMappingHandlerMapping}</span><br><span class="line">	1 = {WelcomePageHandlerMapping}</span><br><span class="line">	2 = {BeanNameUrlHandlerMapping}</span><br><span class="line">	3 = {RouterFunctionMapping}</span><br><span class="line">	4 = {SimpleUrlHandlerMapping}</span><br></pre></td></tr></table></figure></div>

<p><code>RequestMappingHandlerMapping</code>保存了所有<code>@RequestMapping</code>注解的请求映射规则。在<code>.mappingRegistry.registry</code>可以看到所有<code>Controller</code>路径都在其中（以及错误路径/error）</p>
<h3 id="WebMvcAutoConfiguration"><a href="#WebMvcAutoConfiguration" class="headerlink" title="WebMvcAutoConfiguration"></a>WebMvcAutoConfiguration</h3><p>在<code>WebMvcAutoConfiguration</code>中，SpringBoot为我们注册了所有的<code>HandlerMapping</code></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	代码有删减</span></span><br><span class="line"><span class="comment">	映射了所有标@RequestMapping注解的Controller的路径</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> RequestMappingHandlerAdapter <span class="title function_">createRequestMappingHandlerAdapter</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">RequestMappingHandlerMapping</span> <span class="variable">mapping</span> <span class="operator">=</span> <span class="built_in">this</span>.mvcRegistrations.getRequestMappingHandlerMapping();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	代码有删减</span></span><br><span class="line"><span class="comment">	欢迎页</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> WelcomePageHandlerMapping <span class="title function_">welcomePageHandlerMapping</span><span class="params">(ApplicationContext applicationContext,</span></span><br><span class="line"><span class="params">        FormattingConversionService mvcConversionService, ResourceUrlProvider mvcResourceUrlProvider)</span> {</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>java</category>
        <category>SpringBoot</category>
        <category>源码</category>
      </categories>
      <tags>
        <tag>SpringBoot源码系列</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot源码系列（5）：参数解析</title>
    <url>//post/13517/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在SpringBoot/SpringMVC中，我们能在Controller中解析出请求的参数，本文谈一谈其背后的原理。本文中SpringBoot版本号为2.7.5。</p>
<p>原文地址：<a href="https://xuedongyun.cn/post/13517/">https://xuedongyun.cn/post/13517/</a></p>
<h2 id="参数解析原理"><a href="#参数解析原理" class="headerlink" title="参数解析原理"></a>参数解析原理</h2><h3 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h3><p>之前的文章已经提到，<code>DispatcherServlet</code>的核心方法是<code>doDispatch</code>。在<code>doDispatch</code>方法中，我们先通过<code>HandlerMappings</code>找到了<code>handler</code>。再为当前<code>Handler</code>找到<code>HandlerAdapter</code>。</p>
<p>这一部分可以查看我之前的博文复习：<a href="https://xuedongyun.cn/post/15349/">SpringBoot源码系列（4）：请求映射</a>。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">mappedHandler = getHandler(processedRequest);</span><br><span class="line"><span class="type">HandlerAdapter</span> <span class="variable">ha</span> <span class="operator">=</span> getHandlerAdapter(mappedHandler.getHandler());</span><br></pre></td></tr></table></figure></div>

<p><code>getHandlerAdapter</code>方法，遍历<code>this.handlerAdapters</code>，来找到合适的<code>HandlerAdapter</code></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> HandlerAdapter <span class="title function_">getHandlerAdapter</span><span class="params">(Object handler)</span> <span class="keyword">throws</span> ServletException {</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.handlerAdapters != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">for</span> (HandlerAdapter adapter : <span class="built_in">this</span>.handlerAdapters) {</span><br><span class="line">            <span class="keyword">if</span> (adapter.supports(handler)) {</span><br><span class="line">                <span class="keyword">return</span> adapter;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>(<span class="string">"..."</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>其中<code>this.handlerAdapters</code>包含了四个，完成不同的功能</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.handlerAdapters = {ArrayList} size=4</span><br><span class="line">	0 = (RequestMappingHandlerAdapter)	// 支持标注@RequestMapping</span><br><span class="line">	1 = (HandlerFunctionAdapter)		// 支持函数式编程</span><br><span class="line">	2 = {HttpRequestHandlerAdapter}</span><br><span class="line">	3 = {SimpleControllerHandlerAdapter}</span><br></pre></td></tr></table></figure></div>

<h3 id="RequestMappingHandlerAdapter"><a href="#RequestMappingHandlerAdapter" class="headerlink" title="RequestMappingHandlerAdapter"></a>RequestMappingHandlerAdapter</h3><p>通过步入可以看到，<code>RequestMappingHandlerAdapter</code>（其父类<code>AbstractHandlerMethodAdapter</code>）实现了<code>supports</code>方法。</p>
<p>这里主要进行了类型判断，看<code>handler</code>是否是<code>HandlerMethod</code>类型。（<code>RequestMappingHandlerAdapter</code>的<code>supportsInternal</code>总返回true）</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Object handler)</span> {</span><br><span class="line">    <span class="keyword">return</span> (handler <span class="keyword">instanceof</span> HandlerMethod &amp;&amp; supportsInternal((HandlerMethod) handler));</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="DispatcherServlet-1"><a href="#DispatcherServlet-1" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h3><p>现在回到DispatcherServlet中，开始使用<code>handlerAdapter</code>真正执行<code>handler</code>方法</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br></pre></td></tr></table></figure></div>

<h3 id="RequestMappingHandlerAdapter-1"><a href="#RequestMappingHandlerAdapter-1" class="headerlink" title="RequestMappingHandlerAdapter"></a>RequestMappingHandlerAdapter</h3><p>通过步入可以看到，<code>RequestMappingHandlerAdapter</code>（其父类<code>AbstractHandlerMethodAdapter</code>）实现了<code>handle</code>方法。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ModelAndView <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span><br><span class="line">        <span class="keyword">throws</span> Exception {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> handleInternal(request, response, (HandlerMethod) handler);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p><code>RequestMappingHandlerAdapter</code>实现了<code>handleInternal</code>方法。如果设置<code>synchronizeOnSession</code>为true，那么对于同一个session，需要加锁。可以看到，核心方法为<code>invokeHandlerMethod</code></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码有删改</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> ModelAndView <span class="title function_">handleInternal</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">        HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line"></span><br><span class="line">    ModelAndView mav;</span><br><span class="line">    checkRequest(request);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 同一个session加锁</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.synchronizeOnSession) {</span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (session != <span class="literal">null</span>) {</span><br><span class="line">            <span class="comment">// 加锁</span></span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> mav;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p><code>invokeHandlerMethod</code>方法。其核心在于请求值解析器和返回值处理器</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码有删改</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> ModelAndView <span class="title function_">invokeHandlerMethod</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">        HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line"></span><br><span class="line">    <span class="type">ServletWebRequest</span> <span class="variable">webRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request, response);</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="type">ServletInvocableHandlerMethod</span> <span class="variable">invocableMethod</span> <span class="operator">=</span> createInvocableHandlerMethod(handlerMethod);</span><br><span class="line">        <span class="comment">// argumentResolvers：请求值解析器，用于确定目标方法每一个参数值是什么</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.argumentResolvers != <span class="literal">null</span>) {</span><br><span class="line">            invocableMethod.setHandlerMethodArgumentResolvers(<span class="built_in">this</span>.argumentResolvers);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// returnValueHandlers：返回值处理器</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.returnValueHandlers != <span class="literal">null</span>) {</span><br><span class="line">            invocableMethod.setHandlerMethodReturnValueHandlers(<span class="built_in">this</span>.returnValueHandlers);</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="type">ModelAndViewContainer</span> <span class="variable">mavContainer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndViewContainer</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行并处理</span></span><br><span class="line">        invocableMethod.invokeAndHandle(webRequest, mavContainer);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> getModelAndView(mavContainer, modelFactory, webRequest);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 请求值解析器</span><br><span class="line">argumentResolvers = {ArrayList} size = 27</span><br><span class="line">	0 = {RequestParamMethodArgumentResolver}</span><br><span class="line">	1 = {RequestParamMapMethodArgumentResolver}</span><br><span class="line">	2 = {PathVariableMethodArgumentResolver}</span><br><span class="line">	3 = {PathVariableMapMethodArgumentResolver}</span><br><span class="line">	4 = {MatrixVariableMethodArgumentResolver}</span><br><span class="line">	5 = {MatrixVariableMapMethodArgumentResolver}</span><br><span class="line">	6 = {ServletModelAttributeMethodProcessor</span><br><span class="line">	7 = {RequestResponseBodyMethodProcessor}</span><br><span class="line">	...</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 返回值处理器</span><br><span class="line">returnValueHandlers = {ArrayList} size = 15</span><br><span class="line">	0 = {ModelAndViewMethodReturnValueHandler}</span><br><span class="line">	1 = {ModelMethodProcessor)</span><br><span class="line">	2 = {ViewMethodReturnValueHandler}</span><br><span class="line">	3 = {ResponseBodyEmitterReturnValueHandler}</span><br><span class="line">	4 = {StreamingResponseBodyReturnValueHandler}</span><br><span class="line">	...</span><br></pre></td></tr></table></figure></div>

<h3 id="HandlerMethodArgumentResolver"><a href="#HandlerMethodArgumentResolver" class="headerlink" title="HandlerMethodArgumentResolver"></a>HandlerMethodArgumentResolver</h3><p>我们可以简单看一下请求值解析器的接口设计。其中<code>supportsParameter</code>方法用于判断解析器是否支持解析当前参数。若支持，则将调用<code>resolveArgument</code>方法进行解析</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HandlerMethodArgumentResolver</span> {</span><br><span class="line">	</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">supportsParameter</span><span class="params">(MethodParameter parameter)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    Object <span class="title function_">resolveArgument</span><span class="params">(MethodParameter parameter, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">            NativeWebRequest webRequest, <span class="meta">@Nullable</span> WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="ServletInvocableHandlerMethod"><a href="#ServletInvocableHandlerMethod" class="headerlink" title="ServletInvocableHandlerMethod"></a>ServletInvocableHandlerMethod</h3><p>在<code>RequestMappingHandlerAdapter</code>中，调用了<code>invocableMethod.invokeAndHandle</code>。我们现在查看<code>ServletInvocableHandlerMethod</code>的<code>invokeAndHandle</code>方法</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码有删改</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invokeAndHandle</span><span class="params">(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">        Object... providedArgs)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> invokeForRequest(webRequest, mavContainer, providedArgs);</span><br><span class="line">    setResponseStatus(webRequest);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>继续查看<code>invokeForRequest</code>方法。可以看到，使用了<code>getMethodArgumentValues</code>方法获取了所有请求参数的值。最终调用<code>doInvoke</code>方法，利用反射执行了我们<code>Controller</code>中的方法。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invokeForRequest</span><span class="params">(NativeWebRequest request, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">        Object... providedArgs)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 获取所有参数的值</span></span><br><span class="line">    Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> doInvoke(args);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>我们查看<code>getMethodArgumentValues</code>方法，该方法获取请求参数的值</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码有删改</span></span><br><span class="line"><span class="keyword">protected</span> Object[] getMethodArgumentValues(NativeWebRequest request, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer,</span><br><span class="line">        Object... providedArgs) <span class="keyword">throws</span> Exception {</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 获取方法所有参数的详细信息：标了什么注解，索引位置，类型...</span></span><br><span class="line">    MethodParameter[] parameters = getMethodParameters();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 目标方法无参数，无需继续</span></span><br><span class="line">    <span class="keyword">if</span> (ObjectUtils.isEmpty(parameters)) {</span><br><span class="line">        <span class="keyword">return</span> EMPTY_ARGS;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Object[] args = <span class="keyword">new</span> <span class="title class_">Object</span>[parameters.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parameters.length; i++) {</span><br><span class="line">        <span class="type">MethodParameter</span> <span class="variable">parameter</span> <span class="operator">=</span> parameters[i];</span><br><span class="line">        parameter.initParameterNameDiscovery(<span class="built_in">this</span>.parameterNameDiscoverer);</span><br><span class="line">        args[i] = findProvidedArgument(parameter, providedArgs);</span><br><span class="line">        <span class="keyword">if</span> (args[i] != <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 当前参数解析器是否支持当前参数</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.resolvers.supportsParameter(parameter)) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(formatArgumentError(parameter, <span class="string">"No suitable resolver"</span>));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 解析当前参数的值</span></span><br><span class="line">            args[i] = <span class="built_in">this</span>.resolvers.resolveArgument(parameter, mavContainer, request, <span class="built_in">this</span>.dataBinderFactory);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 返回目标函数参数的值</span></span><br><span class="line">    <span class="keyword">return</span> args;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="HandlerMethodArgumentResolverComposite"><a href="#HandlerMethodArgumentResolverComposite" class="headerlink" title="HandlerMethodArgumentResolverComposite"></a>HandlerMethodArgumentResolverComposite</h3><p>我们之前调用了<code>this.resolvers.supportsParameter(parameter)</code>用于判断参数解析器是否支持当前参数。现在来看一下其中的源码</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsParameter</span><span class="params">(MethodParameter parameter)</span> {</span><br><span class="line">    <span class="comment">// 拿到参数解析器</span></span><br><span class="line">    <span class="keyword">return</span> getArgumentResolver(parameter) != <span class="literal">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> HandlerMethodArgumentResolver <span class="title function_">getArgumentResolver</span><span class="params">(MethodParameter parameter)</span> {</span><br><span class="line">    <span class="comment">// 先从缓存中找</span></span><br><span class="line">    <span class="type">HandlerMethodArgumentResolver</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">this</span>.argumentResolverCache.get(parameter);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span>) {</span><br><span class="line">        <span class="comment">// 遍历参数解析器，看谁能处理</span></span><br><span class="line">        <span class="keyword">for</span> (HandlerMethodArgumentResolver resolver : <span class="built_in">this</span>.argumentResolvers) {</span><br><span class="line">            <span class="keyword">if</span> (resolver.supportsParameter(parameter)) {</span><br><span class="line">                result = resolver;</span><br><span class="line">                <span class="comment">// 找到支持的参数解析器，放到缓存中，以后不用再找了</span></span><br><span class="line">                <span class="built_in">this</span>.argumentResolverCache.put(parameter, result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>我们可以看一些例子，明白<code>resolver.supportsParameter</code>背后是如何判断的</p>
<p>比如（第一个）<code>RequestParamMethodArgumentResolver</code>解析器：参数要标<code>@RequestParam</code>注解</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (parameter.hasParameterAnnotation(RequestParam.class)) {}</span><br></pre></td></tr></table></figure></div>

<p>比如（第二个）<code>RequestParamMapMethodArgumentResolver</code>解析器：参数要标<code>@RequestParam</code>注解，参数要为<code>Map</code>类型，<code>@RequestParam</code>注解中要没有<code>name</code>值</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RequestParam</span> <span class="variable">requestParam</span> <span class="operator">=</span> parameter.getParameterAnnotation(RequestParam.class);</span><br><span class="line"><span class="keyword">return</span> (requestParam != <span class="literal">null</span> &amp;&amp; </span><br><span class="line">        Map.class.isAssignableFrom(parameter.getParameterType()) &amp;&amp;</span><br><span class="line">        !StringUtils.hasText(requestParam.name()));</span><br></pre></td></tr></table></figure></div>

<p>而后，<code>this.resolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory)</code>用于解析参数，我们看一看其中源码</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">resolveArgument</span><span class="params">(MethodParameter parameter, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">        NativeWebRequest webRequest, <span class="meta">@Nullable</span> WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 拿到当前参数的参数解析器（上面已经缓存好了）</span></span><br><span class="line">    <span class="type">HandlerMethodArgumentResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> getArgumentResolver(parameter);</span><br><span class="line">    <span class="keyword">if</span> (resolver == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"..."</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 核心代码</span></span><br><span class="line">    <span class="keyword">return</span> resolver.resolveArgument(parameter, mavContainer, webRequest, binderFactory);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="HandlerMethodArgumentResolver-1"><a href="#HandlerMethodArgumentResolver-1" class="headerlink" title="HandlerMethodArgumentResolver"></a>HandlerMethodArgumentResolver</h3><p>可以看到，参数解析靠的还是参数解析器的<code>resolveArgument</code>方法（所有参数解析器都实现了<code>HandlerMethodArgumentResolver</code>接口，我们上面也谈过）。</p>
<h3 id="（举例一）路径变量"><a href="#（举例一）路径变量" class="headerlink" title="（举例一）路径变量"></a>（举例一）路径变量</h3><p>我们这里以<code>PathVariable</code>参数为例来看一看背后的原理。其中类继承关系：<code>HandlerMethodArgumentResolver</code> &lt;- <code>AbstractNamedValueMethodArgumentResolver</code> &lt;- <code>PathVariableMethodArgumentResolver</code></p>
<p>首先，<code>PathVariableMethodArgumentResolver</code>实现了<code>supportsParameter</code>方法。参数要标<code>@PathVariable</code>注解，若参数为<code>Map</code>类型，<code>@PathVariable</code>注解中要没有<code>value</code>值</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsParameter</span><span class="params">(MethodParameter parameter)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!parameter.hasParameterAnnotation(PathVariable.class)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (Map.class.isAssignableFrom(parameter.nestedIfOptional().getNestedParameterType())) {</span><br><span class="line">        <span class="type">PathVariable</span> <span class="variable">pathVariable</span> <span class="operator">=</span> parameter.getParameterAnnotation(PathVariable.class);</span><br><span class="line">        <span class="keyword">return</span> (pathVariable != <span class="literal">null</span> &amp;&amp; StringUtils.hasText(pathVariable.value()));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>其次，<code>AbstractNamedValueMethodArgumentResolver</code>实现<code>resolveArgument</code>方法</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">resolveArgument</span><span class="params">(MethodParameter parameter, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">        NativeWebRequest webRequest, <span class="meta">@Nullable</span> WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line"> 	</span><br><span class="line">    <span class="comment">// 参数的一些信息：名字，是否必须，默认值</span></span><br><span class="line">    <span class="type">NamedValueInfo</span> <span class="variable">namedValueInfo</span> <span class="operator">=</span> getNamedValueInfo(parameter);</span><br><span class="line">    <span class="type">MethodParameter</span> <span class="variable">nestedParameter</span> <span class="operator">=</span> parameter.nestedIfOptional();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了处理注解中使用了SpEL表达式的情况，不用管</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">resolvedName</span> <span class="operator">=</span> resolveEmbeddedValuesAndExpressions(namedValueInfo.name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析参数的值，核心</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">arg</span> <span class="operator">=</span> resolveName(resolvedName.toString(), nestedParameter, webRequest);</span><br><span class="line"></span><br><span class="line">    handleResolvedValue(arg, namedValueInfo.name, parameter, mavContainer, webRequest);</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p><code>PathVariableMethodArgumentResolver</code>实现了<code>resolveName</code>方法</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings("unchecked")</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">resolveName</span><span class="params">(String name, MethodParameter parameter, NativeWebRequest request)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">    Map&lt;String, String&gt; uriTemplateVars = (Map&lt;String, String&gt;) request.getAttribute(</span><br><span class="line">            HandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE, RequestAttributes.SCOPE_REQUEST);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// uriTemplateVars存储路径变量的值，直接获取</span></span><br><span class="line">    <span class="keyword">return</span> (uriTemplateVars != <span class="literal">null</span> ? uriTemplateVars.get(name) : <span class="literal">null</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="（举例二）Servlet-API"><a href="#（举例二）Servlet-API" class="headerlink" title="（举例二）Servlet API"></a>（举例二）Servlet API</h3><p>我们这里以<code>Servlet API</code>参数为例来看一看背后的原理。其中类继承关系：<code>HandlerMethodArgumentResolver</code> &lt;- <code>ServletRequestMethodArgumentResolver</code></p>
<p>首先，<code>ServletRequestMethodArgumentResolver</code>实现了<code>supportsParameter</code>方法。参数需要为特定的类型</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsParameter</span><span class="params">(MethodParameter parameter)</span> {</span><br><span class="line">    Class&lt;?&gt; paramType = parameter.getParameterType();</span><br><span class="line">    <span class="keyword">return</span> (WebRequest.class.isAssignableFrom(paramType) ||</span><br><span class="line">            ServletRequest.class.isAssignableFrom(paramType) ||</span><br><span class="line">            MultipartRequest.class.isAssignableFrom(paramType) ||</span><br><span class="line">            HttpSession.class.isAssignableFrom(paramType) ||</span><br><span class="line">            (pushBuilder != <span class="literal">null</span> &amp;&amp; pushBuilder.isAssignableFrom(paramType)) ||</span><br><span class="line">            (Principal.class.isAssignableFrom(paramType) &amp;&amp; !parameter.hasParameterAnnotations()) ||</span><br><span class="line">            InputStream.class.isAssignableFrom(paramType) ||</span><br><span class="line">            Reader.class.isAssignableFrom(paramType) ||</span><br><span class="line">            HttpMethod.class == paramType ||</span><br><span class="line">            Locale.class == paramType ||</span><br><span class="line">            TimeZone.class == paramType ||</span><br><span class="line">            ZoneId.class == paramType);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>其次，<code>ServletRequestMethodArgumentResolver</code>实现了<code>resolveArgument</code>方法。根据具体类型执行不同的操作。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">resolveArgument</span><span class="params">(MethodParameter parameter, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">			NativeWebRequest webRequest, <span class="meta">@Nullable</span> WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; paramType = parameter.getParameterType();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// WebRequest / NativeWebRequest / ServletWebRequest</span></span><br><span class="line">    <span class="keyword">if</span> (WebRequest.class.isAssignableFrom(paramType)) {</span><br><span class="line">        <span class="keyword">if</span> (!paramType.isInstance(webRequest)) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">"..."</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> webRequest;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ServletRequest / HttpServletRequest / MultipartRequest / MultipartHttpServletRequest</span></span><br><span class="line">    <span class="keyword">if</span> (ServletRequest.class.isAssignableFrom(paramType) || MultipartRequest.class.isAssignableFrom(paramType)) {</span><br><span class="line">        <span class="keyword">return</span> resolveNativeRequest(webRequest, paramType);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HttpServletRequest required for all further argument types</span></span><br><span class="line">    <span class="keyword">return</span> resolveArgument(paramType, resolveNativeRequest(webRequest, HttpServletRequest.class));</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>我们以<code>HttpServletRequest</code>为例，执行了<code>resolveNativeRequest</code>方法，拿到原生<code>ServletRequest</code>并返回</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; T <span class="title function_">resolveNativeRequest</span><span class="params">(NativeWebRequest webRequest, Class&lt;T&gt; requiredType)</span> {</span><br><span class="line">    <span class="comment">// 拿到原生ServletRequest，最后返回</span></span><br><span class="line">    <span class="type">T</span> <span class="variable">nativeRequest</span> <span class="operator">=</span> webRequest.getNativeRequest(requiredType);</span><br><span class="line">    <span class="keyword">if</span> (nativeRequest == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">"..."</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> nativeRequest;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="（举例三）Model-Map原理"><a href="#（举例三）Model-Map原理" class="headerlink" title="（举例三）Model, Map原理"></a>（举例三）Model, Map原理</h3><p><code>ModelMethodProcessor</code>，<code>MapMethodProcessor</code>参数解析器实现了<code>supportsParameter</code>方法</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数为Model</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsParameter</span><span class="params">(MethodParameter parameter)</span> {</span><br><span class="line">    <span class="comment">// 判断参数类型为Model</span></span><br><span class="line">    <span class="keyword">return</span> Model.class.isAssignableFrom(parameter.getParameterType());</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数为Map</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsParameter</span><span class="params">(MethodParameter parameter)</span> {</span><br><span class="line">    <span class="comment">// 判断参数类型为Map，且参数没有标注解</span></span><br><span class="line">    <span class="keyword">return</span> (Map.class.isAssignableFrom(parameter.getParameterType()) &amp;&amp;</span><br><span class="line">            parameter.getParameterAnnotations().length == <span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>其次，它们都实现了<code>resolveArgument</code>方法</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数为Model</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">resolveArgument</span><span class="params">(MethodParameter parameter, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">                              NativeWebRequest webRequest, <span class="meta">@Nullable</span> WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">    <span class="comment">// 从modelAndViewContainer中获得Model</span></span><br><span class="line">    <span class="keyword">return</span> mavContainer.getModel();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数为Map</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">resolveArgument</span><span class="params">(MethodParameter parameter, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">                              NativeWebRequest webRequest, <span class="meta">@Nullable</span> WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">    <span class="comment">// 从modelAndViewContainer中获得Model</span></span><br><span class="line">    <span class="keyword">return</span> mavContainer.getModel();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>可以看到，无论是<code>Model</code>还是<code>Map</code>，返回的都是<code>mavContainer</code>里的<code>Model</code>（<code>BindingAwareModelMap</code>，根本上继承自<code>Map</code>和<code>Model</code>），他们获取的都是同一个对象</p>
]]></content>
      <categories>
        <category>java</category>
        <category>SpringBoot</category>
        <category>源码</category>
      </categories>
      <tags>
        <tag>SpringBoot源码系列</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot源码系列（8）：拦截器执行顺序</title>
    <url>//post/5855/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在SpringBoot/SpringMVC中，拦截器有三个方法</p>
<ul>
<li><code>applyPreHandle</code>（前置操作，目标方法执行前）</li>
<li><code>applyPostHandle</code>（后置操作，目标方法执行后）</li>
<li><code>triggerAfterCompletion</code>（最终操作，渲染结束后）</li>
</ul>
<p>正常情况下，会顺序执行所有<strong>前置操作</strong>，逆序执行所有<strong>后置操作</strong>，逆序执行所有<strong>最终操作</strong>。</p>
<p>如果中间被拦截，会顺序执行所有<strong>前置操作</strong>，直至被拦截，逆序执行所有<strong>放行的后置操作</strong>。</p>
<p>我们根据源码来看一看其中的原理</p>
<p>原文地址：<a href="https://xuedongyun.cn/post/5855/">https://xuedongyun.cn/post/5855/</a></p>
<h2 id="拦截器原理"><a href="#拦截器原理" class="headerlink" title="拦截器原理"></a>拦截器原理</h2><h3 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h3><p>我知道，请求的核心函数是<code>DispatcherServlet</code>中的<code>doDispatch</code>方法</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">    	mappedHandler = getHandler(processedRequest);</span><br><span class="line"></span><br><span class="line">    	<span class="type">HandlerAdapter</span> <span class="variable">ha</span> <span class="operator">=</span> getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 前置处理</span></span><br><span class="line">        <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 执行目标方法</span></span><br><span class="line">        mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后置处理</span></span><br><span class="line">        mappedHandler.applyPostHandle(processedRequest, response, mv);  </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 渲染页面</span></span><br><span class="line">        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">        </span><br><span class="line">    } <span class="keyword">catch</span> (Exception ex) {</span><br><span class="line">        <span class="comment">// 有任何错误，都会触发后置处理</span></span><br><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>目标方法出错，也会执行后置操作</p>
</blockquote>
<h3 id="HandlerExecutionChain"><a href="#HandlerExecutionChain" class="headerlink" title="HandlerExecutionChain"></a>HandlerExecutionChain</h3><p><code>mappedHandler</code>中包含：<code>handler</code>和<code>拦截器链</code></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mappedHandler = {HandlerExecutionChain}</span><br><span class="line">	handler = {HandlerMethod}</span><br><span class="line">	interceptorList = {ArrayList} size = 3</span><br><span class="line">		0={Onelnterceptor}</span><br><span class="line">		1={Twolnterceptor}</span><br><span class="line">		2={Threelnterceptor}</span><br><span class="line">		3={ConversionServiceExposinglnterceptor}</span><br><span class="line">		4={ResourceUrlProviderExposinglnterceptor}</span><br></pre></td></tr></table></figure></div>

<ol>
<li><code>applyPreHandle</code>（前置处理）：可以看到，<strong>顺序执行了所有拦截器的前置操作</strong>。每次都记录了<code>this.interceptorIndex</code>。如果中间有返回<code>false</code>的，则立刻执行<code>triggerAfterCompletion</code>方法。</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">applyPreHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="built_in">this</span>.interceptorList.size(); i++) {</span><br><span class="line">        <span class="type">HandlerInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="built_in">this</span>.interceptorList.get(i);</span><br><span class="line">        <span class="keyword">if</span> (!interceptor.preHandle(request, response, <span class="built_in">this</span>.handler)) {</span><br><span class="line">            triggerAfterCompletion(request, response, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">this</span>.interceptorIndex = i;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>而<code>triggerAfterCompletion</code>则是从<code>this.interceptorIndex</code>开始<strong>逆序执行了所有的后置操作</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">triggerAfterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, <span class="meta">@Nullable</span> Exception ex)</span> {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="built_in">this</span>.interceptorIndex; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">        <span class="type">HandlerInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="built_in">this</span>.interceptorList.get(i);</span><br><span class="line">        interceptor.afterCompletion(request, response, <span class="built_in">this</span>.handler, ex);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li><code>applyPostHandle</code>（后置处理）：可以看到，<strong>逆序执行了所有后置操作</strong></li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">applyPostHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, <span class="meta">@Nullable</span> ModelAndView mv)</span></span><br><span class="line">    <span class="keyword">throws</span> Exception {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="built_in">this</span>.interceptorList.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">        <span class="type">HandlerInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="built_in">this</span>.interceptorList.get(i);</span><br><span class="line">        interceptor.postHandle(request, response, <span class="built_in">this</span>.handler, mv);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li><code>processDispatchResult</code>（渲染页面）：可以看到，渲染完成后，<strong>逆序执行了所有的最终操作</strong></li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processDispatchResult</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                   <span class="meta">@Nullable</span> HandlerExecutionChain mappedHandler, </span></span><br><span class="line"><span class="params">                                   <span class="meta">@Nullable</span> ModelAndView mv,</span></span><br><span class="line"><span class="params">                                   <span class="meta">@Nullable</span> Exception exception)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (mv != <span class="literal">null</span> &amp;&amp; !mv.wasCleared()) {</span><br><span class="line">        render(mv, request, response);</span><br><span class="line">        <span class="keyword">if</span> (errorView) {</span><br><span class="line">            WebUtils.clearErrorRequestAttributes(request);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (mappedHandler != <span class="literal">null</span>) {</span><br><span class="line">        <span class="comment">// 页面渲染完，逆序触发拦截器</span></span><br><span class="line">        mappedHandler.triggerAfterCompletion(request, response, <span class="literal">null</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">triggerAfterCompletion</span><span class="params">(HttpServletRequest request, </span></span><br><span class="line"><span class="params">                            HttpServletResponse response, </span></span><br><span class="line"><span class="params">                            <span class="meta">@Nullable</span> Exception ex)</span> {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="built_in">this</span>.interceptorIndex; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">        <span class="type">HandlerInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="built_in">this</span>.interceptorList.get(i);</span><br><span class="line">        interceptor.afterCompletion(request, response, <span class="built_in">this</span>.handler, ex);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>java</category>
        <category>SpringBoot</category>
        <category>源码</category>
      </categories>
      <tags>
        <tag>SpringBoot源码系列</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot源码系列（6）：参数解析之自定义参数绑定</title>
    <url>//post/44248/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在SpringBoot/SpringMVC中，我们能在Controller中解析出请求的参数。除了一些基本类型之外，我们还可以使用一些复杂类型，诸如：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping("/hello")</span></span><br><span class="line">String <span class="title function_">hello</span><span class="params">(User user)</span>{</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>本文根据SpringBoot源码谈谈其背后的原理，文中SpringBoot版本号为2.7.5。</p>
<p>原文地址：<a href="https://xuedongyun.cn/post/44248/">https://xuedongyun.cn/post/44248/</a></p>
<h2 id="自定义参数绑定原理"><a href="#自定义参数绑定原理" class="headerlink" title="自定义参数绑定原理"></a>自定义参数绑定原理</h2><p>有关参数解析，及参数解析器的部分，可以查看我之前的博客：<a href="https://xuedongyun.cn/post/13517/">SpringBoot源码系列（5）：参数解析</a>。自定义类型参数使用的是<code>ServletModelAttributeMethodProcessor</code>这个参数解析器。</p>
<p>其中类继承关系：<code>HandlerMethodArgumentResolver</code> &lt;- <code>ModelAttributeMethodProcessor</code> &lt;- <code>ServletModelAttributeMethodProcessor</code></p>
<h3 id="ServletModelAttributeMethodProcessor"><a href="#ServletModelAttributeMethodProcessor" class="headerlink" title="ServletModelAttributeMethodProcessor"></a>ServletModelAttributeMethodProcessor</h3><p>其父类<code>ModelAttributeMethodProcessor</code>实现了<code>supportsParameter</code>方法</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsParameter</span><span class="params">(MethodParameter parameter)</span> {</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    	参数标ModelAttribute注解 or 参数不是简单属性</span></span><br><span class="line"><span class="comment">		我们的参数User user肯定不是简单类型</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> (parameter.hasParameterAnnotation(ModelAttribute.class) ||</span><br><span class="line">            (<span class="built_in">this</span>.annotationNotRequired &amp;&amp; !BeanUtils.isSimpleProperty(parameter.getParameterType())));</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>其父类<code>ModelAttributeMethodProcessor</code>还实现了<code>resolveArgument</code>方法。其中的核心点在于，将请求中的参数绑定到创建的空对象上。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码有删改</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">resolveArgument</span><span class="params">(MethodParameter parameter, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">        NativeWebRequest webRequest, <span class="meta">@Nullable</span> WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> ModelFactory.getNameForParameter(parameter);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取ModelAttribute注解，绑定一大堆东西。我们这里没有，暂时不用管 </span></span><br><span class="line">    <span class="type">ModelAttribute</span> <span class="variable">ann</span> <span class="operator">=</span> parameter.getParameterAnnotation(ModelAttribute.class);</span><br><span class="line">    <span class="keyword">if</span> (ann != <span class="literal">null</span>) {</span><br><span class="line">        mavContainer.setBinding(name, ann.binding());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">attribute</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">BindingResult</span> <span class="variable">bindingResult</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 查看mav中有没有对应的参数。如果以前modelAndView中已经有了，就直接返回。也不用管。</span></span><br><span class="line">    <span class="keyword">if</span> (mavContainer.containsAttribute(name)) {</span><br><span class="line">        attribute = mavContainer.getModel().get(name);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 创建一个空实例</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            attribute = createAttribute(name, parameter, binderFactory, webRequest);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 我们还没有绑定参数到对象</span></span><br><span class="line">    <span class="keyword">if</span> (bindingResult == <span class="literal">null</span>) {</span><br><span class="line">        <span class="comment">// 将请求封装到WebDataBinder对象中，WebDataBinder对象负责将值绑定到bean中</span></span><br><span class="line">        <span class="type">WebDataBinder</span> <span class="variable">binder</span> <span class="operator">=</span> binderFactory.createBinder(webRequest, attribute, name);</span><br><span class="line">        <span class="keyword">if</span> (binder.getTarget() != <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> (!mavContainer.isBindingDisabled(name)) {</span><br><span class="line">                <span class="comment">// 最关键的一步，将请求中的参数绑定到target对象</span></span><br><span class="line">                bindRequestParameters(binder, webRequest);</span><br><span class="line">            }</span><br><span class="line">            validateIfApplicable(binder, parameter);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> attribute;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p><code>ServletModelAttributeMethodProcessor</code>重写了<code>bindRequestParameters</code>方法</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">bindRequestParameters</span><span class="params">(WebDataBinder binder, NativeWebRequest request)</span> {</span><br><span class="line">    <span class="type">ServletRequest</span> <span class="variable">servletRequest</span> <span class="operator">=</span> request.getNativeRequest(ServletRequest.class);</span><br><span class="line">    <span class="type">ServletRequestDataBinder</span> <span class="variable">servletBinder</span> <span class="operator">=</span> (ServletRequestDataBinder) binder;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 先对请求做了下类型转换，然后使用WebDataBinder，将request传入</span></span><br><span class="line">    servletBinder.bind(servletRequest);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="ServletRequestDataBinder"><a href="#ServletRequestDataBinder" class="headerlink" title="ServletRequestDataBinder"></a>ServletRequestDataBinder</h3><p>类继承关系：<code>DataBinder</code>&lt;-<code>WebDataBinder</code>&lt;-<code>ServletRequestDataBinder</code></p>
<p>我们首先来看一下<code>WebDataBinder</code>的基本结构。<code>WebDataBinder</code>利用其中的各种<code>Converter</code>，将请求数据转化成指定的数据类型。利用反射封装到<code>JavaBean</code>中。未来，我们还可以放自定义的<code>Converter</code>，将String转为想要的类型</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">target: 我们的空Person对象</span><br><span class="line">conversionService:</span><br><span class="line">	converters: 124种转换器，负责将字符串转化为具体java对象</span><br></pre></td></tr></table></figure></div>

<p><code>ServletRequestDataBinder</code>实现了<code>bind</code>方法。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(ServletRequest request)</span> {</span><br><span class="line">    <span class="type">MutablePropertyValues</span> <span class="variable">mpvs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletRequestParameterPropertyValues</span>(request);</span><br><span class="line">    <span class="type">MultipartRequest</span> <span class="variable">multipartRequest</span> <span class="operator">=</span> WebUtils.getNativeRequest(request, MultipartRequest.class);</span><br><span class="line">    <span class="keyword">if</span> (multipartRequest != <span class="literal">null</span>) {</span><br><span class="line">        bindMultipart(multipartRequest.getMultiFileMap(), mpvs);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.startsWithIgnoreCase(request.getContentType(), MediaType.MULTIPART_FORM_DATA_VALUE)) {</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">httpServletRequest</span> <span class="operator">=</span> WebUtils.getNativeRequest(request, HttpServletRequest.class);</span><br><span class="line">        <span class="keyword">if</span> (httpServletRequest != <span class="literal">null</span> &amp;&amp; HttpMethod.POST.matches(httpServletRequest.getMethod())) {</span><br><span class="line">            StandardServletPartUtils.bindParts(httpServletRequest, mpvs, isBindEmptyMultipartFiles());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    addBindValues(mpvs, request);</span><br><span class="line">    <span class="comment">// 上述操作绑定了所需的参数，mvps保存了请求中所有的key-value对</span></span><br><span class="line">    doBind(mpvs); <span class="comment">// 执行绑定的核心代码</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// mpvs包含请求中的所有key-value对</span><br><span class="line">mpvs: </span><br><span class="line">	propertyValueList:</span><br><span class="line">		0:</span><br><span class="line">			name: "age"</span><br><span class="line">			value: "23"</span><br><span class="line">			converted: false</span><br><span class="line">			convertedValue: null</span><br><span class="line">			conversionNecessary: null</span><br><span class="line">			...</span><br><span class="line">		...</span><br></pre></td></tr></table></figure></div>

<p><code>WebDataBinder</code>实现了<code>doBind</code>方法</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doBind</span><span class="params">(MutablePropertyValues mpvs)</span> {</span><br><span class="line">    checkFieldDefaults(mpvs);</span><br><span class="line">    checkFieldMarkers(mpvs);</span><br><span class="line">    adaptEmptyArrayIndices(mpvs);</span><br><span class="line">    <span class="built_in">super</span>.doBind(mpvs);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>下面进入到父类<code>DataBinder</code>中的<code>doBind</code>方法</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doBind</span><span class="params">(MutablePropertyValues mpvs)</span> {</span><br><span class="line">    checkAllowedFields(mpvs);</span><br><span class="line">    checkRequiredFields(mpvs);</span><br><span class="line">    <span class="comment">// 上述操作做了对所需属性的校验</span></span><br><span class="line">    applyPropertyValues(mpvs); <span class="comment">// 应用属性的值</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p><code>DataBinder</code>中的<code>applyPropertyValues</code>方法。这里通过<code>getPropertyAccessor</code>方法返回了经过处理的<code>bindingResult</code>（具体内容可以自行点开查看源码）</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码有删改</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">applyPropertyValues</span><span class="params">(MutablePropertyValues mpvs)</span> {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 设置属性的值</span></span><br><span class="line">        getPropertyAccessor().setPropertyValues(mpvs, isIgnoreUnknownFields(), isIgnoreInvalidFields());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="AbstractPropertyAccessor"><a href="#AbstractPropertyAccessor" class="headerlink" title="AbstractPropertyAccessor"></a>AbstractPropertyAccessor</h3><p>这里通过<code>getPropertyAccessor</code>方法返回了经过处理的<code>bindingResult</code>后（其类别为<code>AbstractPropertyBindingResult</code>），调用了其<code>setPropertyValues</code>方法。我们可以看到核心为：遍历了<code>mpvs</code>中的所有值</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码有删改</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPropertyValues</span><span class="params">(PropertyValues pvs, <span class="type">boolean</span> ignoreUnknown, <span class="type">boolean</span> ignoreInvalid)</span></span><br><span class="line">        <span class="keyword">throws</span> BeansException {</span><br><span class="line">    <span class="comment">// 遍历了所有的值，并设置</span></span><br><span class="line">    <span class="keyword">for</span> (PropertyValue pv : propertyValues) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            setPropertyValue(pv);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>继续查看<code>AbstractPropertyAccessor</code>的<code>setPropertyValue</code>方法</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码有删改</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPropertyValue</span><span class="params">(PropertyValue pv)</span> <span class="keyword">throws</span> BeansException {</span><br><span class="line">	<span class="type">String</span> <span class="variable">propertyName</span> <span class="operator">=</span> pv.getName();</span><br><span class="line">    AbstractNestablePropertyAccessor nestedPa;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 利用反射工具PropertyAccessor，访问属性，返回</span></span><br><span class="line">        nestedPa = getPropertyAccessorForPropertyPath(propertyName);</span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 利用wrapper设置属性的值</span></span><br><span class="line">    nestedPa.setPropertyValue(tokens, pv);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>在这里，<code>nestedPa</code>是一个<code>BeanWrapperImpl</code>（继承自<code>AbstractNestablePropertyAccessor</code>），内部包装着原生对象</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">nestedPa {BeanWrapperImpl}:</span><br><span class="line">	rootObject: {User}</span><br></pre></td></tr></table></figure></div>

<h3 id="BeanWrapperImpl"><a href="#BeanWrapperImpl" class="headerlink" title="BeanWrapperImpl"></a>BeanWrapperImpl</h3><p>类继承关系：<code>BeanWrapperImpl</code>&lt;-<code>AbstractNestablePropertyAccessor</code></p>
<p><code>AbstractNestablePropertyAccessor</code>中，<code>setPropertyValue</code>方法</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">setPropertyValue</span><span class="params">(PropertyTokenHolder tokens, PropertyValue pv)</span> <span class="keyword">throws</span> BeansException {</span><br><span class="line">    <span class="keyword">if</span> (tokens.keys != <span class="literal">null</span>) {</span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">        	用于处理键值对属性</span></span><br><span class="line"><span class="comment">        	例如，当属性名是person.address.street时，tokens.keys将包含[person, address]作为键的标记</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        processKeyedProperty(tokens, pv);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        	用于处理本地属性。本地属性是指不涉及键值对的普通属性</span></span><br><span class="line"><span class="comment">        	例如，当属性名是name时，tokens.keys将为null，这个方法可以直接获取或设置属性值。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        processLocalProperty(tokens, pv); <span class="comment">// 步入</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p><code>AbstractNestablePropertyAccessor</code>中，<code>processLocalProperty</code>方法</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码有删改</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processLocalProperty</span><span class="params">(PropertyTokenHolder tokens, PropertyValue pv)</span> {</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 类型转换，比如将"23"转化为Integer</span></span><br><span class="line">    valueToApply = convertForProperty(tokens.canonicalName, oldValue, originalValue, ph.toTypeDescriptor());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最终将值设置到对象</span></span><br><span class="line">    ph.setValue(valueToApply);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p><code>AbstractNestablePropertyAccessor</code>中，<code>convertForProperty</code>方法</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">convertForProperty</span><span class="params">(</span></span><br><span class="line"><span class="params">        String propertyName, <span class="meta">@Nullable</span> Object oldValue, <span class="meta">@Nullable</span> Object newValue, TypeDescriptor td)</span></span><br><span class="line">        <span class="keyword">throws</span> TypeMismatchException {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> convertIfNecessary(propertyName, oldValue, newValue, td.getType(), td);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p><code>AbstractNestablePropertyAccessor</code>中，<code>convertIfNecessary</code>方法</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码有删改</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">convertIfNecessary</span><span class="params">(<span class="meta">@Nullable</span> String propertyName, <span class="meta">@Nullable</span> Object oldValue,</span></span><br><span class="line"><span class="params">        <span class="meta">@Nullable</span> Object newValue, <span class="meta">@Nullable</span> Class&lt;?&gt; requiredType, <span class="meta">@Nullable</span> TypeDescriptor td)</span></span><br><span class="line">        <span class="keyword">throws</span> TypeMismatchException {</span><br><span class="line">	</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, newValue, requiredType, td);</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="TypeConverterDelegate"><a href="#TypeConverterDelegate" class="headerlink" title="TypeConverterDelegate"></a>TypeConverterDelegate</h3><p>它是Spring的类型转换器委托类。<code>convertIfNecessary</code>方法目的在于将给定的值转换为指定的目标类型</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码有删改</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">convertIfNecessary</span><span class="params">(<span class="meta">@Nullable</span> String propertyName, <span class="meta">@Nullable</span> Object oldValue, <span class="meta">@Nullable</span> Object newValue,</span></span><br><span class="line"><span class="params">        <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType, <span class="meta">@Nullable</span> TypeDescriptor typeDescriptor)</span> <span class="keyword">throws</span> IllegalArgumentException {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到conversionService，某种转换工具。</span></span><br><span class="line">    <span class="comment">// 里面有converters，包含124种转换器。</span></span><br><span class="line">    <span class="type">ConversionService</span> <span class="variable">conversionService</span> <span class="operator">=</span> <span class="built_in">this</span>.propertyEditorRegistry.getConversionService();</span><br><span class="line">    <span class="keyword">if</span> (editor == <span class="literal">null</span> &amp;&amp; conversionService != <span class="literal">null</span> &amp;&amp; newValue != <span class="literal">null</span> &amp;&amp; typeDescriptor != <span class="literal">null</span>) {</span><br><span class="line">        <span class="type">TypeDescriptor</span> <span class="variable">sourceTypeDesc</span> <span class="operator">=</span> TypeDescriptor.forObject(newValue);</span><br><span class="line">        <span class="comment">// 判断能否转换，可以点开源码看看（和之前的各种解析器类似，第一次遍历找，找到加入缓存）</span></span><br><span class="line">        <span class="keyword">if</span> (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="keyword">return</span> (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (T) convertedValue;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="GenericConversionService"><a href="#GenericConversionService" class="headerlink" title="GenericConversionService"></a>GenericConversionService</h3><p>类继承关系：<code>ConversionService</code> &lt;-<code>ConfigurableConversionService</code> &lt;-<code>GenericConversionService</code></p>
<p>我们继续查看<code>conversionService.convert</code>方法</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码有删改</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">convert</span><span class="params">(<span class="meta">@Nullable</span> Object source, <span class="meta">@Nullable</span> TypeDescriptor sourceType, TypeDescriptor targetType)</span> {</span><br><span class="line">    <span class="comment">// 拿到converter后进行处理</span></span><br><span class="line">    <span class="type">GenericConverter</span> <span class="variable">converter</span> <span class="operator">=</span> getConverter(sourceType, targetType);</span><br><span class="line">    <span class="keyword">if</span> (converter != <span class="literal">null</span>) {</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> ConversionUtils.invokeConverter(converter, source, sourceType, targetType); <span class="comment">// 步入</span></span><br><span class="line">        <span class="keyword">return</span> handleResult(sourceType, targetType, result);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> handleConverterNotFound(source, sourceType, targetType);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="ConversionUtils"><a href="#ConversionUtils" class="headerlink" title="ConversionUtils"></a>ConversionUtils</h3><p><code>ConversionUtils</code>内的静态方法<code>invokeConverter</code></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码有删改</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">invokeConverter</span><span class="params">(GenericConverter converter, <span class="meta">@Nullable</span> Object source,</span></span><br><span class="line"><span class="params">        TypeDescriptor sourceType, TypeDescriptor targetType)</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">return</span> converter.convert(source, sourceType, targetType);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="GenericConversionService-1"><a href="#GenericConversionService-1" class="headerlink" title="GenericConversionService"></a>GenericConversionService</h3><p>调用了<code>converter.convert</code>方法，在当前例子中（<code>User.userAge</code>）<code>sourceType</code>是<code>String</code>，<code>targetType</code>是<code>Integer</code></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">convert</span><span class="params">(<span class="meta">@Nullable</span> Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</span> {</span><br><span class="line">    <span class="keyword">if</span> (source == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> convertNullSource(sourceType, targetType);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.converterFactory.getConverter(targetType.getObjectType()).convert(source);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="StringToNumberConverterFactory"><a href="#StringToNumberConverterFactory" class="headerlink" title="StringToNumberConverterFactory"></a>StringToNumberConverterFactory</h3><p>类继承关系：<code>ConverterFactory</code>&lt;-<code>StringToNumberConverterFactory</code></p>
<p><code>StringToNumberConverterFactory</code>实现了<code>ConverterFactory</code>接口。我们这里的<code>this.converterFactory</code>是<code>StringToNumberConverterFactory</code>类型的。</p>
<p>通过它，我们拿到了需要的<code>StringToNumber</code>（实现自<code>Converter&lt;String, T&gt;</code>）</p>
<h3 id="StringToNumber"><a href="#StringToNumber" class="headerlink" title="StringToNumber"></a>StringToNumber</h3><p><code>StringToNumber</code>类的<code>convert</code>方法如下，其实非常简单</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">convert</span><span class="params">(String source)</span> {</span><br><span class="line">    <span class="keyword">if</span> (source.isEmpty()) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> NumberUtils.parseNumber(source, <span class="built_in">this</span>.targetType);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>未来，我们可以给<code>WebDataBinder</code>里放自己的<code>Converter</code></p>
<h2 id="自定义Converter"><a href="#自定义Converter" class="headerlink" title="自定义Converter"></a>自定义Converter</h2><p>我们已经知道，当我们的参数标注了@ModelAttribute，或是一个复杂对象时，会使用<code>ServletModelAttributeMethodProcessor</code>这个参数解析器。而该解析器会寻找合适的<code>converter</code>来进行类型转换</p>
<p>假设我们的需求是：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line">用户: <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"Tom,6"</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer userAge;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping("/user")</span></span><br><span class="line">String <span class="title function_">addUser</span><span class="params">(User user)</span> {</span><br><span class="line">    System.out.println(<span class="string">"user = "</span> + user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>我们可以通过<code>WebMvcConfigurer</code>的<code>addFormatters</code>方法，为容器中添加自定义的<code>converter</code></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在配置类中配置自定义webMvcConfigurer，利用其中addFormatters添加自定义Converter</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> {</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> WebMvcConfigurer <span class="title function_">webMvcConfigurer</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WebMvcConfigurer</span>() {</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFormatters</span><span class="params">(FormatterRegistry registry)</span> {</span><br><span class="line">                registry.addConverter(<span class="keyword">new</span> <span class="title class_">Converter</span>&lt;String, User&gt;() {</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> User <span class="title function_">convert</span><span class="params">(String source)</span> {</span><br><span class="line">                        <span class="keyword">if</span> (!source.isEmpty()) {</span><br><span class="line">                            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">                            String[] split = source.split(<span class="string">","</span>);</span><br><span class="line">                            user.setUserName(split[<span class="number">0</span>]);</span><br><span class="line">                            user.setUserAge(Integer.parseInt(split[<span class="number">1</span>]));</span><br><span class="line">                            <span class="keyword">return</span> user;</span><br><span class="line">                        }</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    }</span><br><span class="line">                });</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>java</category>
        <category>SpringBoot</category>
        <category>源码</category>
      </categories>
      <tags>
        <tag>SpringBoot源码系列</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot源码系列（9）：DispatcherServlet如何被注册进容器</title>
    <url>//post/19203/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在本文中，将探讨<code>DispatcherServlet</code>是怎样被注册到<code>SpringBoot</code>中的</p>
<p>原文地址：<a href="https://xuedongyun.cn/post/19203/">https://xuedongyun.cn/post/19203/</a></p>
<h2 id="注册进容器的原理"><a href="#注册进容器的原理" class="headerlink" title="注册进容器的原理"></a>注册进容器的原理</h2><h3 id="DispatcherServletAutoConfiguration"><a href="#DispatcherServletAutoConfiguration" class="headerlink" title="DispatcherServletAutoConfiguration"></a>DispatcherServletAutoConfiguration</h3><p>在<code>SpringBoot</code>的<code>web</code>模块中，有<code>DispatcherServletAutoConfiguration</code>这个自动配置类</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)</span></span><br><span class="line"><span class="meta">@AutoConfiguration(after = ServletWebServerFactoryAutoConfiguration.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication(type = Type.SERVLET)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(DispatcherServlet.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DispatcherServletAutoConfiguration</span> {</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="DispatcherServletConfiguration"><a href="#DispatcherServletConfiguration" class="headerlink" title="DispatcherServletConfiguration"></a>DispatcherServletConfiguration</h3><p><code>DispatcherServletAutoConfiguration</code>中有一个<code>DispatcherServletConfiguration</code>配置类，通过<code>@Configuration</code>注解进行标注。 属性绑定到<code>WebMvcProperties</code>，对应配置项<code>spring.mvc</code></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@Conditional(DefaultDispatcherServletCondition.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(ServletRegistration.class)</span></span><br><span class="line"><span class="comment">// 属性绑定到WebMvcProperties，对应配置项"spring.mvc"</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(WebMvcProperties.class)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DispatcherServletConfiguration</span> {</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 向容器中放入DispatcherServlet组件</span></span><br><span class="line">    <span class="meta">@Bean(name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)</span></span><br><span class="line">    <span class="keyword">public</span> DispatcherServlet <span class="title function_">dispatcherServlet</span><span class="params">(WebMvcProperties webMvcProperties)</span> {</span><br><span class="line">        <span class="type">DispatcherServlet</span> <span class="variable">dispatcherServlet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DispatcherServlet</span>();</span><br><span class="line">        dispatcherServlet.setDispatchOptionsRequest(webMvcProperties.isDispatchOptionsRequest());</span><br><span class="line">        dispatcherServlet.setDispatchTraceRequest(webMvcProperties.isDispatchTraceRequest());</span><br><span class="line">        dispatcherServlet.setThrowExceptionIfNoHandlerFound(webMvcProperties.isThrowExceptionIfNoHandlerFound());</span><br><span class="line">        dispatcherServlet.setPublishEvents(webMvcProperties.isPublishRequestHandledEvents());</span><br><span class="line">        dispatcherServlet.setEnableLoggingRequestDetails(webMvcProperties.isLogRequestDetails());</span><br><span class="line">        <span class="keyword">return</span> dispatcherServlet;</span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 文件解析器，这里不用管</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnBean(MultipartResolver.class)</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(name = DispatcherServlet.MULTIPART_RESOLVER_BEAN_NAME)</span></span><br><span class="line">    <span class="keyword">public</span> MultipartResolver <span class="title function_">multipartResolver</span><span class="params">(MultipartResolver resolver)</span> {</span><br><span class="line">        <span class="comment">// Detect if the user has created a MultipartResolver but named it incorrectly</span></span><br><span class="line">        <span class="keyword">return</span> resolver;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="DispatcherServletRegistrationConfiguration"><a href="#DispatcherServletRegistrationConfiguration" class="headerlink" title="DispatcherServletRegistrationConfiguration"></a>DispatcherServletRegistrationConfiguration</h3><p><code>DispatcherServletAutoConfiguration</code>中还有一个<code>DispatcherServletRegistrationConfiguration</code>配置类</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@Conditional(DispatcherServletRegistrationCondition.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(ServletRegistration.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(WebMvcProperties.class)</span></span><br><span class="line"><span class="meta">@Import(DispatcherServletConfiguration.class)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DispatcherServletRegistrationConfiguration</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)</span></span><br><span class="line">    <span class="meta">@ConditionalOnBean(value = DispatcherServlet.class, name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)</span></span><br><span class="line">    <span class="keyword">public</span> DispatcherServletRegistrationBean <span class="title function_">dispatcherServletRegistration</span><span class="params">(DispatcherServlet dispatcherServlet,</span></span><br><span class="line"><span class="params">                                                                           WebMvcProperties webMvcProperties, </span></span><br><span class="line"><span class="params">                                                                           ObjectProvider&lt;MultipartConfigElement&gt; multipartConfig)</span> {</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 关键，此处将DispatcherServlet配置到web容器中</span></span><br><span class="line">        <span class="type">DispatcherServletRegistrationBean</span> <span class="variable">registration</span> <span class="operator">=</span> </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">DispatcherServletRegistrationBean</span>(dispatcherServlet, webMvcProperties.getServlet().getPath());</span><br><span class="line">        </span><br><span class="line">        registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME);</span><br><span class="line">        registration.setLoadOnStartup(webMvcProperties.getServlet().getLoadOnStartup());</span><br><span class="line">        multipartConfig.ifAvailable(registration::setMultipartConfig);</span><br><span class="line">        <span class="keyword">return</span> registration;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p><code>DispatcherServletRegistrationBean</code> 继承自<code>ServletRegistrationBean</code></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DispatcherServletRegistrationBean</span> <span class="keyword">extends</span> <span class="title class_">ServletRegistrationBean</span>&lt;DispatcherServlet&gt; <span class="keyword">implements</span> <span class="title class_">DispatcherServletPath</span> {}</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>java</category>
        <category>SpringBoot</category>
        <category>源码</category>
      </categories>
      <tags>
        <tag>SpringBoot源码系列</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot中的@Asnyc注解</title>
    <url>//post/59240/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将探讨在SpringBoot中的线程问题。Controller是线程安全的吗？如果我们想在用户请求时，开辟新的异步任务，该如何操作？</p>
<p>原文地址：<a href="https://xuedongyun.cn/post/59240/">https://xuedongyun.cn/post/59240/</a></p>
<h2 id="Controller线程安全"><a href="#Controller线程安全" class="headerlink" title="Controller线程安全"></a>Controller线程安全</h2><p>首先我们先测试一下<code>Controller</code>的线程问题。我们在<code>Controller</code>中创建成员变量，并在请求中对它进行更改（请注意，这是非常规操作，请勿在开发中使用）。并且，我们在收到请求时，打印当前线程的Id。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping("/hello")</span></span><br><span class="line">    String <span class="title function_">hello</span><span class="params">()</span> {</span><br><span class="line">        i = i + <span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">"i = "</span> + i);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line">        System.out.println(<span class="string">"threadId = "</span> + threadId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>最终结果显示，<code>Controller</code>默认是单例模式，而这种模式下是线程不安全的。我们每次的请求，都会从<code>SpringBoot</code>的线程池中拿到一个线程进行使用。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">i = 1</span><br><span class="line">threadId = 40</span><br><span class="line">i = 2</span><br><span class="line">threadId = 43</span><br><span class="line">i = 3</span><br><span class="line">threadId = 42</span><br><span class="line">i = 4</span><br><span class="line">threadId = 40	// 线程池中，线程可以复用</span><br></pre></td></tr></table></figure></div>

<p>如果我们将<code>Controller</code>指定为单例模式，又会如何呢？我们使用<code>@Scope</code>注解，指定<code>HelloController</code>为原型模式。</p>
<blockquote>
<p><code>@Scope</code>有五种作用域：</p>
<ul>
<li>SINGLETON：单例模式，默认模式，不写的时候默认是SINGLETON</li>
<li>PROTOTYPE：原型模式</li>
<li>REQUEST：同一次请求则只创建一次实例</li>
<li>SESSION：同一个session只创建一次实例</li>
<li>GLOBAL SESSION：全局的web域，类似于servlet中的application</li>
</ul>
</blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> {</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>此时可以看到，每次请求都会创建一个新的<code>Controller</code>实例，所以其实是线程安全的。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">i = 1</span><br><span class="line">threadId = 40</span><br><span class="line">i = 1</span><br><span class="line">threadId = 43</span><br><span class="line">i = 1</span><br><span class="line">threadId = 42</span><br><span class="line">i = 1</span><br><span class="line">threadId = 40</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>无论如何，请尽量不要在<code>Controller</code>中使用成员变量</p>
</blockquote>
<h2 id="Async异步调用"><a href="#Async异步调用" class="headerlink" title="@Async异步调用"></a>@Async异步调用</h2><p>假设用户提交一个任务，后端需要处理很久，最佳的方案应该是使用异步调用。用户提交任务之后，后端开辟新的线程处理任务。</p>
<p>首先在需要异步执行的方法上加上<code>@Async</code>注解</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncTask</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doTask</span><span class="params">(String taskName)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        log.info(Thread.currentThread().getName());</span><br><span class="line">        log.info(<span class="string">"task: "</span> + taskName+ <span class="string">" is finished!"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>然后需要在主启动类上加上<code>@EnableAsync</code>注解，开启异步功能</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringBootSourceApplication</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(SpringBootSourceApplication.class, args);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>现在我们就能对用户的请求进行异步的处理了，用户发起请求能直接收到响应，3000ms后服务器才完成任务</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncController</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> AsyncTask asyncTask;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping("/task")</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">task</span><span class="params">(String taskName)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        asyncTask.doTask(taskName);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success to submit"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h2><h3 id="配置文件修改默认线程池"><a href="#配置文件修改默认线程池" class="headerlink" title="配置文件修改默认线程池"></a>配置文件修改默认线程池</h3><p>我们可以通过配置文件来修改SpringBoot默认线程池的参数</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">task:</span></span><br><span class="line">    <span class="attr">execution:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">core-size:</span> <span class="number">5</span></span><br><span class="line">        <span class="attr">max-size:</span> <span class="number">50</span></span><br><span class="line">        <span class="attr">queue-capacity:</span> <span class="number">200</span></span><br><span class="line">      <span class="attr">thread-name-prefix:</span> <span class="string">myTask-</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码有删改，具体配置类</span></span><br><span class="line"><span class="meta">@ConfigurationProperties("spring.task.execution")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskExecutionProperties</span> {</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Pool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pool</span>();</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Shutdown</span> <span class="variable">shutdown</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Shutdown</span>();</span><br><span class="line">	<span class="keyword">private</span> <span class="type">String</span> <span class="variable">threadNamePrefix</span> <span class="operator">=</span> <span class="string">"task-"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Pool</span> {</span><br><span class="line">		<span class="keyword">private</span> <span class="type">int</span> <span class="variable">queueCapacity</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">		<span class="keyword">private</span> <span class="type">int</span> <span class="variable">coreSize</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">		<span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxSize</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="配置类定义新的线程池"><a href="#配置类定义新的线程池" class="headerlink" title="配置类定义新的线程池"></a>配置类定义新的线程池</h3><p>也可以在配置类中定义自己的线程池（由于<code>@ConditionalOnMissingBean</code>，默认线程池已经没了）</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncConfig</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = "customTaskExecutor")</span></span><br><span class="line">    <span class="keyword">public</span> ThreadPoolTaskExecutor <span class="title function_">customTaskExecutor</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">taskExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        taskExecutor.setCorePoolSize(<span class="number">2</span>);</span><br><span class="line">        taskExecutor.setMaxPoolSize(<span class="number">10</span>);</span><br><span class="line">        taskExecutor.setKeepAliveSeconds(<span class="number">200</span>);</span><br><span class="line">        taskExecutor.setThreadNamePrefix(executorPrefix);</span><br><span class="line">        taskExecutor.setRejectedExecutionHandler(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line">        taskExecutor.initialize();</span><br><span class="line">        <span class="keyword">return</span> taskExecutor;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="AsyncConfigurer接口"><a href="#AsyncConfigurer接口" class="headerlink" title="AsyncConfigurer接口"></a>AsyncConfigurer接口</h3><p>在配置类中实现<code>AsyncConfigurer</code>接口</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncConfig</span> <span class="keyword">implements</span> <span class="title class_">AsyncConfigurer</span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定默认线程池</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Executor <span class="title function_">getAsyncExecutor</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> getExecutor();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> AsyncUncaughtExceptionHandler <span class="title function_">getAsyncUncaughtExceptionHandler</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> AsyncConfigurer.<span class="built_in">super</span>.getAsyncUncaughtExceptionHandler();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ThreadPoolTaskExecutor <span class="title function_">getExecutor</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">taskExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        taskExecutor.setCorePoolSize(<span class="number">2</span>);</span><br><span class="line">        taskExecutor.setMaxPoolSize(<span class="number">10</span>);</span><br><span class="line">        taskExecutor.setKeepAliveSeconds(<span class="number">200</span>);</span><br><span class="line">        taskExecutor.setThreadNamePrefix(<span class="string">"custom-"</span>);</span><br><span class="line">        taskExecutor.setRejectedExecutionHandler(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line">        taskExecutor.initialize();</span><br><span class="line">        <span class="keyword">return</span> taskExecutor;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="为任务指定不同线程池"><a href="#为任务指定不同线程池" class="headerlink" title="为任务指定不同线程池"></a>为任务指定不同线程池</h2><p>若<code>@Async</code>不指定具体的线程池，会使用默认的线程池。具体规则如下：</p>
<ul>
<li><p>若容器中只有一个<code>TaskExecutor</code>组件，其为默认执行器；</p>
</li>
<li><p>若不唯一，拿名字叫”taskExecutor”的，类型为<code>Executor</code>的组件。</p>
</li>
<li><p>若都不满足，使用<code>SimpleAsyncTaskExecutor</code>作为默认执行器（每次执行被注解方法时，单独创建一个Thread来执行）</p>
</li>
</ul>
<p>我们可以通过value属性，为不同任务指定不同的线程池</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不同方法，指定不同的线程池</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Async("otherTaskExecutor")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doTask1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">    log.info(Thread.currentThread().getName());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Async("testTaskExecutor")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doTask2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">    log.info(Thread.currentThread().getName());</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean(name = "otherTaskExecutor")</span></span><br><span class="line"><span class="keyword">public</span> ThreadPoolTaskExecutor <span class="title function_">otherExecutor</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">taskExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">    taskExecutor.setCorePoolSize(<span class="number">2</span>);</span><br><span class="line">    taskExecutor.setMaxPoolSize(<span class="number">10</span>);</span><br><span class="line">    taskExecutor.setKeepAliveSeconds(<span class="number">200</span>);</span><br><span class="line">    taskExecutor.setThreadNamePrefix(<span class="string">"other-"</span>);</span><br><span class="line">    taskExecutor.setRejectedExecutionHandler(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line">    taskExecutor.initialize();</span><br><span class="line">    <span class="keyword">return</span> taskExecutor;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean(name = "testTaskExecutor")</span></span><br><span class="line"><span class="keyword">public</span> ThreadPoolTaskExecutor <span class="title function_">testExecutor</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">taskExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">    taskExecutor.setCorePoolSize(<span class="number">2</span>);</span><br><span class="line">    taskExecutor.setMaxPoolSize(<span class="number">10</span>);</span><br><span class="line">    taskExecutor.setKeepAliveSeconds(<span class="number">200</span>);</span><br><span class="line">    taskExecutor.setThreadNamePrefix(<span class="string">"test-"</span>);</span><br><span class="line">    taskExecutor.setRejectedExecutionHandler(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line">    taskExecutor.initialize();</span><br><span class="line">    <span class="keyword">return</span> taskExecutor;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>如果你想知道背后的原理（源码），可以查看我之前的文章：<a href="https://xuedongyun.cn/post/24765/">SpringBoot源码系列（10）：@Async原理</a></p>
]]></content>
      <categories>
        <category>java</category>
        <category>SpringBoot</category>
        <category>应用</category>
      </categories>
      <tags>
        <tag>SpringBoot基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring6学习拾遗</title>
    <url>//post/386/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要是在学习Spring6时的知识点拾遗，涉及多个方面，内容较为基础</p>
<p>原文地址：<a href="https://xuedongyun.cn/post/386/">https://xuedongyun.cn/post/386/</a></p>
<h2 id="Spring是如何创建对象的（xml）"><a href="#Spring是如何创建对象的（xml）" class="headerlink" title="Spring是如何创建对象的（xml）"></a>Spring是如何创建对象的（xml）</h2><ul>
<li>调用了无参构造器创建对象</li>
<li><code>dom4j</code>解析<code>beans.xml</code>文件，从中获取类的全类名</li>
<li>通过反射机制调用无参数构造方法创建对象</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">"com.example.spring6.User"</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> clazz.getDeclaredConstructor().newInstance();</span><br></pre></td></tr></table></figure></div>

<ul>
<li>bean最终存储在spring容器中，底层是一个map。map在<code>DefaultListableBeanFactory</code>类中<ul>
<li>key：<code>String</code>，默认是类名首字母小写</li>
<li>values：<code>BeanDefinition</code> , 存的是类的定义(描述信息)</li>
</ul>
</li>
</ul>
<blockquote>
<p><code>BeanDefinition</code></p>
<p>每一个被扫描到的bean都会生成一个<code>BeanDefinition</code>。描述一个bean的全部信息，比如他的class类型、Bean的作用域、是否懒加载…</p>
<p><code>BeanDefinition</code>的常见属性：</p>
<ul>
<li><code>beanClass</code>：表示Bean类型，未加载类的时候存放Bean的名字，加载类后存放Bean的class信息。</li>
<li><code>scope</code>：表示Bean的作用域，一般值为单例或者原型。</li>
<li><code>lazyInit</code>：表示Bean是否是懒加载。</li>
<li><code>initMethodName</code>：Bean初始化需要执行的方法。</li>
<li><code>destroyMethodName</code>：Bean销毁时要执行的方法。</li>
<li><code>factoryBeanName</code>：创建当前Bean的工厂。</li>
</ul>
</blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultListableBeanFactory</span> <span class="keyword">extends</span> <span class="title class_">AbstractAutowireCapableBeanFactory</span> </span><br><span class="line">    									<span class="keyword">implements</span> <span class="title class_">ConfigurableListableBeanFactory</span>, BeanDefinitionRegistry, Serializable {</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="什么是控制反转（IoC）和依赖注入（DI）"><a href="#什么是控制反转（IoC）和依赖注入（DI）" class="headerlink" title="什么是控制反转（IoC）和依赖注入（DI）"></a>什么是控制反转（IoC）和依赖注入（DI）</h2><p>控制反转</p>
<ul>
<li>是一种思想</li>
<li>为了降低程序耦合，提高扩展能力</li>
<li>反转的是什么<ul>
<li>对象的创建权，交由第三方容器负责</li>
<li>对象之间关系的维护权，交由第三方容器负责</li>
</ul>
</li>
<li>如何实现的：依赖注入</li>
</ul>
<p>依赖注入</p>
<ul>
<li>依赖注入实现了控制反转</li>
<li>Spring中，对象创建的过程中，将对象依赖属性通过配置进行注入</li>
<li>常见依赖注入方式<ul>
<li>setter输入</li>
<li>构造器注入</li>
</ul>
</li>
</ul>
<h2 id="IOC容器在Spring中的实现"><a href="#IOC容器在Spring中的实现" class="headerlink" title="IOC容器在Spring中的实现"></a>IOC容器在Spring中的实现</h2><p>Spring中的IoC容器：IoC思想的具体实现，管理的组件叫Bean。</p>
<ol>
<li><code>BeanFactory</code>：IoC 容器的基本实现，Spring内部使用的接口</li>
<li><code>ApplicationContext</code>：子接口，提供了更多高级特性，面向 Spring 的使用者</li>
</ol>
<p><code>ApplicationContext</code>的主要实现类：</p>
<table>
<thead>
<tr>
<th>类型名</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td><code>ClassPathXmlApplicationContext</code></td>
<td>通过读取类路径下的 XML 格式的配置文件创建 IOC 容器对象</td>
</tr>
<tr>
<td><code>FileSystemXmlApplicationContext</code></td>
<td>通过文件系统路径读取 XML 格式的配置文件创建 IOC 容器对象</td>
</tr>
<tr>
<td><code>ConfigurableApplicationContext</code></td>
<td><code>ApplicationContext</code> 的子接口，包含一些扩展方法 refresh() 和 close() ，让 <code>ApplicationContext</code> 具有启动、关闭和刷新上下文的能力。</td>
</tr>
<tr>
<td><code>WebApplicationContext</code></td>
<td>专门为 Web 应用准备，基于 Web 环境创建 IOC 容器对象，并将对象引入存入 <code>ServletContext</code> 域中。</td>
</tr>
</tbody></table>
<h2 id="获取Bean时的类型判断"><a href="#获取Bean时的类型判断" class="headerlink" title="获取Bean时的类型判断"></a>获取Bean时的类型判断</h2><p>根据类型来获取Bean时，实际使用的是<code>instanceof</code>。也即，在满足Bean唯一条件下，我们可以拿到子类型的Bean</p>
<h2 id="Autowired和-Resource的区别"><a href="#Autowired和-Resource的区别" class="headerlink" title="@Autowired和@Resource的区别"></a>@Autowired和@Resource的区别</h2><table>
<thead>
<tr>
<th><code>@Autowired</code></th>
<th><code>@Resource</code></th>
</tr>
</thead>
<tbody><tr>
<td>Spring框架的注解</td>
<td>JDK扩展包<code>javax.annotation-api</code>中的注解</td>
</tr>
<tr>
<td>默认byType注入；若要根据名称，需使用@Qualifier注解</td>
<td>默认byName注入，没有指定name时把属性名当做name；根据name找不到时，才会byType注入</td>
</tr>
<tr>
<td>属性，setter，方法，构造函数</td>
<td>属性，setter</td>
</tr>
</tbody></table>
<h2 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h2><p>Bean的生命周期</p>
<ul>
<li>bean对象创建（调用无参构造器）</li>
<li>为bean对象设置属性</li>
<li>bean的<strong>后置处理器（初始化之前）</strong></li>
<li>bean对象<strong>初始化（需在配置bean时指定初始化方法）</strong></li>
<li>bean的<strong>后置处理器（初始化之后）</strong></li>
<li>bean对象就绪（可以使用了）</li>
<li>bean对象<strong>销毁（需在配置bean时指定销毁方法）</strong></li>
<li>IoC容器关闭</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initMethod</span><span class="params">()</span>{</span><br><span class="line">        System.out.println(<span class="string">"生命周期：初始化"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroyMethod</span><span class="params">()</span>{</span><br><span class="line">        System.out.println(<span class="string">"生命周期：销毁"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initMethod</span><span class="params">()</span>{</span><br><span class="line">        System.out.println(<span class="string">"生命周期：初始化"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroyMethod</span><span class="params">()</span>{</span><br><span class="line">        System.out.println(<span class="string">"生命周期：销毁"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 后置处理器需要放到容器中，才能生效</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException {</span><br><span class="line">        System.out.println(<span class="string">"生命周期：后置处理器，初始化之前"</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException {</span><br><span class="line">        System.out.println(<span class="string">"生命周期：后置处理器，初始化之后"</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>配置<code>initMethod</code>和<code>destroyMethod</code>的几种方法：</p>
<ol>
<li><code>@PostConstruct</code>注解和<code>@PreDestroy</code>注解</li>
<li><code>xml</code>方式：<code>&lt;bean class="xxx" init-method="initMethod" destroy-method="destroyMethod"&gt;</code></li>
<li><code>@Bean</code>注解方式：<code>@Bean(initMethod = "initMethod", destroyMethod = "destroyMethod")</code></li>
</ol>
</blockquote>
<h2 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h2><p><code>FactoryBean</code>是Spring提供的一种整合第三方框架的常用机制。配置一个<code>FactoryBean</code>类型的bean，在获取bean的时候得到的是<code>getObject()</code>方法的返回值。</p>
<p><code>Mybatis</code>就是通过FactoryBean机制来创建<code>SqlSessionFactory</code>对象的</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;User&gt; {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() {</span><br><span class="line">        <span class="keyword">return</span> User.class;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> context.getBean(<span class="string">"userFactoryBean"</span>, User.class);</span><br></pre></td></tr></table></figure></div>

<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>二十三种设计模式的一种。调用目标方法，需要先经过代理，由代理对象调用目标方法。可以让不属于目标方法的逻辑剥离出来，解耦。</p>
<h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><p>原本的类，用于计算</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Calculator</span> {</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalculatorImpl</span> <span class="keyword">implements</span> <span class="title class_">Calculator</span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> i + j;</span><br><span class="line">        System.out.println(<span class="string">"result = "</span> + result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>静态代理模式，将被代理的对象声明为成员变量</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalculatorStaticProxy</span> <span class="keyword">implements</span> <span class="title class_">Calculator</span>{</span><br><span class="line">    <span class="keyword">private</span> Calculator target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CalculatorStaticProxy</span><span class="params">(Calculator target)</span> {</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"方法执行前"</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> target.add(i, j);</span><br><span class="line">        System.out.println(<span class="string">"方法执行后"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>调用方法</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Calculator</span> <span class="variable">calculator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CalculatorImpl</span>();</span><br><span class="line"><span class="type">Calculator</span> <span class="variable">staticProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CalculatorStaticProxy</span>(calculator);</span><br><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> staticProxy.add(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></div>

<h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>使用<code>Proxy.newProxyInstance</code>来创建代理对象</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 工厂类，用来生产代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProxyFactory</span><span class="params">(Object target)</span> {</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 生产代理对象，使用Proxy.newProxyInstance</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> target.getClass().getClassLoader();</span><br><span class="line">        Class&lt;?&gt;[] interfaces = target.getClass().getInterfaces();</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable {</span><br><span class="line">                System.out.println(<span class="string">"方法执行前"</span>);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">                System.out.println(<span class="string">"方法执行后"</span>);</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(classLoader, interfaces, handler);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Calculator</span> <span class="variable">calculator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CalculatorImpl</span>();</span><br><span class="line"><span class="type">ProxyFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>(calculator);</span><br><span class="line"><span class="type">Calculator</span> <span class="variable">proxy</span> <span class="operator">=</span> (Calculator) factory.getProxy();</span><br><span class="line">proxy.add(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></div>

<h3 id="AOP概念"><a href="#AOP概念" class="headerlink" title="AOP概念"></a>AOP概念</h3><p>AOP（面向切面编程）是一种设计思想，是面向对象编程的一种补充。他通过预编译的方式和运行期间动态代理的方式实现。我们可以在不修改源代码的情况下，给程序统一添加额外的功能。</p>
<ul>
<li><p>简化代码：把方法中固定位置的重复的代码<strong>抽取</strong>出来，让被抽取的方法更专注于自己的核心功能，提高内聚性</p>
</li>
<li><p>代码增强：把特定的功能封装到切面类中，看哪里有需要，就往上套，被<strong>套用</strong>了切面逻辑的方法就被切面给增强了</p>
</li>
</ul>
<h3 id="AOP相关术语"><a href="#AOP相关术语" class="headerlink" title="AOP相关术语"></a>AOP相关术语</h3><h4 id="横切关注点"><a href="#横切关注点" class="headerlink" title="横切关注点"></a>横切关注点</h4><p>这是一个逻辑上的概念：分散在每个各个模块中解决同样的问题。比如用户验证，日志管理…</p>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/06/16/m5jN7cziPUMFSlZ.png" alt="img019" style="zoom:50%;">

<h4 id="通知（增强）"><a href="#通知（增强）" class="headerlink" title="通知（增强）"></a>通知（增强）</h4><p>横切关注点上要做的事情都，需要一个方法来实现，这样的方法就叫通知方法</p>
<ul>
<li>前置通知：在被代理的目标方法<strong>前</strong>执行</li>
<li>返回通知：在被代理的目标方法<strong>成功结束</strong>后执行（<strong>寿终正寝</strong>）</li>
<li>异常通知：在被代理的目标方法<strong>异常结束</strong>后执行（<strong>死于非命</strong>）</li>
<li>后置通知：在被代理的目标方法<strong>最终结束</strong>后执行（<strong>盖棺定论</strong>）</li>
<li>环绕通知：使用try…catch…finally结构围绕<strong>整个</strong>被代理的目标方法，包括上面四种通知对应的所有位置</li>
</ul>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/06/16/zomuTxDWpF6fZKU.png" alt="img020" style="zoom:50%;">

<h4 id="切面"><a href="#切面" class="headerlink" title="切面"></a>切面</h4><p>封装通知方法的类</p>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/06/16/4cUNnYRje5ZB8Fu.png" alt="img021" style="zoom:50%;">

<h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><p>被代理的目标对象</p>
<h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><p>目标对象应用通知后的代理对象</p>
<h4 id="连接点"><a href="#连接点" class="headerlink" title="连接点"></a>连接点</h4><p>这是一个逻辑概念：把方法排成一排，每个横切位置看成x轴方向，方法由上到下执行的顺序看成y轴方向，x轴和y轴交叉点就是连接点。</p>
<p>简单来说：<strong>就是Spring允许你使用通知的地方</strong></p>
<h4 id="切入点"><a href="#切入点" class="headerlink" title="切入点"></a>切入点</h4><p>定位连接点的方式。每个类的方法都有多个连接点（连接点是客观存在的事物）</p>
<p>Spring的AOP技术可以<strong>通过切入点，定位到特定的连接点</strong></p>
<h3 id="基于注解的AOP"><a href="#基于注解的AOP" class="headerlink" title="基于注解的AOP"></a>基于注解的AOP</h3><h4 id="技术说明"><a href="#技术说明" class="headerlink" title="技术说明"></a>技术说明</h4><pre class="mermaid">graph TB;
    subgraph Spring基于注解的AOP;
        AspectJ注解层
        subgraph 具体实现层;
            动态代理
            cglib
        end
    end</pre>

<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/06/16/AQh2eMS79mIv4Xs.png" alt="image-20221216132844066" style="zoom:50%;">

<ul>
<li><p>动态代理分为<strong>JDK动态代理</strong>，<strong>cglib动态代理</strong>。有接口的情况可以使用<strong>JDK动态代理</strong>或<strong>cglib动态代理</strong>；没有接口只能使用<strong>cglib动态代理</strong></p>
<ul>
<li><strong>JDK动态代理</strong>：JDK原生的实现方式，被代理的目标类必须实现接口</li>
<li><strong>cglib动态代理</strong>：通过继承被代理的目标类实现代理，不需要目标实现接口</li>
</ul>
</li>
<li><p><strong>JDK动态代理</strong>生成的代理类会在com.sum.proxy包下，类名为$proxy1，和目标方法实现了相同的接口</p>
</li>
<li><p><strong>cglib动态代理</strong>生成的代理类会和目标方法在相同的包下，会继承目标类</p>
</li>
</ul>
<h4 id="所需依赖"><a href="#所需依赖" class="headerlink" title="所需依赖"></a>所需依赖</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring-aop</span><br><span class="line">spring-aspects</span><br></pre></td></tr></table></figure></div>

<h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><p>配置切面类</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAspect</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before("execution(public int org.example.aop.CalculatorImpl.*(..))")</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeMethod</span><span class="params">(JoinPoint joinPoint)</span> {</span><br><span class="line">        </span><br><span class="line">        <span class="type">Signature</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature();</span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"LogAspect.beforeMethod methodName="</span> + methodName + <span class="string">", args="</span> + Arrays.toString(args));</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h4 id="各种通知"><a href="#各种通知" class="headerlink" title="各种通知"></a>各种通知</h4><p><code>@Before</code>：前置通知，目标方法执行前</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before("...")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeMethod</span><span class="params">(JoinPoint joinPoint)</span></span><br></pre></td></tr></table></figure></div>

<p><code>@AfterReturning</code>：返回通知，目标方法成功后</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AfterReturning("...")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturningMethod</span><span class="params">(JoinPoint joinPoint, Object result)</span></span><br></pre></td></tr></table></figure></div>

<p><code>@AfterThrowing</code>：异常通知，目标方法异常结束后</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AfterThrowing("...")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowingMethod</span><span class="params">(JoinPoint joinPoint, Throwable ex)</span></span><br></pre></td></tr></table></figure></div>

<p><code>@After</code>：后置通知，目标方法最终结束后</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@After("...")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterMethod</span><span class="params">(JoinPoint joinPoint)</span></span><br></pre></td></tr></table></figure></div>

<p><code>@Around</code>：环绕通知</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Around("...")</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">aroundMethod</span><span class="params">(ProceedingJoinPoint joinPoint)</span> {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        result = joinPoint.proceed();</span><br><span class="line">    } <span class="keyword">catch</span> (Throwable throwable) {</span><br><span class="line">        throwable.printStackTrace();</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>执行顺序（5.3.x版本以后）：前置通知-&gt;目标操作-&gt;返回通知/异常通知-&gt;后置通知</p>
<h4 id="切入点表达式"><a href="#切入点表达式" class="headerlink" title="切入点表达式"></a>切入点表达式</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/06/16/crdRw458ZBFuz2j.png" alt="img025"></p>
<blockquote>
<p>补：</p>
<p>如果要明确返回值类型，必须写明权限修饰符</p>
<p>在方法参数列表部分，使用(int,..)表示参数列表以一个int类型的参数开头</p>
</blockquote>
<h4 id="重用切入点"><a href="#重用切入点" class="headerlink" title="重用切入点"></a>重用切入点</h4><p>声明切入点</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Pointcut("execution(* org.example.aop.*.*(..))")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointCut</span><span class="params">()</span>{}</span><br></pre></td></tr></table></figure></div>

<p>在同一个类中使用</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before("pointCut()")</span></span><br></pre></td></tr></table></figure></div>

<p>在不同类中使用</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before("org.example.aop.CommonPointCut.pointCut()")</span></span><br></pre></td></tr></table></figure></div>

<h4 id="切面的优先级"><a href="#切面的优先级" class="headerlink" title="切面的优先级"></a>切面的优先级</h4><p>使用@Order注解可以控制切面的优先级：</p>
<ul>
<li><code>@Order</code>(较小的数)：优先级高，外面</li>
<li><code>@Order</code>(较大的数)：优先级低，内层</li>
</ul>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/06/16/znJUXcBQFKuTYiO.png" alt="img026" style="zoom: 50%;">

<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务：一个数据库操作序列，这些操作要么全部执行，要么全部不执行</p>
<p>特性：ACID（原子性，一致性，隔离性，持久性）</p>
<h3 id="jdbcTemplate"><a href="#jdbcTemplate" class="headerlink" title="jdbcTemplate"></a>jdbcTemplate</h3><p><code>jdbcTemplate</code>是Spring对JDBC的封装</p>
<p>所需依赖：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring-jdbc</span><br><span class="line">mysql-connector-java</span><br></pre></td></tr></table></figure></div>

<p>容器中配置<code>jdbcTemplate</code></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan("org.example")</span></span><br><span class="line"><span class="comment">// 开启事务管理功能</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> {</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 数据源</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    DataSource <span class="title function_">dataSource</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">HikariDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HikariDataSource</span>();</span><br><span class="line">        dataSource.setJdbcUrl(<span class="string">"jdbc:mysql://localhost:3306/flask?characterEncoding=utf8&amp;useSSL=false"</span>);</span><br><span class="line">        dataSource.setUsername(<span class="string">"root"</span>);</span><br><span class="line">        dataSource.setPassword(<span class="string">"122599"</span>);</span><br><span class="line">        dataSource.setDriverClassName(<span class="string">"com.mysql.cj.jdbc.Driver"</span>);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 事务管理器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSourceTransactionManager <span class="title function_">transactionManager</span><span class="params">(DataSource datasource)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>(datasource);</span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// jdbcTemplate</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    JdbcTemplate <span class="title function_">jdbcTemplate</span><span class="params">(DataSource dataSource)</span> {</span><br><span class="line">        <span class="type">JdbcTemplate</span> <span class="variable">jdbcTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>();</span><br><span class="line">        jdbcTemplate.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>使用<code>jdbcTemplate</code>（细节略）</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">"insert into t_emp values(null,?,?,?)"</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> jdbcTemplate.update(sql, <span class="string">"xdy"</span>, <span class="number">23</span>, <span class="string">"男"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">"update t_emp set name=? where id=?"</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> jdbcTemplate.update(sql, <span class="string">"xdy"</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">"delete from t_emp where id=?"</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> jdbcTemplate.update(sql, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询一</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">"select * from t_emp where id=?"</span>;</span><br><span class="line"><span class="type">Emp</span> <span class="variable">empResult</span> <span class="operator">=</span> jdbcTemplate.queryForObject(sql, </span><br><span class="line">                                            (rs, rowNum) -&gt; {</span><br><span class="line">                                                <span class="type">Emp</span> <span class="variable">emp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Emp</span>();</span><br><span class="line">                                                emp.setId(rs.getInt(<span class="string">"id"</span>));</span><br><span class="line">                                                emp.setName(rs.getString(<span class="string">"name"</span>));</span><br><span class="line">                                                emp.setAge(rs.getInt(<span class="string">"age"</span>));</span><br><span class="line">                                                emp.setSex(rs.getString(<span class="string">"sex"</span>));</span><br><span class="line">                                                <span class="keyword">return</span> emp;</span><br><span class="line">                                            }, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询二</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">"select * from t_emp where id=?"</span>;</span><br><span class="line"><span class="type">Emp</span> <span class="variable">emp</span> <span class="operator">=</span> jdbcTemplate.queryForObject(sql, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;&gt;(Emp.class), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询三</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">"select * from t_emp"</span>;</span><br><span class="line">List&lt;Emp&gt; list = jdbcTemplate.query(sql, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;&gt;(Emp.class));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询四</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">"select count(id) from t_emp"</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> jdbcTemplate.queryForObject(sql, Integer.class);</span><br></pre></td></tr></table></figure></div>

<h3 id="编程式事务"><a href="#编程式事务" class="headerlink" title="编程式事务"></a>编程式事务</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> ...;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开启事务：关闭事务的自动提交</span></span><br><span class="line">    conn.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 核心操作</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 提交事务</span></span><br><span class="line">    conn.commit();</span><br><span class="line">    </span><br><span class="line">} <span class="keyword">catch</span>(Exception e){</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 回滚事务</span></span><br><span class="line">    conn.rollBack();</span><br><span class="line">    </span><br><span class="line">} <span class="keyword">finally</span>{</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放数据库连接</span></span><br><span class="line">    conn.close();</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>框架可以将固定模式抽取出来，进行封装</p>
</blockquote>
<h3 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h3><blockquote>
<p>记得先配置好事务管理（前面有）</p>
</blockquote>
<p><code>@Transactional</code>注解可以标注在类或者方法上</p>
<h4 id="只读操作"><a href="#只读操作" class="headerlink" title="只读操作"></a>只读操作</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(readOnly = true)</span></span><br></pre></td></tr></table></figure></div>

<h4 id="超时回滚"><a href="#超时回滚" class="headerlink" title="超时回滚"></a>超时回滚</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(timeout = 3)</span></span><br></pre></td></tr></table></figure></div>

<h4 id="回滚策略"><a href="#回滚策略" class="headerlink" title="回滚策略"></a>回滚策略</h4><p>针对具体的异常</p>
<ul>
<li>注意：声明式事务只针对运行时异常</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只有指定的异常才回滚</span></span><br><span class="line"><span class="meta">@Transactional(rollbackFor = ArithmeticException.class)</span></span><br><span class="line"><span class="meta">@Transactional(rollbackForClassName ="java.lang.ArithmeticException")</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定的异常不回滚</span></span><br><span class="line"><span class="meta">@Transactional(noRollbackFor = ArithmeticException.class)</span></span><br><span class="line"><span class="meta">@Transactional(noRollbackForClassName ="java.lang.ArithmeticException")</span></span><br></pre></td></tr></table></figure></div>

<h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p><code>READ_UNCOMMITTED</code>：有脏读的问题（读到了未提交的数据）</p>
<p><code>READ_COMMITTED</code>：有不可重复读的问题（前后两次读取结果不同）</p>
<p><code>REPEATABLE_READ</code>：有幻读的问题（前一次查询没有，后一次查询又有了）</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(isolation = Isolation.DEFAULT)</span>			<span class="comment">//使用数据库默认的隔离级别</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(isolation = Isolation.READ_UNCOMMITTED)</span>	<span class="comment">//读未提交，允许A读取B更新但未提交的修改</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(isolation = Isolation.READ_COMMITTED)</span>	<span class="comment">//读已提交，A只能读取B已提交的修改</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(isolation = Isolation.REPEATABLE_READ)</span>	<span class="comment">//可重复读，A可以多次读到相同的值，也即A执行期间禁止修改（MySQL默认）</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(isolation = Isolation.SERIALIZABLE)</span>		<span class="comment">//串行化，A执行期间，禁止其他事务对表增删改</span></span><br></pre></td></tr></table></figure></div>

<h4 id="传播行为"><a href="#传播行为" class="headerlink" title="传播行为"></a>传播行为</h4><p>A设定了事务，B也设定了事务。A方法中调B方法，事务是如何传递的：</p>
<ul>
<li><code>REQUIRED</code>：没有就新建，有就加入</li>
<li><code>SUPPORTS</code>：有就加入，没有就不管了（以非事务方式运行）</li>
<li><code>MANDATORY</code>：有就加入，没有就抛异常</li>
<li><code>REQUIRES_NEW</code>：不管有没有，直接开启一个新事务，开启的新事务和之前的事务不存在嵌套关系，之前事务被挂起</li>
<li><code>NOT_SUPPORTED</code>：挂起当前事务，以非事务方式运行</li>
<li><code>NEVER</code>：不支持事务，存在就抛异常</li>
<li><code>NESTED</code>：有事务的话，就嵌套一个独立的事务，嵌套的事务可以独立提交和回滚。没有事务的话和<code>REQUIRED</code>一样</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 结账</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkout</span><span class="params">(Integer[] bookIds, Integer userId)</span> {</span><br><span class="line">    <span class="keyword">for</span> (Integer bookId : bookIds) {</span><br><span class="line">        <span class="comment">// 调用buyBook</span></span><br><span class="line">        buyBook(bookId, userId);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p><code>REQUIRED</code>：加入原有事务，只要有一本买不起，就全购买失败</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 买一本书</span></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span> <span class="comment">// 加入原有事务中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buyBook</span><span class="params">(Integer bookId, Integer userId)</span>{</span><br><span class="line">    checkoutService.checkout(bookIds, userId);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p><code>REQUIRES_NEW</code>：开启新事务，可以一直买书到买不起为止</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 买一本书</span></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span> <span class="comment">// 开启新事务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buyBook</span><span class="params">(Integer bookId, Integer userId)</span>{</span><br><span class="line">    checkoutService.checkout(bookIds, userId);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="资源操作Resource"><a href="#资源操作Resource" class="headerlink" title="资源操作Resource"></a>资源操作Resource</h2><p>给予了访问low-level资源的能力</p>
<h3 id="Resource接口"><a href="#Resource接口" class="headerlink" title="Resource接口"></a>Resource接口</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Resource</span> <span class="keyword">extends</span> <span class="title class_">InputStreamSource</span> {</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 资源是否存在</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">exists</span><span class="params">()</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 资源是否可以通过InputStreamResource读取</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isReadable</span><span class="params">()</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 指示当前资源，是否具有开放流的handle</span></span><br><span class="line">    <span class="comment">// 如果是true，InputStream就不能够多次读取，只能够读取一次并且及时关闭以避免内存泄漏</span></span><br><span class="line">    <span class="comment">// 对于所有常规资源实现，返回false，但是InputStreamResource除外</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isOpen</span><span class="params">()</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 资源是否是一个文件</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isFile</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    URL <span class="title function_">getURL</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    URI <span class="title function_">getURI</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">	</span><br><span class="line">    File <span class="title function_">getFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    ReadableByteChannel <span class="title function_">readableChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="title function_">contentLength</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="title function_">lastModified</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 创建此资源的相关资源</span></span><br><span class="line">    Resource <span class="title function_">createRelative</span><span class="params">(String relativePath)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getFilename</span><span class="params">()</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 返回描述信息，通常是完全限定的文件名或资源的URL</span></span><br><span class="line">    String <span class="title function_">getDescription</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>Resource接口继承了InputStreamSource接口</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InputStreamSource</span> {</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 找到并打开资源，返回InputStream以从资源中读取。每次调用都返回新的InputStream()，调用者需关闭每个流</span></span><br><span class="line">    InputStream <span class="title function_">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="Resource实现类"><a href="#Resource实现类" class="headerlink" title="Resource实现类"></a>Resource实现类</h3><h4 id="UrlResource"><a href="#UrlResource" class="headerlink" title="UrlResource"></a>UrlResource</h4><p>用来访问网络资源，它支持URL的绝对路径</p>
<ul>
<li>http: 访问基于HTTP协议的网络资源</li>
<li>ftp: 访问基于FTP协议的网络资源</li>
<li>file: 从文件系统中读取</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    <span class="type">UrlResource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlResource</span>(<span class="string">"http://www.baidu.com"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ""</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">filename</span> <span class="operator">=</span> resource.getFilename(); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// http://www.baidu.com</span></span><br><span class="line">    <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> resource.getURL(); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// URL [http://www.baidu.com]</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">description</span> <span class="operator">=</span> resource.getDescription(); </span><br><span class="line">    </span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> resource.getInputStream();</span><br><span class="line">    <span class="type">byte</span>[] allBytes = inputStream.readAllBytes();</span><br><span class="line">    <span class="comment">// &lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt;&lt;meta http-equiv=content-type content=text/html;charset=utf-8&gt;&lt;me...</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(allBytes); </span><br><span class="line">    </span><br><span class="line">} <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    <span class="type">UrlResource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlResource</span>(<span class="string">"file:C:/test.txt"</span>);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// test.txt</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">filename</span> <span class="operator">=</span> resource.getFilename();</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// file:C:/test.txt</span></span><br><span class="line">    <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> resource.getURL();</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// URL [file:C:/test.txt]</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">description</span> <span class="operator">=</span> resource.getDescription();</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// s = hello my name is xuedongyun</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> resource.getInputStream();</span><br><span class="line">    <span class="type">byte</span>[] allBytes = inputStream.readAllBytes();</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(allBytes);</span><br><span class="line">    </span><br><span class="line">} <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="ClassPathResource"><a href="#ClassPathResource" class="headerlink" title="ClassPathResource"></a>ClassPathResource</h4><p>用来访问类加载路径下的资源，可自动搜索位于 classes 下的资源文件，无须使用绝对路径访问</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ClassPathResource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">"test.txt"</span>);</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>filename</code>：test.txt</li>
<li><code>url</code>：file:/C:/Users/xdy/Desktop/%e5%8d%9a%e5%ae%a2/LearnSpring6/target/classes/test.txt</li>
<li><code>description</code>：class path resource [test.txt]</li>
</ul>
<h4 id="FileSystemResource"><a href="#FileSystemResource" class="headerlink" title="FileSystemResource"></a>FileSystemResource</h4><p>用来访问文件系统资源（并没有太大的优势，因为File 类也可访问文件系统资源）</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//相对路径</span></span><br><span class="line"><span class="type">FileSystemResource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemResource</span>(<span class="string">"test.txt"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//绝对路径</span></span><br><span class="line"><span class="type">FileSystemResource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemResource</span>(<span class="string">"C:/test.txt"</span>);</span><br></pre></td></tr></table></figure></div>

<h4 id="ServletContextResource"><a href="#ServletContextResource" class="headerlink" title="ServletContextResource"></a>ServletContextResource</h4><p>这是<code>ServletContext</code>资源的<code>Resource</code>实现，依赖于Servlet容器</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ServletContextResource</span> <span class="variable">src</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletContextResource</span>(application, <span class="string">"WEB-INF/book.xml"</span>);</span><br></pre></td></tr></table></figure></div>

<h4 id="InputStreamResource"><a href="#InputStreamResource" class="headerlink" title="InputStreamResource"></a>InputStreamResource</h4><p>是给定的输入流<code>InputStream</code>的<code>Resource</code>实现。在没有特定的资源实现的时候使用。与其他Resource实现相比，这是已打开资源的描述符。 因此，它的isOpen()方法返回true。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一次性输入流资源</span></span><br><span class="line"><span class="type">InputStreamResource</span> <span class="variable">inputStreamResource</span> <span class="operator">=</span> </span><br><span class="line"><span class="keyword">new</span> <span class="title class_">InputStreamResource</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">"C:\\dir\\application.xml"</span>)));</span><br></pre></td></tr></table></figure></div>

<h4 id="ByteArrayResource"><a href="#ByteArrayResource" class="headerlink" title="ByteArrayResource"></a>ByteArrayResource</h4><p>字节数组的Resource实现类。通过给定的数组创建了一个ByteArrayInputStream。它对于从任何给定的字节数组加载内容非常有用，而无需求助于单次使用的InputStreamResource。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[] {<span class="number">127</span>, -<span class="number">128</span>, <span class="number">0</span>, <span class="number">22</span>};</span><br><span class="line"><span class="type">ByteArrayResource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayResource</span>(bytes);</span><br></pre></td></tr></table></figure></div>

<h3 id="ResourceLoader接口"><a href="#ResourceLoader接口" class="headerlink" title="ResourceLoader接口"></a>ResourceLoader接口</h3><p>该接口<code>getResource</code>方法，可用于获得一个<code>Resource</code>实例。<code>ApplicationContext</code>即实现了这个接口。Spring将采用和<code>ApplicationContext</code>相同的策略来访问资源。</p>
<ul>
<li>如果<code>ApplicationContext</code>是<code>FileSystemXmlApplicationContext</code>，<code>resource</code>就是<code>FileSystemResource</code>实例；</li>
<li>如果<code>ApplicationContext</code>是<code>ClassPathXmlApplicationContext</code>，<code>resource</code>就是<code>ClassPathResource</code>实例；</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(MyConfig.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路径方面，默认采用与ApplicationContext相同的资源访问策略</span></span><br><span class="line"><span class="type">Resource</span> <span class="variable">resource</span> <span class="operator">=</span> context.getResource(<span class="string">"test.txt"</span>);</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>当Spring应用需要进行资源访问时，实际上并不需要直接使用<code>Resource</code>实现类，而是调用<code>ResourceLoader</code>实例的<code>getResource()</code>方法来获得资源，<code>ReosurceLoader</code>将会负责选择<code>Reosurce</code>实现类，从而<strong>将应用程序和具体的资源访问策略分离</strong></p>
<p>另外，使用<code>ApplicationContext</code>访问资源时，可通过不同前缀指定强制使用指定的<code>ClassPathResource</code>、<code>FileSystemResource</code>等实现类</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Resource</span> <span class="variable">res</span> <span class="operator">=</span> ctx.getResource(<span class="string">"calsspath:bean.xml"</span>);</span><br><span class="line"><span class="type">Resrouce</span> <span class="variable">res</span> <span class="operator">=</span> ctx.getResource(<span class="string">"file:bean.xml"</span>);</span><br><span class="line"><span class="type">Resource</span> <span class="variable">res</span> <span class="operator">=</span> ctx.getResource(<span class="string">"http://localhost:8080/beans.xml"</span>);</span><br></pre></td></tr></table></figure></div>
</blockquote>
<h3 id="ResourceLoaderAware接口"><a href="#ResourceLoaderAware接口" class="headerlink" title="ResourceLoaderAware接口"></a>ResourceLoaderAware接口</h3><p>该接口有<code>setResourceLoader()</code>方法。该方法将由Spring容器负责调用，会将一个<code>ResourceLoader</code>对象作为该方法的参数传入。</p>
<p>把实现<code>ResourceLoaderAware</code>接口的类放在容器中，Spring容器会将自身作为<code>setResourceLoader()</code>方法的参数传入。（<code>ApplicationContext</code>实现了<code>ResourceLoader</code>接口）</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestBean</span> <span class="keyword">implements</span> <span class="title class_">ResourceLoaderAware</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setResourceLoader</span><span class="params">(<span class="meta">@Nonnull</span> ResourceLoader resourceLoader)</span> {</span><br><span class="line">        <span class="built_in">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ResourceLoader <span class="title function_">getResourceLoader</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.resourceLoader;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">TestBean</span> <span class="variable">bean</span> <span class="operator">=</span> context.getBean(TestBean.class);</span><br><span class="line"><span class="type">ResourceLoader</span> <span class="variable">resourceLoader</span> <span class="operator">=</span> bean.getResourceLoader();</span><br><span class="line"><span class="type">Resource</span> <span class="variable">resource</span> <span class="operator">=</span> resourceLoader.getResource(<span class="string">"/test.txt"</span>);</span><br></pre></td></tr></table></figure></div>

<h3 id="依赖注入Resource"><a href="#依赖注入Resource" class="headerlink" title="依赖注入Resource"></a>依赖注入Resource</h3><p><code>Resource</code>可以以字符串形式进行依赖注入，使用file:，http:，ftp:等前缀强制Spring采用对应的资源访问策略。无前缀，则将采用与<code>ApplicationContext</code>相同的资源访问策略</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResourceBean</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value("classpath:test.txt")</span></span><br><span class="line">    <span class="keyword">private</span> Resource res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRes</span><span class="params">(Resource res)</span> {</span><br><span class="line">        <span class="built_in">this</span>.res = res;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> Resource <span class="title function_">getRes</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parse</span><span class="params">()</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(res.getInputStream().readAllBytes()));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="数据校验Validation"><a href="#数据校验Validation" class="headerlink" title="数据校验Validation"></a>数据校验Validation</h2><p>在开发过程中，我们经常遇到参数需要校验的需求，比如用户的电话，邮箱等等。Spring Validation是对Hibernate Validator的进一步的封装，方便在Spring中使用。</p>
<p>Spring中的校验方式：</p>
<ul>
<li>实现Validator接口，然后在代码中调用这个类</li>
<li>按照Bean Validation方式（即注解方式）</li>
<li>基于方法实现校验</li>
</ul>
<h3 id="Validator接口"><a href="#Validator接口" class="headerlink" title="Validator接口"></a>Validator接口</h3><p>导入依赖</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">hibernate-validator</span><br><span class="line">jakarta.el</span><br></pre></td></tr></table></figure></div>

<p>实体类</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> {</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setter和getter省略</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>创建Validator实现类</p>
<ul>
<li>support方法用来判断支持的类型</li>
<li>validate方法设置检验的逻辑，其中ValidationUtils是Spring封装的校验工具类，帮助快速实现校验</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PeopleValidator</span> <span class="keyword">implements</span> <span class="title class_">Validator</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Class&lt;?&gt; clazz)</span> {</span><br><span class="line">        <span class="keyword">return</span> People.class.equals(clazz);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">validate</span><span class="params">(Object target, Errors errors)</span> {</span><br><span class="line">        ValidationUtils.rejectIfEmpty(errors, <span class="string">"name"</span>, <span class="string">"name.empty"</span>);</span><br><span class="line">        <span class="type">People</span> <span class="variable">p</span> <span class="operator">=</span> (People) target;</span><br><span class="line">        <span class="keyword">if</span> (p.getAge() &lt; <span class="number">0</span>) {</span><br><span class="line">            errors.rejectValue(<span class="string">"age"</span>, <span class="string">"error value &lt; 0"</span>);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (p.getAge() &gt; <span class="number">110</span>) {</span><br><span class="line">            errors.rejectValue(<span class="string">"age"</span>, <span class="string">"error value too old"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>使用校验</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line"><span class="type">People</span> <span class="variable">people</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>();</span><br><span class="line">people.setName(<span class="string">"xdy"</span>);</span><br><span class="line">people.setAge(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建People对象对应的DataBinder</span></span><br><span class="line"><span class="type">DataBinder</span> <span class="variable">binder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataBinder</span>(people);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置校验器</span></span><br><span class="line">binder.setValidator(<span class="keyword">new</span> <span class="title class_">PeopleValidator</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 校验</span></span><br><span class="line">binder.validate();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得结果</span></span><br><span class="line"><span class="type">BindingResult</span> <span class="variable">result</span> <span class="operator">=</span> binder.getBindingResult();</span><br><span class="line">System.out.println(<span class="string">"result.getAllErrors() = "</span> + result.getAllErrors());</span><br></pre></td></tr></table></figure></div>

<h3 id="Bean-Validation注解"><a href="#Bean-Validation注解" class="headerlink" title="Bean Validation注解"></a>Bean Validation注解</h3><p>需要将<code>ValidatorFactory</code>和<code>Validator</code>注入到容器中。Spring中默认有一个实现类<code>LocalValidatorFactoryBean</code>，实现了上述接口。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan("org.example")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    LocalValidatorFactoryBean <span class="title function_">localValidatorFactoryBean</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LocalValidatorFactoryBean</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>实体类使用注解定义校验规则</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">People</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Min(0)</span></span><br><span class="line">    <span class="meta">@Max(120)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// getter和setter省略</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>注解</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>@NotNull</td>
<td>限制必须不为null</td>
</tr>
<tr>
<td>@NotEmpty</td>
<td>只作用于字符串类型，字符串不为空，并且长度不为0</td>
</tr>
<tr>
<td>@NotBlank</td>
<td>只作用于字符串类型，字符串不为空，并且trim()后不为空串</td>
</tr>
<tr>
<td>@DecimalMax(value)</td>
<td>限制必须为一个不大于指定值的数字</td>
</tr>
<tr>
<td>@DecimalMin(value)</td>
<td>限制必须为一个不小于指定值的数字</td>
</tr>
<tr>
<td>@Max(value)</td>
<td>限制必须为一个不大于指定值的数字</td>
</tr>
<tr>
<td>@Min(value)</td>
<td>限制必须为一个不小于指定值的数字</td>
</tr>
<tr>
<td>@Pattern(value)</td>
<td>限制必须符合指定的正则表达式</td>
</tr>
<tr>
<td>@Size(max,min)</td>
<td>限制字符长度必须在min到max之间</td>
</tr>
<tr>
<td>@Email</td>
<td>验证注解的元素值是Email，也可以通过正则表达式和flag指定自定义的email格式</td>
</tr>
</tbody></table>
<p>方法一：使用<code>jakarta.validation.Validator</code>校验</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Validator validator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validatePeople</span><span class="params">(People people)</span> {</span><br><span class="line">    Set&lt;ConstraintViolation&lt;People&gt;&gt; violations = validator.validate(people);</span><br><span class="line">    <span class="keyword">return</span>  violations.isEmpty();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>方法二：使用<code>org.springframework.validation.Validator</code>校验</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Validator validator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validatePeople</span><span class="params">(People people)</span> {</span><br><span class="line">    <span class="comment">// 第二个参数是bean的名字，用于输出错误信息等，不重要</span></span><br><span class="line">    <span class="type">BindException</span> <span class="variable">bindException</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BindException</span>(people, people.getName());</span><br><span class="line">    validator.validate(people, bindException);</span><br><span class="line">    <span class="keyword">return</span> bindException.hasErrors();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="基于方法实现校验"><a href="#基于方法实现校验" class="headerlink" title="基于方法实现校验"></a>基于方法实现校验</h3><p>向容器中配置<code>MethodValidationPostProcessor</code></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan("org.example")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MethodValidationPostProcessor <span class="title function_">validationPostProcessor</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MethodValidationPostProcessor</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>实体类上使用注解定义校验</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">People</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Min(0)</span></span><br><span class="line">    <span class="meta">@Max(120)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// getter和setter省略</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>在需要使用的地方，通过注解标注函数参数（类需要加上<code>@Validated</code>注解）</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PeopleService</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testParams</span><span class="params">(<span class="meta">@NotNull</span> <span class="meta">@Valid</span> People people)</span> {</span><br><span class="line">        <span class="keyword">return</span> people.toString();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>使用时，如果校验不通过，会抛出<code>ConstraintViolationException</code>错误</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> peopleService.testParams(people);</span><br></pre></td></tr></table></figure></div>

<h3 id="实现自定义校验"><a href="#实现自定义校验" class="headerlink" title="实现自定义校验"></a>实现自定义校验</h3><p>编写校验逻辑，实现<code>ConstraintValidator</code>接口</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CannotBlankValidator</span> <span class="keyword">implements</span> <span class="title class_">ConstraintValidator</span>&lt;CannotBlank, String&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">(CannotBlank constraintAnnotation)</span> {</span><br><span class="line">        ConstraintValidator.<span class="built_in">super</span>.initialize(constraintAnnotation);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String value, ConstraintValidatorContext context)</span> {</span><br><span class="line">        <span class="keyword">if</span> (value.contains(<span class="string">" "</span>)) {</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 获取默认提示信息（也即注解中的message()），可以如下操作更改默认提示信息</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">template</span> <span class="operator">=</span> context.getDefaultConstraintMessageTemplate();</span><br><span class="line">            System.out.println(<span class="string">"template = "</span> + template);</span><br><span class="line">            <span class="comment">// 禁用默认提示信息</span></span><br><span class="line">            context.disableDefaultConstraintViolation();</span><br><span class="line">            <span class="comment">// 设置提示语</span></span><br><span class="line">            context.buildConstraintViolationWithTemplate(<span class="string">"can not contains blank"</span>).addConstraintViolation();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>编写自定义注解</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target({ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER})</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Constraint(validatedBy = {CannotBlankValidator.class})</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CannotBlank {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认错误消息</span></span><br><span class="line">    String <span class="title function_">message</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">"不能包含空格"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分组</span></span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> {};</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 负载</span></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Payload</span>&gt;[] payload() <span class="keyword">default</span> {};</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用来解决一个元素上不能标多个@CannotBlank的问题</span></span><br><span class="line">    <span class="meta">@Target({ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE})</span></span><br><span class="line">    <span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line">    <span class="meta">@Documented</span></span><br><span class="line">    <span class="meta">@interface</span> List {</span><br><span class="line">        CannotBlank[] value();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>List的写法让我们可以在参数上标注多个相同注解（此处没什么用，仅作展示）</p>
</blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CannotBlank</span>.List({</span><br><span class="line">    <span class="meta">@CannotBlank()</span>,</span><br><span class="line">    <span class="meta">@CannotBlank()</span></span><br><span class="line">})</span><br><span class="line"><span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring基础</tag>
      </tags>
  </entry>
  <entry>
    <title>手写实现Spring中的IoC</title>
    <url>//post/35893/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>依赖反转（IoC）是Spring中一个非常重要的功能。我们基于java反射机制，来尝试实现一个简单的IoC。</p>
<p>原文地址：<a href="https://xuedongyun.cn/post/35893/">https://xuedongyun.cn/post/35893/</a></p>
<h2 id="回顾反射"><a href="#回顾反射" class="headerlink" title="回顾反射"></a>回顾反射</h2><h4 id="获取Class对象"><a href="#获取Class对象" class="headerlink" title="获取Class对象"></a>获取Class对象</h4><ol>
<li>类名.class</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Car.class;</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>对象.getClass</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> car.getClass();</span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li>Class.forName + 全类名</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">"com.xuedongyun.project.Car"</span>);</span><br></pre></td></tr></table></figure></div>

<h3 id="获取构造方法"><a href="#获取构造方法" class="headerlink" title="获取构造方法"></a>获取构造方法</h3><ol>
<li>获取所有构造方法</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// public</span></span><br><span class="line">Constructor[] constructors = clazz.getConstructors();</span><br><span class="line"></span><br><span class="line"><span class="comment">// public 和 private</span></span><br><span class="line">Constructor[] constructors = clazz.getDeclaredConstructors();</span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li>指定获取有参构造器</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// public</span></span><br><span class="line"><span class="type">Constructor</span> <span class="variable">c</span> <span class="operator">=</span> clazz.getConstructor(String.class, <span class="type">int</span>.class, String.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参构造器不写参数即可</span></span><br><span class="line"><span class="type">Constructor</span> <span class="variable">c</span> <span class="operator">=</span> clazz.getConstructor();</span><br><span class="line"></span><br><span class="line"><span class="comment">// public 和 private</span></span><br><span class="line"><span class="type">Constructor</span> <span class="variable">c</span> <span class="operator">=</span> clazz.getDeclaredConstructor(String.class, <span class="type">int</span>.class, String.class);</span><br></pre></td></tr></table></figure></div>

<ol start="4">
<li>创建对象</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置允许访问</span></span><br><span class="line">constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> constructor.newInstance();</span><br></pre></td></tr></table></figure></div>

<h3 id="获取属性"><a href="#获取属性" class="headerlink" title="获取属性"></a>获取属性</h3><ol>
<li>获取所有属性</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// public</span></span><br><span class="line">Field[] fields = clazz.getFields();</span><br><span class="line"></span><br><span class="line"><span class="comment">// public 和 private</span></span><br><span class="line">Field[] fields = clazz.getDeclaredFields();</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>获取某个属性</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// public</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getField(<span class="string">"name"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// public 和 private</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">"name"</span>);</span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li>修改属性</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置允许访问</span></span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field.set(car,<span class="string">"五菱宏光"</span>);</span><br></pre></td></tr></table></figure></div>

<h3 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h3><ol>
<li>获取所有方法</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// public</span></span><br><span class="line">Method[] methods = clazz.getMethods();</span><br><span class="line"></span><br><span class="line"><span class="comment">// public 和 private</span></span><br><span class="line">Method[] methods = clazz.getDeclaredMethods();</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>获得某一个方法</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// public</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> clazz.getMethod(<span class="string">"func"</span>, String.class, <span class="type">int</span>.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// public 和 private</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">"func"</span>, String.class, <span class="type">int</span>.class);</span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li>执行方法</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置允许访问</span></span><br><span class="line">m.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> m.invoke(car, <span class="string">"test"</span>, <span class="number">123</span>);</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>int.class表示基本数据类型int的Class对象，以便在反射时使用。它等价于Integer.TYPE</p>
</blockquote>
<h2 id="实现Spring的IoC"><a href="#实现Spring的IoC" class="headerlink" title="实现Spring的IoC"></a>实现Spring的IoC</h2><h3 id="创建所需的注解"><a href="#创建所需的注解" class="headerlink" title="创建所需的注解"></a>创建所需的注解</h3><p>Bean注解</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.annotation;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Bean {</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>依赖注入的注解</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.annotation;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Autowired {</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="定义IoC容器"><a href="#定义IoC容器" class="headerlink" title="定义IoC容器"></a>定义IoC容器</h3><p>定义容器接口</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.context;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationContext</span> {</span><br><span class="line">    Object <span class="title function_">getBean</span><span class="params">(Class&lt;?&gt; clazz)</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>定义容器实现类</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.context;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationApplicationContext</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContext</span>{</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Class&lt;?&gt;, Object&gt; beanFactory =  <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AnnotationApplicationContext</span><span class="params">(String basePackage)</span> {</span><br><span class="line">		<span class="comment">// TODO</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(Class&lt;?&gt; clazz)</span> {</span><br><span class="line">        <span class="keyword">return</span> beanFactory.get(clazz);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="扫描Bean功能"><a href="#扫描Bean功能" class="headerlink" title="扫描Bean功能"></a>扫描Bean功能</h3><p>获取<code>packageDirName</code>的绝对路径</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotationApplicationContext</span><span class="params">(String basePackage)</span> {</span><br><span class="line">    <span class="type">String</span> <span class="variable">packageDirName</span> <span class="operator">=</span> basePackage.replace(<span class="string">"."</span>, <span class="string">"\\"</span>);</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        Enumeration&lt;URL&gt; dirs = Thread.currentThread().getContextClassLoader().getResources(packageDirName);</span><br><span class="line">        <span class="keyword">while</span> (dirs.hasMoreElements()) {</span><br><span class="line">            <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> dirs.nextElement();</span><br><span class="line">            <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> URLDecoder.decode(url.getFile(), StandardCharsets.UTF_8);</span><br><span class="line">            <span class="type">String</span> <span class="variable">rootPath</span> <span class="operator">=</span> filePath.substring(<span class="number">0</span>, filePath.length() - packageDirName.length());</span><br><span class="line">            loadBean(<span class="keyword">new</span> <span class="title class_">File</span>(rootPath));</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>遍历所有.class文件，若标注有<code>@Bean</code>注解，则将其实例化</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadBean</span><span class="params">(File fileParent, String rootPath)</span> {</span><br><span class="line">    <span class="comment">// 遍历所有子文件</span></span><br><span class="line">    <span class="keyword">if</span> (fileParent.isDirectory()) {</span><br><span class="line">        File[] childFiles = fileParent.listFiles();</span><br><span class="line">        <span class="keyword">if</span> (childFiles == <span class="literal">null</span> || childFiles.length == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 子文件若为文件夹，递归访问</span></span><br><span class="line">        <span class="keyword">for</span> (File childFile : childFiles) {</span><br><span class="line">            <span class="keyword">if</span> (childFile.isDirectory()) {</span><br><span class="line">                loadBean(childFile, rootPath);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 获得文件相对路径</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">pathWithClass</span> <span class="operator">=</span> childFile.getAbsolutePath().substring(rootPath.length() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (!pathWithClass.contains(<span class="string">".class"</span>)) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">// 对所有.class文件，获得其类路径</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">fullName</span> <span class="operator">=</span> pathWithClass.replace(<span class="string">"\\"</span>, <span class="string">"."</span>).replace(<span class="string">".class"</span>, <span class="string">""</span>);</span><br><span class="line">                Class&lt;?&gt; clazz = Class.forName(fullName);</span><br><span class="line">                <span class="keyword">if</span> (clazz.isAnnotation() || clazz.isInterface()) {</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 如果标注了@Bean注解，放入容器中</span></span><br><span class="line">                <span class="type">Bean</span> <span class="variable">annotation</span> <span class="operator">=</span> clazz.getAnnotation(Bean.class);</span><br><span class="line">                <span class="keyword">if</span> (annotation != <span class="literal">null</span>) {</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> clazz.getConstructor().newInstance();</span><br><span class="line">                    <span class="comment">// 如果实现了接口，以接口为key</span></span><br><span class="line">                    <span class="keyword">if</span> (clazz.getInterfaces().length &gt; <span class="number">0</span>) {</span><br><span class="line">                        beanFactory.put(clazz.getInterfaces()[<span class="number">0</span>], instance);</span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                        beanFactory.put(clazz, instance);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotationApplicationContext</span><span class="params">(String basePackage)</span> {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 所有Bean放入容器后，执行依赖注入</span></span><br><span class="line">    loadDi();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>实现依赖注入</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadDi</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : beanFactory.entrySet()) {</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">        Class&lt;?&gt; clazz = obj.getClass();</span><br><span class="line">        Field[] fields = clazz.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) {</span><br><span class="line">            <span class="type">Autowired</span> <span class="variable">annotation</span> <span class="operator">=</span> field.getAnnotation(Autowired.class);</span><br><span class="line">            <span class="keyword">if</span> (annotation != <span class="literal">null</span>) {</span><br><span class="line">                field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    field.set(obj, beanFactory.get(field.getType()));</span><br><span class="line">                } <span class="keyword">catch</span> (IllegalAccessException e) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.test;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pet</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">"dodo"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Pet{"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'}'</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.test;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Pet pet;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">"xdy"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User{"</span> +</span><br><span class="line">                <span class="string">"pet="</span> + pet +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'}'</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationApplicationContext</span>(<span class="string">"org.example"</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> context.getBean(User.class);</span><br><span class="line">        System.out.println(<span class="string">"bean = "</span> + bean);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring基础</tag>
      </tags>
  </entry>
  <entry>
    <title>脏读，不可重复读，幻读以及四种隔离级别</title>
    <url>//post/64889/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在事务中，我们常听到脏读，不可重复读，幻读这三种概念。本文将根据例子来讨论这三种问题。同时，再依次谈谈解决上述问题的三种隔离级别。<br>原文地址：<a href="https://xuedongyun.cn/post/64889/">https://xuedongyun.cn/post/64889/</a></p>
<h2 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h2><h3 id="脏读的定义"><a href="#脏读的定义" class="headerlink" title="脏读的定义"></a>脏读的定义</h3><p>脏读，又称为<strong>“读未提交”</strong>，就是事务A读取到了事务B<strong>已修改但未提交</strong>的数据</p>
<p>我们来看一个例子：假设age原本是13。事务B修改age后，被事务A读到了，但是事务B最后回滚了。也就是说，事务A读到了事务B修改但未提交的数据。</p>
<table>
<thead>
<tr>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody><tr>
<td>开始事务</td>
<td>开始事务</td>
</tr>
<tr>
<td></td>
<td>修改age（从13改为23）</td>
</tr>
<tr>
<td>查询age（age=23）</td>
<td></td>
</tr>
<tr>
<td>commit</td>
<td>rollback（回滚，age实际上还是13）</td>
</tr>
</tbody></table>
<h3 id="解决脏读的隔离级别"><a href="#解决脏读的隔离级别" class="headerlink" title="解决脏读的隔离级别"></a>解决脏读的隔离级别</h3><p>我们可以使用<code>READ_COMMITTED</code>这个隔离级别来解决脏读的问题。<code>READ_COMMITTED</code>要求事务A只能读取其他事务<strong>已提交的修改</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(isolation = Isolation.READ_COMMITTED)</span></span><br></pre></td></tr></table></figure></div>

<h2 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h2><h3 id="不可重复读的定义"><a href="#不可重复读的定义" class="headerlink" title="不可重复读的定义"></a>不可重复读的定义</h3><p>不可重复读，又称为<strong>“读已提交”</strong>，就是事务A中多次读取数据，读取到的结果不一样</p>
<p>我们来看一个例子：在事务A中，先查询了一次，age=13。此时事务B修改并提交。在事务A中，又查询了一次，此时事务B已提交，所以能成功读取，但此时age=23，已经和之前不一致了</p>
<table>
<thead>
<tr>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody><tr>
<td>开始事务</td>
<td>开始事务</td>
</tr>
<tr>
<td>查询age（age=13）</td>
<td></td>
</tr>
<tr>
<td></td>
<td>修改age（从13改为23）</td>
</tr>
<tr>
<td></td>
<td>commit</td>
</tr>
<tr>
<td>查询age（age=23）</td>
<td></td>
</tr>
<tr>
<td>commit</td>
<td></td>
</tr>
</tbody></table>
<h3 id="解决不可重复读的隔离级别"><a href="#解决不可重复读的隔离级别" class="headerlink" title="解决不可重复读的隔离级别"></a>解决不可重复读的隔离级别</h3><p>我们可以使用<code>REPEATABLE_READ</code>这个隔离级别来解决脏读的问题。<code>REPEATABLE_READ</code>要求事务A执行时，其他事务<strong>禁止对这个字段进行修改</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(isolation = Isolation.REPEATABLE_READ)</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>这也是MySQL的默认隔离级别</p>
</blockquote>
<h2 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h2><h3 id="幻读的定义"><a href="#幻读的定义" class="headerlink" title="幻读的定义"></a>幻读的定义</h3><p>幻读，就是事务A前后两次读取中，事务B插入或者删除数据，从而发生的一种类似幻觉的现象</p>
<p>我们来看一个例子：事务A前后两次查询id=1001的用户，第一次找不到，第二次又找到了。这是因为在两次查询之间，事务B插入了新的数据。（<code>REPEATABLE_READ</code>只限制了不能修改，没有限制增删）</p>
<table>
<thead>
<tr>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody><tr>
<td>开始事务</td>
<td>开始事务</td>
</tr>
<tr>
<td>查询id=1001的用户，发现没找到</td>
<td></td>
</tr>
<tr>
<td></td>
<td>插入id=1001的用户</td>
</tr>
<tr>
<td></td>
<td>commit</td>
</tr>
<tr>
<td>查询id=1001的用户，发现又能找到了</td>
<td></td>
</tr>
<tr>
<td>commit</td>
<td></td>
</tr>
</tbody></table>
<h3 id="解决幻读的隔离级别"><a href="#解决幻读的隔离级别" class="headerlink" title="解决幻读的隔离级别"></a>解决幻读的隔离级别</h3><p>我们可以使用<code>SERIALIZABLE</code>这个隔离级别来解决脏读的问题。<code>SERIALIZABLE</code>要求事务A执行时，其他事务<strong>禁止对这个表进行添加、更新、删除操作</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(isolation = Isolation.SERIALIZABLE)</span></span><br></pre></td></tr></table></figure></div>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="三种问题"><a href="#三种问题" class="headerlink" title="三种问题"></a>三种问题</h3><ul>
<li>脏读：读到了已修改但未提交的数据</li>
<li>不可重复读：前后两次读取的结果不一样</li>
<li>幻读：之前读取存在，再读发现不存在了（或者反之亦然）</li>
</ul>
<h3 id="四种隔离级别"><a href="#四种隔离级别" class="headerlink" title="四种隔离级别"></a>四种隔离级别</h3><ul>
<li><code>READ UNCOMMIT</code>：最低的级别，能读到未提交的数据</li>
<li><code>READ COMMIT</code>：只能读修改已提交的数据<ul>
<li>解决：脏读</li>
</ul>
</li>
<li><code>REPEATABLE READ</code>：读取期间，其他事务不能对该字段进行修改<ul>
<li>解决：脏读，不可重复读</li>
</ul>
</li>
<li><code>SERIALIZABLE</code>：读取期间，其他事务不能对这个表进行增删改<ul>
<li>解决：脏读，不可重复读，幻读</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java设计模式系列（1）：单例模式</title>
    <url>//post/25714/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种模式涉及单一的类，需确保代码中最多只有一个该类对象被创建。</p>
<p>原文地址：<a href="https://xuedongyun.cn/post/25714/">https://xuedongyun.cn/post/25714/</a></p>
<h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><p>饿汉式，在一开始就创建对象</p>
<h3 id="方法一：静态成员变量"><a href="#方法一：静态成员变量" class="headerlink" title="方法一：静态成员变量"></a>方法一：静态成员变量</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> {</span><br><span class="line">    <span class="comment">// 私有化构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> {}</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 成员变量位置创建对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态方法提供对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="方法二：静态代码块"><a href="#方法二：静态代码块" class="headerlink" title="方法二：静态代码块"></a>方法二：静态代码块</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> {}</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 使用静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><h3 id="方式一：线程不安全"><a href="#方式一：线程不安全" class="headerlink" title="方式一：线程不安全"></a>方式一：线程不安全</h3><p>第一次使用时才创建对象</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线程不安全</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> {}</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) {</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="方式二：线程安全"><a href="#方式二：线程安全" class="headerlink" title="方式二：线程安全"></a>方式二：线程安全</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线程安全，使用synchronized关键词</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> {}</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) {</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="方式三：双重检查锁"><a href="#方式三：双重检查锁" class="headerlink" title="方式三：双重检查锁"></a>方式三：双重检查锁</h3><p>因为绝大多数操作都是读操作，给方法加锁影响性能，可以改为：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> {}</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) {</span><br><span class="line">            <span class="comment">// 写操作时，给类加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) {</span><br><span class="line">                <span class="comment">// 抢到锁的时候还要判断一下是否已经被竞争者赋过值了</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) {</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>上述代码看起来很完美，但实际上可能会有空指针问题，原因是JVM在实例化对象的时候会进行指令重排</p>
<p>在java中，创建对象实际上不是不是原子操作，而是有三步：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 分配对象的内存空间</span></span><br><span class="line">memory = <span class="built_in">allocate</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 初始化对象</span></span><br><span class="line"><span class="built_in">ctorInstance</span>(memory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 设置instance指向刚分配的内存地址</span></span><br><span class="line">instance = memory;</span><br></pre></td></tr></table></figure></div>

<p>指令重排后，就可能变成：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 分配对象的内存空间</span></span><br><span class="line">memory = <span class="built_in">allocate</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 设置instance指向刚分配的内存地址</span></span><br><span class="line">instance = memory;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 初始化对象</span></span><br><span class="line"><span class="built_in">ctorInstance</span>(memory);</span><br></pre></td></tr></table></figure></div>

<p>上述懒汉式代码中，很有可能：某个线程获取了非空instance，但是此时还没来得及初始化。我们可以使用volatile关键词来解决这个问题</p>
<p>volatile 关键字有如下特征：</p>
<ul>
<li>可见性：当一个线程修改了这个变量的值，volatile保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。但普通变量做不到这点，普通变量的值在线程间传递均需要通过主内存</li>
<li>禁止指令重排序优化：被volatile 修饰的变量，不会被JVM指令重排</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> {}</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 使用volatile关键词解决指令重排的问题</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) {</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>) {</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="方式四：静态内部类"><a href="#方式四：静态内部类" class="headerlink" title="方式四：静态内部类"></a>方式四：静态内部类</h3><p>首次使用时，静态内部类才会被加载，进而初始化INSTANCE。这是开源项目中一种较为常见的单例模式</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> {}</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> {</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="方法五：枚举方式"><a href="#方法五：枚举方式" class="headerlink" title="方法五：枚举方式"></a>方法五：枚举方式</h3><p>这是一种极力推荐的单例实现模式，因为枚举类是线程安全的，且只会装载一次。枚举类无法使用反射创建，因此是唯一不会被破坏的单例模式。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> {</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><p>序列化和反射能破坏单例模式（枚举方法除外）</p>
<h3 id="序列化破坏单例模式"><a href="#序列化破坏单例模式" class="headerlink" title="序列化破坏单例模式"></a>序列化破坏单例模式</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化后存入文件</span></span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">"C:/test.txt"</span>));</span><br><span class="line">oos.writeObject(instance);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从文件中读取</span></span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">ois1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">"C:/test.txt"</span>));</span><br><span class="line"><span class="type">Singleton</span> <span class="variable">singleton1</span> <span class="operator">=</span> (Singleton) ois1.readObject();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从文件中读取</span></span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">ois2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">"C:/test.txt"</span>));</span><br><span class="line"><span class="type">Singleton</span> <span class="variable">singleton2</span> <span class="operator">=</span> (Singleton) ois2.readObject();</span><br><span class="line"></span><br><span class="line"><span class="comment">// singleton1和singleton2是两个对象，单例模式被破坏</span></span><br></pre></td></tr></table></figure></div>

<h3 id="反射破坏单例模式"><a href="#反射破坏单例模式" class="headerlink" title="反射破坏单例模式"></a>反射破坏单例模式</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;Singleton&gt; clazz = Singleton.class;</span><br><span class="line">Constructor&lt;Singleton&gt; constructor = clazz.getDeclaredConstructor();</span><br><span class="line">constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Singleton</span> <span class="variable">singleton1</span> <span class="operator">=</span> constructor.newInstance();</span><br><span class="line"><span class="type">Singleton</span> <span class="variable">singleton2</span> <span class="operator">=</span> constructor.newInstance();</span><br></pre></td></tr></table></figure></div>

<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>解决序列化破坏</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> {}</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> {</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解决序列化，反序列化破解单例模式</span></span><br><span class="line">    <span class="keyword">private</span> Object <span class="title function_">readResolve</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>原理：可以看看<code>ObjectInputStream.readObject</code>的源码：</p>
<p><code>readObject</code>-&gt;<code>readObject0</code>-&gt;<code>readOrdinaryObject</code>-&gt;如果有<code>readResolve()</code>方法，在反序列化的时候会调用该方法返回对象</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj != <span class="literal">null</span> &amp;&amp; handles.lookupException(passHandle) == <span class="literal">null</span> &amp;&amp; desc.hasReadResolveMethod()) {</span><br><span class="line">	<span class="type">Object</span> <span class="variable">rep</span> <span class="operator">=</span> desc.invokeReadResolve(obj);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
</blockquote>
<p>解决反射破坏</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> {</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 被反射调用时，直接抛出错误</span></span><br><span class="line">        <span class="keyword">if</span>(instance != <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="JDK源码-Runtime类"><a href="#JDK源码-Runtime类" class="headerlink" title="JDK源码-Runtime类"></a>JDK源码-Runtime类</h2><p>Runtime类使用饿汉式（静态变量）实现</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Runtime</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Runtime</span> <span class="variable">currentRuntime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runtime</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Runtime <span class="title function_">getRuntime</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> currentRuntime;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>Runtime类的使用</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚拟机内存总量</span></span><br><span class="line"><span class="type">long</span> <span class="variable">totalMemory</span> <span class="operator">=</span> runtime.totalMemory();</span><br><span class="line">System.out.println(<span class="string">"totalMemory = "</span> + totalMemory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚拟机试图使用的最大内存量</span></span><br><span class="line"><span class="type">long</span> <span class="variable">maxMemory</span> <span class="operator">=</span> runtime.maxMemory();</span><br><span class="line">System.out.println(<span class="string">"maxMemory = "</span> + maxMemory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新的进程，执行指定的字符串命令，返回进程对象</span></span><br><span class="line"><span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> runtime.exec(<span class="string">"ipconfig"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过输入流，获取命令执行后的结果</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> process.getInputStream();</span><br><span class="line"><span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> is.read(bytes);</span><br><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span>, i, <span class="string">"gbk"</span>));</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java设计模式系列</tag>
      </tags>
  </entry>
  <entry>
    <title>Java设计模式系列（2）：工厂模式</title>
    <url>//post/33663/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>正常情况下，我们如果有<code>PhoneStore</code>类，其中需要有<code>orderPhone(String type)</code>方法，为用户提供不同的<code>Phone</code>。此时代码耦合十分严重，如果我们要更换或增加对象，都需要改new对象的地方。我们其实可以使用工厂类来生成对象，<code>PhoneStore</code>只需要和工厂打交道即可，实现最终目的：<strong>解耦</strong></p>
<p>原文地址：<a href="https://xuedongyun.cn/post/33663/">https://xuedongyun.cn/post/33663/</a></p>
<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>简单工厂包含：</p>
<ul>
<li>抽象产品（<code>Phone</code>）</li>
<li>具体产品（<code>XiaomiPhone</code>，<code>HuaweiPhone</code>）</li>
<li>具体工厂（<code>PhoneFactory</code>）</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhoneFactory</span> {</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 这里方法也可以设置为static，即“静态工厂模式”</span></span><br><span class="line">    <span class="keyword">public</span> Phone <span class="title function_">createPhone</span><span class="params">(String type)</span> {</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (type.equals(<span class="string">"xiaomi"</span>)) {</span><br><span class="line">            phone = <span class="keyword">new</span> <span class="title class_">XiaomiPhone</span>();</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"huawei"</span>)) {</span><br><span class="line">            phone = <span class="keyword">new</span> <span class="title class_">HuaweiPhone</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> phone;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>此时，<code>PhoneStore</code>需要手机时，只需要从<code>PhoneFactory</code>中获取即可</p>
<p>问题：要增加新的手机，就需要修改<code>PhoneFactory</code>的代码，违背开闭原则</p>
<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>工厂方法模式包含：</p>
<ul>
<li>抽象产品（<code>Phone</code>）</li>
<li>具体产品（<code>XiaomiPhone</code>，<code>HuaweiPhone</code>）</li>
<li>抽象工厂（<code>PhoneFactory</code>）</li>
<li>具体工厂（<code>XiaomiPhoneFactory</code>，<code>HuaweiPhoneFactory</code>）</li>
</ul>
<p>抽象工厂</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PhoneFactory</span> {</span><br><span class="line">    </span><br><span class="line">    Phone <span class="title function_">createPhone</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>具体工厂</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XiaomiPhoneFactory</span> implement PhoneFactory {</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> Phone <span class="title function_">createPhone</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">XiaomiPhoneFactory</span>();</span><br><span class="line">    } </span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p><code>PhoneStore</code>中具体使用</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhoneStore</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PhoneFactory factory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PhoneStore</span><span class="params">(PhoneFactory factory)</span> {</span><br><span class="line">        <span class="built_in">this</span>.factory = factory;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Phone <span class="title function_">orderPhone</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> factory.createPhone();</span><br><span class="line">        <span class="keyword">return</span> phone;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>此时，当增加手机时，无需修改<code>PhoneFactory</code>，只需要增加新的接口实现类即可</p>
<p>问题：每增加一种手机，就要创建一个新的对应工厂类，增加了系统复杂度</p>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/06/21/qpUPvj8JLZtGilF.png" alt="image-20200401214509176" style="zoom: 50%;">

<ul>
<li><p>工厂方法模式：只能生产一个级别的产品</p>
</li>
<li><p>抽象工厂模式：生产多个级别的产品</p>
</li>
</ul>
<p>现在工厂可以生产同一产品族的产品，比如手机和电脑。小米和华为都会生产自己的手机和电脑。现在关系如图：</p>
<pre class="mermaid">classDiagram

class XiaomiFactory {
    + createPhone(): Phone
    + createComputer(): Computer
}

class HuaweiFactory {
    + createPhone(): Phone
    + createComputer(): Computer
}
    
Phone &lt;|-- XiaomiPhone
Phone &lt;|-- HuaweiPhone

Computer &lt;|-- XiaomiComputer
Computer &lt;|-- HuaweiComputer

XiaomiPhone &lt;.. XiaomiFactory
XiaomiComputer &lt;.. XiaomiFactory

HuaweiPhone &lt;.. HuaweiFactory
HuaweiComputer &lt;.. HuaweiFactory

XiaomiFactory ..|&gt; DeviceFacotry
HuaweiFactory ..|&gt; DeviceFacotry</pre>

<p>抽象工厂</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DeviceFactory</span> {</span><br><span class="line">    </span><br><span class="line">    Phone <span class="title function_">createPhone</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    Computer <span class="title function_">createComputer</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>具体工厂</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">xiaomiFactory</span> implement DeviceFactory {</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Phone <span class="title function_">createPhone</span><span class="params">()</span> {</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">XiaomiPhone</span>();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Computer <span class="title function_">createComputer</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">XiaomiComputer</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>现在，当一个产品族种的多个对象被设计成一起工作时，能保证客户端只使用同一个产品族种的对象</p>
<p>问题：产品族中需要增加新的产品时，所有工厂类都需要修改</p>
<h2 id="JDK源码-Collection-iterator方法"><a href="#JDK源码-Collection-iterator方法" class="headerlink" title="JDK源码-Collection.iterator方法"></a>JDK源码-Collection.iterator方法</h2><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) {</span><br><span class="line">    System.out.println(<span class="string">"it.next() = "</span> + it.next());</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>获取迭代器时，使用了工厂方法模式，类图如下</p>
<pre class="mermaid">classDiagram
class Iterator {
    &lt;<interface>&gt;
}
class Collection {
    &lt;<interface>&gt;
    + iterator(): Iterator
}
class ArrayList {
    + iterator(): Iterator
}

Collection &lt;|.. ArrayList
Iterator &lt;|.. ArrayList_Itr
Iterator &lt;.. Collection
ArrayList_Itr &lt;.. ArrayList

Factory &lt;|.. EntityFactory
Product &lt;|.. EntityProduct
Product &lt;.. Factory
EntityProduct &lt;.. EntityFactory</interface></interface></pre>

<p>抽象产品：<code>Iterator</code></p>
<p>具体产品：<code>ArrayList.Itr</code></p>
<p>抽象工厂：<code>Collection</code></p>
<p>具体工厂：<code>ArrayList</code></p>
]]></content>
      <categories>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java设计模式系列</tag>
      </tags>
  </entry>
  <entry>
    <title>Java设计模式系列（3）：原型模式</title>
    <url>//post/12331/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>原型模式：用已经创建的实例作为原型，通过复制该原型的值来创建一个相同的新对象</p>
<p>原文地址：<a href="https://xuedongyun.cn/post/12331/">https://xuedongyun.cn/post/12331/</a></p>
<h2 id="浅克隆"><a href="#浅克隆" class="headerlink" title="浅克隆"></a>浅克隆</h2><p>原型模式包含以下角色：</p>
<ul>
<li>抽象原型类</li>
<li>具体原型类</li>
<li>访问类（调用clone方法）</li>
</ul>
<pre class="mermaid">classDiagram
class Prototype {
    &lt;<interface>&gt;
    + clone(): Prototype
}

class Realizetype {
    + clone(): Prototype
}

Prototype &lt;|.. Realizetype</interface></pre>

<p>Object类中实现了一个protected修饰的naive方法<code>clone()</code>。我们必须实现<code>Cloneable</code>接口并重写<code>clone()</code>（其实就是调用父类方法），才能调用这个方法</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> User <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException {</span><br><span class="line">        <span class="keyword">return</span> (User) <span class="built_in">super</span>.clone();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="深克隆"><a href="#深克隆" class="headerlink" title="深克隆"></a>深克隆</h2><p>对象实现<code>Serializable</code>接口，使用序列化的方式存到文档中，再读出来</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象写出到文件</span></span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">"c://test.txt"</span>));</span><br><span class="line">oos.writeObject(user);</span><br><span class="line">oos.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从文件中写入</span></span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">"c://test.txt"</span>));</span><br><span class="line"><span class="type">User</span> <span class="variable">clone</span> <span class="operator">=</span> (User) ois.readObject();</span><br><span class="line">ois.close();</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java设计模式系列</tag>
      </tags>
  </entry>
  <entry>
    <title>Java设计模式系列（4）：建造者模式</title>
    <url>//post/24102/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>构造者模式：使用多个简单的对象，逐渐构建成一个复杂的对象。构造者模式属于创建型模式，它提供了一种创建对象的最佳方式</p>
<p>原文地址：<a href="https://xuedongyun.cn/post/24102/">https://xuedongyun.cn/post/24102/</a></p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>构造者模式包含以下角色：</p>
<ul>
<li>抽象构造者（Builder）</li>
<li>具体构造者（ConcreteBuilder）</li>
<li>产品类（Product）</li>
<li>指挥者类（Director）</li>
</ul>
<p>产品类：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Phone</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String cpu;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略getter和setter</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>抽象构造者：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Builder</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildCpu</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Phone <span class="title function_">createPhone</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>具体构造者：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplePhoneBuilder</span> <span class="keyword">extends</span> <span class="title class_">Builder</span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildName</span><span class="params">()</span> {</span><br><span class="line">        phone.setName(<span class="string">"iphone"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildCpu</span><span class="params">()</span> {</span><br><span class="line">        phone.setCpu(<span class="string">"A14"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Phone <span class="title function_">createPhone</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> phone;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>指挥者：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Director</span> {</span><br><span class="line">    <span class="keyword">private</span> Builder builder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Director</span><span class="params">(Builder builder)</span> {</span><br><span class="line">        <span class="built_in">this</span>.builder = builder;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 核心，使用不同builder来创建对象</span></span><br><span class="line">    <span class="keyword">public</span> Phone <span class="title function_">construct</span><span class="params">()</span> {</span><br><span class="line">        builder.buildName();</span><br><span class="line">        builder.buildCpu();</span><br><span class="line">        <span class="keyword">return</span> builder.createPhone();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>使用：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AppleBuilder</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">Director</span> <span class="variable">director</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Director</span>(builder);</span><br><span class="line"></span><br><span class="line"><span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> director.construct();</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>有时，可以把<code>Director</code>和<code>Builder</code>合二为一，简化系统结构。不过如果<code>construct()</code>方法过于复杂，还是建议封装到<code>Director</code>中</p>
</blockquote>
<p>将<code>Director</code>和<code>Builder</code>合二为一</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> abstruct <span class="keyword">class</span> <span class="title class_">Builder</span> {</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildName</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildCpu</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Phone <span class="title function_">createPhone</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Phone <span class="title function_">construct</span><span class="params">()</span> {</span><br><span class="line">		<span class="built_in">this</span>.buildName();</span><br><span class="line">        <span class="built_in">this</span>.buildCpu();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.phone;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="模式扩展"><a href="#模式扩展" class="headerlink" title="模式扩展"></a>模式扩展</h2><p>建造者模式还有一个用途。如果类构造器需要传入很多参数时，可读性会很差，而且容易出错。此时就可以使用建造者模式重构。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Computer</span><span class="params">(String cpu, String gpu, String motherboard)</span> {</span><br><span class="line">        <span class="built_in">this</span>.cpu = cpu;</span><br><span class="line">        <span class="built_in">this</span>.gpu = gpu;</span><br><span class="line">        <span class="built_in">this</span>.motherboard = motherboard;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String cpu;</span><br><span class="line">    <span class="keyword">private</span> String gpu;</span><br><span class="line">    <span class="keyword">private</span> String motherboard;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Builder</span> {</span><br><span class="line">        <span class="keyword">private</span> String cpu;</span><br><span class="line">        <span class="keyword">private</span> String gpu;</span><br><span class="line">        <span class="keyword">private</span> String motherboard;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Builder</span><span class="params">()</span> {}</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">cpu</span><span class="params">(String cpu)</span> {</span><br><span class="line">            <span class="built_in">this</span>.cpu = cpu;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">gpu</span><span class="params">(String gpu)</span> {</span><br><span class="line">            <span class="built_in">this</span>.gpu = gpu;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">motherBoard</span><span class="params">(String motherboard)</span> {</span><br><span class="line">            <span class="built_in">this</span>.motherboard = motherboard;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Computer <span class="title function_">build</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Computer</span>(cpu, gpu, motherboard);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>使用</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>.Builder()</span><br><span class="line">                            .cpu(<span class="string">"i9"</span>)</span><br><span class="line">                            .gpu(<span class="string">"3060"</span>)</span><br><span class="line">                            .motherBoard(<span class="string">"asus"</span>)</span><br><span class="line">                            .build();</span><br></pre></td></tr></table></figure></div>

<h2 id="与工厂模式对比"><a href="#与工厂模式对比" class="headerlink" title="与工厂模式对比"></a>与工厂模式对比</h2><h3 id="工厂方法模式-VS-建造者模式"><a href="#工厂方法模式-VS-建造者模式" class="headerlink" title="工厂方法模式 VS 建造者模式"></a>工厂方法模式 VS 建造者模式</h3><ul>
<li>工厂方法模式：注重对整体的创建方式</li>
<li>建造者模式：注重的是部件的创建过程</li>
</ul>
<h3 id="抽象工厂模式-VS-建造者模式"><a href="#抽象工厂模式-VS-建造者模式" class="headerlink" title="抽象工厂模式 VS 建造者模式"></a>抽象工厂模式 VS 建造者模式</h3><ul>
<li><p>抽象工厂模式：实现对产品家族的创建。不关心构建的过程，只关心什么产品由什么工厂生产</p>
</li>
<li><p>建造者模式：要求按照指定的蓝图建造产品，主要目的是通过组装零配件产生新产品</p>
</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java设计模式系列</tag>
      </tags>
  </entry>
  <entry>
    <title>Java设计模式系列（5）：代理模式</title>
    <url>//post/23348/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有时，我们想要给某对象提供一个代理对象，以控制对该对象的访问。代理对象应该作为访问对象和目标对象之间的中介。<br>Java中的代理可以分为静态代理和动态代理。静态代理类在编译期间就生成，动态代理类在Java运行时动态产生。动态代理又分为JDK代理和cglib代理两种。</p>
<p>原文地址：<a href="https://xuedongyun.cn/post/23348/">https://xuedongyun.cn/post/23348/</a></p>
<h2 id="代理模式的角色"><a href="#代理模式的角色" class="headerlink" title="代理模式的角色"></a>代理模式的角色</h2><p>代理（Proxy）模式分为三种角色：</p>
<ul>
<li>抽象主题类（Subject）：声明需要实现的业务方法</li>
<li>真实主题类（Real Subject）：实现抽象主题类。是代理对象所代表的真实对象</li>
<li>代理类（Proxy）：实现抽象主题类。内部有对真实主题类的引用</li>
</ul>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>抽象主题类（Subject）</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SellTickets</span> {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>真实主题类（Real Subject）</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrainStation</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"车站买票"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>代理类（Proxy）</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyPoint</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SellTickets target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProxyPoint</span><span class="params">(SellTickets target)</span> {</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 代理类作为中介，调用引用对象的放，实现代理</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"before"</span>);</span><br><span class="line">        target.sell();</span><br><span class="line">        System.out.println(<span class="string">"after"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>使用代理</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">TrainStation</span> <span class="variable">trainStation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line"><span class="type">ProxyPoint</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyPoint</span>(trainStation);</span><br><span class="line">proxy.sell();</span><br></pre></td></tr></table></figure></div>

<h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><p>Java中提供了一个动态代理类<code>Proxy</code>，其中有一个<code>newProxyInstance</code>方法用来获取代理对象</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 工厂类，用来生产代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">TrainStation</span> <span class="variable">station</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProxyFactory</span><span class="params">(TrainStation station)</span> {</span><br><span class="line">        <span class="built_in">this</span>.station = station;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SellTickets <span class="title function_">getProxyObject</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">SellTickets</span> <span class="variable">proxyInstance</span> <span class="operator">=</span> (SellTickets) Proxy.newProxyInstance(station.getClass().getClassLoader(),</span><br><span class="line">                station.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() {</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    	参数说明</span></span><br><span class="line"><span class="comment">                    	proxy: 代理对象本身（不用this，是因为此处this指向的是InvocationHandler匿名类）</span></span><br><span class="line"><span class="comment">                    	method: 接口中的方法的Method实例</span></span><br><span class="line"><span class="comment">                    	args: 调用方法时传递的实际参数</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable {</span><br><span class="line">                        System.out.println(<span class="string">"before"</span>);</span><br><span class="line">                        <span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span> method.invoke(station, args);</span><br><span class="line">                        System.out.println(<span class="string">"after"</span>);</span><br><span class="line">                        <span class="keyword">return</span> res;</span><br><span class="line">                    }</span><br><span class="line">                });</span><br><span class="line">        <span class="keyword">return</span> proxyInstance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>使用代理</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">TrainStation</span> <span class="variable">trainStation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">ProxyFactory</span> <span class="variable">proxyFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>(trainStation);</span><br><span class="line"><span class="type">SellTickets</span> <span class="variable">proxy</span> <span class="operator">=</span> proxyFactory.getProxyObject();</span><br><span class="line"></span><br><span class="line">proxy.sell();</span><br></pre></td></tr></table></figure></div>

<p>原理分析如下：</p>
<p>Java创建了<code>com.sun.proxy.$Proxy0</code>类作为代理类，是程序在运行中动态的在内存中创建的，我们摘取重点代码来查看</p>
<p>执行时流程如下：</p>
<ol>
<li>测试时，调用代理对象的sell方法</li>
<li>代理对象（$Proxy0）中的sell方法，调用<code>invocationHandler</code>实现类的sell方法（此时传入了this，也即前面提到的proxy参数）</li>
<li><code>invocationHandler</code>实现类中，使用反射执行了真实对象的sell方法</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 程序运行过程中动态生成的代理类（部分）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">extends</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler invocationHandler) {</span><br><span class="line">        <span class="built_in">super</span>(invocationHandler);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        m3 = Class.forName(<span class="string">"com.itheima.proxy.dynamic.jdk.SellTickets"</span>).getMethod(<span class="string">"sell"</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> {</span><br><span class="line">        <span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m3, <span class="literal">null</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h2><p>JDK动态代理要求被代理的对象必须实现接口。CGLIB是一个功能强大的第三方包，能为没有实现接口的类提供代理</p>
<p>需要先引入依赖</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cglib&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;cglib&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">3.3</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>截至目前为止，官方的CGLIB任然没有更新，无法在JDK17下使用。可以使用Spring中官方修改过的CGLIB来代替</p>
</blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TrainStation station;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProxyFactory</span><span class="params">(TrainStation station)</span> {</span><br><span class="line">        <span class="built_in">this</span>.station = station;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TrainStation <span class="title function_">getProxyObject</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 创建Enhancer对象，类似于JDK动态代理的Proxy类，下一步就是设置几个参数</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">// 设置父类的字节码对象</span></span><br><span class="line">        enhancer.setSuperclass(station.getClass());</span><br><span class="line">        <span class="comment">// 设置回调函数</span></span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">// 返回代理对象</span></span><br><span class="line">        <span class="keyword">return</span> (TrainStation) enhancer.create();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		参数说明</span></span><br><span class="line"><span class="comment">		Object o: 代理对象</span></span><br><span class="line"><span class="comment">		method: 真实对象中的方法</span></span><br><span class="line"><span class="comment">		objects: 实际参数</span></span><br><span class="line"><span class="comment">		methodProxy: 代理对象中的方法</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable {</span><br><span class="line">        System.out.println(<span class="string">"before"</span>);</span><br><span class="line">        <span class="type">TrainStation</span> <span class="variable">res</span> <span class="operator">=</span> (TrainStation) methodProxy.invokeSuper(o, objects);</span><br><span class="line">        System.out.println(<span class="string">"after"</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="两种代理的对比"><a href="#两种代理的对比" class="headerlink" title="两种代理的对比"></a>两种代理的对比</h2><ul>
<li>JDK代理 VS CGLIB 代理<ul>
<li>CGLIB底层采用ASM字节码生成框架，使用字节码生成代理类。在JDK1.6之前比反射效率高。CGLIB的原理为生成被代理对象的子类。（因此不能代理final修饰的类）</li>
<li>目前，JDK代理效率高于CGLIB。所以有接口类的使用JDK代理，没接口的类使用CGLIB</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java设计模式系列</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis实战系列（1）：短信登录</title>
    <url>//post/44039/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本系列为Redis实战系列，旨在通过实际场景学习Redis相关使用方法。本系列项目使用<code>spring-boot-starter-data-redis</code>（SpringDataRedis）来操作Redis。</p>
<p>原文地址：<a href="https://xuedongyun.cn/post/44039/">https://xuedongyun.cn/post/44039/</a></p>
<h2 id="项目流程"><a href="#项目流程" class="headerlink" title="项目流程"></a>项目流程</h2><p>发送验证码：</p>
<ol>
<li>随机生成验证码</li>
<li>保存验证码（之前用Session，现在用Redis）</li>
<li>发送验证码</li>
<li>返回ok</li>
</ol>
<p>登录阶段：</p>
<ol>
<li>使用手机号从Redis中获取验证码</li>
<li>校验验证码是否一致（不一致报错）</li>
<li>一致，根据手机号查询用户</li>
<li>判断用户是否存在（不存在则创建用户）</li>
<li>保存用户信息到Redis，使用token作为key</li>
<li>返回token</li>
</ol>
<h2 id="用到的实体类"><a href="#用到的实体类" class="headerlink" title="用到的实体类"></a>用到的实体类</h2><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> {</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDto</span> {</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginFormDto</span> {</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span> {</span><br><span class="line">    <span class="keyword">private</span> Boolean success;</span><br><span class="line">    <span class="keyword">private</span> String errorMsg;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">    <span class="keyword">private</span> Long total;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">ok</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">ok</span><span class="params">(Object data)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="literal">true</span>, <span class="literal">null</span>, data, <span class="literal">null</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">ok</span><span class="params">(List&lt;?&gt; data, Long total)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="literal">true</span>, <span class="literal">null</span>, data, total);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">fail</span><span class="params">(String errorMsg)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="literal">false</span>, errorMsg, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="UserService（发送短信验证码）"><a href="#UserService（发送短信验证码）" class="headerlink" title="UserService（发送短信验证码）"></a>UserService（发送短信验证码）</h2><p>用户上传手机号，生成随机验证码，短信发送给用户</p>
<p>Redis中存储验证码</p>
<table>
<thead>
<tr>
<th>key</th>
<th>value（验证码）</th>
</tr>
</thead>
<tbody><tr>
<td>login:code:13001234567</td>
<td>672636</td>
</tr>
</tbody></table>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(String phone)</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成验证码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> RandomUtil.randomNumbers(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证码存在Redis中，并设置过期时间</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(<span class="string">"login:code:"</span> + phone, code);</span><br><span class="line">    stringRedisTemplate.expire(<span class="string">"login:code:"</span> + phone, <span class="number">5</span>, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">"模拟发送短信：{}"</span>, code);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="UserService（登录）"><a href="#UserService（登录）" class="headerlink" title="UserService（登录）"></a>UserService（登录）</h2><p>登录的主要逻辑</p>
<ul>
<li>验证用户上传的验证码（根据手机号从Redis中拿）</li>
<li>登录成功后，将User信息存入Redis中，返回token</li>
</ul>
<p>Redis中存储用户信息</p>
<table>
<thead>
<tr>
<th>key</th>
<th>value（hash格式的用户信息）</th>
</tr>
</thead>
<tbody><tr>
<td>login:token:b725075b-1ba4-4658-8c89-597d7c43f965</td>
<td>name: xdy, phone: 13001234567</td>
</tr>
</tbody></table>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginFormDto loginForm)</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取手机号</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> loginForm.getPhone();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断用户上传的验证码，和Redis中缓存的验证码是否一致</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">cacheCode</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">"login:code:"</span> + phone);</span><br><span class="line">    <span class="keyword">if</span> (cacheCode == <span class="literal">null</span> || !cacheCode.equals(loginForm.getCode())) {</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">"验证码错误"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从数据库中查询用户是否存在，存在就直接获取</span></span><br><span class="line">    <span class="comment">// 如果不存在，数据库创建新用户</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">"xdy"</span>, phone, <span class="string">"123456"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机生成token，作为登录令牌</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">    <span class="type">String</span> <span class="variable">tokenKey</span> <span class="operator">=</span> <span class="string">"login:token:"</span> + token;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将User转换为UserDto, 再转化为HashMap</span></span><br><span class="line">    <span class="type">UserDto</span> <span class="variable">userDto</span> <span class="operator">=</span> BeanUtil.copyProperties(user, UserDto.class);</span><br><span class="line">    Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap(userDto, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将用户信息存在redis中，并设置token有效期</span></span><br><span class="line">    stringRedisTemplate.opsForHash().putAll(tokenKey, userMap);</span><br><span class="line">    stringRedisTemplate.expire(tokenKey, <span class="number">10</span>, TimeUnit.DAYS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回token</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(token);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="UserHolder"><a href="#UserHolder" class="headerlink" title="UserHolder"></a>UserHolder</h2><p>工具类，用于将<code>UserDto</code>变量存储在<code>ThreadLocal</code>中</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserHolder</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;UserDto&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(UserDto user)</span>{</span><br><span class="line">        tl.set(user);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserDto <span class="title function_">getUser</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">return</span> tl.get();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">removeUser</span><span class="params">()</span>{</span><br><span class="line">        tl.remove();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="RefreshTokenInterceptor"><a href="#RefreshTokenInterceptor" class="headerlink" title="RefreshTokenInterceptor"></a>RefreshTokenInterceptor</h2><p>该拦截器用于<strong>刷新token有效期</strong>（因为有的请求未必需要登录，所以此部分独立出来）</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefreshTokenInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RefreshTokenInterceptor</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> {</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">"authorization"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Strings.isBlank(token)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若有token，从redis中获取userMap</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">tokenKey</span> <span class="operator">=</span> <span class="string">"login:token:"</span> + token;</span><br><span class="line">        Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(tokenKey);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果用户存在，保存信息到ThreadLocal</span></span><br><span class="line">        <span class="keyword">if</span> (userMap.isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">UserDto</span> <span class="variable">userDto</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(userMap, <span class="keyword">new</span> <span class="title class_">UserDto</span>(), <span class="literal">false</span>);</span><br><span class="line">        UserHolder.saveUser(userDto);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 刷新token有效期</span></span><br><span class="line">        stringRedisTemplate.expire(tokenKey, <span class="number">10</span>, TimeUnit.DAYS);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="LoginInterceptor"><a href="#LoginInterceptor" class="headerlink" title="LoginInterceptor"></a>LoginInterceptor</h2><p>该拦截器用于<strong>判断登录状态</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> {</span><br><span class="line">        <span class="comment">// 登录才放行</span></span><br><span class="line">        <span class="keyword">if</span> (UserHolder.getUser() == <span class="literal">null</span>) {</span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="WebConfig"><a href="#WebConfig" class="headerlink" title="WebConfig"></a>WebConfig</h2><p>将拦截器注册到SpringBoot中</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> {</span><br><span class="line">        <span class="type">var</span> <span class="variable">loginInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>();</span><br><span class="line">        <span class="type">var</span> <span class="variable">refreshTokenInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RefreshTokenInterceptor</span>(stringRedisTemplate);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 先注册refreshTokenInterceptor，后注册loginInterceptor</span></span><br><span class="line">        registry.addInterceptor(refreshTokenInterceptor).addPathPatterns(<span class="string">"/**"</span>);</span><br><span class="line">        registry.addInterceptor(loginInterceptor)</span><br><span class="line">                .addPathPatterns(<span class="string">"/**"</span>)</span><br><span class="line">                .excludePathPatterns(<span class="string">"/login"</span>, <span class="string">"/sendCode"</span>);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="UserController"><a href="#UserController" class="headerlink" title="UserController"></a>UserController</h2><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping("/sendCode")</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(<span class="meta">@RequestParam</span> String phone)</span> {</span><br><span class="line">        <span class="keyword">return</span> userService.sendCode(phone);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping("/login")</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginFormDto loginFormDto)</span> {</span><br><span class="line">        <span class="keyword">return</span> userService.login(loginFormDto);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping("/test")</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">test</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="使用效果"><a href="#使用效果" class="headerlink" title="使用效果"></a>使用效果</h2><p>测试是否已登录（请求被拦截，响应401）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET		http://localhost:8080/test</span><br></pre></td></tr></table></figure></div>

<p>首先获取验证码</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST	http://localhost:8080/sendCode</span><br><span class="line"># 请求体</span><br><span class="line">phone	13001234567</span><br></pre></td></tr></table></figure></div>

<p>使用手机号和验证码登录</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST	http://localhost:8080/login</span><br><span class="line"># 请求体</span><br><span class="line">phone	13001234567</span><br><span class="line">code	081256</span><br></pre></td></tr></table></figure></div>

<p>测试是否已登录（请求被放行）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET		http://localhost:8080/test</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>Redis</category>
        <category>实战</category>
      </categories>
      <tags>
        <tag>Redis实战系列</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis实战系列（2）：商户查询缓存</title>
    <url>//post/39214/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本系列为Redis实战系列，旨在通过实际场景学习Redis相关使用方法。本系列项目使用<code>spring-boot-starter-data-redis</code>（SpringDataRedis）来操作Redis。</p>
<p>原文地址：<a href="https://xuedongyun.cn/post/44039/">https://xuedongyun.cn/post/44039/</a></p>
<h2 id="添加缓存"><a href="#添加缓存" class="headerlink" title="添加缓存"></a>添加缓存</h2><ul>
<li>查询数据前先查询缓存<ul>
<li>如果缓存有，直接返回</li>
<li>如果缓存无，查询数据库，再存入redis中</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShopService</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long shopId)</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">"cache:shop:"</span> + shopId;</span><br><span class="line">        <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 缓存中有直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (shopJson != <span class="literal">null</span>) {</span><br><span class="line">            <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">            <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 缓存中无，需要去数据库查询</span></span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Shop</span>(<span class="number">1001L</span>, <span class="string">"KaKaShop"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查不到，返回错误</span></span><br><span class="line">        <span class="keyword">if</span> (shop == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">"店铺不存在"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存在，写入Redis中</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h2><p>三种缓存更新策略</p>
<ul>
<li><p><strong>内存淘汰：</strong>Redis自动进行，当redis内存达到设定的max-memory时，自动触发淘汰机制，淘汰掉一些不重要的数据（可以自行设置）</p>
</li>
<li><p><strong>超时删除：</strong>给Redis中的变量设置ttl，超时的数据自动删除</p>
</li>
<li><p><strong>主动更新：</strong>手动调用方法把缓存删除，用于解决缓存和数据库不一致问题</p>
</li>
</ul>
<p>业务场景：</p>
<ul>
<li>低一致性需求：使用内存淘汰机制</li>
<li>高一致性需求：主动更新，并以超时删除作为兜底方案（本案例使用此方案）</li>
</ul>
<p>在本实例的场景中，如果有人修改了数据库，会导致数据库和缓存不一致。因此需要操作缓存，那么应该更新缓存还是删除缓存？</p>
<ul>
<li>更新缓存：每次修改数据库都更新缓存，无效写操作过多</li>
<li>删除缓存：跟新数据库时，让缓存失效，查询时再写入缓存（更优）</li>
</ul>
<p>那么，应该先<strong>更新数据库</strong>还是先<strong>删除缓存</strong>？（考虑这两个操作之间可能会有新的操作）</p>
<ul>
<li>先删除缓存：在还未来得及更新数据库时，可能会有新的请求读取了数据库并写入到缓存中，出现不一致的情况</li>
<li>先更新数据库：能够保证数据一致性</li>
</ul>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/06/26/pRX65NztiBaEFTJ.png" alt="1653323595206"></p>
<blockquote>
<p>总结：我们应该先更新数据库，再删除缓存</p>
</blockquote>
<p>修改一：读取数据库，并写入Redis时，设置超时时间</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long shopId)</span> {</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">"cache:shop:"</span> + shopId;</span><br><span class="line">    <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓存中有直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (shopJson != <span class="literal">null</span>) {</span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓存中无，需要去数据库查询</span></span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Shop</span>(<span class="number">1001L</span>, <span class="string">"KaKaShop"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查不到，返回错误</span></span><br><span class="line">    <span class="keyword">if</span> (shop == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">"店铺不存在"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存在，写入Redis中，设置超时时间</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop), <span class="number">30L</span>, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>修改二：更新数据后，把缓存中的数据删掉</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">update</span><span class="params">(Shop shop)</span> {</span><br><span class="line">    <span class="comment">// 更新数据库</span></span><br><span class="line">    System.out.println(<span class="string">"模拟更新数据库"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除缓存</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">shopId</span> <span class="operator">=</span> shop.getShopId();</span><br><span class="line">    stringRedisTemplate.delete(<span class="string">"cache:shop:"</span> + shopId);</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="缓存穿透问题"><a href="#缓存穿透问题" class="headerlink" title="缓存穿透问题"></a>缓存穿透问题</h2><p>缓存穿透：请求的数据在数据库和缓存中都不存在，每次请求都会打到数据库中</p>
<p>解决方案：</p>
<ul>
<li>缓存空对象：简单方便。但会有额外内存消耗，且会造成数据短期不一致。</li>
<li>布隆过滤：内存占用少。但实现复杂，存在误判，且无法删除元素。</li>
</ul>
<blockquote>
<p>更改思路（使用缓存空对象）：</p>
<ul>
<li>以前：查询数据时，如果数据库中不存在，返回查询失败</li>
<li>现在：查询数据时，如果数据库中不存在，依然写入Redis缓存null值，返回查询失败</li>
</ul>
</blockquote>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/06/28/POC3ntLzXpbSWAJ.png" alt="1653326156516"></p>
<h2 id="缓存雪崩问题"><a href="#缓存雪崩问题" class="headerlink" title="缓存雪崩问题"></a>缓存雪崩问题</h2><p>缓存雪崩：指同一时间大量缓存的key同时失效，或Redis宕机，导致大量请求到达数据库，带来压力</p>
<p>解决方案：</p>
<ul>
<li>给不同key的TTL添加随机值</li>
<li>利用Redis集群提高服务可用性</li>
<li>给业务添加降级限流策略（微服务相关）</li>
<li>给业务添加多级缓存（请求到达浏览器，nginx可以做缓存，未命中找Redis，再未命中找JVM，最后到数据库……）</li>
</ul>
<h2 id="缓存击穿问题"><a href="#缓存击穿问题" class="headerlink" title="缓存击穿问题"></a>缓存击穿问题</h2><p>缓存击穿：指一个key失效了，在高并发的情况下，会有大量的请求都访问数据库（因为都暂时从缓存中读不到），带来冲击</p>
<p>解决方案：</p>
<ul>
<li>互斥锁</li>
<li>逻辑过期</li>
</ul>
<h3 id="使用互斥锁"><a href="#使用互斥锁" class="headerlink" title="使用互斥锁"></a>使用互斥锁</h3><p>如果从缓存中没有查询到数据，需要不停尝试获取互斥锁。直到获取到锁为止，才能重新进行查询。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span> {</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">"1"</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key)</span> {</span><br><span class="line">    stringRedisTemplate.delete(key);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long shopId)</span> {</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">"cache:shop:"</span> + shopId;</span><br><span class="line">    <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓存中有直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (shopJson != <span class="literal">null</span>) {</span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要互斥锁才能查询数据库</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> <span class="string">"lock:shop:"</span> + shopId;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 获取锁</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">        <span class="keyword">if</span> (!isLock) {</span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            <span class="keyword">return</span> queryById(shopId);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 缓存中无，去数据库查询</span></span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Shop</span>(<span class="number">1001L</span>, <span class="string">"KaKaShop"</span>);</span><br><span class="line">        <span class="comment">// 查不到，返回错误</span></span><br><span class="line">        <span class="keyword">if</span> (shop == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">"店铺不存在"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存在，写入Redis中，设置超时时间</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop), <span class="number">30L</span>, TimeUnit.MINUTES);</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line"></span><br><span class="line">    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        unlock(lockKey);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="使用逻辑过期"><a href="#使用逻辑过期" class="headerlink" title="使用逻辑过期"></a>使用逻辑过期</h3><ul>
<li><p>需要进行缓存预热，提前将数据加入到Redis中</p>
</li>
<li><p>查询Redis时，如果没有命中，直接返回空，不查询数据库</p>
</li>
<li><p>一旦命中，将value取出，判断value中的过期时间是否满足。如果没有过期，则直接返回数据</p>
</li>
<li><p>如果过期，开启独立线程后直接返回数据。独立线程能获取互斥锁，才去重构数据，重构完成后释放互斥锁</p>
</li>
</ul>
<p>新建一个实体类，用来存储数据以及过期时间</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisData</span> {</span><br><span class="line">    <span class="keyword">private</span> LocalDateTime expireTime;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>在ShopService中封装一个方法（测试的时候，缓存预热用）</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveShop2Redis</span><span class="params">(Long shopId, Long expireSeconds)</span> {</span><br><span class="line">    <span class="comment">// 从数据库中查询shop（模拟）</span></span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Shop</span>(shopId, <span class="string">"testShop"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入数据到Redis</span></span><br><span class="line">    <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">    redisData.setData(shop);</span><br><span class="line">    redisData.setExpireTime(LocalDateTime.now().plusSeconds(expireSeconds));</span><br><span class="line"></span><br><span class="line">    stringRedisTemplate.opsForValue().set(<span class="string">"cache:shop:"</span> + shopId, JSONUtil.toJsonStr(redisData));</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>在测试类中预热一下</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSaveShop</span><span class="params">()</span> {</span><br><span class="line">    shopService.saveShop2Redis(<span class="number">1L</span>, <span class="number">10L</span>);</span><br><span class="line">    shopService.saveShop2Redis(<span class="number">2L</span>, <span class="number">10L</span>);</span><br><span class="line">    shopService.saveShop2Redis(<span class="number">3L</span>, <span class="number">10L</span>);</span><br><span class="line">    shopService.saveShop2Redis(<span class="number">4L</span>, <span class="number">10L</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>核心业务</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long shopId)</span> {</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">"cache:shop:"</span> + shopId;</span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不存在直接返回null</span></span><br><span class="line">    <span class="keyword">if</span> (Strings.isBlank(json)) {</span><br><span class="line">        <span class="keyword">return</span> Result.ok(<span class="literal">null</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 命中，需要先把json反序列化为对象</span></span><br><span class="line">    <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(json, RedisData.class);</span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), Shop.class);</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否过期，未过期直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (expireTime.isAfter(LocalDateTime.now())) {</span><br><span class="line">        <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 过期则重建缓存</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> <span class="string">"lock:shop:"</span> + shopId;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">    <span class="keyword">if</span> (isLock) {</span><br><span class="line">        CACHE_REBUILD_EXECUTOR.submit(() -&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">// 重建缓存</span></span><br><span class="line">                <span class="built_in">this</span>.saveShop2Redis(shopId, <span class="number">10L</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                <span class="comment">// 释放锁</span></span><br><span class="line">                unlock(lockKey);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回过期的商铺信息</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="封装Redis工具类"><a href="#封装Redis工具类" class="headerlink" title="封装Redis工具类"></a>封装Redis工具类</h2><p>针对上述问题，我们可以发现，其实很多业务的逻辑都是相似的。因此其实可以封装一个工具类来处理</p>
<ul>
<li>方法1：将任意Java对象序列化为json，存储在String类型的key中，设置TTL</li>
<li>方法2：将任意Java对象序列化为json，存储在String类型的key中，设置逻辑过期时间</li>
<li>方法3：根据key查询缓存，并反序列化为指定类型，利用<strong>缓存空值</strong>的方式解决<strong>缓存穿透</strong>问题</li>
<li>方法4：根据key查询缓存，并反序列化为指定类型，利用<strong>互斥锁</strong>的方式解决<strong>缓存击穿</strong>问题</li>
<li>方法5：根据key查询缓存，并反序列化为指定类型，利用<strong>逻辑过期</strong>的方式解决<strong>缓存击穿</strong>问题</li>
</ul>
<p>创建此工具类</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisClient</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span>  <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="存储到缓存，设置过期"><a href="#存储到缓存，设置过期" class="headerlink" title="存储到缓存，设置过期"></a>存储到缓存，设置过期</h3><p>实现方法1：存储到缓存，并设置过期时间</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, Object value, Long time, TimeUnit unit)</span> {</span><br><span class="line">    stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, unit);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="存储到缓存，逻辑过期"><a href="#存储到缓存，逻辑过期" class="headerlink" title="存储到缓存，逻辑过期"></a>存储到缓存，逻辑过期</h3><p>实现方法2：存储到缓存，并设置逻辑过期时间</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWithLogicalExpire</span><span class="params">(String key, Object value, Long time, TimeUnit unit)</span> {</span><br><span class="line">    <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">    redisData.setData(value);</span><br><span class="line">    redisData.setExpireTime(LocalDateTime.now().plus(time, unit.toChronoUnit()));</span><br><span class="line">    stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="缓存null（缓存穿透）"><a href="#缓存null（缓存穿透）" class="headerlink" title="缓存null（缓存穿透）"></a>缓存null（缓存穿透）</h3><p>实现方法3：使用key查询缓存，数据库中也没有则缓存null</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithPassThrough</span><span class="params">(String keyPrefix,</span></span><br><span class="line"><span class="params">                                           ID id,</span></span><br><span class="line"><span class="params">                                           Class&lt;R&gt; type,</span></span><br><span class="line"><span class="params">                                           Function&lt;ID, R&gt; dbFallback,</span></span><br><span class="line"><span class="params">                                           Long time,</span></span><br><span class="line"><span class="params">                                           TimeUnit unit)</span> {</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓存中有直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!Strings.isBlank(json)) {</span><br><span class="line">        <span class="keyword">return</span> JSONUtil.toBean(json, type);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果命中的是空值，直接返回null</span></span><br><span class="line">    <span class="keyword">if</span> (json != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不存在，去数据库中拿</span></span><br><span class="line">    <span class="type">R</span> <span class="variable">data</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">    <span class="comment">// 若数据库中没有，缓存空值</span></span><br><span class="line">    <span class="keyword">if</span> (data == <span class="literal">null</span>) {</span><br><span class="line">        <span class="built_in">this</span>.set(key, <span class="string">""</span>, time, unit);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">this</span>.set(key, data, time, unit);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="互斥锁（缓存击穿）"><a href="#互斥锁（缓存击穿）" class="headerlink" title="互斥锁（缓存击穿）"></a>互斥锁（缓存击穿）</h3><p>实现方法4：使用互斥锁，解决缓存击穿问题</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithMutex</span><span class="params">(String keyPrefix,</span></span><br><span class="line"><span class="params">                                ID id, Class&lt;R&gt; type,</span></span><br><span class="line"><span class="params">                                Function&lt;ID, R&gt; dbFallback,</span></span><br><span class="line"><span class="params">                                Long time,</span></span><br><span class="line"><span class="params">                                TimeUnit unit)</span> {</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">    <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓存中有直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (Strings.isNotBlank(shopJson)) {</span><br><span class="line">        <span class="keyword">return</span> JSONUtil.toBean(shopJson, type);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断命中的是否是空值，是返回null</span></span><br><span class="line">    <span class="keyword">if</span> (shopJson != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.1.获取互斥锁</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> <span class="string">"lock:"</span> + keyPrefix + id;</span><br><span class="line">    R data;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">        <span class="keyword">if</span> (!isLock) {</span><br><span class="line">            <span class="comment">// 获取锁失败，休眠并重试</span></span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            <span class="keyword">return</span> queryWithMutex(keyPrefix, id, type, dbFallback, time, unit);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 获取锁成功，查询数据库</span></span><br><span class="line">        data = dbFallback.apply(id);</span><br><span class="line">        <span class="keyword">if</span> (data == <span class="literal">null</span>) {</span><br><span class="line">            set(key, <span class="string">""</span>, time, unit);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">this</span>.set(key, data, time, unit);</span><br><span class="line">    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    }<span class="keyword">finally</span> {</span><br><span class="line">        unlock(lockKey);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="逻辑超时（缓存击穿）"><a href="#逻辑超时（缓存击穿）" class="headerlink" title="逻辑超时（缓存击穿）"></a>逻辑超时（缓存击穿）</h3><p>实现方法5：使用逻辑超时，解决缓存击穿问题</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;ID, R&gt; R <span class="title function_">queryWithLogicalExpire</span><span class="params">(String keyPrefix,</span></span><br><span class="line"><span class="params">                                    ID id,</span></span><br><span class="line"><span class="params">                                    Class&lt;R&gt; type,</span></span><br><span class="line"><span class="params">                                    Function&lt;ID, R&gt; dbFallback,</span></span><br><span class="line"><span class="params">                                    Long time,</span></span><br><span class="line"><span class="params">                                    TimeUnit unit)</span> {</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不存在直接返回null</span></span><br><span class="line">    <span class="keyword">if</span> (Strings.isBlank(json)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 命中，进行反序列化</span></span><br><span class="line">    <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(json, RedisData.class);</span><br><span class="line">    <span class="type">R</span> <span class="variable">data</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), type);</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 未过期直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (expireTime.isAfter(LocalDateTime.now())) {</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已过期需要缓存重建</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> <span class="string">"lock:"</span> + keyPrefix + id;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">    <span class="keyword">if</span> (isLock) {</span><br><span class="line">        CACHE_REBUILD_EXECUTOR.submit(()-&gt;{</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">// 获取到锁的人才有资格，查询数据库，重建缓存</span></span><br><span class="line">                <span class="type">R</span> <span class="variable">dbData</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">                <span class="built_in">this</span>.setWithLogicalExpire(key, dbData, time, unit);</span><br><span class="line">            } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                unlock(lockKey);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>Redis</category>
        <category>实战</category>
      </categories>
      <tags>
        <tag>Redis实战系列</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis实战系列（3）：优惠卷秒杀</title>
    <url>//post/20783/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本系列为Redis实战系列，旨在通过实际场景学习Redis相关使用方法。本系列项目使用<code>spring-boot-starter-data-redis</code>（SpringDataRedis）来操作Redis。</p>
<p>原文地址：<a href="https://xuedongyun.cn/post/20783/">https://xuedongyun.cn/post/20783/</a></p>
<h2 id="全局唯一ID"><a href="#全局唯一ID" class="headerlink" title="全局唯一ID"></a>全局唯一ID</h2><p>当用户抢购时，会生成订单，保存到表中。但是如果使用自增ID就会出现问题：</p>
<ul>
<li>id规律太明显</li>
<li>受表单数据量限制</li>
</ul>
<p>所以我们需要全局ID生成器，需满足以下要求：</p>
<ul>
<li>唯一性</li>
<li>高性能</li>
<li>安全性</li>
<li>递增性</li>
<li>高可用</li>
</ul>
<p>为了安全，我们可以不直接使用Redis自增的数据，而是拼接一些其他的数据</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/06/28/ViaI6ejqgHtvdAL.png" alt="1653363172079"></p>
<blockquote>
<p>符号位：1bit，永远为0</p>
<p>时间戳：31bit，以秒为单位，可以使用69年</p>
<p>序列号：32bit，秒内的计数器，每秒可以产生2^32个不同ID</p>
</blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisIdWorker</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始的秒数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">BEGIN_TIMESTAMP</span> <span class="operator">=</span> <span class="number">1687947195L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列号的位数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BIT</span> <span class="operator">=</span> <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">(String keyPrefix)</span> {</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="type">long</span> <span class="variable">second</span> <span class="operator">=</span> now.toEpochSecond(ZoneOffset.UTC);</span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> second - BEGIN_TIMESTAMP;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自增长</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">"yyyy:MM:dd"</span>));</span><br><span class="line">        <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().increment(<span class="string">"icr:"</span> + keyPrefix + <span class="string">":"</span> + date);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 1位符号位 + 31位秒数 + 32位自增数字</span></span><br><span class="line">        <span class="keyword">return</span> timestamp &lt;&lt; <span class="number">32</span> | count;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>测试代码</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisIdWorkerTest</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisIdWorker redisIdWorker;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        <span class="comment">// 这里使用了CountDownLatch，主线程需要在异步线程执行完后才能结束</span></span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) {</span><br><span class="line">                <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">"order"</span>);</span><br><span class="line">                System.out.println(<span class="string">"id = "</span> + id);</span><br><span class="line">            }</span><br><span class="line">            latch.countDown();</span><br><span class="line">        };</span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// （利用线程池）开了300个线程，每个</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">300</span>; i++) {</span><br><span class="line">            es.submit(task);</span><br><span class="line">        }</span><br><span class="line">        latch.await();</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"time = "</span> + (end - begin));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="添加优惠卷"><a href="#添加优惠卷" class="headerlink" title="添加优惠卷"></a>添加优惠卷</h2><p>我们把优惠卷分为两种：普通优惠卷和特价优惠券。普通优惠卷可以任意领取，特价优惠卷需要抢购。</p>
<p>Voucher：普通优惠卷</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Voucher</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主键</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="comment">// 商铺ID</span></span><br><span class="line">    <span class="keyword">private</span> Long shopId;</span><br><span class="line">    <span class="comment">// 代金券标题</span></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="comment">// 副标题</span></span><br><span class="line">    <span class="keyword">private</span> String subTitle;</span><br><span class="line">	<span class="comment">// 使用规则</span></span><br><span class="line">    <span class="keyword">private</span> String rules;</span><br><span class="line">    <span class="comment">// 支付金额</span></span><br><span class="line">    <span class="keyword">private</span> Long payValue;</span><br><span class="line">	<span class="comment">// 抵扣金额</span></span><br><span class="line">    <span class="keyword">private</span> Long actualValue;</span><br><span class="line">	<span class="comment">// 优惠券类型</span></span><br><span class="line">    <span class="keyword">private</span> Integer type;</span><br><span class="line">    <span class="comment">// 库存</span></span><br><span class="line">    <span class="keyword">private</span> Integer stock;</span><br><span class="line">    <span class="comment">// 生效时间</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime beginTime;</span><br><span class="line">    <span class="comment">// 失效时间</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime endTime;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>SeckillVoucher：秒杀优惠卷</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeckillVoucher</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关联的优惠券ID</span></span><br><span class="line">    <span class="keyword">private</span> Long voucherId;</span><br><span class="line">    <span class="comment">// 库存</span></span><br><span class="line">    <span class="keyword">private</span> Integer stock;</span><br><span class="line">    <span class="comment">// 生效时间</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime beginTime;</span><br><span class="line">    <span class="comment">// 失效时间</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime endTime;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p><code>VoucherService</code>中，模拟添加优惠券到数据库，并在Redis中存储秒杀优惠卷库存信息</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addVoucher</span><span class="params">(Voucher voucher)</span> {</span><br><span class="line">    <span class="comment">// 模拟存储到数据库</span></span><br><span class="line">    voucher.setId(<span class="number">1001L</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSeckillVoucher</span><span class="params">(Voucher voucher)</span> {</span><br><span class="line">    <span class="comment">// 模拟保存到数据库</span></span><br><span class="line">    voucher.setId(<span class="number">1002L</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存秒杀信息到数据库（模拟）</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> SeckillVoucher.builder()</span><br><span class="line">            .voucherId(voucher.getId())</span><br><span class="line">            .stock(voucher.getStock())</span><br><span class="line">            .beginTime(voucher.getBeginTime())</span><br><span class="line">            .endTime(voucher.getEndTime())</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存库存到redis</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">"seckill:stock:"</span> + voucher.getId();</span><br><span class="line">    stringRedisTemplate.opsForValue().set(key, voucher.getStock().toString());</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="实现秒杀下单"><a href="#实现秒杀下单" class="headerlink" title="实现秒杀下单"></a>实现秒杀下单</h2><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">orderSeckillVoucher</span><span class="params">(Long voucherId)</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询优惠卷（模拟）</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">voucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now())) {</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">"秒杀尚未开始"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (voucher.getEndTime().isBefore(LocalDateTime.now())) {</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">"秒杀已经结束"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">"库存不足"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扣减库存（模拟）</span></span><br><span class="line">    voucher.setStock(voucher.getStock() - <span class="number">1</span>);</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span> (!success) {</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">"库存不足"</span>);</span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 创建订单，记录：订单唯一ID，用户ID，优惠卷ID</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">"order"</span>);</span><br><span class="line">    voucherOrder.setId(orderId);</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    voucherOrder.setUserId(userId);</span><br><span class="line">    voucherOrder.setVoucherId(voucherId);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存voucherOrder（模拟）</span></span><br><span class="line">    save(voucherOrder);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="库存超卖问题"><a href="#库存超卖问题" class="headerlink" title="库存超卖问题"></a>库存超卖问题</h2><p>在判断库存不足时，出现了问题。假如库存为1：可能线程1判断还有库存，正准备扣去库存时，线程2也查询库存，发现库存还够。最终两个人在库存为1的情况下，都成功减去了库存。</p>
<p>常规来说，我们可以使用乐观锁或悲观锁来解决这个问题：</p>
<ul>
<li><p><strong>乐观锁</strong></p>
<p>认为线程安全问题不一定会发生，只在更新数据时去判断有没有其他线程也做了修改</p>
</li>
<li><p><strong>悲观锁</strong></p>
<p>认为线程安全问题一定会发生，操作数据前先获取锁</p>
</li>
</ul>
<blockquote>
<p>我们可以使用乐观锁来解决之前的问题</p>
</blockquote>
<h3 id="修改更新方案（一）"><a href="#修改更新方案（一）" class="headerlink" title="修改更新方案（一）"></a>修改更新方案（一）</h3><p>核心思想：只要我扣减库存的时候，库存和我之前查询到的库存是一样的，就意味着中间没有人修改过</p>
<p>伪SQL语句</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">update voucher</span><br><span class="line">set stock = stock - 1</span><br><span class="line">where voucher_id = voucherId and stock = {判断库存是否足够时的值}</span><br></pre></td></tr></table></figure></div>

<h3 id="修改更新方案（二）"><a href="#修改更新方案（二）" class="headerlink" title="修改更新方案（二）"></a>修改更新方案（二）</h3><p>如果使用方案一的话，成功率太低了，我们可以改一下判断条件。只要修改的时候库存大于零即可</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">update voucher</span><br><span class="line">set stock = stock - 1</span><br><span class="line">where voucher_id = voucherId and stock &gt; 0</span><br></pre></td></tr></table></figure></div>

<h2 id="一人一单问题"><a href="#一人一单问题" class="headerlink" title="一人一单问题"></a>一人一单问题</h2><p>我们需要添加功能，使得一个人只能抢购一张优惠卷</p>
<p>具体逻辑应该如下：先判断时间；进一步判断库存；再根据优惠卷id和用户id查询是否已下过订单</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">orderSeckillVoucher</span><span class="params">(Long voucherId)</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询优惠卷（模拟）</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">voucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now())) {</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">"秒杀尚未开始"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (voucher.getEndTime().isBefore(LocalDateTime.now())) {</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">"秒杀已经结束"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">"库存不足"</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 一人一单逻辑</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">"user_id"</span>, userId).eq(<span class="string">"voucher_id"</span>, voucherId).count();</span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">"用户已经购买过一次！"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扣减库存（模拟）</span></span><br><span class="line">    voucher.setStock(voucher.getStock() - <span class="number">1</span>);</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span> (!success) {</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">"库存不足"</span>);</span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 创建订单，记录：订单唯一ID，用户ID，优惠卷ID</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">"order"</span>);</span><br><span class="line">    voucherOrder.setId(orderId);</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    voucherOrder.setUserId(userId);</span><br><span class="line">    voucherOrder.setVoucherId(voucherId);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存voucherOrder（模拟）</span></span><br><span class="line">    save(voucherOrder);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>这样还是有问题，如果一开始某一用户进行大量并发请求，可能出现：第一笔订单还没来得及保存，后续请求就来了…查询到的订单数量还是0，进而放行…</p>
<h3 id="解决一致性问题"><a href="#解决一致性问题" class="headerlink" title="解决一致性问题"></a>解决一致性问题</h3><p>我们首先创建一个<code>createVoucherOrder()</code>方法，同时为了线程安全，在方法上加<code>synchronized</code>，<code>@Transactional</code></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> { </span><br><span class="line">	<span class="comment">// 一人一单逻辑</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">"user_id"</span>, userId).eq(<span class="string">"voucher_id"</span>, voucherId).count();</span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">"用户已经购买过一次！"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扣减库存（模拟）</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">            .setSql(<span class="string">"stock = stock - 1"</span>)</span><br><span class="line">            .eq(<span class="string">"voucher_id"</span>, voucherId).gt(<span class="string">"stock"</span>, <span class="number">0</span>)</span><br><span class="line">            .update()</span><br><span class="line">    <span class="keyword">if</span> (!success) {</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">"库存不足"</span>);</span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 创建订单，记录：订单唯一ID，用户ID，优惠卷ID</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">"order"</span>);</span><br><span class="line">    voucherOrder.setId(orderId);			<span class="comment">// 订单ID</span></span><br><span class="line">    voucherOrder.setUserId(userId);			<span class="comment">// 用户ID</span></span><br><span class="line">    voucherOrder.setVoucherId(voucherId);	<span class="comment">// 优惠卷ID</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存voucherOrder（模拟）</span></span><br><span class="line">    save(voucherOrder);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 返回订单ID</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p> 这样的话锁的粒度太粗了</p>
</blockquote>
<p>改进，在<code>userId.toString().intern()</code>上加锁</p>
<blockquote>
<p><code>userId.toString()</code> 拿到的对象实际上是不同的对象，<code>intern()</code>这个方法是从常量池中拿到数据，能保证是唯一的相同对象</p>
</blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> {</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 一人一单逻辑</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="keyword">synchronized</span>(userId.toString().intern()) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">"user_id"</span>, userId).eq(<span class="string">"voucher_id"</span>, voucherId).count();</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">"用户已经购买过一次！"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 扣减库存（模拟）</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">                .setSql(<span class="string">"stock = stock - 1"</span>)</span><br><span class="line">                .eq(<span class="string">"voucher_id"</span>, voucherId).gt(<span class="string">"stock"</span>, <span class="number">0</span>)</span><br><span class="line">                .update()</span><br><span class="line">        <span class="keyword">if</span> (!success) {</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">"库存不足"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建订单，记录：订单唯一ID，用户ID，优惠卷ID</span></span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">"order"</span>);</span><br><span class="line">        voucherOrder.setId(orderId);			<span class="comment">// 订单ID</span></span><br><span class="line">        voucherOrder.setUserId(userId);			<span class="comment">// 用户ID</span></span><br><span class="line">        voucherOrder.setVoucherId(voucherId);	<span class="comment">// 优惠卷ID</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存voucherOrder（模拟）</span></span><br><span class="line">        save(voucherOrder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回订单ID</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>上述方法依然有问题，整个方法被Spring事务管理，但可能出现：锁已经释放了，但事务还没来得及提交的情况。此时如果有一个新的请求碰巧拿到了锁，并且查询订单时也顺利通过，就会出现问题。</p>
<p>可以将<code>synchronized</code>包在方法外部，解决这个问题：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line"><span class="keyword">synchronized</span> (userId.toString().intern()) {</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.createVoucherOrder(voucherId)</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>上述方法依然有问题，我们调用的方法是由this调用的。我们要是想要事务生效，必须使用代理对象。所以这个地方，我们需要获得代理对象：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line"><span class="keyword">synchronized</span> (userId.toString().intern()) {</span><br><span class="line">    <span class="type">VoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (VoucherOrderService) AopContext.currentProxy();</span><br><span class="line">    <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="秒杀优化"><a href="#秒杀优化" class="headerlink" title="秒杀优化"></a>秒杀优化</h2><p>目前逻辑是串行执行的，会比较慢。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/07/13/9SUuiZfOcDo1P3v.png" alt="image-20230713113428231"></p>
<p>我们可以用消息队列，将当前任务优化为异步的。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/07/13/1OqGEaYBTNyRFCb.png" alt="image-20230713113234287"></p>
<h3 id="Redis缓存的数据类型"><a href="#Redis缓存的数据类型" class="headerlink" title="Redis缓存的数据类型"></a>Redis缓存的数据类型</h3><ul>
<li>库存</li>
</ul>
<table>
<thead>
<tr>
<th>KEY</th>
<th>VALUE</th>
</tr>
</thead>
<tbody><tr>
<td>stock:vid:7</td>
<td>100</td>
</tr>
</tbody></table>
<ul>
<li>订单（使用set）</li>
</ul>
<table>
<thead>
<tr>
<th>KEY</th>
<th>VALUE</th>
</tr>
</thead>
<tbody><tr>
<td>order:vid:7</td>
<td>1001, 1002, 1003, 1005, 1010</td>
</tr>
</tbody></table>
<h3 id="流程总结"><a href="#流程总结" class="headerlink" title="流程总结"></a>流程总结</h3><p>Redis中判断资格，耗时的写操作异步进行</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/07/13/6fhxVt95PpYORTS.png" alt="image-20230713113855897"></p>
]]></content>
      <categories>
        <category>Redis</category>
        <category>实战</category>
      </categories>
      <tags>
        <tag>Redis实战系列</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis实战系列（4）：分布式锁</title>
    <url>//post/25055/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本系列为Redis实战系列，旨在通过实际场景学习Redis相关使用方法。本系列项目使用<code>spring-boot-starter-data-redis</code>（SpringDataRedis）来操作Redis。</p>
<p>原文地址：<a href="https://xuedongyun.cn/post/25055/">https://xuedongyun.cn/post/25055/</a></p>
<h2 id="分布式锁-setnx"><a href="#分布式锁-setnx" class="headerlink" title="分布式锁-setnx"></a>分布式锁-setnx</h2><p><strong>分布式锁</strong>：在分布式系统中，多进程可见且互斥的锁</p>
<p><strong>核心思想</strong>：让大家都用同一把锁，只要能锁住线程，就能让大家顺序执行</p>
<p><strong>分布式锁应当满足的条件</strong>：</p>
<ul>
<li>可见性</li>
<li>互斥</li>
<li>高可用</li>
<li>高性能</li>
<li>安全性</li>
</ul>
<p><strong>常见的分布式锁方案</strong>：</p>
<ul>
<li>MySQL：性能一般，比较少见</li>
<li>Redis：非常常见的方式，利用setnx这个方法</li>
<li>Zookeeper：也是企业级开发中较好的实现分布式锁的方案，本文不涉及</li>
</ul>
<p><strong>实现核心思路</strong>：</p>
<ul>
<li>获取锁：<ul>
<li>互斥：只有一个线程获取锁</li>
<li>非阻塞：尝试一次，成功true，失败false</li>
</ul>
</li>
<li>释放锁：<ul>
<li>手动释放</li>
<li>超时释放：获取锁时，添加超时时间</li>
</ul>
</li>
</ul>
<h3 id="一-简单版本"><a href="#一-简单版本" class="headerlink" title="(一)简单版本"></a>(一)简单版本</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleRedisLock</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleRedisLock</span><span class="params">(String name, StringRedisTemplate stringRedisTemplate)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_PREFIX</span> <span class="operator">=</span> <span class="string">"lock:"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ID_PREFIX</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>) + <span class="string">"-"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> {</span><br><span class="line">        <span class="comment">// 获取线程标示</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">        <span class="comment">// 获取锁</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">            .setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE.equals(success);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> {</span><br><span class="line">        stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="二-分布式锁误删情况"><a href="#二-分布式锁误删情况" class="headerlink" title="(二)分布式锁误删情况"></a>(二)分布式锁误删情况</h3><ul>
<li>假如线程A内部阻塞，导致锁超时自动释放</li>
<li>线程B拿到了这把锁</li>
<li>线程A突然又恢复了，正常执行并释放了锁</li>
<li>这将导致线程A误删线程B的锁</li>
</ul>
<p>我们需要在释放锁之前，查看锁存储的value是不是自己</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">    </span><br><span class="line">    <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(threadId.equals(id)) {</span><br><span class="line">        stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="三-进一步的原子性问题"><a href="#三-进一步的原子性问题" class="headerlink" title="(三)进一步的原子性问题"></a>(三)进一步的原子性问题</h3><ul>
<li><p>假如线程A已确定当前这把锁的确是自己的，正要删除，突然锁到期了。</p>
</li>
<li><p>线程B拿到了这把锁</p>
</li>
<li><p>线程A正常释放锁</p>
</li>
<li><p>这将导致线程A误删线程B的锁</p>
</li>
</ul>
<h4 id="编写lua脚本"><a href="#编写lua脚本" class="headerlink" title="编写lua脚本"></a>编写lua脚本</h4><p>我们可以使用lua脚本操作Redis，实现该原子性操作。我们简单了解一下lua脚本的使用：</p>
<p>Redis为lua提供了调用函数</p>
<div class="highlight-container" data-rel="Lua"><figure class="iseeu highlight lua"><table><tr><td class="code"><pre><span class="line">redis.call(<span class="string">'命令名称'</span>, <span class="string">'key'</span>, <span class="string">'其它参数'</span>, ...)</span><br></pre></td></tr></table></figure></div>

<p>例如：</p>
<div class="highlight-container" data-rel="Lua"><figure class="iseeu highlight lua"><table><tr><td class="code"><pre><span class="line">redis.call(<span class="string">'set'</span>, <span class="string">'name'</span>, <span class="string">'Rose'</span>)</span><br><span class="line"><span class="keyword">local</span> name = redis.call(<span class="string">'get'</span>, <span class="string">'name'</span>)</span><br><span class="line"><span class="keyword">return</span> name</span><br></pre></td></tr></table></figure></div>

<p>使用Redis命令调用lua脚本</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/07/10/KNmMebgGYSW5Lxz.png" alt="1653392438917"></p>
<p>我们最终的lua脚本如下</p>
<div class="highlight-container" data-rel="Lua"><figure class="iseeu highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">'GET'</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>]) <span class="keyword">then</span></span><br><span class="line">  <span class="comment">-- 一致，则删除锁</span></span><br><span class="line">  <span class="keyword">return</span> redis.call(<span class="string">'DEL'</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 不一致，则直接返回</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></div>

<h4 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">static</span> {</span><br><span class="line">    UNLOCK_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">"unlock.lua"</span>));</span><br><span class="line">    UNLOCK_SCRIPT.setResultType(Long.class);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> {</span><br><span class="line">    stringRedisTemplate.execute(UNLOCK_SCRIPT,</span><br><span class="line">            Collections.singletonList(KEY_PREFIX + name),</span><br><span class="line">            ID_PREFIX + Thread.currentThread().getId());</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="分布式锁-redisson"><a href="#分布式锁-redisson" class="headerlink" title="分布式锁-redisson"></a>分布式锁-redisson</h2><h3 id="基于setnx的问题"><a href="#基于setnx的问题" class="headerlink" title="基于setnx的问题"></a>基于setnx的问题</h3><ul>
<li><p><strong>不可重入</strong></p>
<p>同一线程无法所次获取同一把锁</p>
</li>
<li><p><strong>不可重试</strong></p>
<p>指目前的分布式只能尝试一次，我们认为合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。</p>
</li>
<li><p><strong>超时释放</strong></p>
<p>我们在加锁时增加了过期时间，这样的我们可以防止死锁。但是如果卡顿的时间超长，虽然我们采用了lua表达式防止删锁的时候，误删别人的锁。但是毕竟没有锁住，有安全隐患</p>
</li>
<li><p><strong>主从一致性</strong></p>
<p>如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。</p>
</li>
</ul>
<h3 id="什么是Redisson"><a href="#什么是Redisson" class="headerlink" title="什么是Redisson"></a>什么是Redisson</h3><p>是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。</p>
<h3 id="分布式锁-Redisson快速入门"><a href="#分布式锁-Redisson快速入门" class="headerlink" title="分布式锁-Redisson快速入门"></a>分布式锁-Redisson快速入门</h3><p>引入依赖</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.redisson&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;redisson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">3.22</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></div>

<p>配置Redisson客户端</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span><span class="params">()</span>{</span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">"redis://127.0.0.1:6379"</span>).setPassword(<span class="string">"123456"</span>);</span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>使用Redisson分布式锁</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">"anyLock"</span>);</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    <span class="comment">// 参数：获取锁的等待时间，锁释放时间</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">1</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">if</span> (isLock) {</span><br><span class="line">        System.out.println(<span class="string">"执行业务"</span>);</span><br><span class="line">    }</span><br><span class="line">} <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">} <span class="keyword">finally</span> {</span><br><span class="line">    lock.unlock();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="redission可重入锁原理"><a href="#redission可重入锁原理" class="headerlink" title="redission可重入锁原理"></a>redission可重入锁原理</h3><p><strong>在Lock锁中</strong>：借助于底层的一个voaltile的state变量，来记录重入的状态的。比如，没有人持有这把锁时，state=0。若有人持有这把锁，那么state=1。若持有这把锁的人再次持有这把锁，那么state就会+1 </p>
<p><strong>对于synchronized而言</strong>：他在c语言代码中会有一个count，原理和state类似。也是重入一次就+1，释放一次就-1 。直到减少成0时，表示当前这把锁没有被人持有  </p>
<p><strong>redission中</strong>，使用Redis中的hash来存储锁。可以重复获取自己的锁。释放锁时，重入次数需要减1，重入次数为0时需要删除key。</p>
<table>
<thead>
<tr>
<th>key</th>
<th>field</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td>lock</td>
<td>thread1</td>
<td>1</td>
</tr>
</tbody></table>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/07/11/2Q1zJ76FHtATO9S.png" alt="image-20230711112309723" style="zoom: 80%;">

<p>底层使用lua脚本保证操作的原子性：</p>
<ul>
<li>获取锁</li>
</ul>
<div class="highlight-container" data-rel="Lua"><figure class="iseeu highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]; <span class="comment">-- 锁的key</span></span><br><span class="line"><span class="keyword">local</span> threadId = ARGV[l]; <span class="comment">-- 线程唯一标识</span></span><br><span class="line"><span class="keyword">local</span> releaseTime = ARGV[<span class="number">2</span>]; <span class="comment">-- 锁的自动释放时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 判断是否存在</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">'exists'</span>, key) == <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 不存在，获取锁</span></span><br><span class="line">    redis.call(<span class="string">'hset'</span>, key, threadId, <span class="string">'1'</span>);</span><br><span class="line">    <span class="comment">-- 设置有效期</span></span><br><span class="line">    redis.call(<span class="string">'expire'</span>, key, releaseTime);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">-- 返回结果</span></span><br><span class="line"><span class="keyword">end</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">--锁已经存在，判断threadId是否是自己</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">'hexists'</span>, key, threadId) == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 获取锁，重入次数+1</span></span><br><span class="line">    redis.call(<span class="string">'hincrby'</span>, key, threadId, <span class="string">'1'</span>);</span><br><span class="line">    <span class="comment">-- 设置有效期</span></span><br><span class="line">    redis.call(<span class="string">'expire'</span>, key, releaseTime);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">-- 返回结果</span></span><br><span class="line"><span class="keyword">end</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">-- 代码走到这里，说明获取锁的不是自己，获取锁失收</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>释放锁</li>
</ul>
<div class="highlight-container" data-rel="Lua"><figure class="iseeu highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]; <span class="comment">-- 锁的key</span></span><br><span class="line"><span class="keyword">local</span> threadId = ARGV[l]; <span class="comment">-- 线程唯-标识</span></span><br><span class="line"><span class="keyword">local</span> releaseTime = ARGV[<span class="number">2</span>]; <span class="comment">-- 锁的自动释放时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 判断当前锁是否还是被自己持有</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">'HEXISTS'</span>, key, threadId) == <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>; <span class="comment">-- 如果已经不是自己，则直接返回</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 是自己的锁，则重入次数-1</span></span><br><span class="line"><span class="keyword">local</span> count = redis.call(<span class="string">'HINCRBY'</span>, key, threadId, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 判断是否重入次数是否已经为0</span></span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 大于0说明不能释放锁，重置有效期然后返回</span></span><br><span class="line">    redis.call(<span class="string">'EXPIRE'</span>, key, releaseTime);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">-- 等于0说明可以释放锁，直接删除</span></span><br><span class="line">    redis.call(<span class="string">'DEL'</span>, key);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>获取锁，Redisson底层源码（其实就是lua脚本）</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; RFuture&lt;T&gt; <span class="title function_">tryLockInnerAsync</span><span class="params">(<span class="type">long</span> waitTime, </span></span><br><span class="line"><span class="params">                                 <span class="type">long</span> leaseTime, </span></span><br><span class="line"><span class="params">                                 TimeUnit unit, </span></span><br><span class="line"><span class="params">                                 <span class="type">long</span> threadId, </span></span><br><span class="line"><span class="params">                                 RedisStrictCommand&lt;T&gt; command)</span> {</span><br><span class="line">    <span class="keyword">return</span> commandExecutor.syncedEval(getRawName(), LongCodec.INSTANCE, command,</span><br><span class="line">            <span class="string">"if ((redis.call('exists', KEYS[1]) == 0) "</span> +</span><br><span class="line">                <span class="string">"or (redis.call('hexists', KEYS[1], ARGV[2]) == 1)) then "</span> +</span><br><span class="line">                    <span class="string">"redis.call('hincrby', KEYS[1], ARGV[2], 1); "</span> +</span><br><span class="line">                    <span class="string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> +</span><br><span class="line">                    <span class="string">"return nil; "</span> +</span><br><span class="line">            <span class="string">"end; "</span> +</span><br><span class="line">            <span class="string">"return redis.call('pttl', KEYS[1]);"</span>,</span><br><span class="line">            Collections.singletonList(getRawName()), unit.toMillis(leaseTime), getLockName(threadId));</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>释放锁，Redisson底层源码（其实就是lua脚本）</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> RFuture&lt;Boolean&gt; <span class="title function_">unlockInnerAsync</span><span class="params">(<span class="type">long</span> threadId)</span> {</span><br><span class="line">    <span class="keyword">return</span> evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</span><br><span class="line">            	<span class="string">"if (redis.call('hexists', KEYS[1], ARGV[3]) == 0) then "</span> +</span><br><span class="line">                    <span class="string">"return nil;"</span> +</span><br><span class="line">                <span class="string">"end; "</span> +</span><br><span class="line">                <span class="string">"local counter = redis.call('hincrby', KEYS[1], ARGV[3], -1); "</span> +</span><br><span class="line">                <span class="string">"if (counter &gt; 0) then "</span> +</span><br><span class="line">                    <span class="string">"redis.call('pexpire', KEYS[1], ARGV[2]); "</span> +</span><br><span class="line">                    <span class="string">"return 0; "</span> +</span><br><span class="line">                <span class="string">"else "</span> +</span><br><span class="line">                    <span class="string">"redis.call('del', KEYS[1]); "</span> +</span><br><span class="line">                    <span class="string">"redis.call(ARGV[4], KEYS[2], ARGV[1]); "</span> + <span class="comment">// 这里publish了消息</span></span><br><span class="line">                    <span class="string">"return 1; "</span> +</span><br><span class="line">                <span class="string">"end; "</span> +</span><br><span class="line">                <span class="string">"return nil;"</span>,</span><br><span class="line">            Arrays.asList(getRawName(), getChannelName()),</span><br><span class="line">            LockPubSub.UNLOCK_MESSAGE, </span><br><span class="line">          	internalLockLeaseTime,</span><br><span class="line">          	getLockName(threadId), </span><br><span class="line">          	getSubscribeService().getPublishCommand());</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="redisson锁重试原理"><a href="#redisson锁重试原理" class="headerlink" title="redisson锁重试原理"></a>redisson锁重试原理</h3><ul>
<li>锁重试部分，利用了发布订阅机制、信号量机制。保证了CPU不会无意义的不断重试。</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码有删改</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> unit.toMillis(waitTime);</span><br><span class="line">    <span class="type">long</span> <span class="variable">current</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">long</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取剩余时间，返回null说明获取到锁</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">ttl</span> <span class="operator">=</span> tryAcquire(waitTime, leaseTime, unit, threadId);</span><br><span class="line">    <span class="keyword">if</span> (ttl == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 没拿到锁，如果已经超时，直接返回false</span></span><br><span class="line">    time -= System.currentTimeMillis() - current;</span><br><span class="line">    <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) {</span><br><span class="line">        acquireFailed(waitTime, unit, threadId);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 否则一直等待，等到有人释放锁时publish消息</span></span><br><span class="line">    current = System.currentTimeMillis();</span><br><span class="line">    CompletableFuture&lt;RedissonLockEntry&gt; subscribeFuture = subscribe(threadId);</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        subscribeFuture.get(time, TimeUnit.MILLISECONDS);</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        unsubscribe(res, threadId);</span><br><span class="line">        acquireFailed(waitTime, unit, threadId);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 开始尝试重新获取锁</span></span><br><span class="line">        <span class="comment">// 超时直接返回false</span></span><br><span class="line">        time -= System.currentTimeMillis() - current;</span><br><span class="line">        <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) {</span><br><span class="line">            acquireFailed(waitTime, unit, threadId);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 循环获取锁</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 获取到了直接返回true</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            ttl = tryAcquire(waitTime, leaseTime, unit, threadId);</span><br><span class="line">            <span class="keyword">if</span> (ttl == <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">			</span><br><span class="line">            <span class="comment">// 超时了直接返回false</span></span><br><span class="line">            time -= System.currentTimeMillis() - currentTime;</span><br><span class="line">            <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) {</span><br><span class="line">                acquireFailed(waitTime, unit, threadId);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 还有时间，继续尝试获取锁</span></span><br><span class="line">            currentTime = System.currentTimeMillis();</span><br><span class="line">            <span class="comment">// 这里采用了一种信号量的方案，getLatch返回值就是信号量</span></span><br><span class="line">            <span class="comment">// 释放锁的人，将来会释放一个信号</span></span><br><span class="line">            <span class="comment">// 我们这里也会尝试获取信号量。当然，这里也有一个最大等待时间，超时会返回false。</span></span><br><span class="line">            <span class="keyword">if</span> (ttl &gt;= <span class="number">0</span> &amp;&amp; ttl &lt; time) {</span><br><span class="line">                commandExecutor.getNow(subscribeFuture).getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                commandExecutor.getNow(subscribeFuture).getLatch().tryAcquire(time, TimeUnit.MILLISECONDS);</span><br><span class="line">            }</span><br><span class="line">			</span><br><span class="line">            <span class="comment">// 等待信号量结束后，时间充足则继续尝试，时间不足则返回失败</span></span><br><span class="line">            time -= System.currentTimeMillis() - currentTime;</span><br><span class="line">            <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) {</span><br><span class="line">                acquireFailed(waitTime, unit, threadId);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        unsubscribe(commandExecutor.getNow(subscribeFuture), threadId);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="redisson锁超时释放原理"><a href="#redisson锁超时释放原理" class="headerlink" title="redisson锁超时释放原理"></a>redisson锁超时释放原理</h3><p>Redisson是如何保证：某个线程获取到锁，的确是因为某线程释放了锁，而不是超时。避免拿到别人未释放的锁？</p>
<p>Redisson提供了一个watchDog机制，它的作用是在Redisson实例被关闭前，不断的延长锁的有效期。也就是说，如果一个拿到锁的线程一直没有完成逻辑，那么看门狗会帮助线程不断的延长锁超时时间，锁不会因为超时而被释放。Redisson默认加锁30秒，每隔10秒刷新加锁时间。</p>
<blockquote>
<p>想要触发Redisson看门狗机制，不能自定义 leaseTime（或者传参 -1）</p>
</blockquote>
<ul>
<li>总结<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/07/12/op1CA86bXwjr2yt.png" alt="image-20230712154241540"></li>
</ul>
<h3 id="redisson主从一致性问题"><a href="#redisson主从一致性问题" class="headerlink" title="redisson主从一致性问题"></a>redisson主从一致性问题</h3><p>举例：主机宕机，某个锁来不及写到从机，出现问题</p>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/07/12/EW5gdGfszr8tU19.png" alt="image-20230712155155957" style="zoom: 50%;">

<p>解决方案：没有主从（也可以建一点从节点），向所有节点都获取锁才有效。只要有一个节点还活着，就不会拿到别人的锁。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/07/12/CVTBNXDPIzkZdqr.png" alt="image-20230712155714147"></p>
<p>代码实现</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient1</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">    config.useSingleServer().setAddress(<span class="string">"redis://127.0.0.1:6379"</span>).setPassword(<span class="string">"12345678"</span>);</span><br><span class="line">    <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient2</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">    config.useSingleServer().setAddress(<span class="string">"redis://127.0.0.1:6380"</span>).setPassword(<span class="string">"12345678"</span>);</span><br><span class="line">    <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient3</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">    config.useSingleServer().setAddress(<span class="string">"redis://127.0.0.1:6381"</span>).setPassword(<span class="string">"12345678"</span>);</span><br><span class="line">    <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建联锁</span></span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock1</span> <span class="operator">=</span> redissonClient1.getLock(<span class="string">":order"</span>);</span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock2</span> <span class="operator">=</span> redissonClient2.getLock(<span class="string">":order"</span>);</span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock3</span> <span class="operator">=</span> redissonClient3.getLock(<span class="string">":order"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种方法：本质和第二种一样</span></span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient1.getMultiLock(lock1, lock2, lock3);</span><br><span class="line"><span class="comment">// 第二种方法</span></span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedissonMultiLock</span>(lock1, lock2, lock3)</span><br></pre></td></tr></table></figure></div>

<p>当设置多个锁时，redission会将多个锁添加到一个集合中，然后用while循环去不停去尝试拿锁。</p>
<p>但是会有一个总共的加锁时间，这个时间是用需要加锁的个数 * 1500ms ，假设有3个锁，那么时间就是4500ms。</p>
<p>假设在这4500ms内，所有的锁都加锁成功， 那么此时才算是加锁成功。</p>
<p>如果在4500ms有线程加锁失败，则会再次去进行重试。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/07/12/15TXHyObSANmKv9.png" alt="1653553093967"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>普通Redis分布式锁</p>
<ul>
<li>原理：利用setnx的互斥性；利用expire避免死锁；释放锁时判断线程标识</li>
<li>缺陷：不可重入、无法重试、锁超时失效</li>
</ul>
<p>Redisson分布式锁原理</p>
<ul>
<li><strong>可重入</strong>：利用hash结构记录线程id和重入次数</li>
<li><strong>可重试</strong>：利用PubSub和信号量机制实现：等待、唤醒、获取锁失败的重试机制</li>
<li><strong>锁超时释放</strong>：利用watchDog，获取锁后每隔一段时间（releaseTime/3），重置超时时间</li>
<li><strong>主从一致性（multiLock）</strong>：多个独立的Redis节点，必须所有节点都获取重入锁，才算获取成功</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
        <category>实战</category>
      </categories>
      <tags>
        <tag>Redis实战系列</tag>
      </tags>
  </entry>
  <entry>
    <title>Java泛型上下限</title>
    <url>//post/3373/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Java中支持泛型机制。泛型的本质是参数化类型，即所操作的数据类型被指定为一个参数。</p>
<p>泛型信息只存在于代码编译阶段，在Java的运行期（已经生成字节码文件后）会被擦除掉，专业术语叫做类型擦除。</p>
<p>Java 泛型中的 <code>extends</code> 和 <code>super</code> 是用来限制泛型类型参数的上限和下限的关键字。</p>
<p>原文地址：<a href="https://xuedongyun.cn/post/3373/">https://xuedongyun.cn/post/3373/</a></p>
<h2 id="T的用法"><a href="#T的用法" class="headerlink" title="T的用法"></a>T的用法</h2><ul>
<li>可以作用在类上</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&lt;T&gt; {</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">function</span><span class="params">(List&lt;T&gt; data)</span> {</span><br><span class="line">        <span class="keyword">return</span> data.get(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Test&lt;String&gt; test = <span class="keyword">new</span> <span class="title class_">Test</span>&lt;&gt;(); <span class="comment">// 在类初始化时，就已经定死T的类型</span></span><br><span class="line">test.function(list);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>也可以作用在方法上</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> {</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">function</span><span class="params">(List&lt;T&gt; data)</span> {</span><br><span class="line">        <span class="keyword">return</span> data.get(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>&lt;&gt;();</span><br><span class="line">test.function(list); <span class="comment">// 自动完成类型推断</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>还可以使用<code>extends</code>限制：T类型为某类型的子类</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(T number)</span> {</span><br><span class="line">    System.out.println(number.intValue());</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="的用法"><a href="#的用法" class="headerlink" title="?的用法"></a>?的用法</h2><ul>
<li><code>&lt;? extends T&gt;</code>：是指 “上界通配符”</li>
<li><code>&lt;? super T&gt;</code>：是指 “下界通配符”</li>
</ul>
<p>这两个用法令我们在使用带泛型类型的容器时，能很方便的处理容器内部泛型类型的多态问题</p>
<h3 id="为什么使用"><a href="#为什么使用" class="headerlink" title="为什么使用"></a>为什么使用</h3><p>我们为什么要使用通配符和边界呢？我们来看一个例子：</p>
<p>假设我们的继承关系如下：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Food</span> { }</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fruit</span> <span class="keyword">extends</span> <span class="title class_">Food</span> { }</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> <span class="keyword">extends</span> <span class="title class_">Fruit</span> { }</span><br></pre></td></tr></table></figure></div>

<p>现在我们有一个盘子类，可以用来装水果</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Plate</span>&lt;T&gt; {</span><br><span class="line">    <span class="keyword">private</span> T item;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getItem</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setItem</span><span class="params">(T item)</span> {</span><br><span class="line">        <span class="built_in">this</span>.item = item;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>理论上，我们有一个装水果的盘子，当然也能用来装苹果对吧？然而事实是，Java编译器会报错。即：即使容器里装的东西有继承关系，但容器之间并没有继承关系。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Plate&lt;Fruit&gt; applePlate = <span class="keyword">new</span> <span class="title class_">Plate</span>&lt;Apple&gt;(); <span class="comment">// 编译器报错</span></span><br></pre></td></tr></table></figure></div>

<p>为了让容器的泛型用起来更舒服，<code>&lt;? extends T&gt;</code>和<code>&lt;? super T&gt;</code>应运而生</p>
<h3 id="上界-extends"><a href="#上界-extends" class="headerlink" title="上界(extends)"></a>上界(extends)</h3><p><code>&lt;? extends T&gt;</code>：表示只能存放T的子类型（包括T）</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Plate&lt;? <span class="keyword">extends</span> <span class="title class_">Fruit</span>&gt; plate = <span class="keyword">new</span> <span class="title class_">Plate</span>&lt;Apple&gt;();</span><br></pre></td></tr></table></figure></div>

<p>上界不能往里存，只能往外取（以父类作为类型）</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Plate&lt;? <span class="keyword">extends</span> <span class="title class_">Fruit</span>&gt; plate = <span class="keyword">new</span> <span class="title class_">Plate</span>&lt;Apple&gt;();</span><br><span class="line"></span><br><span class="line">plate.setItem(<span class="keyword">new</span> <span class="title class_">Fruit</span>()); <span class="comment">// 不能往里存</span></span><br><span class="line"></span><br><span class="line"><span class="type">Food</span> <span class="variable">item</span> <span class="operator">=</span> plate.getItem(); <span class="comment">// 可以往外取（以父类作为类型）</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>原因：</p>
<p>编译器只知道容器内是Fruit或者它的派生类，但具体是什么类型不知道。可能是Fruit？可能是Apple？也可能是Banana？即使编译器在看到后面用Plate赋值以后，盘子里也没有被标上有“Apple”。而是标上一个占位符：CAP#1，来表示捕获一个Food或Food的子类，具体是什么类不知道。无论是想往里插入Apple或者Fruit或者Food编译器都不知道能不能和这个CAP#1匹配，所以就都不允许。</p>
<p>这是为了泛型安全，因为其会在编译期间生成桥接方法<code>&lt;Bridge Methods&gt;</code>该方法中会出现强制转换，若出现多种子类型，则会强制转换失败</p>
<p>虽然不能添加元素，但是其中的元素都有一个共性：有相同的父类。所以可以在获取元素时，统一转化为父类取出。</p>
</blockquote>
<h3 id="下界-super"><a href="#下界-super" class="headerlink" title="下界(super)"></a>下界(super)</h3><p><strong><code>&lt;? super T&gt;</code>：表示只能存放T的父类型（包括T）</strong></p>
<p>下界能往里存，但往外取只能取Object</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Plate&lt;? <span class="built_in">super</span> Fruit&gt; plate = <span class="keyword">new</span> <span class="title class_">Plate</span>&lt;Food&gt;();</span><br><span class="line"></span><br><span class="line">plate.setItem(<span class="keyword">new</span> <span class="title class_">Fruit</span>());	<span class="comment">// 可以存放子类</span></span><br><span class="line">plate.setItem(<span class="keyword">new</span> <span class="title class_">Apple</span>());</span><br><span class="line"></span><br><span class="line"><span class="type">Object</span> <span class="variable">item</span> <span class="operator">=</span> plate.getItem(); <span class="comment">// 只能取Object</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>由于存放的都是T的父类（包括T），添加元素时，只能向其添加T的子类，才能保证转化为T类型时是类型安全的。</p>
<p>但其中的元素类型众多，在获取元素时我们无法判断是哪一种类型，只有所有类的基类Object对象才能装下。</p>
</blockquote>
<h3 id="PECS原则"><a href="#PECS原则" class="headerlink" title="PECS原则"></a>PECS原则</h3><p>Producer Extends Consumer Super</p>
<ul>
<li>频繁往外读取内容的，适合用上界extends</li>
<li>经常往里插入的，适合用下界super</li>
</ul>
<h3 id="方便容器使用"><a href="#方便容器使用" class="headerlink" title="方便容器使用"></a>方便容器使用</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只能往外读，读取类型为父类</span></span><br><span class="line">Plate&lt;? <span class="keyword">extends</span> <span class="title class_">Fruit</span>&gt; plate = <span class="keyword">new</span> <span class="title class_">Plate</span>&lt;Apple&gt;();</span><br><span class="line"><span class="type">Food</span> <span class="variable">item</span> <span class="operator">=</span> plate.getItem();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只能往里存，存放类型为T的子类。读取只能读为Object</span></span><br><span class="line">Plate&lt;? <span class="built_in">super</span> Fruit&gt; plate = <span class="keyword">new</span> <span class="title class_">Plate</span>&lt;Food&gt;();</span><br><span class="line">plate.setItem(<span class="keyword">new</span> <span class="title class_">Fruit</span>());</span><br><span class="line">plate.setItem(<span class="keyword">new</span> <span class="title class_">Apple</span>());</span><br><span class="line"><span class="type">Object</span> <span class="variable">item</span> <span class="operator">=</span> plate.getItem();</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中List.of与Arrays.asList的区别</title>
    <url>//post/8447/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Java中List.of和Arrays.asList都可以用来快速创建一个List容器</p>
<p>在Java中<code>List.of</code>和<code>Arrays.asList</code>都可以用来快速创建一个<code>List</code>容器</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接创建</span></span><br><span class="line">List&lt;Integer&gt; list1 = List.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">List&lt;Integer&gt; list2 = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从数组创建</span></span><br><span class="line">Integer[] ints = {<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>};</span><br><span class="line">List&lt;Integer&gt; list1 = List.of(ints);</span><br><span class="line">List&lt;Integer&gt; list2 = Arrays.asList(ints);</span><br></pre></td></tr></table></figure></div>

<p>原文地址：<a href="https://xuedongyun.cn/post/8447/">https://xuedongyun.cn/post/8447/</a></p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p><code>List.of</code>和<code>Arrays.asList</code>的区别在于：</p>
<table>
<thead>
<tr>
<th></th>
<th>List.of</th>
<th>Arrays.asList</th>
</tr>
</thead>
<tbody><tr>
<td>能否包含null</td>
<td>不可以</td>
<td>可以</td>
</tr>
<tr>
<td>能否修改</td>
<td>不可以</td>
<td>可以</td>
</tr>
<tr>
<td>修改原数组是否影响List</td>
<td>不影响</td>
<td>影响</td>
</tr>
</tbody></table>
<h2 id="List-of不能包含null的原因"><a href="#List-of不能包含null的原因" class="headerlink" title="List.of不能包含null的原因"></a>List.of不能包含null的原因</h2><ul>
<li><code>List.of</code>源代码中明确有写，不能包含null</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SafeVarargs</span></span><br><span class="line"><span class="meta">@SuppressWarnings("varargs")</span></span><br><span class="line"><span class="keyword">static</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">of</span><span class="params">(E... elements)</span> {</span><br><span class="line">    <span class="keyword">switch</span> (elements.length) { <span class="comment">// implicit null check of elements</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="meta">@SuppressWarnings("unchecked")</span></span><br><span class="line">            <span class="type">var</span> <span class="variable">list</span> <span class="operator">=</span> (List&lt;E&gt;) ImmutableCollections.EMPTY_LIST;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ImmutableCollections</span>.List12&lt;&gt;(elements[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ImmutableCollections</span>.List12&lt;&gt;(elements[<span class="number">0</span>], elements[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> ImmutableCollections.listFromArray(elements);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SafeVarargs</span></span><br><span class="line"><span class="keyword">static</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">listFromArray</span><span class="params">(E... input)</span> {</span><br><span class="line">    </span><br><span class="line">    E[] tmp = (E[])<span class="keyword">new</span> <span class="title class_">Object</span>[input.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; input.length; i++) {</span><br><span class="line">        <span class="comment">// 元素不能为null，否则抛出错误</span></span><br><span class="line">        tmp[i] = Objects.requireNonNull(input[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ListN</span>&lt;&gt;(tmp, <span class="literal">false</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="List-of不能修改的原因"><a href="#List-of不能修改的原因" class="headerlink" title="List.of不能修改的原因"></a>List.of不能修改的原因</h2><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 底层存储的数组用final修饰</span></span><br><span class="line"><span class="meta">@Stable</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> E[] elements;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">ListN</span><span class="params">(E[] elements, <span class="type">boolean</span> allowNulls)</span> {</span><br><span class="line">    <span class="built_in">this</span>.elements = elements;</span><br><span class="line">    <span class="built_in">this</span>.allowNulls = allowNulls;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="原数组是否影响List的原因"><a href="#原数组是否影响List的原因" class="headerlink" title="原数组是否影响List的原因"></a>原数组是否影响List的原因</h2><p>对<code>List.of</code>而言，底层创建了新的<code>new Object[]</code>，所以修改数组不影响<code>List</code></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SafeVarargs</span></span><br><span class="line"><span class="keyword">static</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">listFromArray</span><span class="params">(E... input)</span> {</span><br><span class="line">    <span class="comment">// 新建了数组，并复制了值</span></span><br><span class="line">    E[] tmp = (E[])<span class="keyword">new</span> <span class="title class_">Object</span>[input.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; input.length; i++) {</span><br><span class="line">        <span class="comment">// 元素不能为null，否则抛出错误</span></span><br><span class="line">        tmp[i] = Objects.requireNonNull(input[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ListN</span>&lt;&gt;(tmp, <span class="literal">false</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>对<code>Arrays.asList</code>而言，直接使用了传入的数组作为底层存储，所以修改数组影响<code>List</code></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">asList</span><span class="params">(T... a)</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(a);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList(E[] array) {</span><br><span class="line">    a = Objects.requireNonNull(array);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只要传入的数组不是null就行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">requireNonNull</span><span class="params">(T obj)</span> {</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="Arrays-asList常见错误"><a href="#Arrays-asList常见错误" class="headerlink" title="Arrays.asList常见错误"></a>Arrays.asList常见错误</h2><h3 id="Arrays-asList修改"><a href="#Arrays-asList修改" class="headerlink" title="Arrays.asList修改"></a>Arrays.asList修改</h3><p><code>Arrays.asList()</code>返回的是一个固定大小的List，这个List对象是通过Arrays内部类ArrayList（也叫ArrayList！）创建的</p>
<p>这个List不支持修改元素大小（add和remove方法），修改会报异常： <code>java.lang.UnsupportedOperationException</code></p>
<p>原因：<code>Arrays</code>内部类<code>ArrayList</code>其实是<strong>直接使用了原始的数组</strong>，因为共享了数组，相互修改容易产生 Bug</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错：UnsupportedOperationException</span></span><br><span class="line">list.add(<span class="number">222</span>);</span><br></pre></td></tr></table></figure></div>

<p>解决方法1：使用ArrayList来进行转换</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] ints = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};</span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(ints);</span><br><span class="line">ArrayList&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list);</span><br></pre></td></tr></table></figure></div>

<p>解决方法2：使用Collections.addAll()</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] ints = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};</span><br><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(ints.length);</span><br><span class="line">Collections.addAll(list, ints);</span><br></pre></td></tr></table></figure></div>

<p>解决方法3：使用Stream</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] ints = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};</span><br><span class="line">List&lt;Integer&gt; list = Stream.of(ints).toList();</span><br></pre></td></tr></table></figure></div>

<h3 id="原生类型数组作为参数"><a href="#原生类型数组作为参数" class="headerlink" title="原生类型数组作为参数"></a>原生类型数组作为参数</h3><p><code>asList</code>方法的签名为：<code>public static &lt;T&gt; List&lt;T&gt; asList(T... a)</code>，需要匹配参数类型T，但是原生属性是没有这个类型的。所以当传入一个原生数据类型数组时，asList得到的真正参数不是数组中的元素，而是数组本身！</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] ints = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建的List的元素类型为int[]，而不是int</span></span><br><span class="line">List&lt;<span class="type">int</span>[]&gt; list = Arrays.asList(ints);</span><br></pre></td></tr></table></figure></div>

<p>解决方法：使用包装类数组</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] ints = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};</span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(ints);</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的IO流</title>
    <url>//post/17650/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>IO流是Java中有一个重要的概念，指的是数据从一个地点到另一个地点的过程。输入输出的介质有很多，包括：文件、网络、键盘（输入）、显示器（输出）……</p>
<p>原文地址：<a href="https://xuedongyun.cn/post/17650/">https://xuedongyun.cn/post/17650/</a></p>
<h2 id="IO分类"><a href="#IO分类" class="headerlink" title="IO分类"></a>IO分类</h2><p>Java对IO操作提供了相应的API，包含在<code>java.io</code>包中。java中对流的分类包括：</p>
<ul>
<li>按流向分（站在程序的角度）<ul>
<li>输入流（Input）</li>
<li>输出流（Output）</li>
</ul>
</li>
<li>按流的处理类型分<ul>
<li>字节流</li>
<li>字符流</li>
</ul>
</li>
<li>按流的功能来分<ul>
<li>节点流（直接跟输入输出源交互）</li>
<li>处理流（对其他流包装的流：包装流）</li>
</ul>
</li>
</ul>
<h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><p>Java中，几乎所有的流都是从以下四个父类继承而来的：</p>
<table>
<thead>
<tr>
<th></th>
<th>输入流</th>
<th>输出流</th>
</tr>
</thead>
<tbody><tr>
<td><strong>字节流</strong></td>
<td>java.io.InputStream</td>
<td>java.io.OutputStream</td>
</tr>
<tr>
<td><strong>字符流</strong></td>
<td>java.io.Reader</td>
<td>java.io.Writer</td>
</tr>
</tbody></table>
<h3 id="InputStream常用方法"><a href="#InputStream常用方法" class="headerlink" title="InputStream常用方法"></a>InputStream常用方法</h3><ul>
<li><code>int available()</code>：获取流中可读字节数</li>
<li><code>int read()</code>：从流中读取一个字节（0-255，-1表示已读到末尾）</li>
<li><code>int read(byte[] b)</code>：将读取的字节存储到字节数组中，返回实际读到的长度（-1表示已读到末尾）</li>
<li><code>skip(int b)</code>：跳过指定字节</li>
</ul>
<h3 id="OutputStream常用方法"><a href="#OutputStream常用方法" class="headerlink" title="OutputStream常用方法"></a>OutputStream常用方法</h3><ul>
<li><code>write(int b)</code>:将一个字节写出到目标源</li>
<li><code>write(byte[] b)</code>：将一个字节数组写出到目标输</li>
<li><code>write(byte[] b,int offset,int len)</code>将一个字节数组，从offset开始，写出len个字节，到目标输出源</li>
</ul>
<h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><p>计算机中，所有文件都是以字节的形式存储的。因此可以使用字节流进行读写操作。</p>
<h3 id="字节输入流"><a href="#字节输入流" class="headerlink" title="字节输入流"></a>字节输入流</h3><p>JDK对于字节输入提供了一些子类：</p>
<ul>
<li><code>FileInputStream</code></li>
<li><code>ByteArrayInputStream</code></li>
<li><code>BufferedInputStream</code></li>
<li><code>ObjectInputStream</code></li>
</ul>
<h4 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h4><p><code>FileInputStream</code>是一个针对文件的输入字节流</p>
<ul>
<li>常见构造器<ul>
<li><code>FileInputStream(File file)</code>:根据文件构建</li>
<li><code>FileInputStream(String filePath)</code>：根据文件路径构建</li>
</ul>
</li>
<li>读取文件</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">"C:\\data\\Test.java"</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>((len = in.read(b)) != -<span class="number">1</span>){</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(b,<span class="number">0</span>,len);</span><br><span class="line">    System.out.println(str);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="字节输出流"><a href="#字节输出流" class="headerlink" title="字节输出流"></a>字节输出流</h3><p>JDK对于字节输出提供了一些子类：</p>
<ul>
<li><code>FileOutputStream</code></li>
<li><code>ByteArrayOutputStream</code></li>
<li><code>BufferedOutputStream</code></li>
<li><code>ObjectOutputStream</code></li>
</ul>
<h4 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h4><p><code>FileOutputStream</code>主要用于对文件进行写入操作</p>
<ul>
<li>常用构造器<ul>
<li><code>FileOutputStream(String filePath)</code>：基于一个标准文件的路径，创建对其操作的输出流</li>
<li><code>FileOutputStream(String filePath,boolean append)</code>：同上，但使用追加模式</li>
<li><code>FileOutputStream(File file)</code>：基于一个标准文件对象，创建对其操作的输出流</li>
<li><code>FileOutputStream(File file,boolean append)</code>：同上，但使用追加模式</li>
</ul>
</li>
</ul>
<blockquote>
<p>文件不存在会自动创建，文件存在会操作原有文件，目标不是文件而是目录会抛出异常</p>
</blockquote>
<ul>
<li>写文件</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用了try...with...resource语法</span></span><br><span class="line"><span class="comment">// Java中文件相对路径是相对于项目目录而言的</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">FileOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">"test.txt"</span>, <span class="literal">true</span>)) {</span><br><span class="line">    os.write(<span class="string">"你好世界"</span>.getBytes());</span><br><span class="line">} <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><h3 id="字符输入流"><a href="#字符输入流" class="headerlink" title="字符输入流"></a>字符输入流</h3><p>字符输入流一般用于对文本数据进行读取操作，常见的子类：</p>
<ul>
<li><code>InputStreamReader</code></li>
<li><code>FileReader</code></li>
<li><code>BufferedReader</code></li>
<li><code>CharArrayReader</code></li>
</ul>
<h4 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h4><p><code>FileReader</code>是一个以字符流的形式进行文件内容读取的流，从<code>InputStreamReader</code>继承而来</p>
<ul>
<li>常用构造方法<ul>
<li><code>FileReader(File file)</code>：根据文件对象，获取字符输入流</li>
<li><code>FileReader(String path)</code>：根据文件路径，获取字符输入流</li>
</ul>
</li>
<li>具体使用</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">"C:\\data\\test.txt"</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>[] ch = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((len = fr.read(ch)) != -<span class="number">1</span>){</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch, <span class="number">0</span>, len);</span><br><span class="line">    System.out.print(s);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="字符输出流"><a href="#字符输出流" class="headerlink" title="字符输出流"></a>字符输出流</h3><p>字符输出流一般用于对文本数据进行写出操作，常见的子类：</p>
<ul>
<li><code>OutputStreamWriter</code></li>
<li><code>BufferedWriter</code></li>
<li><code>CharArrayWriter</code></li>
<li><code>FileWriter</code></li>
<li><code>PrintWriter</code></li>
</ul>
<h4 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter"></a>FileWriter</h4><p>FileWriter是一个以字符流的形式进行文件内容写出的流，从<code>OutputStreamWriter</code>继承而来</p>
<ul>
<li><p>常用构造方法</p>
<ul>
<li><p><code>FileWriter(File file)</code>：根据文件对象，获取字符输出流</p>
</li>
<li><p><code>FileWriter(File file, boolean append)</code>：同上，但使用追加模式</p>
</li>
<li><p><code>FileWriter(String path)</code>：根据文件路径，获取字符输出流</p>
</li>
<li><p><code>FileWriter(String path, boolean append)</code>：同上，但使用追加模式</p>
</li>
</ul>
</li>
<li><p>具体使用</p>
</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">"readme.txt"</span>);</span><br><span class="line">fw.write(<span class="string">"你好世界"</span>);</span><br><span class="line">fw.flush(); <span class="comment">//允许在流未关闭之前，强制将字符缓冲区中的数据写出到目标输出源</span></span><br><span class="line">fw.write(<span class="string">"abcdefg"</span>);</span><br><span class="line">fw.close();</span><br></pre></td></tr></table></figure></div>

<h2 id="处理流"><a href="#处理流" class="headerlink" title="处理流"></a>处理流</h2><p>按流的功能来分类，可以分为：</p>
<ul>
<li>节点流<ul>
<li>又称低级流。直接跟输入输出源沟通</li>
</ul>
</li>
<li>处理流<ul>
<li>又称高级流或包装流。可以对其他流进行包装，以实现流的<strong>类型转换</strong>或效率的提升。</li>
<li>由<strong>缓冲流</strong>和<strong>转换流</strong>构成</li>
</ul>
</li>
</ul>
<blockquote>
<p>包装使用了23种设计模式中的：装饰器模式</p>
</blockquote>
<h3 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h3><p>缓冲流是一种自带缓冲区的流，主要有四种</p>
<ul>
<li><code>BufferedInputStream</code>：字节缓冲输入流</li>
<li><code>BufferedOutputStream</code>：字节缓冲输出流</li>
<li><code>BufferedReader</code>：字符缓冲输入流</li>
<li><code>BufferedWriter</code>：字符缓冲输出流</li>
</ul>
<blockquote>
<p>缓冲流内部使用了一个默认大小为<code>8kb</code>的字节缓冲区，每次将缓冲区的空间存满之后再将数据通过流对象完成读写操作</p>
</blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">"test.txt"</span>);</span><br><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(fis);</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">8</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((len = bis.read(b)) != -<span class="number">1</span>){</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(b, <span class="number">0</span>, len);</span><br><span class="line">    System.out.println(s);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">bis.close();</span><br></pre></td></tr></table></figure></div>

<h3 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h3><p>一些需求：</p>
<p>字节流转换为字符流、字符流转换为字节流……</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> System.in;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字节流转换为字符流</span></span><br><span class="line"><span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符流包装为缓冲流</span></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取一行</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> br.readLine();</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis基础</title>
    <url>//post/26216/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是Redis基础学习笔记</p>
<p>原文地址：<a href="https://xuedongyun.cn/post/26216/">https://xuedongyun.cn/post/26216/</a></p>
<h2 id="Redis入门概述"><a href="#Redis入门概述" class="headerlink" title="Redis入门概述"></a>Redis入门概述</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><ul>
<li><p>Remote Dictionary Server，远程字典服务器</p>
</li>
<li><p>基于内存的，k-v键值对（一种NoSQL）数据库</p>
</li>
<li><p>相关网站</p>
<ul>
<li>作者博客（有一些更新日志）：<a class="link" href="http://antirez.com/">http://antirez.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>Github仓库：<a class="link" href="https://github.com/redis/redis">https://github.com/redis/redis <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>英文官网：<a class="link" href="https://redis.io/">https://redis.io/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>中文官网：<a class="link" href="http://redis.cn/">http://redis.cn/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>中文文档：<a class="link" href="https://redis.com.cn/documentation.html">https://redis.com.cn/documentation.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>redis在线测试：<a class="link" href="https://try.redis.io/">https://try.redis.io/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>redis命令手册：<a class="link" href="http://doc.redisfans.com/">http://doc.redisfans.com/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
</li>
</ul>
<h3 id="能干什么"><a href="#能干什么" class="headerlink" title="能干什么"></a>能干什么</h3><ul>
<li><p>挡在<code>MySQL</code>前面的带刀护卫</p>
</li>
<li><p>内存存储和持久化（RDB+AOF）</p>
<ul>
<li><code>redis</code>支持异步将内存中的数据写到硬盘上，同时不影响继续服务</li>
</ul>
</li>
<li><p>高可用架构搭配</p>
<ul>
<li>单机</li>
<li>主从</li>
<li>哨兵</li>
<li>集群</li>
</ul>
</li>
<li><p>缓存穿透，击穿，雪崩（预防和处理）</p>
</li>
<li><p>分布式锁</p>
</li>
<li><p>队列</p>
</li>
<li><p>排行榜+点赞</p>
</li>
<li><p>……</p>
</li>
</ul>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul>
<li>性能极高</li>
<li>数据类型丰富，key-value，list，set，zset，hash</li>
<li>支持数据的持久化</li>
<li>支持数据的备份，即master-slave模式的数据备份</li>
</ul>
<h3 id="Redis7新特性"><a href="#Redis7新特性" class="headerlink" title="Redis7新特性"></a>Redis7新特性</h3><ul>
<li><a class="link" href="https://github.com/redis/redis/releases">https://github.com/redis/redis/releases <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>部分新特性总览<ul>
<li>Redis Functions：相当于Redis内部的lua脚本（不用了解）</li>
<li>Client-eviction：连续内存占用独立管理</li>
<li>Multi-part AOF：三个文件构成一个AOF文件（以前是一个文件）</li>
<li>ACL v2：精细化权限管理</li>
<li>新增命令<ul>
<li>新增ZMPOP，BZMPOP，LMPOP，BLMPOP等新命令</li>
<li>对于EXPIRE和SET命令，新增了更多的命令参数选项</li>
<li>需要用到再查文档即可</li>
</ul>
</li>
<li>listpack替代ziplist</li>
<li>底层性能提升</li>
</ul>
</li>
</ul>
<h3 id="Redis7安装相关"><a href="#Redis7安装相关" class="headerlink" title="Redis7安装相关"></a>Redis7安装相关</h3><ul>
<li>安装位置<code>/usr/bin</code><ul>
<li><code>redis-benchmark</code>：性能测试工具</li>
<li><code>redis-check-aof</code>：修复有问题的AOF文件</li>
<li><code>redis-check-rdb</code>：修复有问题的dump.rdb文件</li>
<li>==<code>redis-cli</code>==：客户端，操作入口</li>
<li><code>redis-sentinel</code>：Redis集群使用</li>
<li>==<code>redis-server</code>==：Redis服务器启动命令</li>
</ul>
</li>
<li>关闭<ul>
<li><code>redis</code>中：shutdown</li>
<li>单实例关闭：redis-cli -a 123456 shutdown</li>
<li>多实例，指定端口关闭：redis-cli -p 6379 shutdown</li>
</ul>
</li>
</ul>
<h2 id="Redis十大数据类型"><a href="#Redis十大数据类型" class="headerlink" title="Redis十大数据类型"></a>Redis十大数据类型</h2><p><a class="link" href="https://redis.io/docs/data-types/">https://redis.io/docs/data-types/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="总体概括"><a href="#总体概括" class="headerlink" title="总体概括"></a>总体概括</h3><ul>
<li><code>String</code><ul>
<li>最基本的类型</li>
<li>是二进制安全的，意思是可以包含任何数据，比如图片或序列化的对象</li>
<li>最大512M</li>
</ul>
</li>
<li><code>List</code><ul>
<li><code>String</code>类型的列表</li>
<li>是一个双端链表</li>
<li>最多包含2^32-1个元素（约40亿）</li>
</ul>
</li>
<li><code>Hash</code><ul>
<li><code>String</code>类型的<code>field-value</code>映射表</li>
<li>特别适合存储对象</li>
<li>最多包含2^32-1个键值对（约40亿）</li>
</ul>
</li>
<li><code>Set</code><ul>
<li><code>String</code>类型的无序集合，成员是唯一的</li>
<li>集合对象的编码可以是<code>intset</code>或<code>hashtable</code>（后面会讲）</li>
<li>底层是通过<code>Hash</code>实现的</li>
<li>最多包含2^32-1个元素（约40亿）</li>
</ul>
</li>
<li><code>Sorted set</code>(<code>zset</code>)<ul>
<li>不同的是，每个元素都会关联一个<code>double</code>类型的分数，从小到大排序</li>
</ul>
</li>
<li><code>Geospatial</code><ul>
<li>存储地理位置</li>
<li>可以操作：添加地理位置的坐标，获取地理位置的坐标，计算位置间的距离，根据给定经纬度坐标获取指定范围内地理位置集合</li>
</ul>
</li>
<li><code>Hyperlog</code><ul>
<li>基数统计</li>
<li>输入元素非常大时，计算基数所需的空间总是固定且很小的</li>
<li>每个<code>HyperLogLog</code>键只需要12KB，就可以计算<code>2^64</code>个不同元素的基数</li>
<li>只会根据输入元素计算基数，不会存储元素本身</li>
</ul>
</li>
<li><code>Bitmap</code><ul>
<li>由0，1状态表现的二进制数组</li>
</ul>
</li>
<li><code>Bitfield</code><ul>
<li>可以一次性操作多个比特位域（连续多个比特位），会执行一系列操作并返回一个响应数组</li>
</ul>
</li>
<li><code>Stream</code><ul>
<li>主要用于消息队列</li>
<li>可实现<code>redis</code>版的消息中间件</li>
</ul>
</li>
</ul>
<h3 id="命令查询"><a href="#命令查询" class="headerlink" title="命令查询"></a>命令查询</h3><ul>
<li><p>官方英文：<a class="link" href="https://redis.io/commands/">https://redis.io/commands/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</li>
<li><p>中文：<a class="link" href="http://redis.cn/commands.html">http://redis.cn/commands.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</li>
</ul>
<h3 id="常用key操作命令"><a href="#常用key操作命令" class="headerlink" title="常用key操作命令"></a>常用key操作命令</h3><ul>
<li>查看当前库所有key</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">keys *</span><br></pre></td></tr></table></figure></div>

<ul>
<li>判断某个key是否存在（返回存在个数）</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">exists k1</span><br><span class="line">exists k1 k2 k3</span><br></pre></td></tr></table></figure></div>

<ul>
<li>返回值类型</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">type k1</span><br></pre></td></tr></table></figure></div>

<ul>
<li>删除，成功返回1</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">del k1</span><br></pre></td></tr></table></figure></div>

<ul>
<li>非阻塞删除，仅将keys从keyspace元数据中删除，真正的删除将在后续异步中进行</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">unlink key</span><br></pre></td></tr></table></figure></div>

<ul>
<li>查看还有多少秒过期，-1表示永不过期，-2表示已过期</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ttl key1</span><br></pre></td></tr></table></figure></div>

<ul>
<li>为key设置过期时间</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">expire k1 100</span><br></pre></td></tr></table></figure></div>

<ul>
<li>切换数据库，index（0-15）</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 0</span><br></pre></td></tr></table></figure></div>

<ul>
<li>将当前数据库key移动到给定index（0-15）的数据库中</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">move key 2</span><br></pre></td></tr></table></figure></div>

<ul>
<li>查看当前数据库key的数量</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">dbsize</span><br></pre></td></tr></table></figure></div>

<ul>
<li>清空当前库</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">flushdb</span><br></pre></td></tr></table></figure></div>

<ul>
<li>通杀全部库</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">flushall</span><br></pre></td></tr></table></figure></div>

<h3 id="数据类型命令及落地应用"><a href="#数据类型命令及落地应用" class="headerlink" title="数据类型命令及落地应用"></a>数据类型命令及落地应用</h3><ul>
<li>命令不区分大小写，key区分</li>
<li>帮助命令</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">help @string</span><br></pre></td></tr></table></figure></div>

<h4 id="string字符串"><a href="#string字符串" class="headerlink" title="string字符串"></a>string字符串</h4><ul>
<li><p>最常用</p>
<ul>
<li><p><code>NX</code>：键不存在时才设置键值</p>
</li>
<li><p><code>XX</code>：键存在时才设置键值</p>
</li>
<li><p><code>GET</code>：返回键原本的值，原本无值返回<code>nil</code></p>
</li>
<li><p><code>EX seconds</code>：以秒为单位设置过期时间</p>
</li>
<li><p><code>PX milliseconds</code>：以毫秒为单位设置过期</p>
</li>
<li><p><code>EXAT unix-time-seconds</code>：以秒为单位的unix时间戳对应时间为过期时间</p>
</li>
<li><p><code>PXAT unix-time-milliseconds</code>：以毫秒为单位的unix时间戳对应时间为过期时间</p>
</li>
<li><p><code>KEEPTTL</code>：保留设置前指定键的生存时间</p>
</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET key value [NX | XX] [GET] [EX seconds | PX milliseconds | EXAT unix-time-seconds | PXAT unix-time-milliseconds | KEEPTTL]</span><br></pre></td></tr></table></figure></div>

<ul>
<li>同时设置/获取多个值</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">MSET k1 v1 k2 v2</span><br><span class="line">MGET k1 k2</span><br></pre></td></tr></table></figure></div>

<ul>
<li>不存在键时才设置为指定值</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SETNX key value</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">MSETNX k1 v1 k2 v2 // 类似事务，都之前不存在才能被设置成功</span><br></pre></td></tr></table></figure></div>

<ul>
<li>设置/获取指定范围的值，左右都取</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">set k1 abcdefg</span><br><span class="line">getrange k1 0 -1 // abcdefg</span><br><span class="line">getrange k1 0 4 // abcde</span><br></pre></td></tr></table></figure></div>

<ul>
<li>精准设置字符串值</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">setrange k1 1 xxyy // 从1开始变为“xxyy”</span><br></pre></td></tr></table></figure></div>

<ul>
<li>数值递增/递减</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">incr k1</span><br><span class="line">incr k1 99</span><br><span class="line">decr k1</span><br><span class="line">decr k1 99</span><br></pre></td></tr></table></figure></div>

<ul>
<li>获取字符串长度和内容追加</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">strlen k1</span><br><span class="line">append k1 abcd</span><br></pre></td></tr></table></figure></div>

<ul>
<li>分布式锁</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">setnx key value</span><br><span class="line">setex key value</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>setnx（set if not exist）</p>
<p>setex（set with expire）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">setex key seconds value // set的同时设置过期时间</span><br></pre></td></tr></table></figure></div>

<p>高阶篇再具体讲</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">setnx lock uuid</span><br><span class="line">xxxx</span><br><span class="line">del lock</span><br></pre></td></tr></table></figure></div>
</blockquote>
<ul>
<li>getset，先get再set；最后返回oldValue</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">getset k1 newValue</span><br></pre></td></tr></table></figure></div>

<h4 id="list列表"><a href="#list列表" class="headerlink" title="list列表"></a>list列表</h4><blockquote>
<p>底层是一个双端链表</p>
</blockquote>
<ul>
<li>入队以及遍历</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">lpush list1 1 2 3 4 // 返回修改数</span><br><span class="line">rpush list2 1 2 3 4</span><br><span class="line">lrange list start end // 一定范围内遍历，没有rrange</span><br></pre></td></tr></table></figure></div>

<ul>
<li>出队</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">lpop list1</span><br><span class="line">rpop list1</span><br></pre></td></tr></table></figure></div>

<ul>
<li>根据索引取值</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">lindex list1 0 // 没有rindex</span><br></pre></td></tr></table></figure></div>

<ul>
<li>从左边开始，删除最多num个值为value的项</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">lrem key num value</span><br></pre></td></tr></table></figure></div>

<ul>
<li>截取指定范围的值，代替原有值</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ltrim key start end</span><br></pre></td></tr></table></figure></div>

<ul>
<li>源列表右侧出队，目标列表左侧入队</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpoplpush source destination // 返回修改的那个值</span><br></pre></td></tr></table></figure></div>

<ul>
<li>设置对应索引的值</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">lset key index value</span><br></pre></td></tr></table></figure></div>

<ul>
<li>在已有值（从左开始找到的第一个）前/后插入新值</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">linsert key before/after 已有值 新值</span><br></pre></td></tr></table></figure></div>

<h4 id="hash哈希"><a href="#hash哈希" class="headerlink" title="hash哈希"></a>hash哈希</h4><blockquote>
<p>Map&lt;String, Map&lt;String, Object&gt;&gt;</p>
</blockquote>
<ul>
<li>基本操作</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">hset key field1 value1 field2 value2 // 返回修改field的数量</span><br><span class="line">hget key field</span><br><span class="line">hmget key field1 field2</span><br><span class="line">hgetall key</span><br><span class="line">hdel key field1 field2</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>hmset已被弃用，使用hset代替</p>
</blockquote>
<ul>
<li>获取某个key，field的数量</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">hlen key</span><br></pre></td></tr></table></figure></div>

<ul>
<li>某个key是否存在某个field，返回0或1</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexists key field</span><br></pre></td></tr></table></figure></div>

<ul>
<li>获取某个key中所有field/value</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">hkeys k1</span><br><span class="line">hvals k1</span><br></pre></td></tr></table></figure></div>

<ul>
<li>值增加</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">hincrby key field value // 整数，返回修改后的值</span><br><span class="line">hincrbyfloat key field value // 小数，返回修改后的值</span><br></pre></td></tr></table></figure></div>

<ul>
<li>不存在才赋值</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">hsetnx key field value // 返回0或1</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>应用场景：购物车（现在不这样做了，中小厂可以这样做）</p>
<ul>
<li>新增商品</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">hset shopcar:uid1024 334488 1</span><br><span class="line">hset shopcar:uid1024 334477 1</span><br></pre></td></tr></table></figure></div>

<ul>
<li>增加商品数量</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">hincrby shopcar:uid1024 334488 1</span><br></pre></td></tr></table></figure></div>

<ul>
<li>商品总数</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">hlen shopcar:uuid1024</span><br></pre></td></tr></table></figure></div>

<ul>
<li>全选</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">hgetall shopcar:uuid1024</span><br></pre></td></tr></table></figure></div>
</blockquote>
<h4 id="set集合"><a href="#set集合" class="headerlink" title="set集合"></a>set集合</h4><ul>
<li>添加元素</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sadd key member1 member2</span><br></pre></td></tr></table></figure></div>

<ul>
<li>删除元素</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">srem key member1 member2</span><br></pre></td></tr></table></figure></div>

<ul>
<li>遍历所有元素</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">smenbers key</span><br></pre></td></tr></table></figure></div>

<ul>
<li>判断元素是否在集合中</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sismember key member</span><br></pre></td></tr></table></figure></div>

<ul>
<li>统计元素数量</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">scard key</span><br></pre></td></tr></table></figure></div>

<ul>
<li>从集合中随机展现指定个数个元素</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">srandmember key 5</span><br></pre></td></tr></table></figure></div>

<ul>
<li>从集合中随机弹出指定个数个元素，元素会被删除</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">spop key 5</span><br></pre></td></tr></table></figure></div>

<ul>
<li>将一个元素从一个set移动到另外一个set，返回0或1</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">smove source destination member</span><br></pre></td></tr></table></figure></div>

<ul>
<li>集合运算</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 差集运算：A - B - C</span><br><span class="line">sdiff key1 key2 key3</span><br><span class="line"></span><br><span class="line">// 并集运算：A ∪ B ∪ C</span><br><span class="line">sunion key1 key2 key3</span><br><span class="line"></span><br><span class="line">// 交集运算：A ∩ B ∩ C</span><br><span class="line">sinter key1 key2 key3</span><br><span class="line">sintercard numkeys key [key ...] // redis7.0新出的，返回交集运算结果的基数</span><br><span class="line">sintercard 2 set1 set2</span><br><span class="line">sintercard 2 set1 set2 limit 4 // 可以设置上限</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>应用场景：</p>
<p>微信抽奖小程序：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sadd key userId		// 立即参与</span><br><span class="line">scard key			// 统计参与人次</span><br><span class="line">srandmember key 2	// 随机抽奖2个人，元素不删除（中奖可重复）</span><br><span class="line">spop key 2			// 随机抽奖2个人，元素删除（中奖不可重复）</span><br></pre></td></tr></table></figure></div>

<p>朋友圈点赞</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sadd pub:msgId userId1 userId2	// 新增点赞</span><br><span class="line">srem pub:msgId userId1			// 取消点赞</span><br><span class="line">smembers pub:msgId				// 展现所有点赞用户</span><br><span class="line">scard pub:msgId					// 点赞数</span><br><span class="line">sismember pub:msgId userId1		// 判断是否点赞过</span><br></pre></td></tr></table></figure></div>

<p>qq可能认识的人</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sadd s1 1 2 3 4 5</span><br><span class="line">sadd s2 3 4 5 6 7</span><br><span class="line">sinter s1 s2	// 共同认识</span><br><span class="line">sdiff s1 s2		// s2可能认识</span><br><span class="line">sdiff s2 s1		// s1可能认识</span><br></pre></td></tr></table></figure></div>
</blockquote>
<h4 id="zset有序集合"><a href="#zset有序集合" class="headerlink" title="zset有序集合"></a>zset有序集合</h4><blockquote>
<p>在set基础上，每个val值前加上一个score分数</p>
</blockquote>
<ul>
<li>基础</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">set v1 v2 </span><br><span class="line">zset score1 v1 score2 v2 </span><br></pre></td></tr></table></figure></div>

<ul>
<li>添加元素</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">zadd zset1 60 v1 70 v2 30 v3</span><br></pre></td></tr></table></figure></div>

<ul>
<li>遍历元素</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 元素排序从小到大</span><br><span class="line">zrange zset1 0 -1</span><br><span class="line">zrange zset1 0 -1 withscores // 带分数的遍历</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 元素排序从大到小</span><br><span class="line">zrevrange zset1 0 -1</span><br><span class="line">zrevrange zset1 0 -1 withscores // 带分数的遍历</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">zrangebyscore key 60 90		// 指定分数范围内</span><br><span class="line">zrangebyscore key ( 60 90	// 不包含60 </span><br><span class="line">zrangebyscore key 60 ( 90	// 不包含90 </span><br><span class="line">zrangebyscore key 60 90 limit 0 6	// 类似分页，从0开始6个</span><br></pre></td></tr></table></figure></div>

<ul>
<li>查询score</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">zscore key member	// 返回分值</span><br></pre></td></tr></table></figure></div>

<ul>
<li>获取元素个数</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">zcard key</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">zcount key min max // 指定分数范围元素个数</span><br></pre></td></tr></table></figure></div>

<ul>
<li>删除元素</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">zrem key member1 member2 // 返回删除个数</span><br></pre></td></tr></table></figure></div>

<ul>
<li>增加分数</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">zincrby key 3 member // 增加某个元素的分数</span><br></pre></td></tr></table></figure></div>

<ul>
<li>弹出元素</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ZMPOP numkeys key [key ...] &lt;MIN | MAX&gt; [COUNT count]</span><br><span class="line">// 从小到大or从大到小，弹出指定数量的元素</span><br><span class="line">// count负责控制弹出多少，不写默认为1</span><br></pre></td></tr></table></figure></div>

<ul>
<li>获取下标值</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">zrank key value		// 从小到大</span><br><span class="line">zrevrank key value	// 从大到小</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>应用场景：</p>
<p>根据商品销量进行排序</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">zadd goods:sellsort 9 1001 15 1002</span><br><span class="line">zrange goods:sellsort 0 10 with scores	// 销量前十</span><br><span class="line">zincrby goods:sellsort 2 1001			// 1001商品销量加2</span><br><span class="line">zrange goods:sellsort 0 10 with scores	// 销量前十</span><br></pre></td></tr></table></figure></div>

</blockquote>
<h4 id="bitmap位图"><a href="#bitmap位图" class="headerlink" title="bitmap位图"></a>bitmap位图</h4><blockquote>
<p>由0和1状态表现的二进制数组</p>
<p>底层基于string类型，按位操作</p>
</blockquote>
<ul>
<li>设置</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">setbit key offset value // value只能是0或1</span><br><span class="line"></span><br><span class="line">setbit k1 0 1</span><br><span class="line">setbit k1 1 1</span><br><span class="line">setbit k1 2 1</span><br><span class="line">setbit k1 3 0</span><br><span class="line">type k1 // string</span><br></pre></td></tr></table></figure></div>

<ul>
<li>获取值</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">getbit k1 0</span><br><span class="line">getbit k1 1</span><br><span class="line">getbit k1 2</span><br></pre></td></tr></table></figure></div>

<ul>
<li>strlen</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 底层是string，超过8位后，按照8位一组（1 byte）扩容</span><br><span class="line">setbit k2 0 1</span><br><span class="line">setbit k2 7 1</span><br><span class="line">strlen k2		// 1</span><br><span class="line">setbit k2 8 1</span><br><span class="line">strlen k2		// 2</span><br></pre></td></tr></table></figure></div>

<ul>
<li>bitcount</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">bitcount key	// 全部1的个数</span><br></pre></td></tr></table></figure></div>

<ul>
<li>进行位操作（and or xor not）</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 最终结果将放到destkey中</span><br><span class="line">BITOP &lt;AND | OR | XOR | NOT&gt; destkey key [key ...] // 返回0或1指示是否成功</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>应用场景：签到</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">setbit sign:u1:202106 0 1	// 某用户21年6月，第一天签到了</span><br><span class="line">setbit sign:u1:202106 1 1</span><br><span class="line">setbit sign:u1:202106 2 1</span><br><span class="line">setbit sign:u1:202106 29 1</span><br><span class="line"></span><br><span class="line">getbit sign:u1:202106 2		// 第二天来没来</span><br><span class="line">bitcount sign:u1:202106		// 21年6月来了多少天</span><br></pre></td></tr></table></figure></div>
</blockquote>
<h4 id="hyperloglog基数统计"><a href="#hyperloglog基数统计" class="headerlink" title="hyperloglog基数统计"></a>hyperloglog基数统计</h4><blockquote>
<p>用来做基数统计的，在输入元素的数量或体积特别大时，计算基数所需的空间总是固定且很小的</p>
<p>每个<code>HyperLogLog</code>键只需要花费<code>12KB</code>，就可以计算<code>2^64</code>个不同元素的基数（标准误差0.81%）</p>
<p>底层类型<code>string</code></p>
<ul>
<li>基数：一种数据集，去重后的真实个数</li>
</ul>
</blockquote>
<ul>
<li>添加指定元素到HyperLogLog</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">pfadd key element1 element2</span><br></pre></td></tr></table></figure></div>

<ul>
<li>返回给定HyperLogLog的基数估算值</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">pfcount key</span><br></pre></td></tr></table></figure></div>

<ul>
<li>将多个HyperLogLog合并为同一个</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">pfmerge destkey sourcekey1 sourcekey2 sourcekey3</span><br></pre></td></tr></table></figure></div>

<h4 id="geo地理空间"><a href="#geo地理空间" class="headerlink" title="geo地理空间"></a>geo地理空间</h4><blockquote>
<p>底层zset类型</p>
</blockquote>
<ul>
<li>添加经纬度坐标<ul>
<li>解决中文乱码问题：redis-cli -a 111111 –raw</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">geoadd city 116.403963 39.915119 天安门 116.403414 39.924091 故宫 116.024067 40.362639 长城 // 返回添加的个数</span><br></pre></td></tr></table></figure></div>

<ul>
<li>返回经纬度</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">geopos key member1 member2 member3</span><br></pre></td></tr></table></figure></div>

<ul>
<li>返回坐标的geohash表示<ul>
<li>geohash算法生成的base32编码值</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">geohash key member1 member2 member3</span><br></pre></td></tr></table></figure></div>

<ul>
<li>返回距离</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">geodist key member1 member2 [m|km|ft|mi]</span><br></pre></td></tr></table></figure></div>

<ul>
<li>查找指定半径中的位置<ul>
<li>withdist：返回距离</li>
<li>withcoord：返回坐标</li>
<li>withhash：返回位置经过geohash编码后的值</li>
<li>count：限定返回记录数</li>
<li>asc/desc：由近到远/由远到近</li>
<li>store/storedist：将结果保存到zset，前者score是geohash值，后者是距离</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">GEORADIUS key longitude latitude radius &lt;M | KM | FT | MI&gt;</span><br><span class="line">  [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count [ANY]] [ASC | DESC]</span><br><span class="line">  [STORE key] [STOREDIST key]</span><br></pre></td></tr></table></figure></div>

<h4 id="stream流"><a href="#stream流" class="headerlink" title="stream流"></a>stream流</h4><blockquote>
<p>就是redis版本的消息中间件（MQ）+阻塞队列</p>
<ul>
<li>list实现消息队列：<ul>
<li>用来做异步队列</li>
<li>点对点模式</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">lpush mylist a b c d e</span><br><span class="line">rpop mylist</span><br><span class="line">rpop mylist</span><br></pre></td></tr></table></figure></div>

<ul>
<li>pub/sub发布和订阅机制实现消息队列：<ul>
<li>一对多模式</li>
<li>缺点：消息无法持久化，如果网络断开，宕机等，消息就会丢失；而且也没有ACK机制保证数据可靠性</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li><p>能干什么</p>
<ul>
<li>实现消息队列</li>
<li>支持消息持久化</li>
<li>支持自动生成全局唯一id</li>
<li>支持ack确定消息的模式</li>
<li>支持消费组模式</li>
<li>…让消息队列更加稳定可靠</li>
</ul>
</li>
<li><p>底层结构</p>
<ul>
<li>一个消息链表，每个消息都有唯一id和相应内容</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>内涵</th>
</tr>
</thead>
<tbody><tr>
<td>Message Content</td>
<td>消息内容</td>
</tr>
<tr>
<td>Consumer group</td>
<td>消费组，通过xgroup create命令创建，同一个消费组可以有多个消费者</td>
</tr>
<tr>
<td>Last_delivered_id</td>
<td>游标，每个消费组都有一个，任意消费者读取了消息都会使游标往前移</td>
</tr>
<tr>
<td>Consumer</td>
<td>消费者，消费组中的消费者</td>
</tr>
<tr>
<td>Pending_ids</td>
<td>消费者会有一个状态变量，用于记录已读取未ack的消息id。<br>如果客户端没有ack，这个变量中的id会越来越多；一旦某个消息被ack，它就开始减少。<br>这个变量Redis官方称之为PEL（Pending），记录当前已被客户端读取，但还没有ack的消息。<br>它用来确保客户端至少消费了消息一次，而不会在网络传输的过程中丢失了没处理</td>
</tr>
</tbody></table>
<h5 id="队列相关指令"><a href="#队列相关指令" class="headerlink" title="队列相关指令"></a>队列相关指令</h5><ul>
<li>添加消息到队列末尾<ul>
<li>消息id必须比上一个大</li>
<li>*表示自动生成规矩（让系统自动生成id）</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">xadd mystream * k1 v1 k2 v2 // 返回消息id："1678332037505-0"，该毫秒下第0条消息</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>如果当前毫秒时间戳比以前已存在的小，系统会采用以前相同的毫秒创建新的id（自动纠错）</p>
<p>redis对id有强制要求，格式必须是==时间戳-自增id==，且后续id不能小于前一个</p>
</blockquote>
<ul>
<li>遍历所有消息</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">xrange key start end [count num] // -表示开始值，+表示结束值</span><br><span class="line">xrange key - + count 2</span><br><span class="line">xrevrange key + - count 2</span><br></pre></td></tr></table></figure></div>

<ul>
<li>删除消息</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">xdel key id</span><br></pre></td></tr></table></figure></div>

<ul>
<li>获取消息队列长度</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">xlen key</span><br></pre></td></tr></table></figure></div>

<ul>
<li>对stream长度进行截取，如超长会截取</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// maxlen: 允许的最大长度</span><br><span class="line">// minid：允许的最小id</span><br><span class="line">xtrim key maxlen 2 minid 1678332037505-0</span><br></pre></td></tr></table></figure></div>

<ul>
<li>读取消息</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// COUNT: 最多读取多少条信息</span><br><span class="line">// BLOCK: 是否堵塞的方式读取消息，默认不阻塞；如果miliseconds设为0，表示永远堵塞</span><br><span class="line">xread [COUNT count] [BLOCK miliseconds] streams key1 key2 key3</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">xread count 2 streams mystream $	// $是特殊id，表示stream已经存储的最大id的后一个id。此处返回nil</span><br><span class="line">xread count 2 streams mystream 0-0	// 0-0代表从最小id开始获取stream中的消息，也可使用0;00;000</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">xread count 1 block 0 streams mystream $	// 阻塞等待，一直等到出现新的id。还会返回等待时间</span><br></pre></td></tr></table></figure></div>

<h5 id="消费组相关指令"><a href="#消费组相关指令" class="headerlink" title="消费组相关指令"></a>消费组相关指令</h5><ul>
<li>创建消费组</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">xgroup create key groupA $	// $表示从尾开始消费（只消费新的）</span><br><span class="line">xgroup create key groupB 0	// 0表示从头开始消费</span><br></pre></td></tr></table></figure></div>

<ul>
<li>消费组读取信息</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">xreadgroup group groupB consumer1 streams mystream &gt;	// 能读到消息</span><br><span class="line">xreadgroup group groupB consumer2 streams mystream &gt;	// nil，消息一旦被消费组中一个消费者读取了，就不能再次被组内其他消费者读取了</span><br><span class="line"></span><br><span class="line">// 组内多个消费者分担读取，实现读取的负载均衡</span><br><span class="line">xreadgroup group groupC consumer1 count 1 streams mystream &gt;</span><br><span class="line">xreadgroup group groupC consumer2 count 1 streams mystream &gt;</span><br><span class="line">xreadgroup group groupC consumer3 count 1 streams mystream &gt;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>消息一旦被消费组中一个消费者读取了，就不能再次被组内其他消费者读取了</p>
<p>不同消费组之间不受影响</p>
</blockquote>
<ul>
<li>查询消费组内，所有消费者“已读取，但尚未确认”的消息</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">xpending mystream groupA</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 返回值：总条数；起始时间戳；消费者极其消费的条数</span><br><span class="line">1) (integer) 4</span><br><span class="line">2) "1678332037505-0"</span><br><span class="line">3) "1678347842560-0"</span><br><span class="line">4) 1) 1) "constomer1"</span><br><span class="line">      2) "4"</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">xpending mystream groupB - + 10 consumer2</span><br></pre></td></tr></table></figure></div>

<ul>
<li>签收消息</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">xack mystream groupB 1678332037505-0</span><br></pre></td></tr></table></figure></div>

<ul>
<li>打印Stream/Consumer/Group的详细信息</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">xinfo stream mystream</span><br></pre></td></tr></table></figure></div>



<pre class="mermaid">graph LR;
    Publisher--"xadd"--&gt;Stream
    Stream--&gt;Consumer1
    Stream--"xgroupcreate"--&gt;Consumer2
    Stream--&gt;Consumer3
    Consumer2--"xreadgroup"--&gt;Client
    Client--"xack"--&gt;Consumer2</pre>

<h4 id="bitfield位域"><a href="#bitfield位域" class="headerlink" title="bitfield位域"></a>bitfield位域</h4><ul>
<li>了解即可</li>
</ul>
<h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><ul>
<li><p>redis持久化方式</p>
<ul>
<li><p>RDB (Redis Database)</p>
</li>
<li><p>AOF (Append Only File)</p>
</li>
<li><p>RDB + AOF</p>
</li>
</ul>
</li>
</ul>
<h3 id="RDB方式"><a href="#RDB方式" class="headerlink" title="RDB方式"></a>RDB方式</h3><ul>
<li><p>以指定的时间间隔，执行数据集的时间点快照</p>
<ul>
<li>保存备份时是全量快照</li>
<li>dump.rdb</li>
</ul>
</li>
<li><p>保存时间间隔，配置文件（6 vs 7）</p>
<ul>
<li>以前</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">save 900 1 # 900s,1次修改</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure></div>

<ul>
<li>现在</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">save 3600 1 300 100 60 10000</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="配置说明"><a href="#配置说明" class="headerlink" title="配置说明"></a>配置说明</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">/etc/redis/redis.conf</span><br></pre></td></tr></table></figure></div>

<ul>
<li>本次案例5秒2次修改</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Unless specified otherwise, by default Redis will save the DB:</span><br><span class="line">#   * After 3600 seconds (an hour) if at least 1 change was performed</span><br><span class="line">#   * After 300 seconds (5 minutes) if at least 100 changes were performed</span><br><span class="line">#   * After 60 seconds if at least 10000 changes were performed</span><br><span class="line">#</span><br><span class="line"># You can set these explicitly by uncommenting the following line.</span><br><span class="line">#</span><br><span class="line"># save 3600 1 300 100 60 10000</span><br><span class="line">save 5 2</span><br></pre></td></tr></table></figure></div>

<ul>
<li>修改dump文件保存位置</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># The working directory.</span><br><span class="line">#</span><br><span class="line"># The DB will be written inside this directory, with the filename specified</span><br><span class="line"># above using the 'dbfilename' configuration directive.</span><br><span class="line">#</span><br><span class="line"># The Append Only File will also be created inside this directory.</span><br><span class="line">#</span><br><span class="line"># Note that you must specify a directory here, not a file name.</span><br><span class="line"># dir /var/lib/redis</span><br><span class="line">dir /home/xdy/myredis/dumpfiles</span><br></pre></td></tr></table></figure></div>

<ul>
<li>修改默认文件名</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># The filename where to dump the DB</span><br><span class="line"># dbfilename dump.rdb</span><br><span class="line">dbfilename dump6379.rdb</span><br></pre></td></tr></table></figure></div>

<ul>
<li>开启redis</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-server ./redis-my.config</span><br><span class="line">redis-cli</span><br><span class="line"></span><br><span class="line">// 获取配置，查看修改成功与否</span><br><span class="line">config get save</span><br><span class="line">config get dir</span><br><span class="line">config get dbfilename</span><br></pre></td></tr></table></figure></div>

<h4 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h4><ul>
<li>依照save所设置的那样</li>
<li>恢复方式<ul>
<li>将备份的dump.rdb移动到设置的目录中即可</li>
</ul>
</li>
</ul>
<h4 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h4><ul>
<li><p>save</p>
<ul>
<li>会阻塞当前redis服务器，期间redis不能处理其他命令</li>
<li>线上禁止使用！</li>
</ul>
</li>
<li><p>bgsave</p>
<ul>
<li>后台异步进行快照操作</li>
<li>如何工作的<ul>
<li>redis forks，此时我们有一个子进程一个父进程</li>
<li>子进程开始将数组从内存写到硬盘</li>
<li>子进程完成后，会替换旧的进程</li>
</ul>
</li>
</ul>
</li>
<li><p>lastsave</p>
<ul>
<li>获取最后一次成功执行快照的时间</li>
</ul>
</li>
</ul>
<h4 id="RDB优缺点"><a href="#RDB优缺点" class="headerlink" title="RDB优缺点"></a>RDB优缺点</h4><ul>
<li>优势<ul>
<li>适合大规模数据恢复</li>
<li>按照业务定时备份</li>
<li>对数据完整性和一致性要求不高</li>
<li>RDB文件在内存中加载速度比AOF快得多</li>
</ul>
</li>
<li>劣势<ul>
<li>如果redis意外宕掉，快照之后的数据会丢失</li>
<li>数据量太大会导致I/O，严重影响性能</li>
<li>RDB依赖于主进程的fork，可能导致请求的瞬间延迟。fork时内存数据被克隆，有2倍的膨胀</li>
</ul>
</li>
</ul>
<h4 id="RDB修复命令简介"><a href="#RDB修复命令简介" class="headerlink" title="RDB修复命令简介"></a>RDB修复命令简介</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-check-rdb dump6379.rdb</span><br></pre></td></tr></table></figure></div>

<h4 id="RDB触发小结和快照禁用"><a href="#RDB触发小结和快照禁用" class="headerlink" title="RDB触发小结和快照禁用"></a>RDB触发小结和快照禁用</h4><ul>
<li><p>触发</p>
<ul>
<li>配置文件中默认的配置</li>
<li>手动save/bgsave</li>
<li>执行flushall/flushdb，但里面是空的意义不大</li>
<li>执行shutdown，且没有开启AOF持久化</li>
<li>主从复制时，主节点主动触发</li>
</ul>
</li>
<li><p>如何禁用快照</p>
<ul>
<li>动态停止保存规则</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-cli config set save ""</span><br></pre></td></tr></table></figure></div>

<ul>
<li>快照禁用</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Snapshotting can be completely disabled with a single empty string argument</span><br><span class="line"># as in following example:</span><br><span class="line">#</span><br><span class="line">save ""</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="RDB优化配置项"><a href="#RDB优化配置项" class="headerlink" title="RDB优化配置项"></a>RDB优化配置项</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">save &lt;seconds&gt; &lt;change&gt;</span><br><span class="line">dbfilename</span><br><span class="line">dir</span><br><span class="line"></span><br><span class="line"># 快照写入失败时，redis是否继续接收新的写请求</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line"># 存储到磁盘的快照是否压缩</span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line"># 存储快照后，是否进行数据校验</span><br><span class="line">rdbchecksum yes</span><br><span class="line"></span><br><span class="line"># Redis主从全量同步时，通过RDB文件传输实现。</span><br><span class="line"># 如果没有开启持久化，同步完成后，是否要移除主从同步的RDB文件，默认为no。</span><br><span class="line">rdb-del-sync-files no</span><br></pre></td></tr></table></figure></div>

<h3 id="AOF方式"><a href="#AOF方式" class="headerlink" title="AOF方式"></a>AOF方式</h3><ul>
<li><p>是什么</p>
<ul>
<li>以日志的形式来记录每个写操作</li>
<li>redis启动之初，会读取该文件重新构建数据</li>
</ul>
</li>
<li><p>开启方式</p>
 <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 配置文件中默认未开启</span><br><span class="line">appendonly yes</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="AOF工作流程和写回操作"><a href="#AOF工作流程和写回操作" class="headerlink" title="AOF工作流程和写回操作"></a>AOF工作流程和写回操作</h4><ul>
<li><p>工作流程</p>
<ul>
<li><p>Client作为命令来源，会有多个源头，请求命令源源不断</p>
</li>
<li><p>这些命令先放入AOF缓存中进行保存</p>
</li>
<li><p>AOF缓存会根据AOF缓冲区，==同步文件的三种写回策略==，将命令写入磁盘上的AOF文件</p>
</li>
<li><p>随着写入AOF内容的增加，会==根据规则进行命令的合并==（又称AOF重写）</p>
</li>
</ul>
</li>
<li><p>三种写回策略</p>
<ul>
<li>always：每个命令执行完，立刻同步将日志写回磁盘</li>
<li>everysec：先把日志写到AOF文件的内存缓冲区，每隔一秒将缓冲区内容写回磁盘</li>
<li>no：先把日志写到AOF文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 配置文件，默认everysec</span><br><span class="line">appendfsync everysec</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>总结：</p>
<table>
<thead>
<tr>
<th>配置项</th>
<th>写回时机</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>always</td>
<td>同步写回</td>
<td>可靠性高，数据基本不丢失</td>
<td>每个命令都要落盘，性能影响大</td>
</tr>
<tr>
<td>everysec</td>
<td>每秒写回</td>
<td>性能适中</td>
<td>宕机时丢失1秒内数据</td>
</tr>
<tr>
<td>no</td>
<td>操作系统控制的写回</td>
<td>性能好</td>
<td>宕机时丢失数据较多</td>
</tr>
</tbody></table>
</blockquote>
</li>
</ul>
<h4 id="AOF功能配置开启"><a href="#AOF功能配置开启" class="headerlink" title="AOF功能配置开启"></a>AOF功能配置开启</h4><ul>
<li>配置开启</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 配置文件中默认未开启</span><br><span class="line">appendonly yes</span><br><span class="line"></span><br><span class="line"># 使用默认写回策略</span><br><span class="line">appendfsync everysec</span><br></pre></td></tr></table></figure></div>

<ul>
<li>AOF文件保存路径，AOF文件保存名称</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># redis6之前</span><br><span class="line"></span><br><span class="line">dir /myredis</span><br><span class="line">appendfilename "appendonly.aof"</span><br><span class="line"></span><br><span class="line"># RDB: /myredis/dump.rdb</span><br><span class="line"># AOF: /myredis/appendonly.aof</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># redis7</span><br><span class="line"></span><br><span class="line">dir /myredis</span><br><span class="line">appendfilename "appendonly.aof"</span><br><span class="line">appenddirname "appendonlydir"</span><br><span class="line"></span><br><span class="line"># RDB:	/myredis/dump.rdb</span><br><span class="line"># AOF:	/myredis/appendonlydir/appendonly.aof.1.base.rdb</span><br><span class="line">#		/myredis/appendonlydir/appendonly.aof.1.incr.aof, appendonly.aof.2.incr.aof, ...</span><br><span class="line">#		/myredis/appendonlydir/appendonly.aof.manifest</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>base: 基础AOF，由子进程通过重写产生，该文件最多一个</p>
<p>incr: 增量AOF，后续写操作记录其中，该文件可能存在多个</p>
<p>history: 历史AOF，由base和incr变化而来，每次AOFRW成功完成，本次之前对应的base和incr都将变为history。==history类型的aof会被redis自动删除==</p>
<p>manifest: 清单文件，来跟踪管理这些AOF文件</p>
</blockquote>
<h4 id="AOF正常恢复"><a href="#AOF正常恢复" class="headerlink" title="AOF正常恢复"></a>AOF正常恢复</h4><ul>
<li>写操作，自动生成AOF文件到指定目录</li>
<li>恢复，重启redis时自动加载</li>
</ul>
<h4 id="AOF异常恢复"><a href="#AOF异常恢复" class="headerlink" title="AOF异常恢复"></a>AOF异常恢复</h4><ul>
<li>可能：内容写了一小半，没有写完整，突然redis挂了，导致AOF文件错误</li>
<li>往appendonly.aof.1.incr.aof最后一行胡乱插入一行，模拟文件损坏的情况</li>
<li>AOF文件有误，发现无法启动redis，连接直接报错</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 异常修复指令</span><br><span class="line"># redis-check-aof --fix &lt;file.manifest|file.aof&gt;</span><br><span class="line"></span><br><span class="line">redis-check-aof --fix ./appendonly.aof.1.incr.aof</span><br></pre></td></tr></table></figure></div>

<h4 id="AOF优缺点"><a href="#AOF优缺点" class="headerlink" title="AOF优缺点"></a>AOF优缺点</h4><ul>
<li>优点：<ul>
<li>更好保护数据不丢失，性能高，可做紧急恢复</li>
</ul>
</li>
<li>缺点<ul>
<li>AOF文件远大于RDB文件，恢复速度慢于RDB</li>
<li>根据不同的同步策略，AOF一般都比RDB慢。everysec的情况下，性能消耗任然很高。即使no的情况下，也和RDB差不多快。</li>
</ul>
</li>
</ul>
<h4 id="AOF重写机制"><a href="#AOF重写机制" class="headerlink" title="AOF重写机制"></a>AOF重写机制</h4><ul>
<li><p>自动触发</p>
<ul>
<li>是上次rewrite后大小的一倍，且文件大于64M</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 官方默认配置</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br><span class="line"># 是否同时开启rdb和aof。默认是yes，这里为了实验方便，设为no</span><br><span class="line">aof-use-rdb-preamble no</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>手动触发</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">bgrewriteaof</span><br></pre></td></tr></table></figure></div></li>
</ul>
<blockquote>
<p>AOF文件重写并不是对原文件重新整理，而是直接读取服务器现有键值对，生成新的AOF文件代替原来AOF文件</p>
</blockquote>
<h4 id="AOF重写原理"><a href="#AOF重写原理" class="headerlink" title="AOF重写原理"></a>AOF重写原理</h4><ol>
<li>redis fork一个子进程。子进程基于当前内存中的数据，构建日志，往新的临时AOF文件中写入日志</li>
<li>开启AOF重写缓冲区。保存这段时间内新增的写指令</li>
<li>主进程继续写旧文件。写入AOF重写缓冲区，进而继续写入旧AOF文件</li>
<li>AOF重写缓冲区的指令追加到新文件</li>
<li>新AOF文件替代旧AOF文件</li>
</ol>
<h3 id="RDB-AOF混合持久化"><a href="#RDB-AOF混合持久化" class="headerlink" title="RDB-AOF混合持久化"></a>RDB-AOF混合持久化</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 混合模式默认开启</span><br><span class="line">aof-use-rdb-preamble yes</span><br></pre></td></tr></table></figure></div>

<h4 id="数据恢复流程和加载顺序"><a href="#数据恢复流程和加载顺序" class="headerlink" title="数据恢复流程和加载顺序"></a>数据恢复流程和加载顺序</h4><ul>
<li>默认开启RDB</li>
<li>如果开启AOF，优先加载AOF</li>
</ul>
<pre class="mermaid">graph TB;
    A[加载]--&gt;B{存在AOF?}
    B--&gt;|yes|C[加载AOF文件]
    B--&gt;|no|D{存在RDB}
    D--&gt;|yes|E[加载RDB文件]
    C--&gt;F[启动成功or失败]
    E--&gt;F
    D--&gt;|no|F</pre>

<h4 id="使用选择"><a href="#使用选择" class="headerlink" title="使用选择"></a>使用选择</h4><ul>
<li>AOF保存更完整，因此优先使用AOF恢复</li>
<li>RDB适合用于备份数据库（AOF不断变化不好备份）</li>
<li>推荐：RDB+AOF混合使用</li>
</ul>
<h4 id="纯缓存模式"><a href="#纯缓存模式" class="headerlink" title="纯缓存模式"></a>纯缓存模式</h4><ul>
<li>同时关闭RDB+AOF</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 禁用rdb持久化模式下，仍可以使用save，bgsave命令生成rdb文件</span><br><span class="line">save ""</span><br><span class="line"></span><br><span class="line"># 禁用AOF功能，仍可以使用bgrewriteaof生成aof文件</span><br><span class="line">appendonly no</span><br></pre></td></tr></table></figure></div>

<h2 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><ul>
<li>依次执行多个命令，本质就是一组命令的集合</li>
<li>一个事务中所有命令都会序列化，按顺序串行执行，不会被其他命令加塞</li>
</ul>
<h3 id="Redis事务vs数据库事务"><a href="#Redis事务vs数据库事务" class="headerlink" title="Redis事务vs数据库事务"></a>Redis事务vs数据库事务</h3><ol>
<li>单独的隔离操作<ul>
<li>redis事务仅仅保证事务中操作会被连续独占的执行。（redis命令执行是单线程架构）</li>
</ul>
</li>
<li>没有隔离级别的概念<ul>
<li>事务提交前任何指令都不会被实际执行</li>
</ul>
</li>
<li>不保证原子性<ul>
<li>redis不保证所有指令同时成功或失败，只有决定是否开始执行全部指令的能力，没有回滚的能力</li>
</ul>
</li>
<li>排他性<ul>
<li>redis会保证一个事务内的命令依次执行，不被其他命令插入</li>
</ul>
</li>
</ol>
<h3 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h3><ul>
<li>正常执行</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">multi</span><br><span class="line">set k1 v1</span><br><span class="line">expire k1 30</span><br><span class="line">exec</span><br></pre></td></tr></table></figure></div>

<ul>
<li>放弃执行</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">multi</span><br><span class="line">set k1 v1</span><br><span class="line">discard</span><br></pre></td></tr></table></figure></div>

<ul>
<li>全体连坐<ul>
<li>在exec执行之前，有命令出错，全体无法执行</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">multi</span><br><span class="line">set k1	# 发生错误</span><br><span class="line">exec	# Redis直接返回错误，所有命令都不会执行</span><br></pre></td></tr></table></figure></div>

<ul>
<li>冤有头债有主<ul>
<li>在exec执行之后出错，其他命令不受影响（redis没有rollbask功能）</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">multi</span><br><span class="line">set email 1234@qq.com</span><br><span class="line">incr email	# 运行时错误</span><br><span class="line">exec		# 其他命令不受影响</span><br></pre></td></tr></table></figure></div>

<ul>
<li>watch监控<ul>
<li>Redis使用watch来提供乐观锁，类似于CAS（Check-and-Set）</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">set balance 100</span><br><span class="line">watch balance # 一种乐观锁的实现，监控key，如果key被修改了，后面的事务执行失败</span><br><span class="line"></span><br><span class="line">multi</span><br><span class="line">set k1 v1</span><br><span class="line">set balance 110</span><br><span class="line">exec # 有人加塞，修改了balance，事务不会执行</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 上面 watch 和 exec之间，有人加塞</span><br><span class="line">set balance 300</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 放弃监控</span><br><span class="line">unwatch</span><br></pre></td></tr></table></figure></div>

<h2 id="Redis管道"><a href="#Redis管道" class="headerlink" title="Redis管道"></a>Redis管道</h2><ul>
<li><p>Redis是一种基于==客户端-服务器模型==的<code>TCP</code>服务</p>
<ul>
<li>客户端向服务器发送命令（发送命令，命令排队，命令执行，返回结果），并监听Socket返回，通常阻塞模式等待服务器响应</li>
<li>服务器处理命令，并将结果返回客户端</li>
<li>如果执行大量命令，就有大量RTT，性能不太好</li>
</ul>
</li>
<li><p><code>pipeline</code>可以一次发送多条命令给服务器，服务器依次处理完，一次性响应，减少了通信次数</p>
<ul>
<li>批处理命令变种优化措施，类似Redis的原生批命令（mget，mset）</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat cmd.txt</span><br><span class="line">set k1 v1</span><br><span class="line">set k2 v2</span><br><span class="line">hset k3 name xdy</span><br><span class="line">hset k3 age 12</span><br><span class="line">hset k3 gender male</span><br><span class="line">lpush list 1 2 3 4 5</span><br><span class="line"></span><br><span class="line">cat cmd.txt | redis-cli -a 111111 --pipe</span><br></pre></td></tr></table></figure></div>

<h3 id="管道与原生批量命令对比"><a href="#管道与原生批量命令对比" class="headerlink" title="管道与原生批量命令对比"></a>管道与原生批量命令对比</h3><ul>
<li>原生批量命令有原子性，管道是非原子性</li>
<li>原生批量命令一次只能执行一种命令，管道支持批量执行不同命令</li>
<li>原生批量命令是服务端实现，管道需要服务端与客户端共同完成</li>
</ul>
<h3 id="管道与事务对比"><a href="#管道与事务对比" class="headerlink" title="管道与事务对比"></a>管道与事务对比</h3><ul>
<li>事务具有原子性，管道不具有原子性</li>
<li>管道一次性将多条命令发送到服务器，事务一条一条发，接收到exec命令才执行</li>
<li>执行事务会阻塞其他命令执行，执行管道则不会</li>
</ul>
<h3 id="使用管道注意事项"><a href="#使用管道注意事项" class="headerlink" title="使用管道注意事项"></a>使用管道注意事项</h3><blockquote>
<ul>
<li><p>管道中的指令只是会依次执行，不保证原子性；如果发生异常，会继续执行后续指令</p>
</li>
<li><p>管道组装的命令个数不能太多，不然客户端阻塞的时间可能过久；服务端也被迫回复一个队列，占用内存</p>
</li>
</ul>
</blockquote>
<h2 id="Redis发布订阅"><a href="#Redis发布订阅" class="headerlink" title="Redis发布订阅"></a>Redis发布订阅</h2><blockquote>
<p>了解即可</p>
</blockquote>
<h2 id="Redis复制"><a href="#Redis复制" class="headerlink" title="Redis复制"></a>Redis复制</h2><ul>
<li><p>是什么</p>
<ul>
<li><p>主从复制，master以写为主，slave以读为主</p>
</li>
<li><p>master数据变化时，自动将新的数据异步同步到其他slave数据库</p>
</li>
</ul>
</li>
<li><p>能干什么</p>
<ul>
<li>读写分离</li>
<li>容灾恢复</li>
<li>数据备份</li>
<li>redis7 主从 配置ubuntu水平扩容支撑高并发（一主多从）</li>
</ul>
</li>
<li><p>如何使用</p>
<ul>
<li><p>配从库，不配主库</p>
</li>
<li><p>master配置了requirepass参数，需要密码登录</p>
<ul>
<li>slave配置masterauth设置校验密码</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h3><ul>
<li>一个master，两个slave<ul>
<li>（三台虚拟机，每台都安装redis）</li>
</ul>
</li>
<li>拷贝多个redis.conf<ul>
<li>（redis6379.conf，redis6380.conf，redis6381.conf）</li>
</ul>
</li>
<li>配置文件需要修改的部分</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">port 6380						# 修改端口，6379，6380，6381...</span><br><span class="line">daemonize yes					# redis以守护线程的方式启动，会在后台运行</span><br><span class="line">requirepass	123456				# 设置密码 </span><br><span class="line"></span><br><span class="line"># 其他机器访问</span><br><span class="line"># bind 127.0.0.1 -::1			# 注释掉，bind：将指定的ip设置为redis的对外开放地址。如果设为127.0.0.1的话，只有本机能访问了</span><br><span class="line">protected-mode no				# 关闭保护模式，保护模式下外部网络无法访问</span><br><span class="line"></span><br><span class="line"># 持久化</span><br><span class="line">dir /myredis					# 指定保存位置</span><br><span class="line">dbfilename dump6380.rdb			# RDB文件名</span><br><span class="line">appendonly yes					# 开启AOF（非必选）</span><br><span class="line">appenddirname "appendonlydir"	# 设置AOF文件夹名（非必须）</span><br><span class="line"></span><br><span class="line">pidfile	/var/run/redis_6380.pid	# 该文件中记录了当前redis进程id</span><br><span class="line"></span><br><span class="line"># 日志</span><br><span class="line">loglevel notice					# 日志级别</span><br><span class="line">logfile "/myredis/6380.log"		# 日志位置</span><br><span class="line"></span><br><span class="line"># 从机设置</span><br><span class="line">replicaof 172.26.238.112 6379	# 从机设置主机ip，port（从机必须，主机不需要）</span><br><span class="line">masterauth 123456				# 从机访问主机的密码（从机必须，主机不需要）</span><br></pre></td></tr></table></figure></div>

<h3 id="一主二仆"><a href="#一主二仆" class="headerlink" title="一主二仆"></a>一主二仆</h3><h4 id="配置文件固定写死"><a href="#配置文件固定写死" class="headerlink" title="配置文件固定写死"></a>配置文件固定写死</h4><ul>
<li>replicaof 主库IP 主库端口</li>
<li>配从库不配主库</li>
<li>先master，后两台slave依次启动</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 主库</span><br><span class="line">redis-server ./redis6379.conf</span><br><span class="line">redis-cli -a 123456</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 从库1，记得指定端口</span><br><span class="line">redis-server ./redis6380.conf</span><br><span class="line">redis-cli -a 123456 -p 6380</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 从库2，记得指定端口</span><br><span class="line">redis-server ./redis6381.conf</span><br><span class="line">redis-cli -a 123456 -p 6381</span><br></pre></td></tr></table></figure></div>

<ul>
<li>日志</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 主机日志</span><br><span class="line">vim /myredis/6379.conf</span><br><span class="line"></span><br><span class="line">Synchronization with replica 172.24.252.134:6380 succeeded</span><br><span class="line">Synchronization with replica 172.24.252.150:6381 succeeded</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 从机日志</span><br><span class="line">tail -f /myredis/6380.conf</span><br><span class="line"></span><br><span class="line">Connecting to MASTER 172.24.250.28:6379</span><br><span class="line">MASTER &lt;-&gt; REPLICA sync: receiving streamed RDB from master with EOF to disk</span><br><span class="line">MASTER &lt;-&gt; REPLICA sync: Flushing old data</span><br><span class="line">MASTER &lt;-&gt; REPLICA sync: Loading DB in memory</span><br></pre></td></tr></table></figure></div>

<ul>
<li>命令</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">info replication</span><br></pre></td></tr></table></figure></div>

<h4 id="命令控制手动指定"><a href="#命令控制手动指定" class="headerlink" title="命令控制手动指定"></a>命令控制手动指定</h4><ul>
<li>从机去掉配置项目，3台主机目前都是主机状态，各不从属</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># replicaof 172.26.238.112 6379</span><br></pre></td></tr></table></figure></div>

<ul>
<li>从机上执行</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">slaveof 主库IP 主库端口</span><br></pre></td></tr></table></figure></div>

<ul>
<li>配置：持久稳定</li>
<li>命令：仅当次生效</li>
</ul>
<h4 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h4><blockquote>
<ol>
<li>从机（salve）只能读不能写</li>
<li>数据复制：从机第一次一锅端；后续跟随，master写slave跟</li>
<li>主机shutdown，从机原地待命，等待主机重启归来</li>
<li>主机重启后，主从关系继续</li>
<li>从机shutdown，重启后能跟上大部队</li>
</ol>
</blockquote>
<h3 id="薪火相传"><a href="#薪火相传" class="headerlink" title="薪火相传"></a>薪火相传</h3><ul>
<li>上一个slave可以是下一个slave的master</li>
<li>中途变更转向：会清除之前的数据，重新建立拷贝最新的</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">slaveof 新主库IP 新主库端口</span><br></pre></td></tr></table></figure></div>

<h3 id="反客为主"><a href="#反客为主" class="headerlink" title="反客为主"></a>反客为主</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">slaveof no one</span><br></pre></td></tr></table></figure></div>

<h3 id="工作流程总结"><a href="#工作流程总结" class="headerlink" title="工作流程总结"></a>工作流程总结</h3><h4 id="slave启动，同步初请"><a href="#slave启动，同步初请" class="headerlink" title="slave启动，同步初请"></a>slave启动，同步初请</h4><ul>
<li>slave启动成功连接到master后，会发送一个sync命令</li>
<li>slave首次连接到master，将执行全量复制</li>
</ul>
<h4 id="首次连接，全量复制"><a href="#首次连接，全量复制" class="headerlink" title="首次连接，全量复制"></a>首次连接，全量复制</h4><ul>
<li>master收到sync命令，在后台RDB持久化，同时收集修改命令缓存起来。RDB持久化执行完毕后，将RDB快照和所有缓存命令发送给slave，完成同步</li>
<li>slave接收到数据，存盘并加载到内存，完成复制</li>
</ul>
<h4 id="心跳持续，保持通讯"><a href="#心跳持续，保持通讯" class="headerlink" title="心跳持续，保持通讯"></a>心跳持续，保持通讯</h4><ul>
<li>master发出ping包，默认周期10秒</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">repl-ping-replica-period 10</span><br></pre></td></tr></table></figure></div>

<h4 id="进入平稳，增量复制"><a href="#进入平稳，增量复制" class="headerlink" title="进入平稳，增量复制"></a>进入平稳，增量复制</h4><ul>
<li>master继续将新收到的修改命令依次传给slave，完成同步</li>
</ul>
<h4 id="从机下线，重连续传"><a href="#从机下线，重连续传" class="headerlink" title="从机下线，重连续传"></a>从机下线，重连续传</h4><ul>
<li>master和slave都会保存：复制的offset，masterId。offset保存在backlog中。master只会把已复制的offset后面的数据复制给slave，类似断点续传</li>
</ul>
<h3 id="复制的缺点"><a href="#复制的缺点" class="headerlink" title="复制的缺点"></a>复制的缺点</h3><ul>
<li>复制延时，信号衰减<ul>
<li>写操作在master，同步更新到slave，同步有延时。系统繁忙，延时会更加严重。增加slave会使问题更严重</li>
</ul>
</li>
<li>master挂了<ul>
<li>master挂了，从机待命，系统只能读取不能写入</li>
<li>需要人工介入</li>
</ul>
</li>
</ul>
<h2 id="Redis哨兵"><a href="#Redis哨兵" class="headerlink" title="Redis哨兵"></a>Redis哨兵</h2><h3 id="理论简介"><a href="#理论简介" class="headerlink" title="理论简介"></a>理论简介</h3><ul>
<li>是什么<ul>
<li>监控后台master主机是否故障，如果故障，根据投票数自动将一个从库转换为新主库</li>
</ul>
</li>
<li>作用<ul>
<li>主从监控：监控主从库运行是否正常</li>
<li>消息通知：将故障转移的结果发送给客户端</li>
<li>故障转移：如果master异常，进行主从切换，将一个slave作为master</li>
<li>配置中心：客户端通过哨兵获取当前Redis服务主节点的地址</li>
</ul>
</li>
</ul>
<h3 id="案例实操"><a href="#案例实操" class="headerlink" title="案例实操"></a>案例实操</h3><ul>
<li>三个哨兵：用于监控和维护集群，不存放数据</li>
<li>1主2从：用于数据读取和存放</li>
</ul>
<pre class="mermaid">graph TB;
    Client&lt;--&gt;Sentinel集群
    subgraph Sentinel集群;
        direction RL
        Sentinel1----Sentinel2----Sentinel3
    end
    Sentinel集群&lt;--&gt;Redis主从复制
    subgraph Redis主从复制;
        direction TB
        Master&lt;--&gt;Slave1
        Master&lt;--&gt;Slave2
    end</pre>

<h4 id="配置哨兵"><a href="#配置哨兵" class="headerlink" title="配置哨兵"></a>配置哨兵</h4><ul>
<li>这里使用了docker</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 哨兵</span><br><span class="line">docker run -d -p 26379:26379 --name sentinel1 --privileged=true -v /dockerApp/sentinel1:/myredis redis redis-server /myredis/sentinel26379.conf --sentinel</span><br><span class="line">docker run -d -p 26380:26380 --name sentinel2 --privileged=true -v /dockerApp/sentinel2:/myredis redis redis-server /myredis/sentinel26380.conf --sentinel</span><br><span class="line">docker run -d -p 26381:26381 --name sentinel3 --privileged=true -v /dockerApp/sentinel3:/myredis redis redis-server /myredis/sentinel26381.conf --sentinel</span><br></pre></td></tr></table></figure></div>

<ul>
<li>了解配置</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 重点参数</span><br><span class="line">bind			服务监听地址，用于客户端连接，默认本机ip</span><br><span class="line">daemonize		是否以后台daemon方式运行</span><br><span class="line">protected-mode	安全保护模式</span><br><span class="line">port			端口</span><br><span class="line">logfile			日志文件</span><br><span class="line">pidfile			pid文件路径</span><br><span class="line">dir				工作目录</span><br><span class="line"></span><br><span class="line"># 前三个参数设计要监控的主机，quorum表示最少几个哨兵认为主机宕机，同意故障迁移的票数</span><br><span class="line">sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span><br><span class="line"></span><br><span class="line"># 连接master的密码</span><br><span class="line">sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 其他参数，不怎么需要管，自行差文档</span><br></pre></td></tr></table></figure></div>

<ul>
<li>/myredis目录下<code>sentinel26379.conf</code>文件</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">bind 0.0.0.0</span><br><span class="line">daemonize yes</span><br><span class="line">protected-mode no</span><br><span class="line">port 26379</span><br><span class="line">logfile "/myredis/sentinel26379.log"</span><br><span class="line">pidfile "/myredis/sentinel26379.pid"</span><br><span class="line">dir /myredis</span><br><span class="line">sentinel monitor mymaster 192.168.114.40 6379 2</span><br><span class="line">sentinel auth-pass mymaster 123456</span><br></pre></td></tr></table></figure></div>

<h4 id="配置主从机"><a href="#配置主从机" class="headerlink" title="配置主从机"></a>配置主从机</h4><ul>
<li>使用了docker</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 主机从机</span><br><span class="line">docker run -d -p 6379:6379 --name redis1 --privileged=true -v /dockerApp/redis1:/myredis -v /dockerApp/redis1/data:/data redis redis-server /myredis/redis6379.conf</span><br><span class="line">	</span><br><span class="line">docker run -d -p 6380:6380 --name redis2 --privileged=true -v /dockerApp/redis2:/myredis -v /dockerApp/redis2/data:/data redis redis-server /myredis/redis6380.conf</span><br><span class="line">	</span><br><span class="line">docker run -d -p 6381:6381 --name redis3 --privileged=true -v /dockerApp/redis3:/myredis -v /dockerApp/redis2/data:/data redis redis-server /myredis/redis6381.conf</span><br></pre></td></tr></table></figure></div>

<ul>
<li>主机从机配置<code>redsi6379.conf</code></li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">port 6379</span><br><span class="line">daemonize no # 为让redis不退出，必须有个前台程序</span><br><span class="line">requirepass	123456</span><br><span class="line"></span><br><span class="line"># bind 127.0.0.1 -::1	# 注释掉</span><br><span class="line">protected-mode no</span><br><span class="line"></span><br><span class="line">dir /myredis</span><br><span class="line">dbfilename dump6379.rdb</span><br><span class="line">appendonly yes</span><br><span class="line">appenddirname "appendonlydir"</span><br><span class="line"></span><br><span class="line">pidfile	/myredis/redis6379.pid</span><br><span class="line">loglevel notice</span><br><span class="line">logfile "/myredis/6379.log"</span><br><span class="line"></span><br><span class="line"># 主从机都设置，因为主机可能改变</span><br><span class="line">masterauth 123456 </span><br><span class="line"></span><br><span class="line"># 从机设置</span><br><span class="line">replicaof 192.168.114.40 6379</span><br></pre></td></tr></table></figure></div>

<h4 id="启动所有机器"><a href="#启动所有机器" class="headerlink" title="启动所有机器"></a>启动所有机器</h4><ul>
<li>先启动主从，接着启动哨兵</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 哨兵日志</span><br><span class="line">Sentinel ID is 24f3285df6c3b1019b8bcfc9bcd7132a5aa1363b</span><br><span class="line"></span><br><span class="line">+monitor master mymaster 192.168.114.40 6379 quorum 2</span><br><span class="line">+slave slave 172.17.0.1:6380 172.17.0.1 6380 @ mymaster 192.168.114.40 6379</span><br><span class="line">+slave slave 172.17.0.1:6381 172.17.0.1 6381 @ mymaster 192.168.114.40 6379</span><br><span class="line"></span><br><span class="line">+sentinel sentinel 15a1dd9afaacb46b89486a9e8417354d66b14563 172.17.0.6 26380 @ mymaster 192.168.114.40 6379</span><br><span class="line">+sentinel sentinel 3f3c725be2765afb4a1afe807652c8b57056d0aa 172.17.0.7 26381 @ mymaster 192.168.114.40 6379</span><br></pre></td></tr></table></figure></div>

<h4 id="主机挂掉"><a href="#主机挂掉" class="headerlink" title="主机挂掉"></a>主机挂掉</h4><ul>
<li>手动关掉6379，模拟挂掉了</li>
<li>剩下两台机器自动选出了新的master<ul>
<li>这里info replication发现，6380成为了master</li>
</ul>
</li>
<li>查看哨兵的日志</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">+sdown master mymaster 192.168.114.40 6379</span><br><span class="line">+odown master mymaster 192.168.114.40 6379 #quorum 2/2</span><br><span class="line">+new-epoch 1</span><br><span class="line">+vote-for-leader 24f3285df6c3b1019b8bcfc9bcd7132a5aa1363b 1</span><br><span class="line"></span><br><span class="line">+switch-master mymaster 192.168.114.40 6379 172.17.0.1 6380</span><br><span class="line">+slave slave 172.17.0.1:6381 172.17.0.1 6381 @ mymaster 172.17.0.1 6380</span><br><span class="line">+slave slave 192.168.114.40:6379 192.168.114.40 6379 @ mymaster 172.17.0.1 6380 # 6379变为slave，即使回来了依然是slave</span><br></pre></td></tr></table></figure></div>

<ul>
<li>6379恢复，会变成slave，不会冲突</li>
</ul>
<h3 id="一些问题-1"><a href="#一些问题-1" class="headerlink" title="一些问题"></a>一些问题</h3><ul>
<li>主机刚挂掉，从机get时，会报</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Error: Broken pipe</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>意思是：对端的管道断开了，远端把这个读/写管道关闭了，你无法继续对这个管道进行读写操作</p>
</blockquote>
<ul>
<li>配置自动修改<ul>
<li>观察redis6379.conf, redis6380.conf可以发现，文件的内容被动态修改了</li>
<li>配置文件会被sentinel动态更改</li>
</ul>
</li>
<li>哨兵可以监控多个主机<ul>
<li>自行去官网看文档</li>
</ul>
</li>
</ul>
<h3 id="哨兵运行流程和选举原理"><a href="#哨兵运行流程和选举原理" class="headerlink" title="哨兵运行流程和选举原理"></a>哨兵运行流程和选举原理</h3><ul>
<li>三个哨兵，一主二从，正常运行中</li>
<li>SDown主观下线<ul>
<li>单个哨兵自己主观上。发送PING心跳一段时间没有收到合法回复</li>
<li>配置文件：<code>down-after-milliseconds</code>（默认30s）</li>
</ul>
</li>
<li>ODown客观下线<ul>
<li>多个哨兵达成一致意见</li>
<li>配置文件：<code>sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</code></li>
</ul>
</li>
<li>选出领导者哨兵<ul>
<li>主节点被判断客观下线，各个哨兵协商选出领导者。</li>
<li>由领导者进行failover（故障转移）</li>
</ul>
</li>
<li>领导者如何选择出来的？<ul>
<li>Raft算法</li>
<li>先到先得，哨兵A向哨兵B发送成为领导者的申请。</li>
<li>如果B没同意过别人，就同意A成为领导者。</li>
</ul>
</li>
<li>领导者进行故障转移，并选出新的master<ul>
<li>新主登基：某一个slave被选为master<ul>
<li>replica priority(权限)&gt;replication offset(复制偏移量)&gt;Run ID</li>
</ul>
</li>
<li>群臣俯首<ul>
<li>哨兵领导者对新master发送命令：slaveof no one，提升为master节点</li>
<li>哨兵领导者对其他slave发送命令：slaveof，成为新的slave节点</li>
</ul>
</li>
<li>旧主拜服<ul>
<li>老master上线。哨兵领导者对其降级为slave，恢复工作</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="哨兵使用建议"><a href="#哨兵使用建议" class="headerlink" title="哨兵使用建议"></a>哨兵使用建议</h3><ul>
<li>哨兵数量应为多个</li>
<li>哨兵数量最好为奇数，好投票</li>
<li>哨兵节点配置最好一致</li>
<li>哨兵节点性能最好一致</li>
<li>哨兵节点如果部署在Docker，要注意端口映射</li>
<li>哨兵+主从复制，并不能保证数据不丢失</li>
</ul>
<h2 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>什么是集群<ul>
<li>数据量过大，单Master的复制集难以承担</li>
<li>需要水平扩展，每个复制集只负责存储整个数据集的一部分</li>
</ul>
</li>
</ul>
<pre class="mermaid">graph LR;
    Clinets-write--&gt;M1
    Clinets-write--&gt;M2
    Clinets-write--&gt;M3
    subgraph Master
        M1
        M2
        M3
    end
    subgraph Slave
        S1
        S2
        S3
    end
    Master --&gt; Slave
    S1--&gt;Clinets-read
    S2--&gt;Clinets-read
    S3--&gt;Clinets-read</pre>

<ul>
<li>能干什么<ul>
<li>Redis集群支持多个Master，每个Master又可以挂载多个Slave<ul>
<li>读写分离</li>
<li>支持数据高可用</li>
<li>支持海量数据读写存储</li>
</ul>
</li>
<li>集群自带sentinel的故障转移机制，无需配置哨兵</li>
<li>客户端与Redis节点连接时，只需任意连接集群中一个可用节点</li>
<li>槽位slot负责分配到各个物理服务节点，由对应的集群来负责维护节点、插槽和数据之间的关系</li>
</ul>
</li>
</ul>
<h3 id="集群算法-分片-槽位slot"><a href="#集群算法-分片-槽位slot" class="headerlink" title="集群算法-分片-槽位slot"></a>集群算法-分片-槽位slot</h3><ul>
<li>官网出处<ul>
<li><a class="link" href="https://redis.io/docs/reference/cluster-spec/#overview-of-redis-cluster-main-components">https://redis.io/docs/reference/cluster-spec/#overview-of-redis-cluster-main-components <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
</li>
</ul>
<h4 id="槽位slot"><a href="#槽位slot" class="headerlink" title="槽位slot"></a>槽位slot</h4><ul>
<li>Redis集群没有使用一致性hash，而是引入了哈希槽的概念</li>
<li>Redis集群有16384个哈希槽，每个key通过<code>CRC16(key) mod 16384</code>来决定放哪个槽</li>
</ul>
<h4 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h4><ul>
<li>我们会将存储的数据分散到多台redis机器上，称为分片</li>
<li>每个Redis实例都被认为时整个数据的一个分片</li>
<li>比如有三个节点，0-16383，则分片：<ul>
<li>0-5460</li>
<li>5461-10922</li>
<li>10923-16383</li>
</ul>
</li>
</ul>
<h4 id="分片和槽位的优势"><a href="#分片和槽位的优势" class="headerlink" title="分片和槽位的优势"></a>分片和槽位的优势</h4><ul>
<li>方便扩容和缩容<ul>
<li>假如有三台A,B,C</li>
<li>比如移除A，则需要将A中的槽位匀一部分到B和C</li>
</ul>
</li>
<li>一个节点将哈希槽移动到另一个节点不会停止服务<ul>
<li>不会造成集群不可用</li>
</ul>
</li>
</ul>
<h4 id="槽位映射的三种解决方案"><a href="#槽位映射的三种解决方案" class="headerlink" title="槽位映射的三种解决方案"></a>槽位映射的三种解决方案</h4><h5 id="哈希取余分区（小厂）"><a href="#哈希取余分区（小厂）" class="headerlink" title="哈希取余分区（小厂）"></a>哈希取余分区（小厂）</h5><ul>
<li><code>hash(key)/N</code></li>
<li>优缺点<ul>
<li>优点：简单粗暴，让固定一部分请求落在同一台服务器上</li>
<li>缺点：扩容和缩容后，映射需要重新计算，发生很大变化</li>
</ul>
</li>
</ul>
<h5 id="一致性哈希分区"><a href="#一致性哈希分区" class="headerlink" title="一致性哈希分区"></a>一致性哈希分区</h5><ul>
<li><p>目的：服务器个数发生变化，尽量少影响映射关系</p>
</li>
<li><p>三大步骤</p>
<ol>
<li>一致性哈希环</li>
</ol>
<ul>
<li>一致性哈希对2^32^取模，形成一个虚拟圆环</li>
<li>[0,2^32^-1]，0=2^32^-1，构成hash环</li>
</ul>
<ol start="2">
<li>服务器IP节点映射</li>
</ol>
<ul>
<li>将各IP映射到环上某位置，<code>hash(IP)</code></li>
</ul>
<ol start="3">
<li>key落到各服务器规则</li>
</ol>
<ul>
<li><code>hash(key)</code>计算数据在环上的位置</li>
<li>顺时针走遇到的第一个服务器，就是应该存储的服务器</li>
</ul>
</li>
<li><p>优缺点</p>
<ul>
<li>优点：有一定容错性，有节点宕机，依然可以继续存储。扩展性好。</li>
<li>缺点：节点太少分布不均匀，有数据倾斜问题</li>
</ul>
</li>
</ul>
<h5 id="哈希槽分区"><a href="#哈希槽分区" class="headerlink" title="哈希槽分区"></a>哈希槽分区</h5><ul>
<li><p><code>CRC16(key) % 16384</code></p>
</li>
<li><p>[0,2^14^-1]形成hash slot空间</p>
</li>
<li><p>在数据和节点之间加了一层，称为哈希槽</p>
</li>
<li><p>槽会分配给集群中所有主节点，分配策略没有要求</p>
</li>
</ul>
<h3 id="一些面试问题"><a href="#一些面试问题" class="headerlink" title="一些面试问题"></a>一些面试问题</h3><blockquote>
<p><strong>为什么最大槽数是16384？</strong></p>
<ul>
<li><p><a class="link" href="https://github.com/redis/redis/issues/2576">https://github.com/redis/redis/issues/2576 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</li>
<li><p>如果槽位是65536，发送心跳的消息头达8k，过于庞大</p>
<ul>
<li>消息头中最占空间的是<code>myslots[CLUSTER_SLOTS/8]</code><ul>
<li>槽位65536，大小为65536/8/1024=8kb</li>
<li>槽位16384，大小为16384/8/1024=2kb</li>
</ul>
</li>
<li>每秒钟，redis节点需要发送一定数量的PING包，如果槽位65536，太大了浪费带宽</li>
</ul>
</li>
<li><p>redis集群主节点数量基本不会超过1000个（网络杜塞），对1000以内的redis集群，16384个槽位够了</p>
</li>
<li><p>redis主节点负责的哈希槽是通过bitmap保存的。如果节点数少，哈希槽多，压缩率会很低</p>
</li>
</ul>
</blockquote>
<blockquote>
<p><strong>集群可能会写丢失</strong></p>
<ul>
<li>Redis集群不保证<code>数据强一致性</code>，意味着特定条件下，可能会丢掉一些写入请求命令</li>
</ul>
</blockquote>
<h3 id="集群案例"><a href="#集群案例" class="headerlink" title="集群案例"></a>集群案例</h3><ul>
<li>三主三从</li>
<li>具体的分配是自动来的，未必真的长这样</li>
</ul>
<pre class="mermaid">graph LR;
    subgraph master
        6381
        6383
        6385
    end
    subgraph slave
        6382
        6384
        6386
    end
    6381--&gt;6382
    6383--&gt;6384
    6385--&gt;6386</pre>



<h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><ul>
<li>/myreids/cluster6381.conf</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">bind 0.0.0.0</span><br><span class="line">daemonize yes</span><br><span class="line">protected-mode no</span><br><span class="line">port 6381</span><br><span class="line">logfile "/myredis/cluster6381.log"</span><br><span class="line">pidfile "/myredis/cluster6381.pid"</span><br><span class="line">dir /myredis</span><br><span class="line">dbfilename dump6381.rdb</span><br><span class="line">appendonly yes</span><br><span class="line">appendfilename "appendonly6381.aof"</span><br><span class="line">requirepass 123456</span><br><span class="line">masterauth 123456</span><br><span class="line"></span><br><span class="line">cluster-enabled yes						# 集群是否开启</span><br><span class="line">cluster-config-file nodes-6381.conf		# 集群配置文件</span><br><span class="line">cluster-node-timeout 5000				# 集群超时时间</span><br></pre></td></tr></table></figure></div>

<h4 id="启动6台redis主机"><a href="#启动6台redis主机" class="headerlink" title="启动6台redis主机"></a>启动6台redis主机</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-server /myreids/cluster6381.conf</span><br><span class="line">...</span><br><span class="line">redis-server /myreids/cluster6386.conf</span><br></pre></td></tr></table></figure></div>

<h4 id="通过redis-cli为6台机器构建集群关系"><a href="#通过redis-cli为6台机器构建集群关系" class="headerlink" title="通过redis-cli为6台机器构建集群关系"></a>通过redis-cli为6台机器构建集群关系</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-cli -a 123456 --cluster create --cluster-replicas 1 &lt;地址1:端口1&gt; &lt;地址2:端口2&gt; &lt;地址3:端口3&gt; &lt;地址4:端口4&gt; &lt;地址5:端口5&gt; &lt;地址6:端口6&gt;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>–cluster create：表示集群形式创建</p>
</li>
<li><p>–cluster-replicas 1：每个master一个slave</p>
</li>
<li><p>集群联通成功后，产生nodes-xxxx.conf配置文件</p>
</li>
</ul>
<h4 id="检验集群关系"><a href="#检验集群关系" class="headerlink" title="检验集群关系"></a>检验集群关系</h4><ul>
<li>info replication</li>
<li>cluster nodes：查看集群节点信息</li>
</ul>
<h4 id="读写数据"><a href="#读写数据" class="headerlink" title="读写数据"></a>读写数据</h4><ul>
<li>一定注意槽位的范围，需要路由到位（加参数-c）</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-cli -a 111111 -p 6381 -c</span><br></pre></td></tr></table></figure></div>

<ul>
<li>查看某个key属于的槽位</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">cluster keyslot &lt;key&gt;</span><br></pre></td></tr></table></figure></div>

<h3 id="主从容错切换迁移案例"><a href="#主从容错切换迁移案例" class="headerlink" title="主从容错切换迁移案例"></a>主从容错切换迁移案例</h3><ul>
<li><p>6381宕机，cluster nodes查看</p>
<ul>
<li>直接从机6382上位成为master</li>
</ul>
</li>
<li><p>6381恢复，cluster nodes查看</p>
<ul>
<li>江山易主，变成slave，master是6382</li>
</ul>
</li>
<li><p>6381，6382主从关系颠倒，如果想恢复原有关系（故障转移）</p>
</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">cluster failover</span><br></pre></td></tr></table></figure></div>

<h3 id="集群扩容"><a href="#集群扩容" class="headerlink" title="集群扩容"></a>集群扩容</h3><pre class="mermaid">graph LR;
    subgraph master
        6381
        6383
        6385
        6387-新
    end
    subgraph slave
        6382
        6384
        6386
        6388-新
    end
    6381--&gt;6382
    6383--&gt;6384
    6385--&gt;6386
    6387-新--&gt;6388-新</pre>

<ul>
<li>新启动redis实例，此时还不在集群中</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-server /myreids/cluster6387.conf</span><br><span class="line">redis-server /myreids/cluster6388.conf</span><br></pre></td></tr></table></figure></div>

<ul>
<li>将新增的6387作为master节点加入原有集群<ul>
<li>6381相当于原来集群里的引路人</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-cli -a 123456 --cluster add-node &lt;地址7:6387&gt; &lt;地址1:6381&gt;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>检查集群情况<ul>
<li>发现还未为6387分配槽位</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-cli -a 123456 --cluster check &lt;地址1:6381&gt;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>重新分配槽位<ul>
<li>How many slots do you want to move? <code>4096</code></li>
<li>What is the receving node ID: <code>&lt;6387节点的id&gt;</code></li>
<li>Source node #1: <code>all</code></li>
<li>分完再查看集群情况，可以看到6387被分配了许多段的槽位</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-cli -a 123456 --cluster reshard &lt;地址1:6381&gt;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>将新增的6388作为slave节点加入原有集群</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-cli -a 123456 --cluster add-node &lt;地址8:6388&gt; &lt;地址7:6387&gt; --cluster-slave --cluster-master-id &lt;6387主机节点id&gt;</span><br></pre></td></tr></table></figure></div>

<h3 id="集群缩容"><a href="#集群缩容" class="headerlink" title="集群缩容"></a>集群缩容</h3><ul>
<li>清除master节点6388</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 获得6388，6387，6381的id</span><br><span class="line">redis-cli -a 123456 --cluster check &lt;地址1:6381&gt;</span><br><span class="line"></span><br><span class="line"># 删除6388节点</span><br><span class="line">redis-cli -a 123456 --cluster del-node &lt;地址8:6388&gt; &lt;6388节点的id&gt;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>清除6387槽号，本例中，重新分配给6381<ul>
<li>How many slots do you want to move? <code>4096</code></li>
<li>What is the receving node ID: <code>&lt;6381节点的id&gt;</code></li>
<li>Source node #1: <code>&lt;6387节点的id&gt;</code></li>
<li>Source node #2: <code>done</code></li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-cli -a 123456 --cluster reshard &lt;地址1:6381&gt;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>此时6387由6381变成slave，挂在6381下面</p>
</li>
<li><p>删除slave节点6387</p>
</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-cli -a 123456 --cluster del-node &lt;地址7:6387&gt; &lt;6387节点的id&gt;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>恢复完毕，三主三从</li>
</ul>
<h3 id="集群常用操作和CRC16算法分析"><a href="#集群常用操作和CRC16算法分析" class="headerlink" title="集群常用操作和CRC16算法分析"></a>集群常用操作和CRC16算法分析</h3><h4 id="通识占位符"><a href="#通识占位符" class="headerlink" title="通识占位符"></a>通识占位符</h4><ul>
<li>不在同一个slot槽位下的键值无法使用mset，mget等多键操作</li>
<li>通识占位符登场</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 会分配到同一个槽位上，具体用什么占位符自定义</span><br><span class="line">mset k1{z} v1 k2{z} v2 k3{z} v3</span><br><span class="line"></span><br><span class="line">mget k1{z} k2{z} k3{z}</span><br></pre></td></tr></table></figure></div>

<h4 id="常用配置-x2F-命令"><a href="#常用配置-x2F-命令" class="headerlink" title="常用配置/命令"></a>常用配置/命令</h4><ul>
<li>集群是否完整才能对外提供服务<ul>
<li>原本三主三从。二主三从（可以服务）；二主二从（集群不完整了，不服务）</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 配置文件中</span><br><span class="line">cluster-require-full-coverage yes</span><br></pre></td></tr></table></figure></div>

<ul>
<li>查看槽位是否被占用<ul>
<li>1：被占用</li>
<li>0：没被占用</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">cluster countkeysinslot 12706</span><br></pre></td></tr></table></figure></div>

<ul>
<li>查看键应该存在哪个槽位上</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">cluster keyslot &lt;key&gt;</span><br></pre></td></tr></table></figure></div>

<h2 id="SpringBoot整合Redis"><a href="#SpringBoot整合Redis" class="headerlink" title="SpringBoot整合Redis"></a>SpringBoot整合Redis</h2><h3 id="总体概述"><a href="#总体概述" class="headerlink" title="总体概述"></a>总体概述</h3><ul>
<li>jedis<ul>
<li>相当于jdbc</li>
</ul>
</li>
<li>lettuce<ul>
<li>对jedis进一步优化</li>
</ul>
</li>
<li>RedisTemplate（推荐使用）<ul>
<li>进一步对lettuce做了封装</li>
</ul>
</li>
</ul>
<h3 id="集成jedis"><a href="#集成jedis" class="headerlink" title="集成jedis"></a>集成jedis</h3><ul>
<li>jedis client是Redis官网推荐的，面向java的客户端，实现了对各类API的封装</li>
<li>引入依赖</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>使用</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获得连接</span></span><br><span class="line"><span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">"192.168.114.40"</span>, <span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定密码</span></span><br><span class="line">jedis.auth(<span class="string">"123456"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问redis</span></span><br><span class="line">System.out.println(jedis.ping());</span><br><span class="line"></span><br><span class="line"><span class="comment">// keys</span></span><br><span class="line">Set&lt;String&gt; keys = jedis.keys(<span class="string">"*"</span>);</span><br><span class="line"><span class="type">long</span> <span class="variable">ttl</span> <span class="operator">=</span> jedis.ttl(<span class="string">"k1"</span>);</span><br><span class="line"><span class="type">long</span> <span class="variable">r1</span> <span class="operator">=</span> jedis.expire(<span class="string">"k1"</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// string</span></span><br><span class="line"><span class="type">String</span> <span class="variable">k1</span> <span class="operator">=</span> jedis.get(<span class="string">"k1"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// list</span></span><br><span class="line"><span class="type">long</span> <span class="variable">r2</span> <span class="operator">=</span> jedis.lpush(<span class="string">"l1"</span>, <span class="string">"11"</span>, <span class="string">"12"</span>, <span class="string">"13"</span>);</span><br><span class="line">List&lt;String&gt; l1 = jedis.lrange(<span class="string">"l1"</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他api自行探索</span></span><br></pre></td></tr></table></figure></div>

<h3 id="集成lettuce"><a href="#集成lettuce" class="headerlink" title="集成lettuce"></a>集成lettuce</h3><ul>
<li>使用jedis每次都需要new一个<ul>
<li>需要”池化技术“</li>
</ul>
</li>
<li>SpringBoot2.0之后，都默认使用Lettuce这个客户端连接Redis服务器<ul>
<li>Lettuce底层使用的是Netty</li>
</ul>
</li>
<li>引入依赖</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.lettuce&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>使用</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用构建器链式编程来build我们的RedisURI</span></span><br><span class="line"><span class="type">RedisURI</span> <span class="variable">uri</span> <span class="operator">=</span> RedisURI.builder()</span><br><span class="line">        .withHost(<span class="string">"192.168.114.40"</span>)</span><br><span class="line">        .withPort(<span class="number">6379</span>)</span><br><span class="line">        .withPassword(<span class="string">"123456"</span>)</span><br><span class="line">        .build();</span><br><span class="line"><span class="comment">// 创建连接客户端</span></span><br><span class="line"><span class="type">RedisClient</span> <span class="variable">redisClient</span> <span class="operator">=</span> RedisClient.create(uri);</span><br><span class="line"><span class="comment">// 获得连接</span></span><br><span class="line">StatefulRedisConnection&lt;String, String&gt; connect = redisClient.connect();</span><br><span class="line"><span class="comment">// 创建操作command</span></span><br><span class="line">RedisCommands&lt;String, String&gt; commands = connect.sync();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 业务逻辑</span></span><br><span class="line">List&lt;String&gt; l1 = commands.lrange(<span class="string">"l1"</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">System.out.println(l1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 各种关闭，释放资源</span></span><br><span class="line">connect.close();</span><br><span class="line">redisClient.shutdown();</span><br></pre></td></tr></table></figure></div>

<h3 id="集成RedisTemplate集成"><a href="#集成RedisTemplate集成" class="headerlink" title="集成RedisTemplate集成"></a>集成RedisTemplate集成</h3><ul>
<li>前两种了解即可，这个必须熟悉</li>
<li>导入依赖</li>
</ul>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--SpringBoot与Redis整合--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--swagger2--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>spring-boot-starter-data-redis</code>已帮我们引入了<code>lettuce</code></li>
</ul>
<h4 id="连接单机"><a href="#连接单机" class="headerlink" title="连接单机"></a>连接单机</h4><ul>
<li>配置</li>
</ul>
<div class="highlight-container" data-rel="Properties"><figure class="iseeu highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">7777</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring.application.name</span>=<span class="string">redis7_study</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment"># ========================logging=====================</span></span><br><span class="line"><span class="attr">logging.level.root</span>=<span class="string">info</span></span><br><span class="line"><span class="attr">logging.level.com.example.myredis</span>=<span class="string">info</span></span><br><span class="line"><span class="attr">logging.pattern.console</span>=<span class="string">%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger- %msg%n</span></span><br><span class="line"></span><br><span class="line"><span class="attr">logging.file.name</span>=<span class="string">C:/myredis/redis7_study.log</span></span><br><span class="line"><span class="attr">logging.pattern.file</span>=<span class="string">%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger- %msg%n</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment"># ========================swagger=====================</span></span><br><span class="line"><span class="comment">#在springboot2.6.X结合swagger2.9.X会提示documentationPluginsBootstrapper空指针异常，</span></span><br><span class="line"><span class="comment">#原因是在springboot2.6.X中将SpringMVC默认路径匹配策略从AntPathMatcher更改为PathPatternParser，</span></span><br><span class="line"><span class="comment"># 导致出错，解决办法是matching-strategy切换回之前ant_path_matcher</span></span><br><span class="line"><span class="attr">spring.swagger2.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.mvc.pathmatch.matching-strategy</span>=<span class="string">ant_path_matcher</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment"># ========================redis单机=====================</span></span><br><span class="line"><span class="attr">spring.redis.database</span>=<span class="string">0</span></span><br><span class="line"><span class="attr">spring.redis.host</span>=<span class="string">192.168.114.40</span></span><br><span class="line"><span class="attr">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="attr">spring.redis.password</span>=<span class="string">123456</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.max-active</span>=<span class="string">8</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.max-wait</span>=<span class="string">-1ms</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.max-idle</span>=<span class="string">8</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.min-idle</span>=<span class="string">0</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>配置类</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> {</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(LettuceConnectionFactory lettuceConnectionFactory)</span> {</span><br><span class="line">        RedisTemplate&lt;String,Object&gt; redisTemplate = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        redisTemplate.setConnectionFactory(lettuceConnectionFactory);</span><br><span class="line">        <span class="comment">//设置key序列化方式string</span></span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        <span class="comment">//设置value的序列化方式json，使用GenericJackson2JsonRedisSerializer替换默认序列化</span></span><br><span class="line">        redisTemplate.setValueSerializer(<span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>());</span><br><span class="line"></span><br><span class="line">        redisTemplate.setHashKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        redisTemplate.setHashValueSerializer(<span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>());</span><br><span class="line"></span><br><span class="line">        redisTemplate.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerConfig</span></span><br><span class="line">{</span><br><span class="line">    <span class="meta">@Value("${spring.swagger2.enabled}")</span></span><br><span class="line">    <span class="keyword">private</span> Boolean enabled;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">createRestApi</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .enable(enabled)</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">"com.example.myredis"</span>)) <span class="comment">//你自己的package</span></span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> ApiInfo <span class="title function_">apiInfo</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">                .title(<span class="string">"springboot利用swagger2构建api接口文档 "</span>+<span class="string">"\t"</span>+ DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd"</span>).format(LocalDateTime.now()))</span><br><span class="line">                .description(<span class="string">"springboot+redis整合,有问题给管理员发邮件:1625378509@qq.com"</span>)</span><br><span class="line">                .version(<span class="string">"1.0"</span>)</span><br><span class="line">                .termsOfServiceUrl(<span class="string">"https://www.atguigu.com/"</span>)</span><br><span class="line">                .build();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>使用</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ORDER_KEY</span> <span class="operator">=</span> <span class="string">"ord:"</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> ORDER_KEY + keyId;</span><br><span class="line">redisTemplate.opsForValue().set(key, value);</span><br><span class="line"></span><br><span class="line">redisTemplate.opsForValue().get(ORDER_KEY + keyId);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>问题</li>
</ul>
<blockquote>
<p>key和value都是通过Spring提供的Serialize序列化到数据库的</p>
<ul>
<li><p><code>RedisTemplate</code>默认使用<code>JdkSerializationRedisSerializer</code></p>
</li>
<li><p><code>StringRedisTemplate</code>默认使用<code>StringRedisSerializer</code></p>
</li>
</ul>
</blockquote>
<blockquote>
<p>redis-cli中使用中文</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-cli -a 123456 -p 6379 --raw</span><br></pre></td></tr></table></figure></div>
</blockquote>
<h4 id="连接集群"><a href="#连接集群" class="headerlink" title="连接集群"></a>连接集群</h4>]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>RabbitMQ基础</title>
    <url>//post/33842/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是RabbitMQ基础学习笔记</p>
<p>原文地址：<a href="https://xuedongyun.cn/post/33842/">https://xuedongyun.cn/post/33842/</a></p>
<h2 id="MQ相关概念"><a href="#MQ相关概念" class="headerlink" title="MQ相关概念"></a>MQ相关概念</h2><h3 id="什么是MQ"><a href="#什么是MQ" class="headerlink" title="什么是MQ"></a>什么是MQ</h3><ul>
<li>本质是个队列，先进先出（FIFO）</li>
<li>跨进程的通信机制，用于上下游传递消息</li>
<li>“逻辑解耦+物理解耦”的消息通信服务</li>
</ul>
<h3 id="为什么使用MQ"><a href="#为什么使用MQ" class="headerlink" title="为什么使用MQ"></a>为什么使用MQ</h3><ul>
<li>流量消峰</li>
</ul>
<p>比如下单，使用消息队列做缓冲。高峰期，排队进行，让短时间的请求分散到一定时间来处理。</p>
<p>可能导致用户下单很久，才能收到下单成功的消息。但也比无法下单好。</p>
<ul>
<li>应用解耦</li>
</ul>
<p>比如订单系统，通过消息队列调用物流系统。即使物流系统宕机10分钟，恢复后，也能继续处理订单。</p>
<ul>
<li>异步处理</li>
</ul>
<p>比如A调用B，B需要处理很长时间。可以用消息队列，A调用B的服务后，监听B处理完的消息。B完成后，会发送消息给MQ，MQ会将消息转发给A服务。</p>
<h3 id="MQ的分类"><a href="#MQ的分类" class="headerlink" title="MQ的分类"></a>MQ的分类</h3><ul>
<li><code>ActiveMQ</code>：很老的MQ</li>
<li><code>Kafka</code>：为大数据而生<ul>
<li>大型公司建议使用。有日志采集需求首选Kafka</li>
</ul>
</li>
<li><code>RocketMQ</code>：出自阿里巴巴，消息可以做到0丢失<ul>
<li>为金融互联网而生</li>
</ul>
</li>
<li><code>RabbitMQ</code>：最主流的消息中间件之<ul>
<li>性能好，时效性微秒级，社区活动度高，管理界面方便。如果数据量没有那么大，优先选用。</li>
</ul>
</li>
</ul>
<h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p>RabbitMQ是一个消息中间件，负责接收，存储，转发消息数据</p>
<h3 id="四大核心"><a href="#四大核心" class="headerlink" title="四大核心"></a>四大核心</h3><ul>
<li>生产者：产生数据的人</li>
<li>交换机：决定将消息推送到哪一个队列</li>
<li>队列：大的消息缓冲区</li>
<li>消费者：从队列中接收数据进行处理</li>
</ul>
<h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/07/31/27aZQYDc54exVnK.png" alt="image-20230731171245490" style="zoom: 67%;">

<ul>
<li><strong>Broker</strong>: 接收和分发消息的应用，Rabbit Server就是Message Broker</li>
<li><strong>Virtual host</strong>: 当多个用户使用同一个Rabbit MQ时，可以划分多个vhost。每个用户在自己的vhost中创建exchange，queue等</li>
<li><strong>Connection</strong>: publisher/consumer与broker之间的TCP连接</li>
<li><strong>Channel</strong>: 在Connection内部建立的逻辑连接，通常使用channel id帮助客户端和brocker识别channel</li>
<li><strong>Exchange</strong>: 交换机</li>
<li><strong>Queue</strong>: 队列</li>
<li><strong>Binding</strong>: Exchange和Queue之间的虚拟连接。Binding可以包含routing key，被保存到exchange中的查询表中。用作message的分发依据</li>
</ul>
<h3 id="安装教程"><a href="#安装教程" class="headerlink" title="安装教程"></a>安装教程</h3><p>使用系统：ubuntu22</p>
<p>官方文档：<a class="link" href="https://www.rabbitmq.com/download.html">https://www.rabbitmq.com/download.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<ul>
<li>安装RabbitMQ</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">sudo apt-get install curl gnupg apt-transport-https -y</span><br><span class="line"></span><br><span class="line"><span class="comment">## Team RabbitMQ's main signing key</span></span><br><span class="line">curl -1sLf <span class="string">"https://keys.openpgp.org/vks/v1/by-fingerprint/0A9AF2115F4687BD29803A206B73A36E6026DFCA"</span> | sudo gpg --dearmor | sudo <span class="built_in">tee</span> /usr/share/keyrings/com.rabbitmq.team.gpg &gt; /dev/null</span><br><span class="line"><span class="comment">## Community mirror of Cloudsmith: modern Erlang repository</span></span><br><span class="line">curl -1sLf https://ppa1.novemberain.com/gpg.E495BB49CC4BBE5B.key | sudo gpg --dearmor | sudo <span class="built_in">tee</span> /usr/share/keyrings/rabbitmq.E495BB49CC4BBE5B.gpg &gt; /dev/null</span><br><span class="line"><span class="comment">## Community mirror of Cloudsmith: RabbitMQ repository</span></span><br><span class="line">curl -1sLf https://ppa1.novemberain.com/gpg.9F4587F226208342.key | sudo gpg --dearmor | sudo <span class="built_in">tee</span> /usr/share/keyrings/rabbitmq.9F4587F226208342.gpg &gt; /dev/null</span><br><span class="line"></span><br><span class="line"><span class="comment">## Add apt repositories maintained by Team RabbitMQ</span></span><br><span class="line">sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/rabbitmq.list &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">## Provides modern Erlang/OTP releases</span></span><br><span class="line"><span class="string">##</span></span><br><span class="line"><span class="string">deb [signed-by=/usr/share/keyrings/rabbitmq.E495BB49CC4BBE5B.gpg] https://ppa1.novemberain.com/rabbitmq/rabbitmq-erlang/deb/ubuntu jammy main</span></span><br><span class="line"><span class="string">deb-src [signed-by=/usr/share/keyrings/rabbitmq.E495BB49CC4BBE5B.gpg] https://ppa1.novemberain.com/rabbitmq/rabbitmq-erlang/deb/ubuntu jammy main</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## Provides RabbitMQ</span></span><br><span class="line"><span class="string">##</span></span><br><span class="line"><span class="string">deb [signed-by=/usr/share/keyrings/rabbitmq.9F4587F226208342.gpg] https://ppa1.novemberain.com/rabbitmq/rabbitmq-server/deb/ubuntu jammy main</span></span><br><span class="line"><span class="string">deb-src [signed-by=/usr/share/keyrings/rabbitmq.9F4587F226208342.gpg] https://ppa1.novemberain.com/rabbitmq/rabbitmq-server/deb/ubuntu jammy main</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Update package indices</span></span><br><span class="line">sudo apt-get update -y</span><br><span class="line"></span><br><span class="line"><span class="comment">## Install Erlang packages</span></span><br><span class="line">sudo apt-get install -y erlang-base \</span><br><span class="line">                        erlang-asn1 erlang-crypto erlang-eldap erlang-ftp erlang-inets \</span><br><span class="line">                        erlang-mnesia erlang-os-mon erlang-parsetools erlang-public-key \</span><br><span class="line">                        erlang-runtime-tools erlang-snmp erlang-ssl \</span><br><span class="line">                        erlang-syntax-tools erlang-tftp erlang-tools erlang-xmerl</span><br><span class="line"></span><br><span class="line"><span class="comment">## Install rabbitmq-server and its dependencies</span></span><br><span class="line">sudo apt-get install rabbitmq-server -y --fix-missing</span><br></pre></td></tr></table></figure></div>

<ul>
<li>查看状态</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl status rabbitmq-server</span><br></pre></td></tr></table></figure></div>

<ul>
<li>启用web界面插件</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sudo rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><a class="link" href="http://localhost:15672/">http://localhost:15672 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>默认账号和密码：guest guest，但只有localhost才能登录</p>
</blockquote>
<ul>
<li>添加用户并设置权限</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建账号</span></span><br><span class="line">rabbitmqctl add_user admin 123456</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置角色：超级管理员</span></span><br><span class="line">rabbitmqctl set_user_tags admin administrator</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置权限</span></span><br><span class="line"><span class="comment"># set_permissions [-p &lt;vhostpath&gt;] &lt;user&gt; &lt;conf&gt; &lt;write&gt; &lt;read&gt;</span></span><br><span class="line"><span class="comment"># 用户将拥有"/"这个virtual host中所有资源的配置、写、读权限</span></span><br><span class="line">rabbitmqctl set_permissions -p <span class="string">"/"</span> admin <span class="string">".*"</span> <span class="string">".*"</span> <span class="string">".*"</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>查看当前用户和角色</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">rabbitmqctl list_users</span><br></pre></td></tr></table></figure></div>

<ul>
<li>重置命令</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 关闭应用</span></span><br><span class="line">rabbitmqctl stop_app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除命令</span></span><br><span class="line">rabbitmqctl reset</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动命令</span></span><br><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure></div>

<h2 id="简单队列模式"><a href="#简单队列模式" class="headerlink" title="简单队列模式"></a>简单队列模式</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/08/01/yepJnGmX2rQsA9a.png" alt="image-20230801201330758"></p>
<p>Java依赖</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># rabbitmq依赖客户端</span></span><br><span class="line">amqp-client</span><br><span class="line"></span><br><span class="line"><span class="comment"># 操作文件的依赖</span></span><br><span class="line">commons-io</span><br></pre></td></tr></table></figure></div>

<h3 id="创建连接"><a href="#创建连接" class="headerlink" title="创建连接"></a>创建连接</h3><p>创建：连接工厂 -&gt; 连接 -&gt; 信道 -&gt; 队列</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建连接工厂</span></span><br><span class="line"><span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">factory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">factory.setPassword(<span class="string">"123456"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建连接</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取信道</span></span><br><span class="line"><span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  声明一个队列</span></span><br><span class="line"><span class="comment">  参数1：队列名称</span></span><br><span class="line"><span class="comment">  参数2：消息是否持久化。消息默认存在内存中，可持久化到硬盘</span></span><br><span class="line"><span class="comment">  参数3：消息是否共享。一个消息可由多个消费者消费</span></span><br><span class="line"><span class="comment">  参数4：是否自动删除。最后一个消费者断开连接，队列是否删除</span></span><br><span class="line"><span class="comment">  参数5：其他配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure></div>

<h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">"hello world"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  发送消息</span></span><br><span class="line"><span class="comment">  参数1：发送到哪个交换机</span></span><br><span class="line"><span class="comment">  参数2：路由的key值</span></span><br><span class="line"><span class="comment">  参数3：其他配置</span></span><br><span class="line"><span class="comment">  参数4：消息体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, <span class="literal">null</span>, message.getBytes());</span><br></pre></td></tr></table></figure></div>

<h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (String consumerTag, Delivery message) -&gt; {</span><br><span class="line">    System.out.println(<span class="string">"消费已成功：message = "</span> + <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">CancelCallback</span> <span class="variable">cancelCallback</span> <span class="operator">=</span> (String consumerTag) -&gt; {</span><br><span class="line">    System.out.println(<span class="string">"消费被取消：consumerTag = "</span> + consumerTag);</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  消费消息</span></span><br><span class="line"><span class="comment">  参数1：消费的队列</span></span><br><span class="line"><span class="comment">  参数2：消费成功后是否自动应答</span></span><br><span class="line"><span class="comment">  参数3：消费成功回调</span></span><br><span class="line"><span class="comment">  参数4：消费取消回调</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">channel.basicConsume(QUEUE_NAME, <span class="literal">true</span>, deliverCallback, cancelCallback);</span><br></pre></td></tr></table></figure></div>

<h2 id="Work-Queues"><a href="#Work-Queues" class="headerlink" title="Work Queues"></a>Work Queues</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/08/01/SoMyBYrWQ7eLTnE.png" alt="image-20230801201354696"></p>
<p>工作队列模式：生产者发送大量消息，多个工作线程（消费者）接受并处理消息。</p>
<h3 id="轮询分发消息"><a href="#轮询分发消息" class="headerlink" title="轮询分发消息"></a>轮询分发消息</h3><p>多个消费者是竞争的关系，每条消息只会被处理一次</p>
<h4 id="抽取工具类"><a href="#抽取工具类" class="headerlink" title="抽取工具类"></a>抽取工具类</h4><p>RabbitMQ创建信道的工具类</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMqUtils</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Channel <span class="title function_">getChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException {</span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        factory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        factory.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="keyword">return</span> connection.createChannel();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="消费者-1"><a href="#消费者-1" class="headerlink" title="消费者"></a>消费者</h4><blockquote>
<p>这里使用idea手动运行多个线程</p>
</blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Work01</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException {</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt; {</span><br><span class="line">            System.out.println(<span class="string">"消费已成功：message = "</span> + <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        <span class="type">CancelCallback</span> <span class="variable">cancelCallback</span> <span class="operator">=</span> (consumerTag) -&gt; {</span><br><span class="line">            System.out.println(<span class="string">"消费被取消：consumerTag = "</span> + consumerTag);</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"c1等待接受消息"</span>);</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="literal">true</span>, deliverCallback, cancelCallback);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="生产者-1"><a href="#生产者-1" class="headerlink" title="生产者"></a>生产者</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Task01</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException {</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext()) {</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="消息应答"><a href="#消息应答" class="headerlink" title="消息应答"></a>消息应答</h3><p>为了保证消息在发送过程中不丢失，RabbitMQ引入了消息应答机制。消费者处理完消息后，告诉RabbitMQ：可以把消息删除了</p>
<h4 id="自动应答"><a href="#自动应答" class="headerlink" title="自动应答"></a>自动应答</h4><p>以接受到消息为准。自动应答相对不是很靠谱</p>
<h4 id="手动应答"><a href="#手动应答" class="headerlink" title="手动应答"></a>手动应答</h4><table>
<thead>
<tr>
<th>API</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>void basicAck(long deliveryTag, boolean multiple)</code></td>
<td>用于肯定确认</td>
</tr>
<tr>
<td><code>void basicNack(long deliveryTag, boolean multiple, boolean requeue)</code></td>
<td>用于否认</td>
</tr>
<tr>
<td><code>void basicReject(long deliveryTag, boolean requeue)</code></td>
<td>用于否认，少一个参数（不批量应答）</td>
</tr>
</tbody></table>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Work01</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException {</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt; {</span><br><span class="line">            System.out.println(<span class="string">"消费已成功：message = "</span> + <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line">            <span class="comment">// 手动应答 </span></span><br><span class="line">            channel.basicAck(message.getEnvelope().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        <span class="type">CancelCallback</span> <span class="variable">cancelCallback</span> <span class="operator">=</span> (consumerTag) -&gt; {</span><br><span class="line">            System.out.println(<span class="string">"消费被取消：consumerTag = "</span> + consumerTag);</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        <span class="comment">// autoAck设为false</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="literal">false</span>, deliverCallback, cancelCallback);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="Multiple解释"><a href="#Multiple解释" class="headerlink" title="Multiple解释"></a>Multiple解释</h4><p>手动应答可以批量应答，减少网络拥堵</p>
<p>true代表批量应答channel上未应答的消息（tag比当前小的都会被应答）</p>
<ul>
<li>假如channel上传递消息，tag为：8，7，6，5。若当前tag为8，应答后5-8中未应答的消息都会被确认</li>
</ul>
<p>false代表只应答当前消息</p>
<ul>
<li>假如channel上传递消息，tag为：8，7，6，5。若当前tag为8，应答后只有8会被确认</li>
</ul>
<blockquote>
<p>一般情况下使用false</p>
</blockquote>
<h4 id="消息重新入队"><a href="#消息重新入队" class="headerlink" title="消息重新入队"></a>消息重新入队</h4><p>假如消费者由于某些原因失去连接（通道关闭，连接关闭或TCP连接丢失），导致未发送ACK确认，RabbitMQ将对其重新排队。</p>
<p>当消息回滚到消息队列时，这条消息不会回到队列尾部，而是仍是在队列头部，这时某个消费者会立马又接收到这条消息进行处理。</p>
<h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>为了确保消息在RabbitMQ中不会丢失，我们需要将<strong>队列</strong>和<strong>消息</strong>都标记为持久化</p>
<h4 id="队列持久化"><a href="#队列持久化" class="headerlink" title="队列持久化"></a>队列持久化</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建队列时，声明队列需要持久化</span></span><br><span class="line"><span class="comment">// 记得先将之前的同名队列删除</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">durable</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">channel.queueDeclare(QUEUE_NAME, durable, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure></div>

<p>此时Features下方会有一个”D”，现在即使重启RabbitMQ队列也不会丢失</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/08/01/TfZhc6xpe3YHAk4.png" alt="image-20230801222521233"></p>
<h4 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发布消息时</span></span><br><span class="line"><span class="comment">// 以前</span></span><br><span class="line">channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, <span class="literal">null</span>, message.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在</span></span><br><span class="line">channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes());</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>尽管它告诉RabbitMQ将消息保存到磁盘，但是这里依然存在：当刚准备存储在磁盘时，突然宕机的情况。无法保证百分百数据不丢失。但是对我们的简单队列来说，绰绰有余了。</p>
<p>更强力的持久化策略，参考后面的发布确认章节</p>
</blockquote>
<h3 id="不公平分发"><a href="#不公平分发" class="headerlink" title="不公平分发"></a>不公平分发</h3><p>正常情况下使用轮询分发。假如有两个消费者，消费者A处理非常快，消费者B处理非常慢。这会导致处理的快的A有大量的空闲时间，处理的慢的消费者B一直在干活。</p>
<p>为避免这种情况，我们可以设置参数<code>channel.basicQos(int prefetchCount)</code>。能者多劳</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由消费方设置</span></span><br><span class="line"><span class="comment">// 设为1就是不公平分发，设为0就是轮询分发</span></span><br><span class="line"><span class="type">int</span> <span class="variable">prefetchCount</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">channel.basicQos(prefetchCount);</span><br></pre></td></tr></table></figure></div>

<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/08/03/ypuAfQKGsFkzMN3.png" alt="image-20230803160747978"></p>
<blockquote>
<p>可以在Channels里看到一个Queue，Prefetch count（分配数量）为1</p>
</blockquote>
<h4 id="预取值概念"><a href="#预取值概念" class="headerlink" title="预取值概念"></a>预取值概念</h4><p>预取值（prefetch）：一个channel中，未确认的消息缓冲区大小。（消费者的手动确认本质上也是异步的）</p>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/08/03/wWQTHmgCE7ZcYV8.png" alt="image-20230803161552926" style="zoom:50%;">

<p>正常情况下依然是能者多干。如果同时有7条数据，那么会指定，按照2条，5条分配。</p>
<h2 id="发布确认"><a href="#发布确认" class="headerlink" title="发布确认"></a>发布确认</h2><p>即使队列和消息都设置持久化，仍然存在消息丢失的可能（比如还未存到磁盘上就宕机了）</p>
<p>生产者将信道设置成confirm模式。所有在该信道上面发布的消息都将会被指派一个唯一的ID(从1开始)，一旦消息被投递到所有匹配的队列之后，broker就会发送一个确认给生产者(包含消息的唯一 ID)，这就使得生产者知道消息已经正确到达目的队列了。</p>
<p> 如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出。</p>
<h3 id="开启发布确认"><a href="#开启发布确认" class="headerlink" title="开启发布确认"></a>开启发布确认</h3><p>在生产者部分设置</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开启发布确认功能</span></span><br><span class="line">channel.confirmSelect();</span><br></pre></td></tr></table></figure></div>

<h3 id="单个确认发布"><a href="#单个确认发布" class="headerlink" title="单个确认发布"></a>单个确认发布</h3><p>它是一种<strong>同步确认发布</strong>方式。发一条，确认一次。上一条消息确认了，下一条消息才能发布。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">pubMsgOne</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException {</span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">    channel.confirmSelect();</span><br><span class="line">    channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) {</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> String.valueOf(i);</span><br><span class="line">        channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, <span class="literal">null</span>, msg.getBytes());</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> channel.waitForConfirms();</span><br><span class="line">        <span class="keyword">if</span> (flag) {</span><br><span class="line">            System.out.println(<span class="string">"发送成功"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="批量确认发布"><a href="#批量确认发布" class="headerlink" title="批量确认发布"></a>批量确认发布</h3><p>依然是同步的</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">pubMsgBatch</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException {</span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">    channel.confirmSelect();</span><br><span class="line">    <span class="comment">// 批量确认消息大小</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">batchSize</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 待确认消息个数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">outstandingMsg</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) {</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> String.valueOf(i);</span><br><span class="line">        channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, <span class="literal">null</span>, msg.getBytes());</span><br><span class="line">        outstandingMsg++;</span><br><span class="line">        <span class="keyword">if</span> (outstandingMsg == batchSize) {</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> channel.waitForConfirms();</span><br><span class="line">            <span class="keyword">if</span> (flag) {</span><br><span class="line">                System.out.println(<span class="string">"本批次消息发送成功"</span>);</span><br><span class="line">            }</span><br><span class="line">            outstandingMsg = <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="异步确认发布"><a href="#异步确认发布" class="headerlink" title="异步确认发布"></a>异步确认发布</h3><p>通过回调函数的方式来确保投递成功</p>
<blockquote>
<p>简单来说：<code>ConcurrentSkipListMap</code>是<code>TreeMap</code>的并发实现，但是为什么没有称之为<code>ConcurrentTreeMap</code>呢？这和其自身的实现有关，该类是<code>SkipLists</code>的变种实现</p>
</blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">pubMsgAsync</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException {</span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">    channel.confirmSelect();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程安全的有序哈希表，将序号与消息关联。支持通过序列号批量删除</span></span><br><span class="line">    ConcurrentSkipListMap&lt;Long, String&gt; outstandingConfirm = <span class="keyword">new</span> <span class="title class_">ConcurrentSkipListMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="type">ConfirmCallback</span> <span class="variable">ackCallback</span> <span class="operator">=</span> (deliveryTag, multiple) -&gt; {</span><br><span class="line">        <span class="comment">// 批量确认（不过一般很少用）</span></span><br><span class="line">        <span class="keyword">if</span> (multiple) {</span><br><span class="line">            <span class="comment">// 返回小于等于当前序列号的未确认消息，是一个map</span></span><br><span class="line">            ConcurrentNavigableMap&lt;Long, String&gt; confirm = outstandingConfirm.headMap(deliveryTag, <span class="literal">true</span>);</span><br><span class="line">            confirm.clear();</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 只清除当前序号</span></span><br><span class="line">            outstandingConfirm.remove(deliveryTag);</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 传参：ackCallback和nackCallback</span></span><br><span class="line">    channel.addConfirmListener(ackCallback, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) {</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> String.valueOf(i);</span><br><span class="line">        outstandingConfirm.put(channel.getNextPublishSeqNo(), msg);</span><br><span class="line">        channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, <span class="literal">null</span>, msg.getBytes());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h3><ul>
<li>发布1000个单独确认消息：50,278 ms</li>
<li>发布1000个批量确认消息：635 ms</li>
<li>发布1000个异步确认消息：92 ms</li>
</ul>
<h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>我们之前一直假设，每个任务都恰好交付给一个消费者。现在，我们希望将一个消息传达给多个消费者。这种模式就是Pub/Sub模式</p>
<p>例子：日志系统，第一个程序将日志发送到消息队列中；然后启动两个消费者，一个消费者把日志存储到磁盘，另一个消费者把日志打印在屏幕上</p>
<h3 id="Exchanges"><a href="#Exchanges" class="headerlink" title="Exchanges"></a>Exchanges</h3><p>事实上，在RabbitMQ中消息不会直接发送给队列，而是会发送给交换机。交换机负责接受消息并推入队列。</p>
<h4 id="交换机的类型"><a href="#交换机的类型" class="headerlink" title="交换机的类型"></a>交换机的类型</h4><p>直接（direct），主题（topic），标题（headers），扇出（fanout）</p>
<h4 id="无名交换机"><a href="#无名交换机" class="headerlink" title="无名交换机"></a>无名交换机</h4><p>当我们用空字符串，表示无名交换机时：目标队列实际上是由<code>routeKey</code>绑定的key指定的</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, <span class="literal">null</span>, msg.getBytes());</span><br></pre></td></tr></table></figure></div>

<h3 id="临时队列"><a href="#临时队列" class="headerlink" title="临时队列"></a>临时队列</h3><p>我们可以创建一个随机名称的新队列。一旦消费者全断开连接，队列将被删除</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br></pre></td></tr></table></figure></div>

<h4 id="绑定-binding"><a href="#绑定-binding" class="headerlink" title="绑定(binding)"></a>绑定(binding)</h4><p>就是交换机和队列之间的映射关系</p>
<p><img lazyload="" src="/images/loading.svg" data-src="C:\Users\xdy\AppData\Roaming\Typora\typora-user-images\image-20230805114503667.png" alt="image-20230805114503667"></p>
<h3 id="Fanout交换机"><a href="#Fanout交换机" class="headerlink" title="Fanout交换机"></a>Fanout交换机</h3><p>Fanout这种类型的Exchange，会将接受到的消息<strong>广播</strong>到它知道的所有队列中</p>
<ul>
<li>消费者（可以运行多个）</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLog1</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException {</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明交换机，类型为Fanout</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">"logs"</span>, BuiltinExchangeType.FANOUT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明一个临时队列，消费者断开连接队列就没了</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定交换机和队列</span></span><br><span class="line">        channel.queueBind(queueName, <span class="string">"logs"</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt; {</span><br><span class="line">            System.out.println(<span class="string">"消费者1已接收到消息："</span> + <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        channel.basicConsume(queueName, <span class="literal">true</span>, deliverCallback, (CancelCallback) <span class="literal">null</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>生产者</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmitLog</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException {</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">// 声明一个交换机，类型为Fanout</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">"logs"</span>, BuiltinExchangeType.FANOUT);</span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext()) {</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            channel.basicPublish(<span class="string">"logs"</span>, <span class="string">""</span>, <span class="literal">null</span>, msg.getBytes());</span><br><span class="line">            System.out.println(<span class="string">"msg = "</span> + msg);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>此时，Fanout类型的交换机会把接受到的消息<strong>广播</strong>到所有绑定的队列上去</p>
<h3 id="Direct交换机"><a href="#Direct交换机" class="headerlink" title="Direct交换机"></a>Direct交换机</h3><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/08/05/ah3JHXP5mIpWV4j.png" alt="image-20230805163515227"></p>
<ul>
<li>我们可以声明Direct类型的交换机，发送到交换机的消息，会根据Routing key分配到不同的队列中</li>
</ul>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/08/05/58btmSXJTEOMe6x.png" alt="image-20230805160323352"></p>
<ul>
<li>消费者，声明完Direct类型的交换机后，还根据routingKey为交换机绑定了队列</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLogDirect01</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">"direct_logs"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException {</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明交换机</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明一个队列</span></span><br><span class="line">        channel.queueDeclare(<span class="string">"console"</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定交换机和队列，routingKey为：info或warning的消息，都会被分配给该队列</span></span><br><span class="line">        channel.queueBind(<span class="string">"console"</span>, EXCHANGE_NAME, <span class="string">"info"</span>);</span><br><span class="line">        channel.queueBind(<span class="string">"console"</span>, EXCHANGE_NAME, <span class="string">"warning"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt; {</span><br><span class="line">            System.out.println(<span class="string">"消费者1已接收到消息："</span> + <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        channel.basicConsume(<span class="string">"console"</span>, <span class="literal">true</span>, deliverCallback, (CancelCallback) <span class="literal">null</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>现在发送给direct_logs交换机的消息，只要routingKey为info或者warning，都会被发送到console队列</p>
<h3 id="Topic交换机"><a href="#Topic交换机" class="headerlink" title="Topic交换机"></a>Topic交换机</h3><p>对于Direct交换机来说，一个routingKey只能路由到唯一的队列。</p>
<h4 id="Topic的要求"><a href="#Topic的要求" class="headerlink" title="Topic的要求"></a>Topic的要求</h4><p>发送到Topic类型交换机的消息的routingKey不能随意写，必须满足一定的要求。它必须是<strong>一个单词列表，以点分割</strong>。比如”quick.orange.rabbit“。单词列表最多不能超过255个字节。</p>
<p>有两个替换符需要注意：</p>
<ul>
<li><p>*可以代替一个单词，比如:</p>
<ul>
<li><p>*.orange.*</p>
</li>
<li><h4 id="rabbit"><a href="#rabbit" class="headerlink" title="*.*.rabbit"></a>*.*.rabbit</h4></li>
</ul>
</li>
<li><p>#可以代替零个或多个单词，比如:</p>
<ul>
<li>quick.#</li>
</ul>
</li>
</ul>
<h4 id="Topic匹配案例"><a href="#Topic匹配案例" class="headerlink" title="Topic匹配案例"></a>Topic匹配案例</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/08/05/LIM5yEPc7SBp8WQ.png" alt="image-20230805164243582"></p>
<table>
<thead>
<tr>
<th>routingKey</th>
<th>接收队列</th>
</tr>
</thead>
<tbody><tr>
<td><code>quick.orange.rabbit</code></td>
<td>Q1，Q2</td>
</tr>
<tr>
<td><code>lazy.orange.elephant</code></td>
<td>Q1，Q2</td>
</tr>
<tr>
<td><code>quick.orange.fox</code></td>
<td>Q1</td>
</tr>
<tr>
<td><code>lazy.brown.fox</code></td>
<td>Q2</td>
</tr>
<tr>
<td><code>lazy.pink.rabbit</code></td>
<td>Q2（只会接收一次）</td>
</tr>
<tr>
<td><code>quick.brown.fox</code></td>
<td>不匹配任何绑定，被丢弃</td>
</tr>
<tr>
<td><code>quick.orange.male.rabbit</code></td>
<td>不匹配任何绑定，被丢弃</td>
</tr>
<tr>
<td><code>lazy.orange.male.rabbit</code></td>
<td>Q2</td>
</tr>
</tbody></table>
<p>两种特殊队列绑定：</p>
<ul>
<li>#：这个队列将接收交换机的所有消息，类似Fanout</li>
<li>没有#和*：这个队列的绑定类型就是Direct了</li>
</ul>
<h4 id="实战代码"><a href="#实战代码" class="headerlink" title="实战代码"></a>实战代码</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/08/05/weOFVnk8NjSTIuR.png" alt="image-20230805165031366"></p>
<ul>
<li>消费者</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 消费者1，消费者2同理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLogTopic1</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">"topic_logs"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException {</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明Topic类型的交换机</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(<span class="string">"Q1"</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 绑定队列，指定routingKey</span></span><br><span class="line">        channel.queueBind(<span class="string">"Q1"</span>, EXCHANGE_NAME, <span class="string">"*.orange.*"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt; {</span><br><span class="line">            System.out.println(<span class="string">"消费者1已接收到消息："</span> + <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()) +</span><br><span class="line">                    <span class="string">"绑定键为："</span> + message.getEnvelope().getRoutingKey());</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        channel.basicConsume(<span class="string">"Q1"</span>, <span class="literal">true</span>, deliverCallback, (CancelCallback) <span class="literal">null</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>生产者</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmitLog</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">"topic_logs"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException {</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        map.put(<span class="string">"quick.orange.rabbit"</span>, <span class="string">"Q1，Q2"</span>);</span><br><span class="line">        map.put(<span class="string">"lazy.orange.elephant"</span>, <span class="string">"Q1，Q2"</span>);</span><br><span class="line">        map.put(<span class="string">"quick.orange.fox"</span>, <span class="string">"Q1"</span>);</span><br><span class="line">        map.put(<span class="string">"lazy.brown.fox"</span>, <span class="string">"Q2"</span>);</span><br><span class="line">        map.put(<span class="string">"lazy.pink.rabbit"</span>, <span class="string">"Q2（只会接收一次）"</span>);</span><br><span class="line">        map.put(<span class="string">"quick.brown.fox"</span>, <span class="string">"不匹配任何绑定，被丢弃"</span>);</span><br><span class="line">        map.put(<span class="string">"quick.orange.male.rabbit"</span>, <span class="string">"不匹配任何绑定，被丢弃"</span>);</span><br><span class="line">        map.put(<span class="string">"lazy.orange.male.rabbit"</span>, <span class="string">"Q2"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) {</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, key, <span class="literal">null</span>, value.getBytes());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h2><p>死信，就是无法被消费的消息。消费者取出消息后，可能由于某些原因<strong>导致消息无法被消费</strong>，这样消息没有后续处理，就成为了死信。</p>
<p>为保证订单消息数据不丢失，需要用到死信队列机制。</p>
<p>应用场景：</p>
<ul>
<li>当消息消费异常时，将消息投入死信队列（等后续恢复了再消费）</li>
<li>用户下单后，指定时间未付款，订单自动取消</li>
</ul>
<h3 id="死信的来源"><a href="#死信的来源" class="headerlink" title="死信的来源"></a>死信的来源</h3><ul>
<li>消息TTL过期</li>
<li>队列达到最大长度</li>
<li>消息被拒绝（basicReject，且requeue为false）（basicNack）</li>
</ul>
<h3 id="死信实战"><a href="#死信实战" class="headerlink" title="死信实战"></a>死信实战</h3><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/08/05/hBbOQHpRn7iZYjJ.png" alt="image-20230805171705551" style="zoom: 50%;">

<ul>
<li>消息生产者，设置TTL</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_EXCHANGE</span> <span class="operator">=</span> <span class="string">"normal_exchange"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException {</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 死信消息，设置TTL</span></span><br><span class="line">        AMQP.<span class="type">BasicProperties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AMQP</span>.BasicProperties().builder().expiration(<span class="string">"5000"</span>).build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">"info"</span> + i;</span><br><span class="line">            channel.basicPublish(NORMAL_EXCHANGE, <span class="string">"normal"</span>, properties, message.getBytes());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>普通消费者</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 死信队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer01</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_EXCHANGE</span> <span class="operator">=</span> <span class="string">"normal_exchange"</span>;</span><br><span class="line">    <span class="comment">// 死信交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_EXCHANGE</span> <span class="operator">=</span> <span class="string">"dead_exchange"</span>;</span><br><span class="line">    <span class="comment">// 普通队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_QUEUE</span> <span class="operator">=</span> <span class="string">"normal_queue"</span>;</span><br><span class="line">    <span class="comment">// 死信队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_QUEUE</span> <span class="operator">=</span> <span class="string">"dead_queue"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException {</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明交换机</span></span><br><span class="line">        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// arguments.put("x-message-ttl", 10000); // 消息过期时间，更推荐发送方来设置</span></span><br><span class="line">        arguments.put(<span class="string">"x-dead-letter-exchange"</span>, DEAD_EXCHANGE); <span class="comment">// 死信交换机</span></span><br><span class="line">        arguments.put(<span class="string">"x-dead-letter-routing-key"</span>, <span class="string">"dead"</span>); <span class="comment">// 死信routing-key</span></span><br><span class="line">        arguments.put(<span class="string">"x-max-length"</span>, <span class="number">6</span>); <span class="comment">// 消息最大长度</span></span><br><span class="line">        channel.queueDeclare(NORMAL_QUEUE, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, arguments);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 死信队列</span></span><br><span class="line">        channel.queueDeclare(DEAD_QUEUE, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定普通队列</span></span><br><span class="line">        channel.queueBind(NORMAL_QUEUE, NORMAL_EXCHANGE, <span class="string">"normal"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定死信队列</span></span><br><span class="line">        channel.queueBind(DEAD_QUEUE, DEAD_EXCHANGE, <span class="string">"dead"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt; {</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">            <span class="comment">// 模拟消息被拒</span></span><br><span class="line">            <span class="keyword">if</span> (msg.equals(<span class="string">"info5"</span>)) {</span><br><span class="line">                System.out.println(<span class="string">"message = "</span> + msg + <span class="string">"此消息被拒绝"</span>);</span><br><span class="line">                <span class="comment">// 拒绝该消息，该消息会发送给死信交换机</span></span><br><span class="line">                channel.basicReject(message.getEnvelope().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                System.out.println(<span class="string">"message = "</span> + msg);</span><br><span class="line">                channel.basicAck(message.getEnvelope().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        channel.basicConsume(NORMAL_QUEUE, <span class="literal">false</span>, deliverCallback, (CancelCallback) <span class="literal">null</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>死信消费者</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer02</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_QUEUE</span> <span class="operator">=</span> <span class="string">"dead_queue"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException {</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt; {</span><br><span class="line">            System.out.println(<span class="string">"message = "</span> + <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        channel.basicConsume(DEAD_QUEUE, <span class="literal">true</span>, deliverCallback, (CancelCallback) <span class="literal">null</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="总结：声明队列时的参数"><a href="#总结：声明队列时的参数" class="headerlink" title="总结：声明队列时的参数"></a>总结：声明队列时的参数</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">arguments.put(<span class="string">"x-message-ttl"</span>, <span class="number">10000</span>); 						<span class="comment">// 更推荐发送方来设置</span></span><br><span class="line">arguments.put(<span class="string">"x-dead-letter-exchange"</span>, DEAD_EXCHANGE);		<span class="comment">// 声明死信息交换机</span></span><br><span class="line">arguments.put(<span class="string">"x-dead-letter-routing-key"</span>, <span class="string">"dead"</span>);			<span class="comment">// 设置发送到死信交换机的routing-key</span></span><br><span class="line">arguments.put(<span class="string">"x-max-length"</span>, <span class="number">6</span>);							<span class="comment">// 设置队列的最大长度，超出发给死信交换机</span></span><br></pre></td></tr></table></figure></div>

<h2 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h2><p>延迟队列其实就是死信队列的一种。简单来说，延迟队列就是用来存放需要在指定时间被处理的元素的队列。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>订单十分钟内未支付，则自动取消</li>
<li>新创建的店铺，十天都没有上传过商品，则自动提醒</li>
<li>用户注册成功后，三天都没有登录，则短信提醒</li>
<li>用户发起退款，三天没人处理，则通知相关运营人员</li>
<li>预定会议后，开始前十分钟提醒各人员参会</li>
</ul>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>可以直接看下一章：《整合SpringBoot》</p>
<h2 id="整合SpringBoot"><a href="#整合SpringBoot" class="headerlink" title="整合SpringBoot"></a>整合SpringBoot</h2><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--RabbitMQ 依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!--RabbitMQ 测试依赖 可不加--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.amqp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-rabbit-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">guest</span></span><br></pre></td></tr></table></figure></div>

<h3 id="队列TTL"><a href="#队列TTL" class="headerlink" title="队列TTL"></a>队列TTL</h3><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/08/12/juFIVCkmaGp3lgH.png" alt="image-20230812213639446"></p>
<h4 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h4><p>创建：交换机，队列，绑定</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqConstant</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_EXCHANGE</span> <span class="operator">=</span> <span class="string">"X"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TTL_10_QUEUE_KEY</span> <span class="operator">=</span> <span class="string">"XA"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TTL_40_QUEUE_KEY</span> <span class="operator">=</span> <span class="string">"XB"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TTL_10_QUEUE</span> <span class="operator">=</span> <span class="string">"QA"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TTL_40_QUEUE</span> <span class="operator">=</span> <span class="string">"QB"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_EXCHANGE</span> <span class="operator">=</span> <span class="string">"Y"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_QUEUE_KEY</span> <span class="operator">=</span> <span class="string">"YD"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_QUEUE</span> <span class="operator">=</span> <span class="string">"QD"</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TtlQueueConfig</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">normalExchange</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(NORMAL_EXCHANGE);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">deadExchange</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(DEAD_EXCHANGE);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueTtl10</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.nonDurable(TTL_10_QUEUE)</span><br><span class="line">                .deadLetterExchange(DEAD_EXCHANGE)</span><br><span class="line">                .deadLetterRoutingKey(DEAD_QUEUE_KEY)</span><br><span class="line">                .ttl(<span class="number">10000</span>)</span><br><span class="line">                .build();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueTtl40</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.nonDurable(TTL_40_QUEUE)</span><br><span class="line">                .deadLetterExchange(DEAD_EXCHANGE)</span><br><span class="line">                .deadLetterRoutingKey(DEAD_QUEUE_KEY)</span><br><span class="line">                .ttl(<span class="number">40000</span>)</span><br><span class="line">                .build();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueDead</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.nonDurable(DEAD_QUEUE).build();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">queueABindingX</span><span class="params">(Queue queueTtl10, DirectExchange normalExchange)</span> {</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueTtl10).to(normalExchange).with(TTL_10_QUEUE_KEY);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">queueBBindingX</span><span class="params">(Queue queueTtl40, DirectExchange normalExchange)</span> {</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueTtl40).to(normalExchange).with(TTL_40_QUEUE_KEY);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">queueDBindingY</span><span class="params">(Queue queueDead, DirectExchange deadExchange)</span> {</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueDead).to(deadExchange).with(DEAD_QUEUE_KEY);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="生产者-2"><a href="#生产者-2" class="headerlink" title="生产者"></a>生产者</h4><p>发送消息：<a class="link" href="http://localhost:8080/ttl/sendMsg/hello">http://localhost:8080/ttl/sendMsg/hello <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping("/ttl")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMsgController</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping("/sendMsg/{msg}")</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sendMsg</span><span class="params">(<span class="meta">@PathVariable</span> String msg)</span> {</span><br><span class="line">        log.info(<span class="string">"当前时间：{}，发送消息给队列：{}"</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), msg);</span><br><span class="line">        rabbitTemplate.convertAndSend(NORMAL_EXCHANGE, TTL_10_QUEUE_KEY, <span class="string">"来自TTL为10s的队列"</span> + msg);</span><br><span class="line">        rabbitTemplate.convertAndSend(NORMAL_EXCHANGE, TTL_40_QUEUE_KEY, <span class="string">"来自TTL为40s的队列"</span> + msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"发送成功"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="消费者-2"><a href="#消费者-2" class="headerlink" title="消费者"></a>消费者</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadQueueConsumer</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = DEAD_QUEUE)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveDead</span><span class="params">(Message message, Channel channel)</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">        log.info(<span class="string">"当前时间：{}，收到死信队列消息：{}"</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), msg);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="延迟队列优化"><a href="#延迟队列优化" class="headerlink" title="延迟队列优化"></a>延迟队列优化</h4><p>QC不设置过期时间，由生产者指定过期时间</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/08/12/f7hXe69vkmNSnMC.png" alt="image-20230812213704665"></p>
<ul>
<li>添加队列</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqConstant</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">Queue_C</span> <span class="operator">=</span> <span class="string">"QC"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_C_KEY</span> <span class="operator">=</span> <span class="string">"XC"</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TtlQueueConfig</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不设置TTL</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueC</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.nonDurable(Queue_C)</span><br><span class="line">                .deadLetterExchange(DEAD_EXCHANGE)</span><br><span class="line">                .deadLetterRoutingKey(DEAD_QUEUE_KEY)</span><br><span class="line">                .build();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">queueCBingX</span><span class="params">(Queue queueC, DirectExchange normalExchange)</span> {</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueC).to(normalExchange).with(QUEUE_C_KEY);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>发送消息时，设置TTL</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">rabbitTemplate.convertAndSend(NORMAL_EXCHANGE, QUEUE_C_KEY, <span class="string">"来自queueC的消息"</span> + msg,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">MessagePostProcessor</span>() {</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Message <span class="title function_">postProcessMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> AmqpException {</span><br><span class="line">                        message.getMessageProperties().setExpiration(<span class="string">"10000"</span>);</span><br><span class="line">                        <span class="keyword">return</span> message;</span><br><span class="line">                    }</span><br><span class="line">                });</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用lambda表达式</span></span><br><span class="line">rabbitTemplate.convertAndSend(NORMAL_EXCHANGE, QUEUE_C_KEY, <span class="string">"来自queueC的消息"</span> + msg,</span><br><span class="line">                message -&gt; {</span><br><span class="line">                    message.getMessageProperties().setExpiration(<span class="string">"10000"</span>);</span><br><span class="line">                    <span class="keyword">return</span> message;</span><br><span class="line">                });</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>但是这么做是<strong>有问题的</strong>：</p>
<p>RabbitMQ只会检查第一个消息是否过期，如果过期则丢到死信队列。</p>
<p>如果第一个消息的延时时长很长，而第二个消息的延时时长很短，第二个消息并不会优先得到执行。</p>
</blockquote>
<h3 id="RabbitMQ插件实现延迟队列"><a href="#RabbitMQ插件实现延迟队列" class="headerlink" title="RabbitMQ插件实现延迟队列"></a>RabbitMQ插件实现延迟队列</h3><h4 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h4><p>为了解决上述提到的问题，使用了插件</p>
<p>插件官网：<a class="link" href="https://www.rabbitmq.com/community-plugins.html">https://www.rabbitmq.com/community-plugins.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>下载插件：<code>rabbitmq_delayed_message_exchange</code></p>
<p>将插件放在<code>/usr/lib/rabbitmq/lib/rabbitmq_server-3.12.2/plugins</code>目录中，执行命令</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo rabbitmq-plugins enable rabbitmq_delayed_message_exchange</span><br></pre></td></tr></table></figure></div>

<p>安装成功后，添加交换机时可以看到，出现了新的Type：<code>x-delayed-message</code></p>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/08/12/XK4CwDcNYb27nuk.png" alt="image-20230812220627538" style="zoom:50%;">

<p>此时整体原理将简单很多。消息将在交换机处延迟，时间到了之后发给死信队列。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/08/12/j5MCr4hWNoO6m81.png" alt="image-20230812220816709"></p>
<h4 id="配置类-1"><a href="#配置类-1" class="headerlink" title="配置类"></a>配置类</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAYED_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">"delayed.queue"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAYED_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">"delayed.exchange"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAYED_ROUTING_KEY</span> <span class="operator">=</span> <span class="string">"delayed.routingkey"</span>;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">delayedQueue</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(DELAYED_QUEUE_NAME);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> CustomExchange <span class="title function_">delayedExchange</span><span class="params">()</span> {</span><br><span class="line">    HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">"x-delayed-type"</span>, <span class="string">"direct"</span>);</span><br><span class="line">    <span class="comment">// 自定义交换机的类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomExchange</span>(DELAYED_EXCHANGE_NAME, <span class="string">"x-delayed-message"</span>, <span class="literal">true</span>, <span class="literal">false</span>, map);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">bindingDelayedQueue</span><span class="params">(Queue delayedQueue, CustomExchange delayedExchange)</span> {</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(delayedQueue).to(delayedExchange).with(DELAYED_ROUTING_KEY).noargs();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="生产者-3"><a href="#生产者-3" class="headerlink" title="生产者"></a>生产者</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意这里是setDelay</span></span><br><span class="line">rabbitTemplate.convertAndSend(DELAYED_EXCHANGE_NAME, DELAYED_ROUTING_KEY, msg, message -&gt; {</span><br><span class="line">    message.getMessageProperties().setDelay(ttl);</span><br><span class="line">    <span class="keyword">return</span> message;</span><br><span class="line">});</span><br></pre></td></tr></table></figure></div>

<h4 id="消费者-3"><a href="#消费者-3" class="headerlink" title="消费者"></a>消费者</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = DELAYED_QUEUE_NAME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveDead</span><span class="params">(Message message, Channel channel)</span> {</span><br><span class="line">    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">    log.info(<span class="string">"当前时间：{}，收到死信队列消息：{}"</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), msg);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>延时队列在需要延时处理的场景下非常有用，使用RabbitMQ来实现延时队列可以很好的利用RabbitMQ的特性，如：消息可靠发送、消息可靠投递、死信队列。</p>
<p>来保障消息至少被消费一次以及未被正确处理的消息不会被丢弃。</p>
<p>另外，通过 RabbitMQ 集群的特性，可以很好的解决单点故障问题，不会因为单个节点挂掉导致延时队列不可用或者消息丢失。</p>
<p>当然，延时队列还有很多其它选择，比如利用Java的DelayQueue，利用Redis 的zset，利用 Quartz或者利用kafka的时间轮，这些方式各有特点，看需要适用的场景</p>
<h2 id="发布确认（高级）"><a href="#发布确认（高级）" class="headerlink" title="发布确认（高级）"></a>发布确认（高级）</h2><p>在生产环境中由于一些不明原因，导致RabbitMQ重启。</p>
<p>在RabbitMQ重启期间，生产者消息投递失败，导致消息丢失。</p>
<h3 id="发布确认SpringBoot版本"><a href="#发布确认SpringBoot版本" class="headerlink" title="发布确认SpringBoot版本"></a>发布确认SpringBoot版本</h3><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/08/14/IRerWGOQy6YCJwS.png" alt="image-20230814214747879" style="zoom:50%;">

<h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><ul>
<li>NONE：禁用发布确认模式，默认值</li>
<li>CORRELATED：发布消息到交换机成功后，触发回调函数</li>
<li>SIMPLE：有两种效果<ul>
<li>其一，和CORRELATED一样触发回调方法；</li>
<li>其二，在发布消息成功后使用<code>rabbitTemplate</code>调用 <code>waitForConfirms</code> 或 <code>waitForConfirmsOrDie</code> 方法等待 <code>broker</code> 节点返回发送结果，根据返回结果来判定下一步的逻辑（同步确认消息）。要注意的点是<code>waitForConfirmsOrDie</code> 方法如果返回 false 则会关闭 channel，则接下来无法发送消息到 broker</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Properties"><figure class="iseeu highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.rabbitmq.publisher-confirm-type</span>=<span class="string">correlated</span></span><br></pre></td></tr></table></figure></div>

<h4 id="基础代码"><a href="#基础代码" class="headerlink" title="基础代码"></a>基础代码</h4><ul>
<li>配置类</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfirmConfig</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">"confirm_exchange"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">"confirm_queue"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_ROUTING_KEY</span> <span class="operator">=</span> <span class="string">"key1"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">confirmExchange</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(CONFIRM_EXCHANGE_NAME);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">confirmQueue</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.nonDurable(CONFIRM_QUEUE_NAME).build();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">queueBindingExchange</span><span class="params">(Queue confirmQueue, DirectExchange confirmExchange)</span> {</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(confirmQueue).to(confirmExchange).with(CONFIRM_ROUTING_KEY);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>生产者</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping("/confirm")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerController</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping("/sendMsg/{msg}")</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(<span class="meta">@PathVariable</span> String msg)</span> {</span><br><span class="line">        rabbitTemplate.convertAndSend(ConfirmConfig.CONFIRM_EXCHANGE_NAME, </span><br><span class="line">                                      ConfirmConfig.CONFIRM_ROUTING_KEY, msg);</span><br><span class="line">        log.info(<span class="string">"发送消息：{}"</span>, msg);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>消费者</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = ConfirmConfig.CONFIRM_QUEUE_NAME)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveConfirmMsg</span><span class="params">(Message message)</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">        log.info(<span class="string">"接收到的消息：{}"</span>, msg);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="自定义回调方法"><a href="#自定义回调方法" class="headerlink" title="自定义回调方法"></a>自定义回调方法</h4><ul>
<li>自定义回调方法，注入到<code>rabbitTemplate</code>中</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallBack</span> <span class="keyword">implements</span> <span class="title class_">RabbitTemplate</span>.ConfirmCallback {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> {</span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="built_in">this</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirm</span><span class="params">(CorrelationData correlationData, <span class="type">boolean</span> ack, String cause)</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> correlationData == <span class="literal">null</span> ? <span class="string">""</span> : correlationData.getId();</span><br><span class="line">        <span class="keyword">if</span> (ack) {</span><br><span class="line">            log.info(<span class="string">"交换机已收到Id为：{}的消息"</span>, id);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            log.info(<span class="string">"交换机未收到Id为：{}的消息，原因是：{}"</span>, id, cause);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>比如发消息时故意将<code>exchangeName</code>写错，会打印原因：找不到交换机</p>
</blockquote>
<h3 id="回退消息"><a href="#回退消息" class="headerlink" title="回退消息"></a>回退消息</h3><p>在仅开启了生产者确认机制的情况下，交换机接收到消息后，会直接给消息生产者发送确认消息。</p>
<p>但假如队列没收到消息（比如routingkey写错了），我们是无法得知的。消息会被直接丢弃。</p>
<p>通过设置mandatory参数可以在当消息传递过程中不可达目的地时将消息返回给生产者。</p>
<h4 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h4><div class="highlight-container" data-rel="Properties"><figure class="iseeu highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打开消息回退</span></span><br><span class="line"><span class="attr">spring.rabbitmq.publisher-returns</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure></div>

<h4 id="自定义回调方法-1"><a href="#自定义回调方法-1" class="headerlink" title="自定义回调方法"></a>自定义回调方法</h4><ul>
<li>继续实现<code>RabbitTemplate.ReturnsCallback</code></li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallBack</span> <span class="keyword">implements</span> <span class="title class_">RabbitTemplate</span>.ConfirmCallback, RabbitTemplate.ReturnsCallback {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> {</span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="built_in">this</span>);</span><br><span class="line">        rabbitTemplate.setReturnsCallback(<span class="built_in">this</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirm</span><span class="params">(CorrelationData correlationData, <span class="type">boolean</span> ack, String cause)</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> correlationData == <span class="literal">null</span> ? <span class="string">""</span> : correlationData.getId();</span><br><span class="line">        <span class="keyword">if</span> (ack) {</span><br><span class="line">            log.info(<span class="string">"交换机已收到Id为：{}的消息"</span>, id);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            log.info(<span class="string">"交换机未收到Id为：{}的消息，原因是：{}"</span>, id, cause);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnedMessage</span><span class="params">(ReturnedMessage returned)</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(returned.getMessage().getBody());</span><br><span class="line">        <span class="type">String</span> <span class="variable">exchange</span> <span class="operator">=</span> returned.getExchange();</span><br><span class="line">        <span class="type">String</span> <span class="variable">replyText</span> <span class="operator">=</span> returned.getReplyText();</span><br><span class="line">        <span class="type">String</span> <span class="variable">routingKey</span> <span class="operator">=</span> returned.getRoutingKey();</span><br><span class="line">        log.info(<span class="string">"消息{}，被交换机{}退回，原因：{}，路由key：{}"</span>, msg, exchange, replyText, routingKey);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="备份交换机"><a href="#备份交换机" class="headerlink" title="备份交换机"></a>备份交换机</h3><ul>
<li><p>有了mandatory参数和回退消息，我们获得了对无法投递消息的感知能力，有机会在生产者的消息无法被投递时发现并处理。但有时候，我们并不知道该如何处理这些无法路由的消息，最多打个日志，然后触发报警，再来手动处理。</p>
</li>
<li><p>还有一种解决方案，我们可以使用备份交换机。</p>
</li>
<li><p>当交换机接收到一条不可路由消息时，将会把这条消息转发到备份交换机中，由备份交换机来进行转发和处理，通常备份交换机的类型为Fanout，这样就能把所有消息都投递到与其绑定的队列中。</p>
</li>
</ul>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/08/14/Oy5lD7aQLBGeKAC.png" alt="image-20230814223244376" style="zoom:50%;">

<h4 id="代码构建"><a href="#代码构建" class="headerlink" title="代码构建"></a>代码构建</h4><ul>
<li>配置类</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 备份交换机（扇出）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BACKUP_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">"backup_exchange"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BACKUP_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">"backup_queue"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">WARNING_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">"warning_queue"</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> FanoutExchange <span class="title function_">backupExchange</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(BACKUP_EXCHANGE_NAME);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">backupQueue</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder.nonDurable(BACKUP_QUEUE_NAME).build();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">warningQueue</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder.nonDurable(WARNING_QUEUE_NAME).build();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">backupQueue2BackupExchange</span><span class="params">(Queue backupQueue, FanoutExchange backupExchange)</span> {</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(backupQueue).to(backupExchange);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">warningQueue2BackupExchange</span><span class="params">(Queue warningQueue, FanoutExchange backupExchange)</span> {</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(warningQueue).to(backupExchange);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>确认交换机，设置将无法投递的消息发送给备份交换机</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DirectExchange <span class="title function_">confirmExchange</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> ExchangeBuilder.directExchange(CONFIRM_EXCHANGE_NAME)</span><br><span class="line">            .durable(<span class="literal">true</span>)</span><br><span class="line">            .withArgument(<span class="string">"alternate-exchange"</span>, BACKUP_EXCHANGE_NAME)</span><br><span class="line">        	<span class="comment">// .alternate(BACKUP_EXCHANGE_NAME)</span></span><br><span class="line">            .build();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>消费者</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WarningConsumer</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = ConfirmConfig.WARNING_QUEUE_NAME)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveWarning</span><span class="params">(Message message)</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">        log.error(<span class="string">"发现不可路由消息：{}"</span>, s);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h4><p>当mandatory参数与备份交换机同时开启，经测试，<strong>备份交换机优先级高</strong></p>
<h2 id="RabbitMQ其他知识点"><a href="#RabbitMQ其他知识点" class="headerlink" title="RabbitMQ其他知识点"></a>RabbitMQ其他知识点</h2><h3 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h3><h4 id="幂等性的概念"><a href="#幂等性的概念" class="headerlink" title="幂等性的概念"></a>幂等性的概念</h4><p>同一操作发起一次请求或者多次请求，结果是一致的，不会因为多次点击而产生了副作用。</p>
<ul>
<li>比如：<ul>
<li>用户购买商品后支付，支付扣款成功，但是返回结果的时候网络异常</li>
<li>用户再次点击按钮，此时会进行第二次扣款，返回结果成功</li>
<li>用户查询余额发现多扣钱了，流水记录也变成了两条</li>
</ul>
</li>
</ul>
<h4 id="重复消费"><a href="#重复消费" class="headerlink" title="重复消费"></a>重复消费</h4><ul>
<li>场景<ul>
<li>MQ已把消息发送给消费者，消费者在给MQ返回ack时网络中断</li>
<li>该条消息会重新发给其他的消费者，或者在网络重连后再次发送给该消费者</li>
<li>造成消费者消费了重复的消息</li>
</ul>
</li>
</ul>
<h4 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h4><ul>
<li>使用全局ID，或者写个唯一标识，比如：时间戳、UUID、按自己的规则生成一个全局唯一 id…</li>
<li>每次消费消息时用该 id 先判断该消息是否已消费过</li>
</ul>
<h4 id="消费端的幂等性保障"><a href="#消费端的幂等性保障" class="headerlink" title="消费端的幂等性保障"></a>消费端的幂等性保障</h4><p>在海量订单生成的业务高峰期，生产端有可能就会重复发生了消息，这时候消费端就要实现幂等性。</p>
<p>消息永远不会被消费多次，即使我们收到了一样的消息。</p>
<ul>
<li><p>主流的幂等性有两种操作：</p>
<ul>
<li>唯一ID+指纹码机制，利用数据库主键去重</li>
<li>利用redis的原子性去实现</li>
</ul>
</li>
</ul>
<ol>
<li>唯一ID+指纹码</li>
</ol>
<p>指纹码:我们的一些规则或者时间戳加别的服务给到的唯一信息码,它并不一定是我们系统生成的，基本都是由我们的业务规则拼接而来，但是一定要保证唯一性。利用查询语句进行判断这个id是否存在数据库中。</p>
<p>优势：实现简单，拼接然后查询判断是否重复</p>
<p>劣势：高并发时，如果是单个数据库就会有写入性能瓶颈。当然也可以采用分库分表提升性能，但也不是我们最推荐的方式。</p>
<ol start="2">
<li>利用redis的原子性</li>
</ol>
<p>利用redis执行setnx命令，天然具有幂等性。从而实现不重复消费</p>
<h3 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h3><p>优先级越高的消息，越先被消费</p>
<h4 id="如何添加"><a href="#如何添加" class="headerlink" title="如何添加"></a>如何添加</h4><ul>
<li>使用Web UI</li>
</ul>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/08/18/hJeWOK9u36NqcPM.png" alt="image-20230818220616550" style="zoom: 50%;">

<ul>
<li>使用代码：如下所示</li>
</ul>
<h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">priorityConfig</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">priQueue</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.nonDurable(<span class="string">"pri_queue"</span>).maxPriority(<span class="number">10</span>).build();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">priExchange</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(<span class="string">"pri_exchange"</span>).durable(<span class="literal">false</span>).build();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">priBinding</span><span class="params">(Queue priQueue, DirectExchange priExchange)</span> {</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(priQueue).to(priExchange).with(<span class="string">"pri_key"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">"aaa"</span>;</span><br><span class="line"><span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(msg.getBytes()).setPriority(<span class="number">5</span>).build();</span><br><span class="line">rabbitTemplate.send(<span class="string">"pri_exchange"</span>, <span class="string">"pri_key"</span>, message);</span><br></pre></td></tr></table></figure></div>

<h3 id="堕性队列"><a href="#堕性队列" class="headerlink" title="堕性队列"></a>堕性队列</h3><p>正常情况：消息保存在内存中</p>
<p>堕性队列：消息保存在磁盘上</p>
<p>当消费者由于各种原因（比如下线，宕机，或者由于维护而关闭等），致使长时间不能消费，造成消息堆积时，堕性队列就很有必要了。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">QueueBuilder.nonDurable(<span class="string">"lazy.queue"</span>).lazy().build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">args.put(<span class="string">"x-queue-mode"</span>, <span class="string">"lazy"</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">"lazy.queue"</span>,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,args);</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>在发送1百万条消息，每条消息大概占1KB的情况下，普通队列占用内存是1.2GB，而惰性队列仅仅占用1.5MB</p>
</blockquote>
<h2 id="RabbitMQ集群"><a href="#RabbitMQ集群" class="headerlink" title="RabbitMQ集群"></a>RabbitMQ集群</h2><p>生产者大量发送消息，单机版的RabbitMQ性能捉襟见肘。</p>
<ul>
<li>如果RabbitMQ服务器遇到内存崩溃、机器掉电或者主板故障等情况，该怎么办？</li>
<li>单台RabbitMQ服务器可以满足每秒1000条消息的吞吐量，如果应用需要满足每秒 10 万条消息的吞吐量，该怎么办？</li>
</ul>
<h3 id="clustering"><a href="#clustering" class="headerlink" title="clustering"></a>clustering</h3><ol>
<li>修改三台主机名称</li>
</ol>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/hostname</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>配置各台主机的host文件，使其能相互识别</li>
</ol>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/hosts</span><br><span class="line"></span><br><span class="line">10.211.55.74 node1</span><br><span class="line">10.211.55.75 node2</span><br><span class="line">10.211.55.76 node3</span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li>确保各个节点使用的cookie是同一个值（搭建的集群要求erlang底层的cookie是同一个值）</li>
</ol>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在node1执行，将第一台机器的cookie复制给的第二台和第三台</span></span><br><span class="line">scp /var/lib/rabbitmq/.erlang.cookie root@node2:/var/lib/rabbitmq/.erlang.cookie </span><br><span class="line">scp /var/lib/rabbitmq/.erlang.cookie root@node3:/var/lib/rabbitmq/.erlang.cookie</span><br></pre></td></tr></table></figure></div>

<ol start="4">
<li>重启RabbitMQ</li>
</ol>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 每个节点都执行</span></span><br><span class="line"><span class="comment"># 重启RabbitMQ，以及底层的Erlang虚拟机</span></span><br><span class="line"></span><br><span class="line">rabbitmq-server -detached</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第二台节点执行</span></span><br><span class="line"><span class="comment"># rabbitmqctl stop会将Erlang虚拟机关闭，rabbitmqctl stop_app只关闭RabbitMQ服务</span></span><br><span class="line"></span><br><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl reset</span><br><span class="line">rabbitmqctl join_cluster rabbit@node1 </span><br><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第三台节点执行</span></span><br><span class="line"></span><br><span class="line">rabbitmqctl stop_app </span><br><span class="line">rabbitmqctl reset</span><br><span class="line">rabbitmqctl join_cluster rabbit@node2 </span><br><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>后续操作可以在任意一台机器上运行</p>
</blockquote>
<ol start="5">
<li>查看集群状态</li>
</ol>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">rabbitmqctl cluster_status</span><br></pre></td></tr></table></figure></div>

<ol start="6">
<li>为集群创建账户</li>
</ol>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">rabbitmqctl add_user admin 123</span><br><span class="line"><span class="comment"># 设置用户角色</span></span><br><span class="line">rabbitmqctl set_user_tags admin administrator</span><br><span class="line"><span class="comment"># 设置用户权限</span></span><br><span class="line">rabbitmqctl set_permissions -p <span class="string">"/"</span> admin <span class="string">".*"</span> <span class="string">".*"</span> <span class="string">".*"</span></span><br></pre></td></tr></table></figure></div>

<ol start="7">
<li>解除任意一台机器</li>
</ol>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在待解除的机器上执行</span></span><br><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl reset </span><br><span class="line">rabbitmqctl start_app </span><br><span class="line">rabbitmqctl cluster_status</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在node1机器上执行</span></span><br><span class="line">rabbitmqctl forget_cluster_node rabbit@node2</span><br></pre></td></tr></table></figure></div>

<h3 id="镜像队列"><a href="#镜像队列" class="headerlink" title="镜像队列"></a>镜像队列</h3><h4 id="使用镜像队列的原因"><a href="#使用镜像队列的原因" class="headerlink" title="使用镜像队列的原因"></a>使用镜像队列的原因</h4><p>使用集群的时候，在哪个机器创建的队列，队列实际上就存在哪台机器上。如果那一台机器宕机了，相应队列也会消失。</p>
<p>从Web UI看，某台机器宕机了，该节点成为红色。在队列选项中查看，队列还在，但是状态为Down。</p>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/08/19/J1LKMihtA6kqVG8.png" alt="image-20230819112144388" style="zoom: 50%;">

<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/08/19/LSYIRrZinMEAFkG.png" alt="image-20230819112221387" style="zoom:50%;">

<p>使用镜像队列，可以将队列镜像到集群中的其他节点上。如果某节点宕机了，队列能自动切换到另一个节点上，保证服务的可用性。</p>
<h4 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h4><ol>
<li>启动三台集群节点</li>
<li>随便找一台节点，添加policy<ul>
<li>ha-mode: exactly                      (备机模式：指定，也即指定备份的个数)</li>
<li>ha-params: 2                             (指定备份个数：两份)</li>
<li>ha-sync-mode: automatic       (同步的模式：自动)</li>
</ul>
</li>
</ol>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/08/19/nhmVXK2AZFJoc1x.png" alt="image-20230819120610257" style="zoom: 67%;">

<ol start="3">
<li>在某节点上创建队列（比如节点1），自动备份到另一个节点</li>
</ol>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/08/19/EmosL6wBTuqMgzy.png" alt="image-20230819121131426" style="zoom: 50%;">

<ol start="4">
<li>假如停掉node1，node2成为镜像队列</li>
</ol>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">rabbitmqctl stop_app</span><br></pre></td></tr></table></figure></div>

<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/08/19/5kZwb2U8F1Oxlqz.png" alt="image-20230819121307722" style="zoom:50%;">

<ol start="5">
<li>就算集群只剩下一台机器了，依然能消费队列中的内容</li>
</ol>
<blockquote>
<p>具体到Java选择连接MQ的部分，需要使用负载均衡软件（比如Haproxy + Keepalive），这里不在继续讨论</p>
</blockquote>
<h3 id="Federation-Exchange"><a href="#Federation-Exchange" class="headerlink" title="Federation Exchange"></a>Federation Exchange</h3><p>不重要，略</p>
]]></content>
      <categories>
        <category>MQ</category>
        <category>RabbitMQ</category>
      </categories>
  </entry>
  <entry>
    <title>Java设计模式系列（6）：适配器模式</title>
    <url>//post/26888/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/09/07/z1SbZwLJWlPBIX2.png" alt="img"></p>
<p>将一个类的接口，替换成客户端希望的另外一个接口，使原本因接口不兼容的类能一起工作，这就是适配器模式。</p>
<p>原文地址：<a href="https://xuedongyun.cn/post/26888/">https://xuedongyun.cn/post/26888/</a></p>
<h2 id="适配器模式的角色"><a href="#适配器模式的角色" class="headerlink" title="适配器模式的角色"></a>适配器模式的角色</h2><p>适配器模式（Adapter）包含以下主要角色</p>
<ul>
<li>目标（Target）接口：当前业务所期待的接口</li>
<li>适配者（Adapter）类：当前组件的接口</li>
<li>适配器（Adapter）类：一个转换器，把适配者接口，转化为目标接口</li>
</ul>
<h2 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h2><p>实现方法：定义一个适配器类来<strong>实现当前业务接口</strong>，同时又<strong>继承原有组件</strong></p>
<ul>
<li>假如我们的电脑只能读取SD卡，读取TF卡就需要适配器模式</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readSD</span><span class="params">(SDCard sdCard)</span> {</span><br><span class="line">        <span class="keyword">if</span>(sdCard == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">"sd card null"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sdCard.readSD();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>SD卡的接口</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SDCard</span> {</span><br><span class="line">    String <span class="title function_">readSD</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">writeSD</span><span class="params">(String msg)</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// SD卡实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SDCardImpl</span> <span class="keyword">implements</span> <span class="title class_">SDCard</span> {</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readSD</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">"sd card read a msg :hello word SD"</span>;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeSD</span><span class="params">(String msg)</span> {</span><br><span class="line">        System.out.println(<span class="string">"sd card write msg : "</span> + msg);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>TF卡的接口</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TFCard</span> {</span><br><span class="line">    String <span class="title function_">readTF</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">writeTF</span><span class="params">(String msg)</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//TF卡实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TFCardImpl</span> <span class="keyword">implements</span> <span class="title class_">TFCard</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readTF</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span><span class="string">"tf card read msg : hello word tf card"</span>;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeTF</span><span class="params">(String msg)</span> {</span><br><span class="line">        System.out.println(<span class="string">"tf card write a msg : "</span> + msg);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>定义适配器类</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义适配器类（用SD兼容TF）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SDAdapterTF</span> <span class="keyword">extends</span> <span class="title class_">TFCardImpl</span> <span class="keyword">implements</span> <span class="title class_">SDCard</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readSD</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"adapter read tf card "</span>);</span><br><span class="line">        <span class="keyword">return</span> readTF();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeSD</span><span class="params">(String msg)</span> {</span><br><span class="line">        System.out.println(<span class="string">"adapter write tf card"</span>);</span><br><span class="line">        writeTF(msg);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>使用</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SDAdapterTF</span> <span class="variable">adapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SDAdapterTF</span>();</span><br><span class="line">computer.readSD(adapter);</span><br></pre></td></tr></table></figure></div>

<h2 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h2><p>实现方式：该类实现当前业务接口，同时将现有组件引入适配器类中</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建适配器对象（SD兼容TF）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SDAdapterTF</span> <span class="keyword">implements</span> <span class="title class_">SDCard</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TFCard tfCard;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SDAdapterTF</span><span class="params">(TFCard tfCard)</span> {</span><br><span class="line">        <span class="built_in">this</span>.tfCard = tfCard;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readSD</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"adapter read tf card "</span>);</span><br><span class="line">        <span class="keyword">return</span> tfCard.readTF();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeSD</span><span class="params">(String msg)</span> {</span><br><span class="line">        System.out.println(<span class="string">"adapter write tf card"</span>);</span><br><span class="line">        tfCard.writeTF(msg);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol>
<li>以前的组件满足功能需求，但是接口定义不一致</li>
<li>第三方开发的组件，接口定义不一致</li>
</ol>
<h2 id="JDK源码-InputStreamReader"><a href="#JDK源码-InputStreamReader" class="headerlink" title="JDK源码-InputStreamReader"></a>JDK源码-InputStreamReader</h2><p>在JDK中，使用InputStreamReader，进行从InputStream（字节流）到Reader（字符流）的转换。</p>
<ul>
<li>InputStreamReader继承了抽象类Reader</li>
<li>InputStreamReader内部使用了StreamDecoder来执行实际的功能（抽象类Reader的具体实现）<ul>
<li>不是Java SE API中的内容，是Sun JDK给出的实现</li>
<li>对构造方法中的字节流类（InputStream）进行封装，并通过该类进行了字节流和字符流之间的解码转换</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputStreamReader</span> <span class="keyword">extends</span> <span class="title class_">Reader</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StreamDecoder sd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">        <span class="keyword">return</span> sd.read();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">char</span>[] cbuf, <span class="type">int</span> off, <span class="type">int</span> len)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">        <span class="keyword">return</span> sd.read(cbuf, off, len);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/09/07/pwCELd39fQ2Yxql.png" alt="img" style="zoom: 80%;">

<blockquote>
<p>结论：</p>
<ul>
<li>表层来看，InputStreamReader做了InputStream（字节流）到Reader（字符流）之间的转换</li>
<li>实际上，是StreamDecoder的设计实现，采用了适配器模式</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java设计模式系列</tag>
      </tags>
  </entry>
  <entry>
    <title>一小时git教程</title>
    <url>//post/24535/</url>
    <content><![CDATA[<p><a class="link" href="https://www.bilibili.com/video/BV1HM411377j">https://www.bilibili.com/video/BV1HM411377j <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h2><p>下载地址：<a class="link" href="https://git-scm.com/">https://git-scm.com/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<ul>
<li>查看一下版本，确保安装成功</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git -v</span><br></pre></td></tr></table></figure></div>

<ul>
<li>配置一下用户名和邮箱</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">"Dongyun Xue"</span></span><br><span class="line">git config --global user.email 1235678@qq.com</span><br></pre></td></tr></table></figure></div>

<ul>
<li>用下面这个命令来保存用户名和密码，就不用每次都输入了</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure></div>

<ul>
<li>查看git的所有信息</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global --list</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>省略（Local）：只对本地仓库有效</p>
<p>–global：全局配置，所有仓库生效</p>
<p>–system：系统配置，对所有用户生效</p>
</blockquote>
<h2 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h2><ul>
<li>创建一个仓库</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 当前文件夹创建仓库</span></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个工作文件夹，作为仓库</span></span><br><span class="line">git init my-repo</span><br></pre></td></tr></table></figure></div>

<h2 id="工作区域和文件状态"><a href="#工作区域和文件状态" class="headerlink" title="工作区域和文件状态"></a>工作区域和文件状态</h2><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/11/24/J7gn9C1cDYtMud5.png" alt="image-20231124191824498" style="zoom:50%;">

<p>工作区域：</p>
<ul>
<li>工作区：电脑上实际的文件</li>
<li>暂存区：一种临时存储区域，保存即将提交到仓库的修改内容</li>
<li>本地仓库：包含完整的项目历史和元数据</li>
</ul>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/11/24/gbJe568wGmOcTA9.png" alt="image-20231124192149058" style="zoom:50%;">

<p>文件状态：</p>
<ul>
<li>未跟踪：没被git管理</li>
<li>未修改：已被git管理，但是没有变动</li>
<li>已修改：已被git管理，发生变动了，还没提交到暂存中</li>
<li>已暂存：已被git管理，发生变动了，提交到暂存中</li>
</ul>
<h2 id="添加和提交文件"><a href="#添加和提交文件" class="headerlink" title="添加和提交文件"></a>添加和提交文件</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>git status</td>
<td>查看仓库状态</td>
</tr>
<tr>
<td>git add</td>
<td>添加到暂存区<br>可以使用通配符，例如：<code>git add *.txt</code><br>也可以使用目录，例如：<code>git add .</code></td>
</tr>
<tr>
<td>git commit</td>
<td>提交<br>只提交<strong>暂存区</strong>中的内容，不会提交<strong>工作区</strong>中的内容</td>
</tr>
<tr>
<td>git log</td>
<td>查看提交记录<br>可以使用**–oneline**参数来查看简洁的提交记录</td>
</tr>
</tbody></table>
<h2 id="git-reset回退版本"><a href="#git-reset回退版本" class="headerlink" title="git reset回退版本"></a>git reset回退版本</h2><img lazyload="" src="/images/loading.svg" data-src="C:\Users\xdy\AppData\Roaming\Typora\typora-user-images\image-20231124194321334.png" alt="image-20231124194321334" style="zoom:50%;">

<p>git reset三种模式：</p>
<ul>
<li><p>git reset –soft</p>
</li>
<li><p>git reset –hard</p>
</li>
<li><p>git reset –mixed（默认参数）</p>
</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 回到指定的某个版本</span></span><br><span class="line">git reset --soft 5af90</span><br><span class="line"></span><br><span class="line"><span class="comment"># 回到HEAD的上一个版本</span></span><br><span class="line">git reset --soft HEAD^</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>soft和mixed：当我们提交了多个版本，但是觉得没什么意义，就可以用soft或者mixed将之前的所有提交精简为一个版本。唯一的区别的就是mixed要先git add一下</p>
</blockquote>
<blockquote>
<p>hard：谨慎操作，不过如果出问题了也可以回退</p>
<p>先查看一下操作记录，找到误操作前的版本号：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">2de4fd4 (HEAD -&gt; master) HEAD@{0}: reset: moving to 2de4</span><br><span class="line">50fac56 HEAD@{1}: commit: commit 3</span><br><span class="line">2de4fd4 (HEAD -&gt; master) HEAD@{2}: commit: file2.txt</span><br><span class="line">fd474d1 HEAD@{3}: commit (initial): commit1</span><br></pre></td></tr></table></figure></div>

<p>回退到之前的版本：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reset 50fac</span><br></pre></td></tr></table></figure></div>
</blockquote>
<h2 id="git-diff查看文件差异"><a href="#git-diff查看文件差异" class="headerlink" title="git diff查看文件差异"></a>git diff查看文件差异</h2><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/11/24/LY9atnuKSXNIHgb.png" alt="image-20231124204822941" style="zoom:50%;">

<ul>
<li>什么参数都不加，默认查看<strong>工作区和暂存区之间的差异</strong></li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line">diff --git a/file1.txt b/file1.txt	<span class="comment"># 发生变更的文件</span></span><br><span class="line">index ce01362..5be8819 100644		<span class="comment"># 文件哈希算法的值（只显示前7位），后面100644是文件的权限</span></span><br><span class="line">--- a/file1.txt</span><br><span class="line">+++ b/file1.txt						</span><br><span class="line">@@ -1 +1 @@</span><br><span class="line">-hello								<span class="comment"># 删除的内容</span></span><br><span class="line">+hello123							<span class="comment"># 添加的内容</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>工作区与版本库</strong>之间的差异</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git diff HEAD</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>暂存区与版本库</strong>之间的差异</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git diff --cached</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>两个版本</strong>之间的差异</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git diff 833ff b291a</span><br><span class="line"></span><br><span class="line">git diff HEAD~ HEAD</span><br><span class="line">git diff HEAD~2 HEAD</span><br><span class="line">git diff HEAD~3 HEAD</span><br><span class="line"></span><br><span class="line">git diff HEAD^ HEAD</span><br><span class="line">git diff HEAD^2 HEAD</span><br><span class="line">git diff HEAD^3 HEAD</span><br><span class="line"></span><br><span class="line">git diff &lt;branch_name&gt; &lt;branch_name&gt; <span class="comment"># 比较两个分支间的差异</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><code>HEAD~</code>表示HEAD的上一个父亲提交，<code>HEAD~~</code>表示HEAD的上两个父提交，依次类推</p>
<p><code>HEAD^</code>只能表示HEAD的上一个父亲提交，如果上一次有很多父提交（比如合并操作），<code>HEAD^1</code>代表第一个，<code>HEAD^2</code>代表第二个，以此类推</p>
</blockquote>
<h2 id="使用git-rm删除文件"><a href="#使用git-rm删除文件" class="headerlink" title="使用git rm删除文件"></a>使用git rm删除文件</h2><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/11/24/oF91TSYODWcQqrn.png" alt="image-20231124205233107" style="zoom:50%;">

<p>方法一：直接删除文件，再提交</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> file1.txt</span><br><span class="line"></span><br><span class="line">git status</span><br><span class="line">git ls-files	<span class="comment"># 查看暂存区文件，发现file1.txt还在</span></span><br><span class="line"></span><br><span class="line">git add file1.txt</span><br><span class="line">git commit -m <span class="string">"delete file1.txt"</span></span><br></pre></td></tr></table></figure></div>

<p>方法二：使用git rm命令</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">rm</span> file1.txt	<span class="comment"># 工作区和暂存区，同时删除</span></span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">"delete file1.txt"</span></span><br></pre></td></tr></table></figure></div>

<h2 id="gitignore忽略文件"><a href="#gitignore忽略文件" class="headerlink" title="gitignore忽略文件"></a>gitignore忽略文件</h2><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># .gitignore</span></span><br><span class="line"></span><br><span class="line">access.log</span><br><span class="line">*.<span class="built_in">log</span></span><br><span class="line">temp/</span><br></pre></td></tr></table></figure></div>

<p><strong>注意：</strong>已经被添加到版本库中的文件，会继续被追踪。假如之前已经提交过<code>other.log</code>，后面它将无法被忽略</p>
<p>解决方法：使用<code>git rm</code>从暂存库中删除它</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">rm</span> --cached other.log	<span class="comment"># 从暂存区删除，工作区不删除</span></span><br><span class="line">git commit -m <span class="string">"ignore other.log"</span></span><br></pre></td></tr></table></figure></div>

<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/11/24/XhGToktmYE8Uqc4.png" alt="image-20231124210020230" style="zoom:50%;">

<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 忽略.a文件，除了lib.a</span></span><br><span class="line">*.a</span><br><span class="line">!lib.a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略当前目录下的TODO文件</span></span><br><span class="line">/TODO</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略任意目录下的build文件夹</span></span><br><span class="line">build/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略任意doc文件夹下，直接有的txt文件（不会忽略doc/server/arch.txt）</span></span><br><span class="line">doc/*.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略任意doc文件夹及所有子文件夹下的.pdf文件</span></span><br><span class="line">doc/**/*.pdf</span><br></pre></td></tr></table></figure></div>

<h2 id="SSH配置和克隆"><a href="#SSH配置和克隆" class="headerlink" title="SSH配置和克隆"></a>SSH配置和克隆</h2><p>我们在github上建立一个仓库后，使用SSH的方式clone，会发现没有权限</p>
<ul>
<li>使用SSH的方式，必须先配置SSH的密钥</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@github.com:pigeon-dove/learngit.git</span><br><span class="line">Cloning into <span class="string">'learngit'</span>...</span><br><span class="line">The authenticity of host <span class="string">'github.com (20.205.243.166)'</span> can<span class="string">'t be established.</span></span><br></pre></td></tr></table></figure></div>

<p>回到用户根目录，进入.ssh目录，使用<code>ssh-keygen -t rsa -b 4096</code>命令来生成SSH密钥</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/.ssh</span><br><span class="line">$ ssh-keygen -t rsa -b 4096</span><br><span class="line"></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/c/Users/xdy/.ssh/id_rsa): id_rsa_2 <span class="comment"># 因为之前有了，所以重命名一下</span></span><br><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase): <span class="comment"># 密码为空就行</span></span><br></pre></td></tr></table></figure></div>

<p>如果像上面那样改了名字的话，在<code>~/.ssh/config</code>文件中加上如下配置即可</p>
<ul>
<li>意思：当访问github.com的时候，指定使用以下文件的密钥</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># github</span></span><br><span class="line">Host github.com</span><br><span class="line">HostName github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa_2</span><br></pre></td></tr></table></figure></div>

<p>复制公钥文件<code>id_rsa_2.pub</code>中的值，到github的个人设置中</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/11/24/q8j1R6oHTOhYkys.png" alt="image-20231124230622511"></p>
<p>现在可以正常clone了</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:pigeon-dove/learngit.git</span><br></pre></td></tr></table></figure></div>

<h2 id="关联本地仓库和远程仓库"><a href="#关联本地仓库和远程仓库" class="headerlink" title="关联本地仓库和远程仓库"></a>关联本地仓库和远程仓库</h2><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/11/24/mNEhxoV9IUvibys.png" alt="image-20231124233238624" style="zoom:50%;">

<p>在github上创建一个空仓库，将它和本地已有的仓库关联起来</p>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/11/24/hvm4CdeqTcAtRpV.png" alt="image-20231124232105274" style="zoom: 33%;">

<p>使用<code>git remote add &lt;shortname&gt; &lt;url&gt;</code>添加远程仓库</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:pigeon-dove/firsti-repo.git</span><br><span class="line"></span><br><span class="line">git remote -v					<span class="comment"># 查看远程仓库，名字和地址</span></span><br><span class="line"></span><br><span class="line">git branch -M main				<span class="comment"># 指定分支的名称为main</span></span><br><span class="line"></span><br><span class="line">git push -u origin main			<span class="comment"># 将本地main分支，和远程仓库的main分支，关联起来（u: upstream）</span></span><br><span class="line">git push -u origin main:main	<span class="comment"># 上一条命令写全应该是这样的</span></span><br></pre></td></tr></table></figure></div>

<p>现在，我们在github上创建一个README.md，模拟远程仓库改动的情况。我们现在可以拉取远程仓库</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git pull					<span class="comment"># 拉取远端服务器</span></span><br><span class="line"></span><br><span class="line">git pull origin main		<span class="comment"># 上一条命令写全，将远程仓库的指定分支，拉到本地指定分支，进行合并</span></span><br><span class="line">git pull origin main:main	<span class="comment"># 上一条命令写全，将远程仓库的指定分支，拉到本地指定分支，进行合并</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>注意：</p>
<ul>
<li>执行git pull，会自动帮我们<strong>执行一次合并操作</strong>，没有冲突则合并成功。有冲突需要手动处理。</li>
<li>git fetch命令，只是获取远程仓库修改，并不会自动合并到本地仓库中</li>
</ul>
</blockquote>
<h2 id="分支简介和基本操作"><a href="#分支简介和基本操作" class="headerlink" title="分支简介和基本操作"></a>分支简介和基本操作</h2><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/11/25/bM6vRi4safAmew5.png" alt="image-20231125002037803" style="zoom:50%;">

<ul>
<li>创建一个新的分支</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git branch dev</span><br></pre></td></tr></table></figure></div>

<ul>
<li>查看所有分支，*表示当前所在分支</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure></div>

<ul>
<li>切换到别的分支</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># git checkout命令还可以用来恢复文件或目录，到之前的一个状态。如果文件和分支名称一样，会默认切换分支，出现歧义</span></span><br><span class="line">git checkout dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新的命令，专门用来切换分支，避免歧义</span></span><br><span class="line">git switch dev</span><br></pre></td></tr></table></figure></div>

<ul>
<li>在dev分支进行修改并提交，切回main分支。切换分支的时候，工作区也会发生变化。</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git switch main	<span class="comment"># 工作区会变，之前在dev分支上的修改不见了</span></span><br></pre></td></tr></table></figure></div>

<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/11/25/jt2xDYpzuaIBKX7.png" alt="image-20231125001308100" style="zoom:50%;">

<ul>
<li>合并指定分支，到当前分支中（git会帮我们进行一次提交）</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git merge dev</span><br></pre></td></tr></table></figure></div>

<ul>
<li>查看分支情况</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline --decorate --all --graph</span><br><span class="line">*   02a6da7 (HEAD -&gt; main) Merge branch <span class="string">'dev'</span></span><br><span class="line">|\</span><br><span class="line">| * 739daae (dev) dev:2</span><br><span class="line">| * c3ecc04 dev:1</span><br><span class="line">* | 0a463e2 main:5</span><br><span class="line">* | ccf6525 main:4</span><br><span class="line">|/</span><br><span class="line">* b40c1c1 main:3</span><br><span class="line">* bc8f037 main:2</span><br><span class="line">* fe7a4aa main:1</span><br></pre></td></tr></table></figure></div>

<ul>
<li>删除一个分支（如果这个分支，<strong>已经被合并到别的分支</strong>）</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch -d dev</span><br><span class="line"></span><br><span class="line">$ git branch	<span class="comment"># 看到dev分支已经没有了</span></span><br><span class="line">* main</span><br></pre></td></tr></table></figure></div>

<ul>
<li>强制删除一个分支（如果这个分支，<strong>还没有被合并到别的分支</strong>）</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch -D dev</span><br></pre></td></tr></table></figure></div>

<h2 id="解决合并冲突"><a href="#解决合并冲突" class="headerlink" title="解决合并冲突"></a>解决合并冲突</h2><ul>
<li>如图，创建feat分支后，main分支和feat分支对同一个文件进行了修改</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --graph --oneline --all</span><br><span class="line">* dc0dcb9 (HEAD -&gt; main) main:5</span><br><span class="line">* 702f5f3 main:4</span><br><span class="line">| * 9eae972 (feat) feat:2</span><br><span class="line">| * 6ef0326 feat:1</span><br><span class="line">|/</span><br><span class="line">* b40c1c1 main:3</span><br><span class="line">* bc8f037 main:2</span><br><span class="line">* fe7a4aa main:1</span><br></pre></td></tr></table></figure></div>

<ul>
<li>尝试合并分支，提示冲突</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ git merge feat</span><br><span class="line">Auto-merging main1.txt</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> main1.txt</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure></div>

<ul>
<li>git status查看冲突的文件列表</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch main</span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run <span class="string">"git commit"</span>)</span><br><span class="line">  (use <span class="string">"git merge --abort"</span> to abort the merge)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to mark resolution)</span><br><span class="line">        both modified:   main1.txt</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line">        how-branch</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure></div>

<ul>
<li>git diff查看冲突的具体内容</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ git diff</span><br><span class="line">diff --cc main1.txt</span><br><span class="line">index d9717b9,70bcab5..0000000</span><br><span class="line">--- a/main1.txt</span><br><span class="line">+++ b/main1.txt</span><br><span class="line">@@@ -1,2 -1,2 +1,6 @@@</span><br><span class="line">  main1</span><br><span class="line">++&lt;&lt;&lt;&lt;&lt;&lt;&lt; <span class="string">HEAD</span></span><br><span class="line"><span class="string"> +main添加123123</span></span><br><span class="line"><span class="string">++=======</span></span><br><span class="line"><span class="string">+ feat添加333</span></span><br><span class="line"><span class="string">++&gt;&gt;&gt;&gt;&gt;&gt;&gt; feat</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>手工编辑冲突的文件，然后提交即可</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -a -m <span class="string">"merge conflit"</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>如果不想合并分支，也可以终止合并</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git merge --abort</span><br></pre></td></tr></table></figure></div>

<h2 id="回退和rebase"><a href="#回退和rebase" class="headerlink" title="回退和rebase"></a>回退和rebase</h2><ul>
<li>使用merge：在main分支上合并两个分支</li>
</ul>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/11/25/ASXyRBLrE6cjuml.png" alt="image-20231125003255296" style="zoom: 33%;">

<ul>
<li>使用rebase：当前分支上的提交，嫁接到指定分支后面，变成一条直线</li>
</ul>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/11/25/z7wTZ15AdinusjK.png" alt="image-20231125003712391" style="zoom:33%;">

<p>实战如下：</p>
<ul>
<li>之前dev分支已经被我们删除了，我们要先恢复dev分支</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">*   02a6da7 Merge branch <span class="string">'dev'</span></span><br><span class="line">|\</span><br><span class="line">| * 739daae (HEAD -&gt; dev) dev:2</span><br><span class="line">| * c3ecc04 dev:1</span><br><span class="line">* | 0a463e2 main:5</span><br><span class="line">* | ccf6525 main:4</span><br><span class="line">|/</span><br><span class="line">* b40c1c1 main:3</span><br><span class="line">* bc8f037 main:2</span><br><span class="line">* fe7a4aa main:1</span><br></pre></td></tr></table></figure></div>

<ul>
<li>恢复dev分支，到某一个状态（并进入dev分支中）</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b dev 739daae</span><br></pre></td></tr></table></figure></div>

<ul>
<li>将main分支回退到<code>main:5</code>的时间点</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --hard 0a463e2</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">* 0a463e2 (HEAD -&gt; main) main:5</span><br><span class="line">* ccf6525 main:4</span><br><span class="line">| * 739daae (dev) dev:2</span><br><span class="line">| * c3ecc04 dev:1</span><br><span class="line">|/</span><br><span class="line">* b40c1c1 main:3</span><br><span class="line">* bc8f037 main:2</span><br><span class="line">* fe7a4aa main:1</span><br></pre></td></tr></table></figure></div>

<ul>
<li>进行变基操作，dev分支的修改嫁接在main分支上了（反之亦然）</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ git switch dev</span><br><span class="line">$ git rebase main</span><br><span class="line">* d9d7adb (HEAD -&gt; dev) dev:2</span><br><span class="line">* 0528a98 dev:1</span><br><span class="line">* 0a463e2 (main) main:5</span><br><span class="line">* ccf6525 main:4</span><br><span class="line">* b40c1c1 main:3</span><br><span class="line">* bc8f037 main:2</span><br><span class="line">* fe7a4aa main:1</span><br></pre></td></tr></table></figure></div>

<p><strong>优缺点：</strong></p>
<p>Merge</p>
<ul>
<li>优点：不会破坏原分支的提交历史，方便回溯查看</li>
<li>缺点：会产生额外提交节点，分支图会比较复杂</li>
</ul>
<p>Rebase</p>
<ul>
<li>优点：不会新增额外的提交记录；线性历史，比较直观</li>
<li>缺点：会改变提交历史（请避免在共享分支时，使用变基）</li>
</ul>
<h2 id="分支管理和工作流程"><a href="#分支管理和工作流程" class="headerlink" title="分支管理和工作流程"></a>分支管理和工作流程</h2><h3 id="GitFlow模型"><a href="#GitFlow模型" class="headerlink" title="GitFlow模型"></a>GitFlow模型</h3><blockquote>
<p>main和dev分支长期存在，其他分支合并后可以删除</p>
</blockquote>
<p><strong>主线/基线分支：main</strong></p>
<ul>
<li>会被部署到生产环境</li>
<li>不允许直接修改，只能通过合并分支的方式来修改</li>
<li>每次合并都生成一个新的版本号</li>
</ul>
<p>问题修复分支：hotfix</p>
<ul>
<li>用于修复线上的问题</li>
<li>修复完成后合并会主分支</li>
<li>命名规则：hotfix-#issueid-desc</li>
<li>更新一个小版本号</li>
</ul>
<p><strong>开发分支：develop</strong></p>
<ul>
<li>长期存在</li>
</ul>
<p>功能分支：feature</p>
<ul>
<li><p>从dev分支分离出来，最后合并回开发分支</p>
</li>
<li><p>用于开发新的分支</p>
</li>
<li><p>命名例子：feature-login-page</p>
</li>
</ul>
<p>预发布分支：release</p>
<ul>
<li>发布前的测试和验证</li>
<li>从dev分支中分离出来</li>
<li>稳定后，合并回main分支和dev分支</li>
</ul>
<h3 id="GitHubFlow模型"><a href="#GitHubFlow模型" class="headerlink" title="GitHubFlow模型"></a>GitHubFlow模型</h3><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/11/25/GSakAh83TYni9gl.png" alt="image-20231125011024536" style="zoom:33%;">

<p><strong>分支命名：</strong></p>
<ul>
<li>版本发布分支/Tag示例：v1.0.0</li>
<li>功能分支实例：feature-login-page</li>
<li>修复分支示例：hotfix-#issueid-desc</li>
</ul>
<p><strong>分支管理：</strong></p>
<ul>
<li>定期合并已经成功验证的分支，及时删除已经合并的分支</li>
<li>保持合适的分支数量</li>
<li>为分支设置合适的管理权限</li>
</ul>
]]></content>
      <categories>
        <category>工具和应用</category>
        <category>github</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC系列：（一）进程</title>
    <url>//post/50019/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>进程与线程：</strong></p>
<ul>
<li><p>进程：程序实体的运行过程就是进程，<strong>是系统进行资源分配的基本单位</strong></p>
</li>
<li><p>线程：是一个基本的CPU执行单元，是程序执行流的最小单元。线程是进程中的一个实体，<strong>是系统独立调度的基本单位</strong></p>
</li>
</ul>
<p><strong>并行与并发：</strong></p>
<ul>
<li><p>并行：同一时刻，多个指令在多个CPU上同时执行</p>
</li>
<li><p>并发：同一时刻，多个指令在单个CPU上交替执行（时间片轮转）（好像在同一时间发生一样）</p>
</li>
</ul>
<p><strong>同步与异步：</strong></p>
<ul>
<li>同步：需要等待结果返回，才能继续执行</li>
<li>异步：不需要等待结果返回</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>juc</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC系列：（二）线程</title>
    <url>//post/19310/</url>
    <content><![CDATA[<h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><h3 id="方法一：继承于Thread类"><a href="#方法一：继承于Thread类" class="headerlink" title="方法一：继承于Thread类"></a>方法一：继承于Thread类</h3><ul>
<li>继承Thread类，重写run方法</li>
<li>创建MyThread对象，并调用start方法</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"run"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t1.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="方法二：实现Runnable接口"><a href="#方法二：实现Runnable接口" class="headerlink" title="方法二：实现Runnable接口"></a>方法二：实现Runnable接口</h3><ul>
<li>实现Runnable接口，实现run方法</li>
<li>创建MyRunnable对象，作为Thread构造方法的参数</li>
<li>创建Thread对象，调用start方法</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"run"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r1);</span><br><span class="line">        t1.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>开发中优先选择Runnable接口的方式，因为：</p>
<ul>
<li>没有单继承的局限性</li>
<li>可以实现多个线程共用一个Runnable，共享数据</li>
</ul>
</blockquote>
<h3 id="方法三：实现Callable接口"><a href="#方法三：实现Callable接口" class="headerlink" title="方法三：实现Callable接口"></a>方法三：实现Callable接口</h3><p>Callable提供带返回值的call方法，需要和Future实现类连用，后续章节会讲到</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        Callable&lt;String&gt; callable = <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line">        FutureTask&lt;String&gt; task = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callable);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        thread.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="Thread和Runnable的关系"><a href="#Thread和Runnable的关系" class="headerlink" title="Thread和Runnable的关系"></a>Thread和Runnable的关系</h3><p>Runnable作为参数，构造线程源码</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先调用它</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Thread</span><span class="params">(Runnable target)</span> {</span><br><span class="line">    <span class="built_in">this</span>(<span class="literal">null</span>, target, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后调用它</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Thread</span><span class="params">(ThreadGroup group, Runnable target, String name, <span class="type">long</span> stackSize)</span> {</span><br><span class="line">    <span class="built_in">this</span>(group, target, name, stackSize, <span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主要的代码：</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Thread</span><span class="params">(ThreadGroup g, Runnable target, String name, </span></span><br><span class="line"><span class="params">               <span class="type">long</span> stackSize, AccessControlContext acc, <span class="type">boolean</span> inheritThreadLocals)</span> {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最重要的：这里将Runnable接口（target）赋值给Thread自己的target成员属性 </span></span><br><span class="line">    <span class="built_in">this</span>.target = target;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果实现了runnable接口，那么target不会为null，最终调用实现的run方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="literal">null</span>) {</span><br><span class="line">        target.run();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// start方法，只能被调用一次</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line"></span><br><span class="line">    group.add(<span class="built_in">this</span>);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">started</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        start0();</span><br><span class="line">        started = <span class="literal">true</span>;</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">if</span> (!started) {</span><br><span class="line">                group.threadStartFailed(<span class="built_in">this</span>);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (Throwable ignore) {</span><br><span class="line">            <span class="comment">/* do nothing. If start0 threw a Throwable then it will be passed up the call stack */</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">start0</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></div>

<p><strong>设计模式（代理模式）</strong></p>
<p>Thread是代理类，用户自定义核心功能的实现，辅助功能交由Thread类来实现</p>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/11/15/wy2hVBcn8m5jioS.png" alt="img" style="zoom: 67%;">

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果实现了runnable接口，那么target不会为null，最终调用实现的run方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="literal">null</span>) {</span><br><span class="line">        target.run();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p><strong>设计模式（策略模式）</strong></p>
<p>Runnable接口使用了策略模式，将执行逻辑（run方法）和程序的执行单元（start0方法）分离出来。使得用户可以定义自己的程序处理逻辑，更符合面向对象的思想。</p>
<p><strong>为什么线程的启动不直接使用run()而必须使用start():</strong></p>
<ul>
<li>run的调用是在本地方法start0中</li>
<li>start0方法依赖于不同的操作系统实现<ul>
<li>JNI（Java Native Interface），Java本地接口</li>
</ul>
</li>
</ul>
<h3 id="Thread的构造方法"><a href="#Thread的构造方法" class="headerlink" title="Thread的构造方法"></a>Thread的构造方法</h3><ul>
<li>创建Thread对象，默认有一个线程名（Thread-0，Thread-1，Thread-2）</li>
<li>如果构造线程对象时，未传入ThreadGroup，Thread会默认使用父线程的ThreadGroup</li>
<li>stackSize可以提高线程栈的深度，放更多栈帧，会减少能创建线程的数目</li>
<li>stackSize默认是0，代表着被忽略，该参数会被JNI函数调用<ul>
<li>JVM一旦启动，虚拟机栈的大小已经确定了</li>
<li>但是如果你创建Thread的时候传了stackSize，该参数会被JNI函数去使用</li>
<li>某些平台可能会失效，可以通过<code>-Xss10m</code>设置</li>
</ul>
</li>
</ul>
<h2 id="线程的方法"><a href="#线程的方法" class="headerlink" title="线程的方法"></a>线程的方法</h2><h3 id="Thread类的API"><a href="#Thread类的API" class="headerlink" title="Thread类的API"></a>Thread类的API</h3><p>静态方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static Thread currentThread()</code></td>
<td>获取当前线程对象</td>
</tr>
<tr>
<td><code>static void sleep(long time)</code></td>
<td>让当前线程休眠多少毫秒再继续执行<br><code>Thread.sleep(0)</code> : 让操作系统立刻重新进行一次 CPU 竞争</td>
</tr>
<tr>
<td><code>static native void yield()</code></td>
<td>提示线程调度器，让出当前线程对CPU的使用</td>
</tr>
<tr>
<td><code>static boolean interrupted()</code></td>
<td>判断当前线程是否被打断，清除打断标记</td>
</tr>
</tbody></table>
<p>实例方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void start()</code></td>
<td>启动一个新线程，JVM会调用此线程的run方法</td>
</tr>
<tr>
<td><code>void run()</code></td>
<td>线程启动后，调用该方法</td>
</tr>
<tr>
<td><code>void setName(String name)</code></td>
<td>设置线程名字</td>
</tr>
<tr>
<td><code>void getName()</code></td>
<td>获取当前线程名字<br>线程存在默认名称：子线程是Thread-索引，主线程是main</td>
</tr>
<tr>
<td><code>final int getPriority()</code></td>
<td>获取此线程的优先级</td>
</tr>
<tr>
<td><code>final void setPriority(int priority)</code></td>
<td>设置此线程的优先级，常用1，5，10</td>
</tr>
<tr>
<td><code>void interrupt()</code></td>
<td>中断这个线程，异常处理机制（不清除打断标记）</td>
</tr>
<tr>
<td><code>boolean isInterrupted()</code></td>
<td>判断当前线程是否被打断（不清除打断标记）</td>
</tr>
<tr>
<td><code>final void join()</code></td>
<td>等待这个线程结束</td>
</tr>
<tr>
<td><code>final void join(long millis)</code></td>
<td>等待这个线程结束，最多millis毫秒，0意味着永远等待</td>
</tr>
<tr>
<td><code>final native boolean isAlive()</code></td>
<td>判断线程是否存活（还没有运行完毕）</td>
</tr>
<tr>
<td><code>final void setDaemon(boolean on)</code></td>
<td>将此线程标记为守护线程或用户线程</td>
</tr>
</tbody></table>
<h3 id="sleep与yield方法"><a href="#sleep与yield方法" class="headerlink" title="sleep与yield方法"></a>sleep与yield方法</h3><p>Thread.sleep：</p>
<ul>
<li>当前线程从Running进入Timed Waiting状态</li>
<li>其他线程可以使用interrupt方法打断它的睡眠，此时sleep方法抛出InterruptedException</li>
<li>睡眠结束后，未必立即执行，需要抢占CPU</li>
<li>锁资源不会释放</li>
</ul>
<p>Thread.yield:</p>
<ul>
<li>提示线程调度器，让出当前线程对CPU的使用</li>
<li>锁资源不会释放</li>
</ul>
<h3 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h3><p>作用：等待这个线程结束</p>
<p>原理：调用者轮询检查线程alive</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    <span class="keyword">while</span> (isAlive()) {</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="setDaemon方法"><a href="#setDaemon方法" class="headerlink" title="setDaemon方法"></a>setDaemon方法</h3><p>作用：将此线程标记为守护线程</p>
<ul>
<li>只要其他非守护线程（用户线程）结束了，守护线程会强制结束</li>
</ul>
<p>常见的守护线程：</p>
<ul>
<li>垃圾回收线程</li>
<li>Tomcat中的Acceptor和Poller线程。所以Tomcat接收到shutdown命令后，不会等待它们处理完当前请求</li>
</ul>
<h3 id="interrupt方法"><a href="#interrupt方法" class="headerlink" title="interrupt方法"></a>interrupt方法</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void interrupt()</code></td>
<td>中断这个线程，清空打断标记，异常处理机制</td>
</tr>
</tbody></table>
<ul>
<li>sleep、wait、join方法都会让线程进入阻塞状态<ul>
<li>此时打断线程，会清空打断状态（interrupted = false）</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>); <span class="comment">// 阻塞状态</span></span><br><span class="line">    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">        e.printStackTrace(); <span class="comment">// 打断后，进入异常处理</span></span><br><span class="line">    }</span><br><span class="line">}, <span class="string">"t1"</span>);</span><br><span class="line"></span><br><span class="line">t1.start();</span><br><span class="line">Thread.sleep(<span class="number">500</span>);</span><br><span class="line">t1.interrupt();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">" 打断状态: "</span> + t1.isInterrupted()); <span class="comment">// 打断状态: false</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>打断正常线程，不会清空打断状态（interrupted = true）</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;{</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) {</span><br><span class="line">        <span class="keyword">if</span>(Thread.currentThread().isInterrupted()) {</span><br><span class="line">            System.out.println(<span class="string">" 打断状态: "</span> + interrupted); <span class="comment">// 打断状态: true</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}, <span class="string">"t2"</span>);</span><br><span class="line"></span><br><span class="line">t2.start();</span><br><span class="line">Thread.sleep(<span class="number">500</span>);</span><br><span class="line">t2.interrupt();</span><br></pre></td></tr></table></figure></div>

<h3 id="打断park方法"><a href="#打断park方法" class="headerlink" title="打断park方法"></a>打断park方法</h3><p>park方法作用类似于sleep方法，但是打断它，不会清空打断状态</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">    System.out.println(<span class="string">"park..."</span>);</span><br><span class="line">    LockSupport.park();</span><br><span class="line">    System.out.println(<span class="string">"unpark..."</span>);</span><br><span class="line">    System.out.println(<span class="string">"打断状态: "</span> + Thread.currentThread().isInterrupted()); <span class="comment">// 打断状态: true</span></span><br><span class="line">}, <span class="string">"t1"</span>);</span><br><span class="line"></span><br><span class="line">t1.start();</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">t1.interrupt();</span><br></pre></td></tr></table></figure></div>

<h3 id="优雅的终止线程"><a href="#优雅的终止线程" class="headerlink" title="优雅的终止线程"></a>优雅的终止线程</h3><p><code>thread.stop()</code>：会真正的杀死线程，其资源将永远不能释放，因此需要更优雅的方式</p>
<ul>
<li>使用中断</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> {</span><br><span class="line">    <span class="keyword">private</span> Thread monitor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> {</span><br><span class="line">        monitor = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">                <span class="keyword">if</span> (Thread.interrupted()) {</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        monitor.start();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> {</span><br><span class="line">        monitor.interrupt();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="线程原理"><a href="#线程原理" class="headerlink" title="线程原理"></a>线程原理</h2><h3 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h3><p><strong>虚拟机栈：</strong></p>
<ul>
<li>每个线程启动后，虚拟机就会为其分配一块栈内存</li>
<li>每个栈由多个栈帧（Frame）组成，对应着每次方法调用</li>
<li>每个线程只有一个活动栈帧</li>
</ul>
<p><strong>线程上下文切换：</strong> </p>
<ul>
<li><p>CPU不再执行当前线程，转而执行另一个线程</p>
<ul>
<li><p>线程的 CPU 时间片用完</p>
</li>
<li><p>垃圾回收</p>
</li>
<li><p>有更高优先级的线程需要运行</p>
</li>
<li><p>线程自己调用了sleep，yield，wait，join，park等方法</p>
</li>
</ul>
</li>
</ul>
<p><strong>程序计数器：</strong></p>
<ul>
<li>线程私有的，记住下一条JVM指令的地址</li>
</ul>
<p><strong>上下文切换：</strong></p>
<ul>
<li><p>当上下文切换发生时，由操作系统保存当前线程的状态，并恢复另一个线程的状态</p>
<ul>
<li>包括：程序计数器，虚拟机栈中每个栈帧的信息（如局部变量，操作数栈，返回地址等等）</li>
</ul>
</li>
<li><p>JVM 规范并没有限定线程模型，以HotSpot为例</p>
<ul>
<li><p>Java 的线程是内核级线程（1:1线程模型），每个Java 线程都映射到一个操作系统原生线程，需要消耗一定的内核资源</p>
</li>
<li><p><strong>线程的调度是在内核态运行的，而线程中的代码是在用户态运行</strong>，所以线程切换（状态改变）会导致用户与内核态转换进行系统调用，这是非常消耗性能</p>
</li>
</ul>
</li>
</ul>
<h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><p><strong>方式有两种：</strong></p>
<ul>
<li>协同式线程调度：线程做完任务才通知系统切换到其他线程</li>
<li>抢占式线程调度（Java选择）：线程的执行时间由系统分配</li>
</ul>
<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> {</span><br><span class="line">    </span><br><span class="line">    NEW,			<span class="comment">// 创建状态：线程已创建，但是还没start</span></span><br><span class="line"></span><br><span class="line">    RUNNABLE,		<span class="comment">// 就绪状态：调用了start，可能在CPU上运行，也可能没有，取决于操作系统</span></span><br><span class="line"></span><br><span class="line">    BLOCKED,		<span class="comment">// 阻塞状态：尝试获取一个锁，但是获取失败</span></span><br><span class="line"></span><br><span class="line">    WAITING,		<span class="comment">// 无限等待状态：等待其他线程的唤醒（其他线程调用notify）</span></span><br><span class="line"></span><br><span class="line">    TIMED_WAITING,	<span class="comment">// 超时等待状态：保持到期满，或者接收到唤醒通知（如：Thread.sleep, Object.wait）</span></span><br><span class="line"></span><br><span class="line">    TERMINATED;		<span class="comment">// 结束状态：正常退出，或者有没有捕获的异常而终止</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="查看线程"><a href="#查看线程" class="headerlink" title="查看线程"></a>查看线程</h2><p>Windows：</p>
<ul>
<li><code>tasklist</code>：查看进程</li>
<li><code>taskkill</code>：杀死进程</li>
</ul>
<p>Linux：</p>
<ul>
<li><code>ps -ef</code>：查看所有进程</li>
<li><code>ps -fT -p &lt;PID&gt;</code>：查看某个进程的线程</li>
<li><code>kill</code>：杀死进程</li>
<li><code>top + 大写H</code>：显示所有进程 + 开启显示线程</li>
<li><code>top -H -p &lt;PID&gt;</code>：查看某个进程的所有线程</li>
</ul>
<p>Java：</p>
<ul>
<li><code>jps</code>：查看所有Java进程</li>
<li><code>jstack &lt;PID&gt;</code>：查看某个Java进程的所有线程</li>
<li><code>jconsole</code>查看所有进程中线程的运行情况（图形界面）</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>juc</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC系列：（四）内存</title>
    <url>//post/39218/</url>
    <content><![CDATA[<h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><p>Java内存模型（Java Memory Model），是一个抽象的概念。</p>
<p><strong>详细内容：</strong></p>
<ul>
<li><p>系统存在一个主内存（Main Memory），Java中所有的变量都存储在主存中，对所有线程都是共享的</p>
</li>
<li><p>每条线程都有自己的工作内存（Working Memory），保存的是主存中变量的拷贝</p>
</li>
<li><p>线程对所有变量的操作都是先对变量进行拷贝，然后在工作内存中进行，不能直接操作主内存中的变量</p>
</li>
<li><p>线程之间无法相互直接访问，线程间的通信（传递）必须通过主内存来完成</p>
</li>
</ul>
<p><strong>JMM的作用：</strong></p>
<ul>
<li>屏蔽各种硬件和操作系统的差异</li>
<li>规定线程和内存之间的关系</li>
</ul>
<p><strong>JVM和JMM之间的关系：</strong></p>
<ul>
<li>JMM中的主内存、工作内存与 JVM中的堆、栈、方法区等并不是同一个层次的内存划分，这两者基本上是没有关系的</li>
</ul>
<h2 id="内存交互"><a href="#内存交互" class="headerlink" title="内存交互"></a>内存交互</h2><p>JMM中定义了8种操作（工作内存与主内存交互）</p>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/12/06/aN7BijHRLAKCt2c.png" alt="image-20231206192803118" style="zoom:67%;">

<h2 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h2><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><ul>
<li>一个线程修改了这个变量的值，其他线程能够立即看得到修改的值</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">run</span> <span class="operator">=</span> <span class="literal">true</span>;	<span class="comment">// 如果不加volatile</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;{</span><br><span class="line">        <span class="keyword">while</span>(run){</span><br><span class="line">            System.out.println(<span class="string">"running"</span>);</span><br><span class="line">        }</span><br><span class="line">    }).start();</span><br><span class="line">    </span><br><span class="line">    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">    run = <span class="literal">false</span>; <span class="comment">// 线程不会如预想的停下来</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p><strong>原因：</strong></p>
<ul>
<li>线程从主内存读了run的值</li>
<li>JIT编译器会将run的值缓存到工作内存（的高速缓存中），减少对主内存run的访问，提高效率</li>
<li>主内存修改了run的值，但是工作内存中还是老的值</li>
</ul>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/12/06/MqYrFRvnzICDwPk.png" alt="image-20231206194127613" style="zoom:67%;">

<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><ul>
<li>要么所有的操作都成功，要么所有的操作都不执行，不会出现中间状态</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) {</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) {</span><br><span class="line">                a++;</span><br><span class="line">            }</span><br><span class="line">        }).start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">2</span>) {</span><br><span class="line">        Thread.<span class="keyword">yield</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"a = "</span> + a);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>结果理应是20000，但是由于并发不安全，结果往往偏小</li>
<li>反编译class文件，a++的字节码如下：<ul>
<li>一个线程对共享变量操作到一半，另外线程也可能来操作共享变量，干扰了前一个线程的操作</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"> 9 getstatic #32 &lt;org/example/TestVolatile.a : I&gt;	// 取值操作</span><br><span class="line">12 iconst_1</span><br><span class="line">13 iadd</span><br><span class="line">14 putstatic #32 &lt;org/example/TestVolatile.a : I&gt;	// 赋值操作</span><br></pre></td></tr></table></figure></div>

<h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><ul>
<li><p>虽然，在本线程内看来，所有指令都是有序的（或者说从执行的结果来看，是和有序一样的）</p>
</li>
<li><p>但是，从其他线程来看，这个线程的指令顺序未必就是代码编写的顺序</p>
</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线程1</span></span><br><span class="line"><span class="keyword">if</span> (ready) {</span><br><span class="line">    r.r1 = num + num;</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">    r.r1 = <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程2</span></span><br><span class="line">num = <span class="number">2</span>;</span><br><span class="line">ready = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 很有可能出现，先ready=true，再num=2的情况</span></span><br></pre></td></tr></table></figure></div>

<p>为了提高性能，编译器和处理器会对指令重排，一般分为以下三种：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[源代码] -&gt; 编译器优化的重排 -&gt; 指令并行的重排 -&gt; 内存系统的重排 -&gt; [最终执行指令]</span><br></pre></td></tr></table></figure></div>

<h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><h3 id="计算机中的缓存"><a href="#计算机中的缓存" class="headerlink" title="计算机中的缓存"></a>计算机中的缓存</h3><p>发出内存访问请求时，先查看缓存内是否有请求数据</p>
<ul>
<li>如果存在（命中），则不用访问内存直接返回该数据</li>
<li>如果不存在（失效），则要先把内存中的相应数据载入缓存，再将其返回处理器</li>
</ul>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/12/07/APmsw2H5FuT1rGp.png" alt="image-20231207153152691" style="zoom:50%;">

<table>
<thead>
<tr>
<th>从 CPU 到</th>
<th>大约需要的时钟周期</th>
</tr>
</thead>
<tbody><tr>
<td>寄存器</td>
<td>1 cycle (4GHz 的 CPU 约为 0.25ns)</td>
</tr>
<tr>
<td>L1</td>
<td>3~4 cycle</td>
</tr>
<tr>
<td>L2</td>
<td>10~20 cycle</td>
</tr>
<tr>
<td>L3</td>
<td>40~45 cycle</td>
</tr>
<tr>
<td>内存</td>
<td>120~240 cycle</td>
</tr>
</tbody></table>
<h3 id="伪共享"><a href="#伪共享" class="headerlink" title="伪共享"></a>伪共享</h3><p>缓存以缓存行（cache line）为单位</p>
<p>缓存会造成数据副本的产生，即同一份数据会缓存在不同核心的缓存行中。CPU要保证数据的一致性，需要做到某个CPU核心更改了数据，其它 CPU 核心对应的<strong>整个缓存行必须失效</strong>，这就是伪共享</p>
<p><strong>解决方法：</strong></p>
<ul>
<li>padding：通过填充，让数据落在不同的cache line中</li>
<li>@Contended：原理参考，无锁→Adder→优化机制→伪共享</li>
</ul>
<p><strong>Linux 查看 CPU 缓存行大小：</strong></p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">cat /sys/devices/system/cpu/cpu0/cache/index0/coherency_line_size</span><br></pre></td></tr></table></figure></div>

<h3 id="缓存一致"><a href="#缓存一致" class="headerlink" title="缓存一致"></a>缓存一致</h3><p>缓存一致性：多个处理器运算都涉及到同一块主内存区域时，可能各自的缓存数据不一致</p>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/12/07/vm4E97St1lKpqBQ.png" alt="image-20231207154559164" style="zoom:50%;">

<p>MESI是一种缓存一致性协议，CPU中每个缓存行使用四种状态标记：</p>
<ul>
<li>M：被修改（Modified）<ul>
<li>该缓存行只被缓存在该 CPU 的缓存中，并且是被修改过的</li>
<li>该缓存行中的内存需要写回</li>
<li>再次修改不需要广播</li>
</ul>
</li>
<li>E：独享的（Exclusive）<ul>
<li>该缓存行只被缓存在该 CPU 的缓存中，是未被修改过的</li>
<li>修改不需要广播</li>
</ul>
</li>
<li>S：共享的（Shared）<ul>
<li>该缓存行可能被多个 CPU 缓存</li>
<li>修改前，需要广播，使别人变成Invalid的</li>
</ul>
</li>
<li>I：无效的（Invalid）<ul>
<li>该缓存是无效的，可能有其它 CPU 修改了该缓存行</li>
</ul>
</li>
</ul>
<h3 id="处理机制"><a href="#处理机制" class="headerlink" title="处理机制"></a>处理机制</h3><p><strong>单核CPU：</strong></p>
<ul>
<li>自动保证内存操作的原子性</li>
</ul>
<p><strong>多核CPU：</strong></p>
<ul>
<li>总线锁定：当处理器要操作共享变量时，在 BUS 总线上发出一个 LOCK 信号，其他处理器就无法操作这个共享变量。该操作会导致大量阻塞，从而增加系统的性能开销（<strong>平台级别的加锁</strong>）</li>
<li>缓存锁定：当处理器对缓存中的共享变量进行了操作，其他处理器有嗅探机制，将各自缓存中的该共享变量的失效，读取时会重新从主内存中读取最新的数据，基于 MESI 缓存一致性协议来实现</li>
</ul>
<p><strong>有的情况不会使用缓存锁定：</strong></p>
<ul>
<li>操作的数据跨多个行</li>
<li>有的处理器不支持缓存锁定</li>
</ul>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>volatile：保证可见性，保证有序性（禁止指令重排），不保证原子性</p>
<blockquote>
<p><strong>synchronized为什么也可以保证有序性和可见性？（即使它无法禁用指令重排和处理器优化）</strong></p>
<ul>
<li>有序性：加锁之后，只有一个线程获得了锁。相当于单线程，由于数据依赖的存在，指令重排没有问题</li>
<li>可见性：加锁前，将清空工作内存中的值，后续使用需要从主内存中重新读取新的值；解锁前，把工作内存中的值刷新到主内存</li>
</ul>
</blockquote>
<h3 id="缓存一致-1"><a href="#缓存一致-1" class="headerlink" title="缓存一致"></a>缓存一致</h3><ul>
<li>对volatile变量，写指令后，插入写屏障</li>
<li>对volatile变量，读指令前，插入读屏障</li>
</ul>
<p>内存屏障的作用：</p>
<ul>
<li>确保对变量的“读-改-写”操作原子执行</li>
<li>阻止指令重排</li>
<li>强制把缓存中的脏数据写回主内存</li>
</ul>
<h3 id="保证可见性"><a href="#保证可见性" class="headerlink" title="保证可见性"></a>保证可见性</h3><ul>
<li>写屏障（Store Barrier），保证屏障之前对共享变量的操作，都同步到主存中</li>
<li>读屏障（Load Barrier），保证凭证之后对共享变量的读取，从主存刷新值，加载的是主存最新的值</li>
</ul>
<blockquote>
<p>写屏障仅仅是保证之后的读能够读到最新的结果，但不能保证其他线程的读跑到写屏障之前</p>
</blockquote>
<h3 id="保证有序性"><a href="#保证有序性" class="headerlink" title="保证有序性"></a>保证有序性</h3><ul>
<li>写屏障（Store Barrier），确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</li>
<li>读屏障（Load Barrier），确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</li>
</ul>
<blockquote>
<p>只能保证本线程内的代码不被重排，无法避免指令交错</p>
</blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无法避免指令交错</span></span><br><span class="line"><span class="type">volatile</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {i++});</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {i--});</span><br></pre></td></tr></table></figure></div>

<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/12/07/3bMDHOUZzwv84ix.png" alt="image-20231207163034006" style="zoom:50%;">

<h3 id="双重锁检查"><a href="#双重锁检查" class="headerlink" title="双重锁检查"></a>双重锁检查</h3><p><strong>禁止重排序上：</strong></p>
<p>单例模式的双重锁检查</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) {</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) {</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();	<span class="comment">// 避免赋值操作指令重排</span></span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">memory=<span class="built_in">allocate</span>();		<span class="comment">// 分配内存</span></span><br><span class="line"><span class="built_in">ctorInstanc</span>(memory);	<span class="comment">// 初始化对象</span></span><br><span class="line">s=memory;				<span class="comment">// s指向刚分配的地址</span></span><br></pre></td></tr></table></figure></div>

<p>如果instance变量不使用volatile关键词，可能发生重排序</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">memory=<span class="built_in">allocate</span>();		<span class="comment">// 分配内存</span></span><br><span class="line">s=memory;				<span class="comment">// 此时instance不为空，但是还没初始化完成。别的线程判断不为空，直接返回了没初始化的对象</span></span><br><span class="line"><span class="built_in">ctorInstanc</span>(memory);	<span class="comment">// 初始化对象</span></span><br></pre></td></tr></table></figure></div>

<h2 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h2><p>JMM具备一些先天的有序性，即不需要通过任何同步手段，就能够得到保证的安全</p>
<ol>
<li><strong>程序次序规则</strong>：操作之间有先后依赖关系</li>
<li><strong>锁定规则</strong>：unlock操作先行发生于，后面对同一个锁的lock操作<ul>
<li>这就是为什么，解锁之前的写操作，对接下来加锁的线程是可见的</li>
</ul>
</li>
<li><strong>volatile规则</strong>：对volatile变量的写操作先行发生于后面对这个变量的读</li>
<li><strong>传递规则</strong>：A-&gt;B，B-&gt;C，推导出A-&gt;C</li>
<li><strong>线程启动规则</strong>：Thread对象的start方法先行发生于后面的每一个操作</li>
<li><strong>线程中断规则</strong>：对线程interrupt()方法的调用。先行发生于检测到中断事件的发生</li>
<li><strong>线程终止规则</strong>：线程中所有的操作，都先行发生于线程的终止检测（比如thread.join()）</li>
<li><strong>对象终结规则</strong>：一个对象的初始化（构造函数执行结束），先行发生于他的finalize()方法</li>
</ol>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="终止模式"><a href="#终止模式" class="headerlink" title="终止模式"></a>终止模式</h3><p>停止标记用volatile：保证该变量在多个线程之间的可见性</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Termination</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Thread monitor;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">stop</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> {</span><br><span class="line">        monitor = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">                <span class="keyword">if</span> (stop) {</span><br><span class="line">                    System.out.println(<span class="string">"后置处理"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    System.out.println(<span class="string">"被打断，退出睡眠"</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        monitor.start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> {</span><br><span class="line">        stop = <span class="literal">true</span>;</span><br><span class="line">        monitor.interrupt();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Termination</span> <span class="variable">termination</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Termination</span>();</span><br><span class="line">termination.start();</span><br><span class="line">Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">termination.stop();</span><br></pre></td></tr></table></figure></div>

<h3 id="Balking"><a href="#Balking" class="headerlink" title="Balking"></a>Balking</h3><p>犹豫模式：发现另一个线程或本线程已经做了一样的事，就无需再做了，直接返回</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MonitorService</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">starting</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 需要加锁，synchronized能保证可见性</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) {</span><br><span class="line">            <span class="keyword">if</span> (starting) {</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">            starting = <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// actually do sth...</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>juc</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC系列：（五）无锁</title>
    <url>//post/62388/</url>
    <content><![CDATA[<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>CAS （Compare-And-Swap），是<strong>CPU并发原语</strong></p>
<p><strong>在Java中：</strong></p>
<ul>
<li>调用UnSafe类中的CAS 方法，JVM会实现出CAS汇编指令，这是一种完全依赖于硬件的功能，实现了原子操作</li>
</ul>
<p><strong>CAS作用：</strong></p>
<ul>
<li>比较当前工作内存中的值和主物理内存中的值，如果相同则执行规定操作</li>
</ul>
<p><strong>CAS特点：</strong></p>
<ul>
<li><p>CAS是基于乐观锁的思想</p>
</li>
<li><p>无锁并发，无阻塞并发（线程不会陷入阻塞，线程不需要频繁切换上下文）</p>
</li>
</ul>
<p><strong>CAS缺点：</strong></p>
<ul>
<li><p>执行的是循环操作，可能无限循环导致饥饿（使用CAS线程数最好不要超过CPU核心数）</p>
</li>
<li><p>只能同时保证一个变量的原子操作</p>
</li>
<li><p>引出ABA问题</p>
</li>
</ul>
<h2 id="Atomic"><a href="#Atomic" class="headerlink" title="Atomic"></a>Atomic</h2><h3 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h3><p>常见原子类：AtomicInteger、AtomicBoolean、AtomicLong</p>
<p>构造方法：</p>
<ul>
<li><code>public AtomicInteger()</code>：初始化一个默认值为 0 的原子型 Integer</li>
<li><code>public AtomicInteger(int initialValue)</code>：初始化一个指定值的原子型 Integer</li>
</ul>
<p>常用API：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>public final int get()</code></td>
<td>获取 AtomicInteger 的值</td>
</tr>
<tr>
<td><code>public final int getAndIncrement()</code></td>
<td>以原子方式将当前值加 1，返回的是自增前的值</td>
</tr>
<tr>
<td><code>public final int incrementAndGet()</code></td>
<td>以原子方式将当前值加 1，返回的是自增后的值</td>
</tr>
<tr>
<td><code>public final int getAndSet(int value)</code></td>
<td>以原子方式设置为 new Value 的值，返回旧值</td>
</tr>
<tr>
<td><code>public final int addAndGet(int data)</code></td>
<td>以原子方式将输入的数值与实例中的值相加并返回<br>实例：AtomicInteger 里的 value</td>
</tr>
</tbody></table>
<h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><p><strong>AtomicInteger 原理</strong>：</p>
<p>自旋锁+CAS算法（有3个操作数：内存值V， 旧的预期值A，要修改的值B）</p>
<p><strong>getAndSet方法：</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">int</span> newValue)</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * this: 		当前对象</span></span><br><span class="line"><span class="comment">    * valueOffset:	内存偏移量，内存地址</span></span><br><span class="line"><span class="comment">    * valueOffset = unsafe.objectFieldOffset(AtomicInteger.class.getDeclaredField("value"));</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndSetInt(<span class="built_in">this</span>, valueOffset, newValue);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// val1: AtomicInteger对象本身，var2: 该对象值的引用地址，var4: 需要变动的数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSetInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4)</span> {</span><br><span class="line">    <span class="type">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> {</span><br><span class="line">        <span class="comment">// 用this和valueOffset找到内存中真实的值</span></span><br><span class="line">        var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">        </span><br><span class="line">    } <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var4)); <span class="comment">// 使用CAS</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p><strong>getAndSet方法：</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">AtomicInteger</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">a.getAndUpdate(i -&gt; i + <span class="number">10</span>);</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndUpdate</span><span class="params">(IntUnaryOperator updateFunction)</span> {</span><br><span class="line">    <span class="type">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> {</span><br><span class="line">        prev = get();							<span class="comment">// 内存真实值</span></span><br><span class="line">        next = updateFunction.applyAsInt(prev);	<span class="comment">// 期望更新到的值</span></span><br><span class="line">    } <span class="keyword">while</span> (!compareAndSet(prev, next));		<span class="comment">// 自旋</span></span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p><strong>compareAndSet方法：</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * this: 		当前对象</span></span><br><span class="line"><span class="comment">    * valueOffset:	内存偏移量，内存地址</span></span><br><span class="line"><span class="comment">    * expect:		期望的值</span></span><br><span class="line"><span class="comment">    * update: 		更新的值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, valueOffset, expect, update);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h3><p>对Object进行原子操作</p>
<p>原子引用类：<code>AtomicReference</code>、<code>AtomicStampedReference</code>、<code>AtomicMarkableReference</code></p>
<p><strong>AtomicReference类：</strong></p>
<ul>
<li><p>构造方法：<code>AtomicReference&lt;T&gt; atomicReference = new AtomicReference&lt;T&gt;()</code></p>
</li>
<li><p>常用 API：</p>
<ul>
<li><code>public final boolean compareAndSet(V expectedValue, V newValue)</code>：CAS操作，返回是否成功</li>
<li><code>public final void set(V newValue)</code>：将值设置为newValue </li>
<li><code>public final V get()</code>：返回当前值</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需要自行实现自旋</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">33</span>, <span class="string">"z3"</span>);</span><br><span class="line"></span><br><span class="line">AtomicReference&lt;Student&gt; atomicReference = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line">atomicReference.set(s1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">    <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">44</span>, <span class="string">"l4"</span>);</span><br><span class="line">    <span class="keyword">if</span> (atomicReference.compareAndSet(s1, s2)) {</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">System.out.println(atomicReference.get());</span><br></pre></td></tr></table></figure></div>

<h3 id="原子数组"><a href="#原子数组" class="headerlink" title="原子数组"></a>原子数组</h3><p>原子数组类：<code>AtomicIntegerArray</code>、<code>AtomicLongArray</code>、<code>AtomicReferenceArray</code></p>
<p><strong>AtomicIntegerArray类方法：</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> expect, <span class="type">int</span> update)</span> {</span><br><span class="line">    <span class="keyword">return</span> compareAndSetRaw(checkedByteOffset(i), expect, update);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="原子更新器"><a href="#原子更新器" class="headerlink" title="原子更新器"></a>原子更新器</h3><p>原子更新器类：<code>AtomicReferenceFieldUpdater</code>、<code>AtomicIntegerFieldUpdater</code>、<code>AtomicLongFieldUpdater</code></p>
<ul>
<li><p>对象的某个域（Field）进行原子操作</p>
</li>
<li><p>只能配合volatile修饰的字段使用，否则会出现异常 <code>IllegalArgumentException: Must be volatile type</code></p>
</li>
</ul>
<p><strong>常用API：</strong></p>
<ul>
<li><code>static &lt;U&gt; AtomicIntegerFieldUpdater&lt;U&gt; newUpdater(Class&lt;U&gt; c, String fieldName)</code>：构造方法</li>
<li><code>abstract boolean compareAndSet(T obj, int expect, int update)</code>：CAS方法</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">AtomicIntegerFieldUpdater&lt;Student&gt; fieldUpdater = </span><br><span class="line">    			AtomicIntegerFieldUpdater.newUpdater(Student.class, <span class="string">"id"</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">0</span>, <span class="string">"z3"</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> fieldUpdater.compareAndSet(s1, <span class="number">0</span>, <span class="number">33</span>);</span><br></pre></td></tr></table></figure></div>

<h3 id="原子累加器"><a href="#原子累加器" class="headerlink" title="原子累加器"></a>原子累加器</h3><p>原子累加器类：<code>LongAdder</code>、<code>DoubleAdder</code>、<code>LongAccumulator</code>、<code>DoubleAccumulator</code> </p>
<p><strong>LongAdder和LongAccumulator区别：</strong></p>
<ul>
<li>相同点：<ul>
<li>都是CAS实现的</li>
<li>当accumulatorFunction等于null，初始值等于0时，LongAccumulator等于LongAdder</li>
</ul>
</li>
<li>不同点：<ul>
<li>LongAdder是LongAccumulator的特例</li>
<li>LongAccumulator可以自定义累加规则，初始值</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LongAdder</span> <span class="variable">longAdder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAdder</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) {</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">        longAdder.increment();</span><br><span class="line">    }).start();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数依次是：原值，累加值，初始值</span></span><br><span class="line"><span class="type">LongAccumulator</span> <span class="variable">longAccumulator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAccumulator</span>((left, right) -&gt; left + right, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) {</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">        longAccumulator.accumulate(<span class="number">1</span>);</span><br><span class="line">    }).start();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="Adder"><a href="#Adder" class="headerlink" title="Adder"></a>Adder</h2><h3 id="优化机制"><a href="#优化机制" class="headerlink" title="优化机制"></a>优化机制</h3><p>LongAdder是JDK8提供的类，跟AtomicLong有相同的效果，但对CAS机制进行了优化</p>
<ul>
<li><p>CAS缺点：大量空循环，自旋转</p>
</li>
<li><p>优化思路：数据分离，将单点得更新压力分担到各个节点上，空间换时间</p>
</li>
</ul>
<p><strong>分段CAS机制：</strong></p>
<ul>
<li>发生竞争时：创建Cell数组，将不同线程的操作离散到不同节点上（通过hash等算法映射）</li>
<li>设置多个累加单元，比如Thread-0累加Cell[0]，Thread-1累加Cell[1]…最后将结果汇总</li>
<li>累加时操作不同的Cell变量，减少了CAS失败，从而提升了性能</li>
</ul>
<p><strong>自动分段迁移机制：</strong></p>
<ul>
<li>某个Cell的value执行CAS失败，自动寻找另一个Cell分段内的value值进行CAS</li>
</ul>
<h3 id="伪共享"><a href="#伪共享" class="headerlink" title="伪共享"></a>伪共享</h3><p>Cell为累加的单元，是数组的形式</p>
<p>数组访问的索引是通过Thread里的<code>threadLocalRandomProbe</code>域取模实现的（这个域是<code>ThreadLocalRandom</code>更新的）</p>
<p><strong>下面是Cell的部分代码：</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Striped64类中</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Cell</span> {</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> value;</span><br><span class="line">    </span><br><span class="line">    Cell(<span class="type">long</span> x) { </span><br><span class="line">        value = x; </span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">cas</span><span class="params">(<span class="type">long</span> cmp, <span class="type">long</span> val)</span> {</span><br><span class="line">        <span class="comment">// 使用CAS方式累加，cmp为旧值，val为新值</span></span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapLong(<span class="built_in">this</span>, valueOffset, cmp, val);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p><strong>@sun.misc.Contended注解的作用：</strong></p>
<p>Cell是数组的形式，在内存中是连续的。64位系统中，一个Cell为24字节（16字节的对象头，8字节的value）。一个cache line是64字节的，因此<strong>缓存可以存下两个Cell对象</strong>。当Core-0要修改Cell[0]，Core-1要修改Cell[1]时，无论谁成功都会导致当前缓存行失效，进而数据失效，需要从主存获取，影响效率</p>
<p>@sun.misc.Contended：在对象或字段的前后各增加128字节大小的padding，让CPU将对象预读至缓存时<strong>占用不同的缓存行</strong>，这样就不会造成对方缓存行的失效</p>
<h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LongAdder继承于Striped64</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Striped64</span> <span class="keyword">extends</span> <span class="title class_">Number</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前CPU数量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NCPU</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 累加单元数组</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> Cell[] cells;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 基础值。如果没有发生竞争，会累加这个域。</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">long</span> base;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 初始化或者扩容时，只能有一个线程执行，通过CAS设置cellsBusy为1来实现加锁</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> cellsBusy;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p><strong>工作流程：</strong></p>
<ul>
<li>cells占用内存大，所以是惰性加载的。如果无竞争，会直接累加base。</li>
<li>第一次竞争发生时，创建大小为2的cells数组，将当前base值包装为Cell对象，放入映射的槽位上</li>
<li>分段迁移后，还发生竞争时，扩容cells数组长度为原来的2倍，然后rehash。<ul>
<li>数组总长度是2的幂，默认为最大CPU数量（比如：6核心CPU最大为8槽位）</li>
</ul>
</li>
<li>分段累加的过程中，如果当前线程对应的cells槽位为空，会新建Cell填充<ul>
<li>如果出现竞争，重新计算线程对应的槽位，继续自旋尝试修改</li>
</ul>
</li>
</ul>
<p><strong>LongAdder#add方法：</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">long</span> x)</span> {</span><br><span class="line">    </span><br><span class="line">    Cell[] as; </span><br><span class="line">    <span class="type">long</span> b, v; </span><br><span class="line">    <span class="type">int</span> m; </span><br><span class="line">    Cell a;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// cells不为空，说明cells已被初始化</span></span><br><span class="line">    <span class="comment">// 进入||后的逻辑，去更新base域，失败表示发生竞争</span></span><br><span class="line">    <span class="keyword">if</span> ((as = cells) != <span class="literal">null</span> || !casBase(b = base, b + x)) {</span><br><span class="line">        <span class="comment">// 多线程写base发生竞争，使用cells来写</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 表示cell没有竞争</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">uncontended</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 条件一：cells未初始化</span></span><br><span class="line">        <span class="comment">// 条件二：对应槽位尚未初始化</span></span><br><span class="line">        <span class="comment">// 条件三：当前槽位CAS有竞争</span></span><br><span class="line">        <span class="keyword">if</span> (as == <span class="literal">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[getProbe() &amp; m]) == <span class="literal">null</span> ||</span><br><span class="line">            !(uncontended = a.cas(v = a.value, v + x))) {</span><br><span class="line">            <span class="comment">// 上述条件满足任何一条后，进入以下逻辑</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// uncontended在对应的cell上累加失败的时候才为false，其余情况均为true</span></span><br><span class="line">        	longAccumulate(x, <span class="literal">null</span>, uncontended);</span><br><span class="line">        }    	</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Striped64类的方法</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">casBase</span><span class="params">(<span class="type">long</span> cmp, <span class="type">long</span> val)</span> {</span><br><span class="line">    <span class="keyword">return</span> UNSAFE.compareAndSwapLong(<span class="built_in">this</span>, BASE, cmp, val);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Striped64类的方法</span></span><br><span class="line"><span class="comment">// 当前值：x, null, false|true</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">longAccumulate</span><span class="params">(<span class="type">long</span> x, LongBinaryOperator fn,</span></span><br><span class="line"><span class="params">                              <span class="type">boolean</span> wasUncontended)</span> {</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="comment">// 当前线程还没有对应cell，随机生成一个hash值，将当前线程绑定到一个cell</span></span><br><span class="line">    <span class="keyword">if</span> ((h = getProbe()) == <span class="number">0</span>) {</span><br><span class="line">        ThreadLocalRandom.current();</span><br><span class="line">        h = getProbe();</span><br><span class="line">        wasUncontended = <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 表示扩容意向，false一定不会扩容，true可能扩容</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">collide</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        Cell[] as;	<span class="comment">// cells引用</span></span><br><span class="line">        Cell a; 	<span class="comment">// 当前线程Cell</span></span><br><span class="line">        <span class="type">int</span> n; 		<span class="comment">// cells长度</span></span><br><span class="line">        <span class="type">long</span> v;		<span class="comment">// 期望值</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 【case1】如果cells已经初始化，应将数据写入对应的cell中</span></span><br><span class="line">        <span class="keyword">if</span> ((as = cells) != <span class="literal">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 【case1.1】当前下标的cell为null，需要初始化</span></span><br><span class="line">            <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="literal">null</span>) {</span><br><span class="line">                <span class="comment">// 是否被锁（通过cellsBusy）</span></span><br><span class="line">                <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) {</span><br><span class="line">                    <span class="comment">// 创建cell，初始值为x</span></span><br><span class="line">                    <span class="type">Cell</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cell</span>(x);</span><br><span class="line">                    <span class="comment">// 加锁</span></span><br><span class="line">                    <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) {</span><br><span class="line">                        <span class="type">boolean</span> <span class="variable">created</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">try</span> {</span><br><span class="line">                            Cell[] rs; <span class="type">int</span> m, j;</span><br><span class="line">                            <span class="keyword">if</span> ((rs = cells) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                                (m = rs.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="literal">null</span>) {</span><br><span class="line">                                rs[j] = r;</span><br><span class="line">                                created = <span class="literal">true</span>;</span><br><span class="line">                            }</span><br><span class="line">                        } <span class="keyword">finally</span> {</span><br><span class="line">                            <span class="comment">// 解锁</span></span><br><span class="line">                            cellsBusy = <span class="number">0</span>;</span><br><span class="line">                        }</span><br><span class="line">                        <span class="keyword">if</span> (created) <span class="comment">// 创建完成，可以退出循环了</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                collide = <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 【case1.2】线程对应的cell有竞争，改变对应的cell来重试</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)</span><br><span class="line">                wasUncontended = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 【case1.3】当前线程rehash过，新命中的cell不为空，尝试累加</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (a.cas(v = a.value, ((fn == <span class="literal">null</span>) ? v + x : fn.applyAsLong(v, x))))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 【case1.4】cells长度超长或已经扩容过了</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= NCPU || cells != as)</span><br><span class="line">                collide = <span class="literal">false</span>;			<span class="comment">// 扩容意向变为false</span></span><br><span class="line">            <span class="comment">// 【case1.5】更改扩容意向为true，上一行判断如果进入了，永远不会进入这一条判断的</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">                collide = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 【case1.6】逻辑扩容，进行加锁</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="keyword">if</span> (cells == as) {</span><br><span class="line">                        Cell[] rs = <span class="keyword">new</span> <span class="title class_">Cell</span>[n &lt;&lt; <span class="number">1</span>]; <span class="comment">// 扩容为以前的两倍</span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                            rs[i] = as[i];</span><br><span class="line">                        cells = rs;</span><br><span class="line">                    }</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    cellsBusy = <span class="number">0</span>;</span><br><span class="line">                }</span><br><span class="line">                collide = <span class="literal">false</span>;	<span class="comment">// 扩容意向改为false，表示不扩容了</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            h = advanceProbe(h);	<span class="comment">// 重置当前线程hash值</span></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//【case2】cells还没初始化，判断有没有加锁，没有就用CAS加锁</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) {</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">init</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> {                           <span class="comment">// Initialize table</span></span><br><span class="line">                <span class="keyword">if</span> (cells == as) {</span><br><span class="line">                    Cell[] rs = <span class="keyword">new</span> <span class="title class_">Cell</span>[<span class="number">2</span>];</span><br><span class="line">                    rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Cell</span>(x);</span><br><span class="line">                    cells = rs;</span><br><span class="line">                    init = <span class="literal">true</span>;</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                cellsBusy = <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (init)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//【case3】说明其他线程正在初始化cells，当前线程值将累加到base，累加成功结束自旋</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (casBase(v = base, ((fn == <span class="literal">null</span>) ? v + x : fn.applyAsLong(v, x))))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p><strong>LongAdder#sum方法：</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sum</span><span class="params">()</span> {</span><br><span class="line">    Cell[] as = cells; </span><br><span class="line">    Cell a;</span><br><span class="line">    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> base;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="literal">null</span>) {</span><br><span class="line">        <span class="comment">// 遍历cells，累加</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; as.length; ++i) {</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="literal">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="ABA"><a href="#ABA" class="headerlink" title="ABA"></a>ABA</h2><p><strong>什么是ABA问题：</strong></p>
<ul>
<li>（A）一个线程先读取共享内存数据值A，随后因某种原因，线程暂时挂起</li>
<li>（B）另一个线程临时将共享内存数据值先改为B，随后又改回为A</li>
<li>（A）并通过CAS比较，最终比较结果将会无变化</li>
</ul>
<p><strong>解决方法，用版本号：</strong></p>
<ul>
<li><code>AtomicStampedReference</code>内部还维护了一个“状态戳”</li>
<li>修改对象值得同时，也要修改状态戳</li>
<li>当<code>AtomicStampedReference</code>设置对象值时，对象值以及状态戳都必须满足期望值，写入才会成功</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">    <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> num.getStamp();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">expected</span> <span class="operator">=</span> num.getReference();</span><br><span class="line">    <span class="keyword">if</span> (num.compareAndSet(expected, expected + <span class="number">100</span>, stamp, stamp + <span class="number">1</span>)) {</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h2><ul>
<li><p>Unsafe类是在<code>sun.misc</code>包下，不属于Java标准。但是很多Java的基础类库，包括一些被广泛使用的高性能开发库都是基于Unsafe类开发的，比如Netty、Cassandra、Hadoop、Kafka等</p>
</li>
<li><p>Java中Unsafe类为我们提供类似C++手动管理内存的功能，同时也有了指针的问题</p>
</li>
<li><p>Unsafe类是final的，不能继承；构造函数是private的，因此无法在外部实例化</p>
<ul>
<li>只能用反射获取实例</li>
</ul>
</li>
<li><p>所有方法都是native的</p>
</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Unsafe</span> {</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">theUnsafe</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Unsafe</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Unsafe</span><span class="params">()</span> {}</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="获取Unsafe"><a href="#获取Unsafe" class="headerlink" title="获取Unsafe"></a>获取Unsafe</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Unsafe <span class="title function_">getUnsafe</span><span class="params">()</span> <span class="keyword">throws</span> IllegalAccessException {</span><br><span class="line">    <span class="type">Field</span> <span class="variable">unsafeField</span> <span class="operator">=</span> Unsafe.class.getDeclaredFields()[<span class="number">0</span>];</span><br><span class="line">    unsafeField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> (Unsafe) unsafeField.get(<span class="literal">null</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/11/20/ObhcnakjTq7B3rI.png" alt="image-20231120203047561" style="zoom: 67%;">

<h3 id="CAS相关"><a href="#CAS相关" class="headerlink" title="CAS相关"></a>CAS相关</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapObject</span><span class="params">(Object o, <span class="type">long</span> offset, Object expected, Object x)</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapInt</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">int</span> expected, <span class="type">int</span> x)</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapLong</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">long</span> expected, <span class="type">long</span> x)</span></span><br></pre></td></tr></table></figure></div>

<h3 id="偏移量相关"><a href="#偏移量相关" class="headerlink" title="偏移量相关"></a>偏移量相关</h3><ul>
<li>读写属性，需要用到偏移量（offset）</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取静态属性，在对象中的偏移量</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">staticFieldOffset</span><span class="params">(Field f)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 获取非静态属性，在对象中的偏移量</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">objectFieldOffset</span><span class="params">(Field f)</span></span><br></pre></td></tr></table></figure></div>

<h3 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个类的实例，但是不会调用他的构造方法。如果类还没有初始化，则初始化这个类</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">allocateInstance</span><span class="params">(Class&lt;?&gt; cls)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 判断是否需要初始化一个类</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">shouldBeInitialized</span><span class="params">(Class&lt;?&gt; c)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保一个类已经初始化了</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ensureClassInitialized</span><span class="params">(Class&lt;?&gt; c)</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>defineClass</code>方法：定义一个类，用于动态地创建类。（JDK11被移除）</li>
<li><code>defineAnonymousClass</code>方法：用于动态的创建一个匿名内部类。（JDK11被移除）</li>
</ul>
<h3 id="普通读写"><a href="#普通读写" class="headerlink" title="普通读写"></a>普通读写</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getInt</span><span class="params">(Object o, <span class="type">long</span> offset)</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">putInt</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">int</span> x)</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnsafeTest</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, NoSuchFieldException {</span><br><span class="line">        <span class="type">UnsafeTest</span> <span class="variable">unsafeTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnsafeTest</span>();</span><br><span class="line">        <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> unsafeTest.getUnsafe();</span><br><span class="line">        <span class="type">Guard</span> <span class="variable">guard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Guard</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> guard.getClass().getDeclaredField(<span class="string">"value"</span>);</span><br><span class="line">        unsafe.putInt(guard, unsafe.objectFieldOffset(field), <span class="number">100</span>); <span class="comment">// 需要获取偏移量</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"guard.getValue() = "</span> + guard.getValue());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Unsafe <span class="title function_">getUnsafe</span><span class="params">()</span> <span class="keyword">throws</span> IllegalAccessException {</span><br><span class="line">        <span class="type">Field</span> <span class="variable">unsafeField</span> <span class="operator">=</span> Unsafe.class.getDeclaredFields()[<span class="number">0</span>];</span><br><span class="line">        unsafeField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> (Unsafe) unsafeField.get(<span class="literal">null</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Guard</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h3><ul>
<li>主要为了避免代码重排序<ul>
<li>比如：使用<code>loadFence()</code>，则屏障前的load操作不能被重排序到屏障后，屏障后的load操作不能被重排序到屏障前</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadFence</span><span class="params">()</span>		<span class="comment">// 保证在这个屏障之前，所有读操作都已经完成</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">storeFence</span><span class="params">()</span>	<span class="comment">// 保证在这个屏障之前，所有写操作都已经完成</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fullFence</span><span class="params">()</span>		<span class="comment">// 保证在这个屏障之前，所有读写操作都已经完成</span></span><br></pre></td></tr></table></figure></div>

<h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 恢复阻塞线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unpark</span><span class="params">(Object thread)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">park</span><span class="params">(<span class="type">boolean</span> isAbsolute, <span class="type">long</span> time)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得对象锁（可重入锁）</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">monitorEnter</span><span class="params">(Object o)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 释放对象锁</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">monitorExit</span><span class="params">(Object o)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 尝试获取对象锁</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">tryMonitorEnter</span><span class="params">(Object o)</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>park</code>方法，<code>unpark</code>方法，看过<code>LockSupport</code>类的都不会陌生，这两个方法主要用来挂起和唤醒线程<ul>
<li><code>LockSupport</code>中的<code>park</code>和<code>unpark</code>方法正是通过Unsafe来实现的：</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unpark</span><span class="params">(Thread thread)</span> {</span><br><span class="line">    <span class="keyword">if</span> (thread != <span class="literal">null</span>)</span><br><span class="line">        U.unpark(thread);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">park</span><span class="params">(Object blocker)</span> {</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    setBlocker(t, blocker);</span><br><span class="line">    U.park(<span class="literal">false</span>, <span class="number">0L</span>);</span><br><span class="line">    setBlocker(t, <span class="literal">null</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>monitorEnter</code>方法和<code>monitorExit</code>方法用于加锁，Java中的<code>synchronized</code>锁就是通过这两个指令来实现的<ul>
<li>JDK11之后，这几个方法被移除</li>
</ul>
</li>
</ul>
<h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main6</span> {</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p><strong>字节码如下：</strong></p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"> 0 aload_0</span><br><span class="line"> 1 invokespecial #1 &lt;java/lang/Object.&lt;init&gt; : ()V&gt;</span><br><span class="line"> 4 aload_0</span><br><span class="line"> 5 bipush 20		# 将值直接放入栈中</span><br><span class="line"> 7 putfield #2		# Field a:I</span><br><span class="line"> 					# 此处有个写屏障</span><br><span class="line">10 return</span><br></pre></td></tr></table></figure></div>

<p>final变量的赋值通过putfield指令来完成，这条指令后会加入写屏障，避免其他线程读到他的值不会出现为零值的问题</p>
<p><strong>其他线程访问final修饰的变量：</strong></p>
<ul>
<li>赋值一份放入栈中，直接访问</li>
<li>大于short的最大值，会将其复制到类的常量池，访问时从常量池取</li>
</ul>
<h3 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h3><ul>
<li><p>定义：一个对象不能够修改其内部状态（属性），比如String类</p>
</li>
<li><p>不可变对象是线程安全的</p>
</li>
<li><p>更改String对象，会构建新的字符串对象（这种创建副本来避免共享的方式称为：保护性拷贝）</p>
</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h2><p>状态信息：成员变量保存的数据</p>
<p>无状态：没有成员变量</p>
<blockquote>
<p>如果一个类没有任何成员变量，那他就是线程安全的</p>
</blockquote>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul>
<li><p>用来提供线程内部的局部变量，分配在堆内的TLAB中</p>
</li>
<li><p>ThreadLocal实例属于一个线程的本地变量，每个线程都有，所以是线程安全的</p>
</li>
</ul>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ThreadLocal&lt;&gt;()</td>
<td>创建ThreadLocal对象</td>
</tr>
<tr>
<td>protected T initialValue()</td>
<td>返回：当前线局部变量，的初始值</td>
</tr>
<tr>
<td>public void set( T value)</td>
<td>设置：当前线程绑定，的局部变量</td>
</tr>
<tr>
<td>public T get()</td>
<td>获取：当前线程绑定，的局部变量</td>
</tr>
<tr>
<td>public void remove()</td>
<td>移除：当前线程绑定，的局部变量</td>
</tr>
</tbody></table>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyDemo</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; t1 = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getContent</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> t1.get();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContent</span><span class="params">(String content)</span> {</span><br><span class="line">        t1.set(content);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">    <span class="type">String</span> <span class="variable">finalI</span> <span class="operator">=</span> <span class="string">""</span> + i;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">        <span class="comment">// 每个线程都有自己的独立的数据</span></span><br><span class="line">        myDemo.setContent(finalI);</span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> myDemo.getContent();</span><br><span class="line">    }).start();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><h4 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a>底层结构</h4><p><strong>JDK8以前：</strong></p>
<ul>
<li><p>每个ThreadLocal都创建一个Map，线程作为key，存储的值作为value</p>
</li>
<li><p>缺点：Map结果过大、内存泄露（Thread停止后，key对应的数据无法删除）</p>
</li>
</ul>
<p><strong>JDK8以后：</strong></p>
<ul>
<li><p>每个Thread维护一个ThreadLocalMap，ThreadLocal实例作为key，存储的值作为value</p>
</li>
<li><p>优点：</p>
<ul>
<li>Map中的Entry数量变少（以前由Thread数决定，现在由ThreadLocal数量决定）</li>
<li>防止内存泄露（Thread销毁，ThreadLocalMap也会销毁）</li>
</ul>
</li>
</ul>
<h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><ul>
<li>每个Thread线程持有一个<code>ThreadLocalMap</code>对象</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> {</span><br><span class="line">    </span><br><span class="line">    ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">inheritableThreadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>ThreadLocal中：</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocal</span>&lt;T&gt; {</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadLocalHashCode</span> <span class="operator">=</span> nextHashCode();			<span class="comment">// 计算ThreadLocal哈希值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">nextHashCode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();<span class="comment">// 每新增ThreadLocal对象，分配新hash</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HASH_INCREMENT</span> <span class="operator">=</span> <span class="number">0x61c88647</span>;			<span class="comment">// 新增hash量（黄金分割数）</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h4><ul>
<li>返回线程局部变量的初始值（此方法缺省，为了让子类覆盖而设计的）</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> T <span class="title function_">initialValue</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>计算哈希值（每次以斐波纳契数/黄金分割数递增），好处是分布均匀</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nextHashCode</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>修改当前线程ThreadLocal的局部变量</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> {</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) {</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        createMap(t, value);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> {</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>获取当前线程ThreadLocal的局部变量</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) {</span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) {</span><br><span class="line">            <span class="meta">@SuppressWarnings("unchecked")</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// map==null，或者没有与当前ThreadLocal关联的entry，就会设置默认值</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置默认值（null）</span></span><br><span class="line"><span class="keyword">private</span> T <span class="title function_">setInitialValue</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> initialValue();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) {</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        createMap(t, value);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> <span class="keyword">instanceof</span> TerminatingThreadLocal) {</span><br><span class="line">        TerminatingThreadLocal.register((TerminatingThreadLocal&lt;?&gt;) <span class="built_in">this</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> T <span class="title function_">initialValue</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>移除当前线程ThreadLocal的局部变量</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">m</span> <span class="operator">=</span> getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="literal">null</span>) {</span><br><span class="line">        m.remove(<span class="built_in">this</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h2><h3 id="成员属性"><a href="#成员属性" class="headerlink" title="成员属性"></a>成员属性</h3><p>是ThreadLocal内部类，用独立的方式实现了Map的功能，内部Entry也是独立实现</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 散列表数组的初始长度16</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存放数据的table，长度必须是2的幂。</span></span><br><span class="line"><span class="keyword">private</span> Entry[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组里面entrys的个数，可以用于判断table当前使用量是否超过阈值</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行扩容的阈值，表使用量大于它的时候进行扩容。</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> threshold;</span><br></pre></td></tr></table></figure></div>

<p>存储结构Entry：</p>
<ul>
<li>继承WeakReference，key是弱引用，以便将ThreadLocal生命周期与线程生命周期解绑</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; {</span><br><span class="line">    Object value;</span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) {</span><br><span class="line">        <span class="comment">// this.referent = referent = key;</span></span><br><span class="line">        <span class="built_in">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>构造方法（是延迟初始化的，Thread第一次存储firstKey-firstValue时才会创建<code>ThreadLocalMap</code>）</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) {</span><br><span class="line">    table = <span class="keyword">new</span> <span class="title class_">Entry</span>[INITIAL_CAPACITY];</span><br><span class="line">    <span class="comment">// 【寻址算法】计算索引</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">    table[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(firstKey, firstValue);</span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 将阈值设置为 （当前数组长度 * 2）/ 3。</span></span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="成员方法-1"><a href="#成员方法-1" class="headerlink" title="成员方法"></a>成员方法</h3><p><strong>添加数据：</strong></p>
<ul>
<li>一直探测下一个地址，直到有空的地址后插入</li>
<li>若插入后Map数量超过阈值，数组扩容为原来两倍</li>
<li>探测过程中，key为null的脏Entry会被垃圾清理，并复用位置</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> {</span><br><span class="line"></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);	<span class="comment">// 哈希寻址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i]; e != <span class="literal">null</span>; e = tab[i = nextIndex(i, len)]) {	<span class="comment">// 一直找到entry为null</span></span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == key) {		<span class="comment">// ThreadLocal对应的key存在，直接覆盖即可</span></span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) {	<span class="comment">// key为null，值不为null，说明之前ThreadLocal对象已被回收了</span></span><br><span class="line">            replaceStaleEntry(key, value, i);	<span class="comment">// 垃圾清理，槽位复用</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 逻辑到这里，说明碰到槽位为null的情况，创建新的Entry</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">    <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> ++size;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启发式清理一下，还是超过阈值，则进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nextIndex</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> len)</span> {</span><br><span class="line">    <span class="comment">// 环形数组，不断访问下一个</span></span><br><span class="line">    <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">prevIndex</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> len)</span> {</span><br><span class="line">    <span class="comment">// 环形数组，不断访问上一个</span></span><br><span class="line">    <span class="keyword">return</span> ((i - <span class="number">1</span> &gt;= <span class="number">0</span>) ? i - <span class="number">1</span> : len - <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// stateSlot是最新的过期数据的位置</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value, <span class="type">int</span> staleSlot)</span> {</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">slotToExpunge</span> <span class="operator">=</span> staleSlot;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在不为空的Entry中向前找，找到第一个过期数据的位置（key，也即弱引用，为null）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> prevIndex(staleSlot, len); (e = tab[i]) != <span class="literal">null</span>; i = prevIndex(i, len))</span><br><span class="line">        <span class="keyword">if</span> (e.get() == <span class="literal">null</span>)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 向后找，找到第一个值为null的位置为止</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nextIndex(staleSlot, len); (e = tab[i]) != <span class="literal">null</span>; i = nextIndex(i, len)) {</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 找到key相等的条件【替换逻辑】</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) {</span><br><span class="line">            e.value = value;</span><br><span class="line">			</span><br><span class="line">            <span class="comment">// 本来要在staleSlot处放置数据，现在发现i处key与数据一致。</span></span><br><span class="line">            <span class="comment">// 把数据放在stateSlot处。原本在stateSlot处的过期数据放到i这里来</span></span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line">			</span><br><span class="line">            <span class="comment">// 之前往前没找到过期数据，第一条过期数据是位置staleSlot</span></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">  				<span class="comment">// 不过现在第一条过期数据到位置i了</span></span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 从slotToExpunge往后清理垃圾</span></span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 当前位置i也是过期数据，且之前向前找没找到过期数据，i就是第一条过期数据</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    tab[staleSlot].value = <span class="literal">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 从slotToExpunge往后清理垃圾</span></span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/12/12/kqTZQPKyvhR1emS.png" alt="image-20231212132900946"></p>
<p><strong>获取数据：</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// get函数调用它</span></span><br><span class="line"><span class="keyword">private</span> Entry <span class="title function_">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 线性探测</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Entry <span class="title function_">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="type">int</span> i, Entry e)</span> {</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">	</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (e != <span class="literal">null</span>) {</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key)				<span class="comment">// 找到第一个满足条件的</span></span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>)				<span class="comment">// 过期数据回收</span></span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;					<span class="comment">// 没有找到数据，返回null（数据一定是紧挨着的，不可能隔一个null放到后面）</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p><strong>rehash：</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rehash</span><span class="params">()</span> {</span><br><span class="line">    expungeStaleEntries();					<span class="comment">// 遍历所有槽位清理过期数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)	<span class="comment">// 还是超过阈值，扩容</span></span><br><span class="line">        resize();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">expungeStaleEntries</span><span class="params">()</span> {</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; len; j++) {			<span class="comment">// 遍历所有槽位清理过期数据</span></span><br><span class="line">        <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == <span class="literal">null</span>)</span><br><span class="line">            expungeStaleEntry(j);			<span class="comment">// 探测式清理</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p><strong>remove：</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> {</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i]; e != <span class="literal">null</span>; e = tab[i = nextIndex(i, len)]) {</span><br><span class="line">        <span class="keyword">if</span> (e.get() == key) {		<span class="comment">// 找到了对应的key	</span></span><br><span class="line">            e.clear();				<span class="comment">// 设置key为null</span></span><br><span class="line">            expungeStaleEntry(i);	<span class="comment">// 探测式清理</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="探测式清理方法"><a href="#探测式清理方法" class="headerlink" title="探测式清理方法"></a>探测式清理方法</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">expungeStaleEntry</span><span class="params">(<span class="type">int</span> staleSlot)</span> {}</span><br></pre></td></tr></table></figure></div>

<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/12/12/GlaOHSgtpURuxKi.png" alt="image-20231212134042892" style="zoom:50%;">

<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/12/12/m9fVE4D6hA5cFqb.png" alt="image-20231212134055906" style="zoom:50%;">

<h3 id="启发式清理"><a href="#启发式清理" class="headerlink" title="启发式清理"></a>启发式清理</h3><ul>
<li>向后循环扫描，发现过期数据就用<strong>探测式清理方法</strong>，来清理</li>
<li>加入当前数组长度为16，16-&gt;8-&gt;4-&gt;2-&gt;1，会向后扫描四次</li>
<li>假如扫到了垃圾，就又恢复到16，重新开始16-&gt;8-&gt;4…</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">cleanSomeSlots</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">removed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="keyword">do</span> {</span><br><span class="line">        i = nextIndex(i, len);</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == <span class="literal">null</span>) {</span><br><span class="line">            n = len;</span><br><span class="line">            removed = <span class="literal">true</span>;</span><br><span class="line">            i = expungeStaleEntry(i);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">while</span> ( (n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h2><h3 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h3><p>父子线程：创建子线程的就是父线程，比如实例中的main线程就是父线程</p>
<p>想实现线程间局部变量传递，可以使用InheritableThreadLocal</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    InheritableThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">InheritableThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    threadLocal.set(<span class="string">"hello"</span>);			<span class="comment">// 父线程设置值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> threadLocal.get();	<span class="comment">// 子线程也能拿到</span></span><br><span class="line">    }).start();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3><p>InheritableThreadLocal源码：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InheritableThreadLocal</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">ThreadLocal</span>&lt;T&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> T <span class="title function_">childValue</span><span class="params">(T parentValue)</span> {</span><br><span class="line">        <span class="keyword">return</span> parentValue;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> {</span><br><span class="line">       <span class="keyword">return</span> t.inheritableThreadLocals;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> {</span><br><span class="line">        t.inheritableThreadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>在Thread的构造方法中：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数调用了init方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span><br><span class="line"><span class="params">                      <span class="type">long</span> stackSize, AccessControlContext acc,</span></span><br><span class="line"><span class="params">                      <span class="type">boolean</span> inheritThreadLocals)</span> {</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">parent</span> <span class="operator">=</span> currentThread();</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 父线程的inheritableThreadLocals属性不为null，复制父线程的inheritableThreadLocals</span></span><br><span class="line">    <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="literal">null</span>) {</span><br><span class="line">        <span class="built_in">this</span>.inheritableThreadLocals = </span><br><span class="line">            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本质上还是创建ThreadLocalMap</span></span><br><span class="line"><span class="keyword">static</span> ThreadLocalMap <span class="title function_">createInheritedMap</span><span class="params">(ThreadLocalMap parentMap)</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(parentMap);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 逐个复制父线程ThreadLocalMap中的数据</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">ThreadLocalMap</span><span class="params">(ThreadLocalMap parentMap)</span> {</span><br><span class="line">    Entry[] parentTable = parentMap.table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> parentTable.length;</span><br><span class="line">    setThreshold(len);</span><br><span class="line">    table = <span class="keyword">new</span> <span class="title class_">Entry</span>[len];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; len; j++) {</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> parentTable[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) {</span><br><span class="line">            <span class="meta">@SuppressWarnings("unchecked")</span></span><br><span class="line">            ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();</span><br><span class="line">            <span class="keyword">if</span> (key != <span class="literal">null</span>) {</span><br><span class="line">                <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> key.childValue(e.value);</span><br><span class="line">                <span class="type">Entry</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">                <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">while</span> (table[h] != <span class="literal">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                table[h] = c;</span><br><span class="line">                size++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>juc</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC系列：（七）同步器</title>
    <url>//post/1126/</url>
    <content><![CDATA[<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><p>AQS（AbstractQueuedSynchronizer），是阻塞式锁的框架，许多同步类都依赖于该同步器</p>
<p><strong>独占与共享：</strong></p>
<ul>
<li><p>AQS用状态属性，来表示资源的状态</p>
</li>
<li><p>独占模式：只有一个线程能访问资源</p>
</li>
<li><p>共享模式：允许多个线程访问资源，比如Semaphore，ReentrantReadWriteLock</p>
</li>
</ul>
<p><strong>AQS核心思想：</strong></p>
<ul>
<li>如果请求的资源空闲，则将当前线程设为有效的工作线程，资源设为锁定状态</li>
<li>如果请求的资源锁定，则将当前线程加入到队列中</li>
</ul>
<p>CLH是一种基于单向链表的高性能、公平的自旋锁。AQS将所有请求的线程封装为CLH锁队列的一个结点，来实现锁的分配</p>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/12/12/WoS4rjNiwqfeQZK.png" alt="image-20231212202746559" style="zoom:67%;">

<h3 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h3><ul>
<li>获取锁</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (state 状态不允许获取) {</span><br><span class="line">	<span class="keyword">if</span> (队列中没有此线程) {</span><br><span class="line">		入队并阻塞 park</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line">当前线程出队</span><br></pre></td></tr></table></figure></div>

<ul>
<li>释放锁</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (state 状态允许了) {</span><br><span class="line">	恢复阻塞的线程(s) unpark</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p><strong>AQS中state设计：</strong></p>
<ul>
<li>state使用32位 int来维护同步状态，0表示未加锁，大于0表示已加锁</li>
<li>state使用volatile，配合CAS保证修改的原子性</li>
<li>state表示线程重入的次数（独占模式），或者剩余许可数（共享模式）</li>
<li>state API<ul>
<li><code>protected final int getState()</code>：获取state状态</li>
<li><code>protected final void setState(int newState)</code>：设置state状态</li>
<li><code>protected final boolean compareAndSetState(int expect,int update)</code>：CAS安全设置state</li>
</ul>
</li>
</ul>
<p><strong>线程的Node节点中waitstate设计：</strong></p>
<ul>
<li>使用volatile，配合CAS保证修改的原子性</li>
<li>状态有以下几种</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> waitStatus;			<span class="comment">// 默认为0</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;	<span class="comment">// 由于超时或中断，此节点被取消，不会再改变状态</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;	<span class="comment">// 此节点后面的节点已被阻止（park）（当前节点释放或取消时必须唤醒后面的节点）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;	<span class="comment">// 此节点在条件队列中</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;	<span class="comment">// 将releaseShared传播到其他节点</span></span><br></pre></td></tr></table></figure></div>

<p><strong>阻塞恢复设计：</strong></p>
<ul>
<li>使用park-unpark来实现线程的暂停和恢复（命令的先后不影响结果）</li>
<li>park线程可以通过interrupt来打断</li>
</ul>
<p><strong>队列设计：</strong></p>
<ul>
<li>双向链表，FIFO队列</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;	<span class="comment">// 头节点，哑元节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;	<span class="comment">// 尾节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();	<span class="comment">// 枚举：共享模式</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;		<span class="comment">// 枚举：独占模式</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;						<span class="comment">// 指向上一个节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;						<span class="comment">// 指向下一个节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;					<span class="comment">// 当前node所属线程</span></span><br><span class="line">    Node nextWaiter;						<span class="comment">// （条件队列使用该属性）条件队列是单向链表，只有后继指针</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>条件变量，来实现：等待、唤醒</li>
<li>支持多个条件变量，类似Monitor的WaitSet</li>
<li>条件队列是单向队列</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionObject</span> <span class="keyword">implements</span> <span class="title class_">Condition</span>, java.io.Serializable {</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;	<span class="comment">// 指向条件队列的第一个node节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;	<span class="comment">// 指向条件队列的最后一个node节点</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="模板对象"><a href="#模板对象" class="headerlink" title="模板对象"></a>模板对象</h3><ul>
<li>使用者继承 <code>AbstractQueuedSynchronizer</code> 并重写指定的方法</li>
<li>将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，这些模板方法会调用使用者重写的方法</li>
</ul>
<p>自定义同步器需要重写下面几个AQS提供的模板方法</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">isHeldExclusively()		<span class="comment">// 该线程是否正在独占资源。只有用到condition才需要去实现它</span></span><br><span class="line">tryAcquire(<span class="type">int</span>)			<span class="comment">// 独占方式。尝试获取资源，成功则返回true，失败则返回false</span></span><br><span class="line">tryRelease(<span class="type">int</span>)			<span class="comment">// 独占方式。尝试释放资源，成功则返回true，失败则返回false</span></span><br><span class="line">tryAcquireShared(<span class="type">int</span>)	<span class="comment">// 共享方式。尝试获取资源。负数表示失败；0表示成功但没有剩余可用资源；正数表示成功且有剩余资源</span></span><br><span class="line">tryReleaseShared(<span class="type">int</span>)	<span class="comment">// 共享方式。尝试释放资源，成功则返回true，失败则返回false</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>默认，这些方法会抛出<code>UnsupportedOperationException</code></li>
<li>这些方法必须内部线程安全</li>
</ul>
<h3 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h3><ul>
<li>自定义一个独占模式的可重入锁</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS独占锁，不可重入</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MySync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> {</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试加锁</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> {</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) {</span><br><span class="line">                <span class="comment">// 设置owner为当前线程</span></span><br><span class="line">                <span class="built_in">this</span>.setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试解锁</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> arg)</span> {</span><br><span class="line">            <span class="built_in">this</span>.setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">            <span class="built_in">this</span>.setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断，是否持有独占锁</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.getState() == <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConditionObject</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">MySync</span> <span class="variable">sync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MySync</span>();</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 加锁（不成功加入等待队列）</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> {</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 加锁，可以打断</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 尝试加锁，只尝试一次</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 尝试加锁，带超时</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(time));</span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> {</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 条件变量</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><h3 id="对比synchronized"><a href="#对比synchronized" class="headerlink" title="对比synchronized"></a>对比synchronized</h3><ol>
<li>锁的实现：ReentrantLock是JDK实现的，synchronized是JVM实现的</li>
<li>性能：ReentrantLock和synchronized大致相同</li>
<li>使用：ReentrantLock需要手动解锁，synchronized自动解锁</li>
<li><strong>可中断</strong>：ReentrantLock可中断，而synchronized不行</li>
<li><strong>公平锁</strong>：ReentrantLock可以设置公平锁，synchronized中的锁是非公平的</li>
<li><strong>锁超时</strong>：ReentrantLock可以设置超时时间，synchronized会一直等待</li>
<li><strong>锁绑定多个条件</strong>：ReentrantLock可以同时绑定多个Condition对象（细粒度的唤醒）</li>
<li>可重入：两者都是可重入锁</li>
</ol>
<h3 id="使用锁"><a href="#使用锁" class="headerlink" title="使用锁"></a>使用锁</h3><ul>
<li><code>public void lock()</code>：获得锁<ul>
<li>锁没有被其他线程占用，计数设为1</li>
<li>锁被当前线程占用，计数+1</li>
<li>锁被其他线程占用，进入休眠状态</li>
</ul>
</li>
<li><code>public void unlock()</code>：尝试释放锁<ul>
<li>锁被当前线程占用，计数-1；如果计数器为0，则锁被释放</li>
<li>如果锁不是被当前线程占用，抛出异常</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">reentrantLock.lock();		<span class="comment">// 获取锁</span></span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    						<span class="comment">// 临界区</span></span><br><span class="line">} <span class="keyword">finally</span> {</span><br><span class="line">	reentrantLock.unlock();	<span class="comment">// 释放锁</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>构造方法：<code>ReentrantLock lock = new ReentrantLock(true)</code></p>
<ul>
<li>默认是非公平的</li>
<li>公平锁一般没必要，会降低并发度</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> {</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> {</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="非公平锁原理"><a href="#非公平锁原理" class="headerlink" title="非公平锁原理"></a>非公平锁原理</h4><p><code>NonfairSync</code>继承自AQS</p>
<ul>
<li><code>NonfairSync</code> -&gt; <code>Sync</code> -&gt; <code>AQS</code></li>
</ul>
<p><strong>加锁原理：</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NonfairSync类</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))	<span class="comment">// 使用CAS尝试一次，将state从0改为1</span></span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);					<span class="comment">// 失败进入</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// AQS类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> {</span><br><span class="line">    <span class="comment">// tryAcquire尝试获取锁</span></span><br><span class="line">    <span class="comment">// 获取锁失败，会调用addWaiter将当前线程封装成Node入队，acquireQueued阻塞当前线程</span></span><br><span class="line">    <span class="comment">// acquireQueued返回true表示被中断唤醒过，false表示从未被中断唤醒过</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();	<span class="comment">// 如果被中断唤醒过，会来到这里（执行Thread.currentThread().interrupt();）</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/12/12/wNzpdJEtIPQvByK.png" alt="image-20231212231824339"></p>
<ul>
<li>tryAcquire尝试获取锁，只有两种情况能成功<ol>
<li>当前AQS锁未被占有</li>
<li>当前AQS锁被自己占有，可以进行锁重入</li>
</ol>
</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NonfairSync类</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> {</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// AQS类	</span></span><br><span class="line"><span class="comment">// 抢占成功返回true，失败返回false</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> {</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();										<span class="comment">// 当前AQS的状态</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) {											<span class="comment">// 锁没有被占有，尝试使用CAS获取锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) {</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) {		<span class="comment">// 锁被当前线程占有，锁重入</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;											<span class="comment">// 否则都返回false</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>接下来是addWaiter的逻辑<ul>
<li>图中黄色三角表示Node的waitStatus状态，0为默认正常状态</li>
<li>Node的创建是懒惰的，第一个Node是哑元，用来占位</li>
</ul>
</li>
</ul>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/12/12/5ivVQSAxL1NDpHo.png" alt="image-20231212233215319"></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// addWaiter(Node.EXCLUSIVE)</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);	<span class="comment">// 创建Node对象，模式为独占模式</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="literal">null</span>) {									<span class="comment">// tail不为null，说明有队列</span></span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) {			<span class="comment">// CAS，尾插法加入</span></span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        enq(node);											<span class="comment">// 初始队列为空，或者CAS失败</span></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> {</span><br><span class="line">        <span class="keyword">for</span> (;;) {											<span class="comment">// 自旋入队，必须成功才结束循环</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))			<span class="comment">// tail为null，CAS设置哑元头节点</span></span><br><span class="line">                    tail = head;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                node.prev = t;								<span class="comment">// 当前节点前序节点设为之前的tail</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) {			<span class="comment">// CAS自旋尝试入队（tail指针指向它）</span></span><br><span class="line">                    t.next = node;							<span class="comment">// 之前的tail节点的后继节点设为当前节点			</span></span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }	</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>接下来是acquireQueued<ul>
<li>返回true表示被中断唤醒过</li>
<li>返回false表示从未被中断唤醒过</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> {</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;						<span class="comment">// 是否被中断唤醒过</span></span><br><span class="line">        <span class="keyword">for</span> (;;) {											<span class="comment">// 开始for循环</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();				<span class="comment">// 获得当前线程节点的前驱节点</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) {				<span class="comment">// 前驱是head，尝试去获取锁</span></span><br><span class="line">                setHead(node);								<span class="comment">// 获取成功，设置自己的node为head</span></span><br><span class="line">                p.next = <span class="literal">null</span>;</span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;	<span class="comment">// 判断是否应当park</span></span><br><span class="line">                parkAndCheckInterrupt())					<span class="comment">// park，会返回期间是否被打断</span></span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>shouldParkAfterFailedAcquire，判断是否应当park<ul>
<li>将前驱的node的waitStatus改为Node.SIGNAL（-1）</li>
<li>waitStatus为-1的节点用来唤醒下一个节点</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> pred.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL)					<span class="comment">// 如果前置节点可以唤醒当前节点（waitState等于-1）</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;						<span class="comment">// 返回应该park</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) {							<span class="comment">// 前置节点处于取消状态，需要不断删除前面取消的节点</span></span><br><span class="line">            <span class="keyword">do</span> {</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            } <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);	<span class="comment">//	CAS尝试一次，设置上一个节点状态为Node.SIGNAL</span></span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;							<span class="comment">// 返回不应该park（返回外部，会继续循环重试）</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>parkAndCheckInterrupt，判断是否被打断</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> {</span><br><span class="line">    LockSupport.park(<span class="built_in">this</span>);			<span class="comment">// 阻塞当前线程，如果打断标记是true则park失败</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();	<span class="comment">// 判断是否被打断，清除打断标记</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/12/13/auLxDYjfp5POytg.png" alt="image-20231213000328943"></p>
<p><strong>解锁原理：</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> {</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AQS类 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> {</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) {						<span class="comment">// 尝试释放锁，返回true表示成功</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)		<span class="comment">// 头节点不为空，说明有唤醒队列，需要唤醒head节点后面的线程</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>tryRelease方法，尝试解锁</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AQS类  </span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;								<span class="comment">// 减去释放的值</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())	<span class="comment">// 不是当前线程持有锁，直接报错</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) {												<span class="comment">// state为0，表示锁释放成功</span></span><br><span class="line">        free = <span class="literal">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">    }</span><br><span class="line">    setState(c);												<span class="comment">// 当前线程持有锁，直接更新新值，不需要CAS</span></span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>unparkSuccessor，唤醒当前节点的后继节点</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AQS类  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> {</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 尝试将当前节点状态重置为0，因为要完成对后续节点的唤醒，不需要-1了</span></span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到需要unpark的节点，当前节点的下一个</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果后继节点为null，或者已被取消，就不能唤醒，所以需要找到距离最新的非取消节点</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) {</span><br><span class="line">        s = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 从后向前，找到需要unpark的节点，直到t等于当前node为止，找不到就算了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 唤醒线程</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><strong>从后向前的原因：</strong></p>
<p>enq方法中，节点是尾插法，首先赋值的是尾节点的前驱节点。</p>
<p>此时前驱节点的next并没有指向尾节点，从前向后遍历会丢失尾节点。</p>
</blockquote>
<ul>
<li>唤醒的线程从之前park位置开始，继续在循环中<code>tryAcquire(arg)</code>尝试获取锁，如果成功<ul>
<li>exclusiveOwnerThread为Thread-1，state=1</li>
<li>head指向Thread1所在的Node</li>
<li>原本的head出队，然后被GC垃圾回收（图中有误，原本head的waitState改为0了）</li>
</ul>
</li>
</ul>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/12/13/tf2mdkKNZX69GYu.png" alt="image-20231213121916458"></p>
<ul>
<li>如果有其他线程来竞争，假如此时有Thread-4来抢占了锁<ul>
<li>exclusiveOwnerThread为Thread-4，state=1</li>
<li>Thread-1再次进入acquireQueued流程，获取锁失败，重新进入park阻塞</li>
</ul>
</li>
</ul>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/12/13/PyOlTqZJbdAe89W.png" alt="image-20231213124223536"></p>
<h4 id="公平锁原理"><a href="#公平锁原理" class="headerlink" title="公平锁原理"></a>公平锁原理</h4><p>主要的区别在于tryAcquire方法</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> {</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 先检查AQS队列有没有待唤醒节点，或者待唤醒节点是不是自己，才去竞争</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) {</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractQueuedSynchronizer</span> </span><br><span class="line">    				<span class="keyword">extends</span> <span class="title class_">AbstractOwnableSynchronizer</span> </span><br><span class="line">    				<span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable {</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasQueuedPredecessors</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        Node s;</span><br><span class="line">        <span class="comment">// 1. 头尾指向一个节点，链表为空，返回false</span></span><br><span class="line">        <span class="comment">// 2. 头尾之间有节点，头节点的下一个是不是空</span></span><br><span class="line">        <span class="comment">// 3. 头节点下一个不是空，判断是不是本线程所有</span></span><br><span class="line">        <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">            ((s = h.next) == <span class="literal">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h3><p>如果没有可重入，拥有锁的线程再次加锁，自己也会被挡住，造成死锁</p>
<p>源码解析部分参考之前的：<code>nonfairTryAcquire</code>和<code>tryRelease</code></p>
<ul>
<li>判断ExclusiveOwnerThread是不是自己</li>
<li>计数器增减</li>
</ul>
<blockquote>
<p>加锁一次，解锁两次，程序会直接报错</p>
</blockquote>
<h3 id="可打断"><a href="#可打断" class="headerlink" title="可打断"></a>可打断</h3><p><code>public void lockInterruptibly()</code>：获得可打断的锁</p>
<ul>
<li>如果没有竞争，就会获得lock对象锁</li>
<li>如果有竞争，就进入阻塞队列，但是可以被其他线程用interrupt打断</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {        </span><br><span class="line">    <span class="keyword">try</span> {                </span><br><span class="line">        lock.lockInterruptibly();	<span class="comment">// 尝试获取锁      </span></span><br><span class="line">    } <span class="keyword">catch</span> (InterruptedException e) {                   </span><br><span class="line">        <span class="keyword">return</span>;  					<span class="comment">// 没有获取到锁，在等待队列中被打断，直接返回      </span></span><br><span class="line">    }        </span><br><span class="line">    <span class="keyword">try</span> {            </span><br><span class="line">        <span class="comment">// do sth					// 获取到锁      </span></span><br><span class="line">    } <span class="keyword">finally</span> {            </span><br><span class="line">        lock.unlock();        		<span class="comment">// 最终解锁</span></span><br><span class="line">    }    </span><br><span class="line">});</span><br></pre></td></tr></table></figure></div>

<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><ul>
<li>不可打断模式：即使被打断，任会驻留在AQS队列中，<strong>一直到获得锁之后才能直到自己被打断了</strong><ul>
<li>acquireQueued方法中，用interrupted变量记录了是否被打断过</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))	<span class="comment">// 阻塞等待</span></span><br><span class="line">        <span class="comment">// 如果acquireQueued返回true，打断状态interrupted=true</span></span><br><span class="line">        selfInterrupt();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selfInterrupt</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// 自己被打断了，重新产生一次打断，完成真正的中断效果</span></span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> {</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) {</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>;</span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;			<span class="comment">// 还是要获得锁后，才能返回打断的状态</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())	<span class="comment">// 第二个条件，判断自己是否被打断了</span></span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> {    </span><br><span class="line">    LockSupport.park(<span class="built_in">this</span>);			<span class="comment">// 阻塞当前线程，如果打断标记已经是true, 则 park会失效</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();	<span class="comment">// 返回线程打断状态（且会清除打断标记）</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>可打断模式</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ReentrantLock类方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// AQS类方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();	<span class="comment">// 被打断了直接抛出错误</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))					<span class="comment">// CAS尝试获取锁</span></span><br><span class="line">        doAcquireInterruptibly(arg);		<span class="comment">// 没获取到锁，进入这里</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AQS类方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) {</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>;</span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();	<span class="comment">// 和之前不一样，没有变量记录，如果被中断会直接抛出错误</span></span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);					<span class="comment">// 抛出错误，进入如下逻辑</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AQS类方法</span></span><br><span class="line"><span class="comment">// 将当前节点出队</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cancelAcquire</span><span class="params">(Node node)</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    node.thread = <span class="literal">null</span>;					<span class="comment">// 当前节点的Thread置空</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> node.prev;				<span class="comment">// 获取当前节点前的，第一个没被取消的节点</span></span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">predNext</span> <span class="operator">=</span> pred.next;			<span class="comment">// 获取前驱节点的后继节点（可能是当前node，也可能是某个被取消的节点）</span></span><br><span class="line">    node.waitStatus = Node.CANCELLED;	<span class="comment">// 当前节点状态设置为1</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) {	<span class="comment">// 如果当前节点是尾节点，则将前驱节点设为尾节点</span></span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="literal">null</span>);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="type">int</span> ws;</span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;													 <span class="comment">// 当前节点不是head.next</span></span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||						 <span class="comment">// 前驱节点状态是不是-1</span></span><br><span class="line">             (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp; <span class="comment">// 如果不是-1，前驱节点状态设为-1</span></span><br><span class="line">            pred.thread != <span class="literal">null</span>) {											 <span class="comment">// 前驱节点的线程不为null</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> node.next;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="literal">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)		<span class="comment">// 当前节点的后驱节点是正常节点</span></span><br><span class="line">                compareAndSetNext(pred, predNext, next);	<span class="comment">// 前驱的后继，设为当前节点的后继（队伍删除当前节点）</span></span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            unparkSuccessor(node);							<span class="comment">// 当前节点就是head.next节点，唤醒后继节点</span></span><br><span class="line">        }</span><br><span class="line">        node.next = node;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h3><h4 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h4><p><code>public boolean tryLock()</code>：尝试获取锁，获取到返回 true，获取不到直接返回false</p>
<p><code>public boolean tryLock(long timeout, TimeUnit unit)</code>：在给定时间内获取锁，获取不到返回false</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">if</span> (!lock.tryLock(<span class="number">2</span>, TimeUnit.SECONDS)) {</span><br><span class="line">            System.out.println(<span class="string">"获取锁失败"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">        System.out.println(<span class="string">"被打断，获取不到锁"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// do sth</span></span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        lock.unlock();</span><br><span class="line">    }</span><br><span class="line">});</span><br></pre></td></tr></table></figure></div>



<h4 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ReetrantLock类方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ReetrantLock类方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquireNanos</span><span class="params">(<span class="type">int</span> arg, <span class="type">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="comment">// 先尝试获取一次锁，没获取到进入doAcquireNanos逻辑</span></span><br><span class="line">    <span class="keyword">return</span> tryAcquire(arg) || doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>doAcquireNanos方法，在一定时间内获取锁，获取不到返回false</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// static final long spinForTimeoutThreshold = 1000L;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// AQS类方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">doAcquireNanos</span><span class="params">(<span class="type">int</span> arg, <span class="type">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> System.nanoTime() + nanosTimeout;	<span class="comment">// 计算DDL</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) {</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>;</span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();	<span class="comment">// 计算还需等待的时间</span></span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;								<span class="comment">// 超时还没拿到锁，直接返回false</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                nanosTimeout &gt; spinForTimeoutThreshold)		<span class="comment">// 如果还需等待的时间大于这个值，才有阻塞的意义</span></span><br><span class="line">                											<span class="comment">// 否则自旋好一些</span></span><br><span class="line">                LockSupport.parkNanos(<span class="built_in">this</span>, nanosTimeout);</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())						<span class="comment">// 如果被打断，抛出错误</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><h4 id="基本使用-2"><a href="#基本使用-2" class="headerlink" title="基本使用"></a>基本使用</h4><ul>
<li>synchronized的条件变量：当不满足时进入WaitSet等待</li>
<li>ReentrantLock的条件变量：强大之处在于，支持多个条件变量</li>
</ul>
<p>ReentrantLock类获取Condition变量：<code>public Condition newCondition()</code></p>
<ul>
<li><code>void await()</code>：当前线程进入等待状态，释放锁</li>
<li><code>void signal()</code>：唤醒一个等待在当前Condition上的线程（必须已经获取了当前的锁）</li>
</ul>
<p>使用流程：</p>
<ul>
<li>await / signal前，需要获得锁</li>
<li>await执行后，会释放锁进入ConditionObject等待</li>
<li>await的线程被唤醒后，会重新竞争锁</li>
<li>线程在条件队列中被打断，会抛出异常</li>
<li>竞争lock成功后，从await后继续执行</li>
</ul>
<h4 id="实现原理-2"><a href="#实现原理-2" class="headerlink" title="实现原理"></a>实现原理</h4><h5 id="await"><a href="#await" class="headerlink" title="await"></a>await</h5><p>概括：</p>
<ul>
<li>开始Thread-0持有锁，调用await，线程进入ConditionObject等待，直到被唤醒或打断。如果被唤醒，就转移到AQS阻塞队列，等待获取锁。</li>
</ul>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/12/16/fCmuWolsBhvG1Eb.png" alt="image-20231216172849550" style="zoom:67%;">

<ul>
<li><p>每个Condition都包含一个队列</p>
</li>
<li><p>将await线程包装成node节点，放入ConditionObject的条件队列。</p>
</li>
<li><p>如果被唤醒就将node转移到AQS队列中</p>
</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionObject</span> <span class="keyword">implements</span> <span class="title class_">Condition</span>, java.io.Serializable {</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())					<span class="comment">// 当前线程是中断状态，直接抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();			<span class="comment">// 将调用await的线程包装成Node，添加到条件队列并返回</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);		<span class="comment">// 完全释放锁</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;						<span class="comment">// 设置状态为没有被打断</span></span><br><span class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node)) {				<span class="comment">// 阻塞，直至节点转移至AQS队列</span></span><br><span class="line">            LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">            <span class="comment">// 如果被打断，退出等待队列</span></span><br><span class="line">            <span class="comment">// 对应的node也会迁移至AQS阻塞队列尾部，状态设为0</span></span><br><span class="line">            <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 逻辑到这里，说明当前线程已经进入AQS阻塞队列，且再次被唤醒了</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 尝试获取锁，释放多少锁，就要重新获取多少次锁</span></span><br><span class="line">        <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">            interruptMode = REINTERRUPT;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// node在条件队列时，如果被外部线程中断唤醒，会加入到阻塞队列，但是并未设node.nextWaiter=null</span></span><br><span class="line">        <span class="keyword">if</span> (node.nextWaiter != <span class="literal">null</span>)</span><br><span class="line">            unlinkCancelledWaiters();					<span class="comment">// 清理条件队列内所有已取消的Node</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)							<span class="comment">// 条件成立，说明期间发生过中断</span></span><br><span class="line">            reportInterruptAfterWait(interruptMode);	<span class="comment">// 应用打断模式</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>addConditionWaiter方法：将调用await的线程包装成Node，添加到条件队列并返回</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionObject</span> <span class="keyword">implements</span> <span class="title class_">Condition</span>, java.io.Serializable {</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">addConditionWaiter</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> lastWaiter;									<span class="comment">// 条件队列尾节点</span></span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) {		<span class="comment">// 尾节点不是等待状态</span></span><br><span class="line">            unlinkCancelledWaiters();							<span class="comment">// 清理所有已取消节点</span></span><br><span class="line">            t = lastWaiter;										<span class="comment">// 重新获取尾节点</span></span><br><span class="line">        }</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), Node.CONDITION);	<span class="comment">// 创建节点，状态为等待状态</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">            firstWaiter = node;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            t.nextWaiter = node;</span><br><span class="line">        lastWaiter = node;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从头遍历，清理条件队列中，所有已取消的node（状态不为CONDITION）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlinkCancelledWaiters</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">trail</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (t != <span class="literal">null</span>) {</span><br><span class="line">            <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> t.nextWaiter;</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) {</span><br><span class="line">                t.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (trail == <span class="literal">null</span>)</span><br><span class="line">                    firstWaiter = next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    trail.nextWaiter = next;</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="literal">null</span>)</span><br><span class="line">                    lastWaiter = trail;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                trail = t;</span><br><span class="line">            t = next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>接下来进入AQS的fullyRelease方法，释放同步器上的锁</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AQS类中的方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程可能重入，需要将state全部释放</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">fullyRelease</span><span class="params">(Node node)</span> {</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;				<span class="comment">// 释放锁是否失败</span></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> getState();	<span class="comment">// 获取当前线程持有的state值总数</span></span><br><span class="line">        <span class="keyword">if</span> (release(savedState)) {		<span class="comment">// 解锁重入锁</span></span><br><span class="line">            failed = <span class="literal">false</span>;				<span class="comment">// 释放成功</span></span><br><span class="line">            <span class="keyword">return</span> savedState;			<span class="comment">// 返回解锁的深度</span></span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();	<span class="comment">// 解锁失败抛出异常</span></span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">if</span> (failed)										<span class="comment">// 没有释放成功，将node设为取消状态</span></span><br><span class="line">            node.waitStatus = Node.CANCELLED;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>Thread-0进入isOnSyncQueue(node)逻辑，判断节点是否移动到了阻塞队列中，没有就阻塞Thread-0</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isOnSyncQueue</span><span class="params">(Node node)</span> {</span><br><span class="line">    <span class="comment">// node的状态是CONDITION（-2），或前驱为null，signal方法是先修改状态再迁移，所以前驱节点为空证明还【没有完成迁移】</span></span><br><span class="line">    <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 说明当前节点已经成功入队到阻塞队列，且当前节点后面已经有其它node</span></span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="comment">// 说明【可能在阻塞队列，但是是尾节点】</span></span><br><span class="line">    <span class="comment">// 从阻塞队列的尾节点开始向前【遍历查找 node】，如果查找到返回 true，查找不到返回 false</span></span><br><span class="line">    <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>await线程park后如果被unpark或者被打断，都会进入 checkInterruptWhileWaiting 判断线程是否被打断</li>
<li>在条件队列被打断的线程需要抛出异常</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">checkInterruptWhileWaiting</span><span class="params">(Node node)</span> {</span><br><span class="line">    <span class="comment">// 如果被中断了，根据是否在条件队列被中断的，设置中断状态码</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted() ? (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) : <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果是被中断唤醒的</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">transferAfterCancelledWait</span><span class="params">(Node node)</span> {</span><br><span class="line">    <span class="comment">// 条件成立说明当前node一定是在条件队列内，因为signal迁移节点到阻塞队列时，会将节点的状态修改为0</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>)) {</span><br><span class="line">        enq(node);			<span class="comment">// 把中断唤醒的node，加入到阻塞队列中</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;		<span class="comment">// 表示是在条件队列内被中断了，设置interruptMode为THROW_IE（-1）</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行到这里的情况：</span></span><br><span class="line">    <span class="comment">// 	1.当前node已经被外部线程调用signal方法将其迁移到【阻塞队列】内了</span></span><br><span class="line">    <span class="comment">// 	2.当前node正在被外部线程调用signal方法将其迁移至【阻塞队列】进行中状态</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果当前线程还没到阻塞队列，一直释放 CPU</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node))</span><br><span class="line">        Thread.<span class="keyword">yield</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示当前节点被中断唤醒时不在条件队列了，设置为REINTERRUPT为1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>最后开始处理中断状态</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reportInterruptAfterWait</span><span class="params">(<span class="type">int</span> interruptMode)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    <span class="comment">// 条件成立说明【在条件队列内发生过中断，此时await方法抛出中断异常】</span></span><br><span class="line">    <span class="keyword">if</span> (interruptMode == THROW_IE)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 条件成立说明【在条件队列外发生的中断，此时设置当前线程的中断标记位为true】</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (interruptMode == REINTERRUPT)</span><br><span class="line">        <span class="comment">// 进行一次自己打断，产生中断的效果</span></span><br><span class="line">        selfInterrupt();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h5 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h5><p>fullyRelease中会unpark AQS队列中的下一个节点，来竞争锁，假设Thread-1竞争成功</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/12/16/3bmAF1ClkpNKjXz.png" alt="image-20231216173049012"></p>
<ul>
<li>Thread-1调用signal方法</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())		<span class="comment">// 判断调用signal方法的线程是否是独占锁</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;		<span class="comment">// 获取条件队列中第一个Node</span></span><br><span class="line">    <span class="keyword">if</span> (first != <span class="literal">null</span>)				</span><br><span class="line">        doSignal(first);			<span class="comment">// 不为空，就将该节点迁移至AQS队列</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignal</span><span class="params">(Node first)</span> {</span><br><span class="line">    <span class="keyword">do</span> {</span><br><span class="line">        <span class="comment">// 成立，说明当前节点的下一个节点是null，只剩这一个节点了</span></span><br><span class="line">        <span class="keyword">if</span> ((firstWaiter = first.nextWaiter) == <span class="literal">null</span>)</span><br><span class="line">            lastWaiter = <span class="literal">null</span>;</span><br><span class="line">        first.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 将等待的node转移至AQS队列，不成功且还有节点，则继续循环</span></span><br><span class="line">    } <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp; (first = firstWaiter) != <span class="literal">null</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// signalAll()方法会调这个方法，唤醒所有节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignalAll</span><span class="params">(Node first)</span> {</span><br><span class="line">    lastWaiter = firstWaiter = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">do</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> first.nextWaiter;</span><br><span class="line">        first.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">        transferForSignal(first);</span><br><span class="line">        first = next;</span><br><span class="line">    } <span class="keyword">while</span> (first != <span class="literal">null</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>transferForSignal，将节点加入AQS队列</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">transferForSignal</span><span class="params">(Node node)</span> {</span><br><span class="line">    <span class="comment">// CAS修改状态为0</span></span><br><span class="line">    <span class="comment">// 如果修改失败，说明当前状态不是Node.CONDITION，说明线程被取消（await释放全部锁失败）或者中断了（可打断lock）</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="comment">// 返回false，寻找下一个节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 当前node入阻塞队列，p是前驱节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> enq(node);</span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> p.waitStatus;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果前驱节点被取消，或者不能设置状态为Node.SIGNAL，就unpark阻塞node.thread，直到它被唤醒</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/12/17/mCczFWEhwjue2lg.png" alt="image-20231217112524497" style="zoom:67%;">

<h3 id="哲学家就餐"><a href="#哲学家就餐" class="headerlink" title="哲学家就餐"></a>哲学家就餐</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main7</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        <span class="type">Chopstick</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">"1"</span>);</span><br><span class="line">        <span class="type">Chopstick</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">"2"</span>);</span><br><span class="line">        <span class="type">Chopstick</span> <span class="variable">c3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">"3"</span>);</span><br><span class="line">        <span class="type">Chopstick</span> <span class="variable">c4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">"4"</span>);</span><br><span class="line">        <span class="type">Chopstick</span> <span class="variable">c5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">"5"</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">"苏格拉底"</span>, c1, c2).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">"柏拉图"</span>, c2, c3).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">"亚里士多德"</span>, c3, c4).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">"赫拉克利特"</span>, c4, c5).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">"阿基米德"</span>, c5, c1).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Philosopher</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Chopstick left;</span><br><span class="line">    <span class="keyword">private</span> Chopstick right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Philosopher</span><span class="params">(String name, Chopstick left, Chopstick right)</span> {</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">            <span class="keyword">if</span> (left.tryLock()) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="keyword">if</span> (right.tryLock()) {</span><br><span class="line">                        <span class="keyword">try</span> {</span><br><span class="line">                            System.out.println(name + <span class="string">" eating"</span>);</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        } <span class="keyword">finally</span> {</span><br><span class="line">                            right.unlock();</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    left.unlock();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chopstick</span> <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span> {</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Chopstick</span><span class="params">(String name)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h2><ul>
<li>独占锁：只能被一个线程持有</li>
<li>共享锁：可以被多个线程持有</li>
</ul>
<p>ReentrantReadWriteLock：读锁是共享锁，写锁是独占锁</p>
<h3 id="基本使用-3"><a href="#基本使用-3" class="headerlink" title="基本使用"></a>基本使用</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">r.lock();</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">} <span class="keyword">finally</span> {</span><br><span class="line">	r.unlock();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>【读-读】能共存，【读-写】不能共存，【写-写】不能共存</li>
<li>读锁不支持条件变量</li>
<li>不支持重入升级。原本获取了读锁，不能重入写锁（不然获取写锁会永久等待）</li>
<li>支持重入降级。原本获取了写锁，支持重入获取读锁（造成当前线程只持有读锁）</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">w.lock();</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    r.lock();		<span class="comment">// 降级为读锁, 释放写锁, 这样能够让其它线程读取缓存</span></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        			<span class="comment">// 临界区</span></span><br><span class="line">    } <span class="keyword">finally</span>{</span><br><span class="line">    	r.unlock();	<span class="comment">// 要在写锁释放之前获取读锁</span></span><br><span class="line">    }</span><br><span class="line">} <span class="keyword">finally</span>{</span><br><span class="line">	w.unlock();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>构造方法：</p>
<ul>
<li><code>public ReentrantReadWriteLock()</code>：默认构造方法，非公平锁</li>
<li><code>public ReentrantReadWriteLock(boolean fair)</code>：true 为公平锁</li>
</ul>
<p>常用API：</p>
<ul>
<li><code>public ReentrantReadWriteLock.ReadLock readLock()</code>：返回读锁</li>
<li><code>public ReentrantReadWriteLock.WriteLock writeLock()</code>：返回写锁</li>
<li><code>public void lock()</code>：加锁</li>
<li><code>public void unlock()</code>：解锁</li>
<li><code>public boolean tryLock()</code>：尝试获取锁</li>
</ul>
<h3 id="缓存应用"><a href="#缓存应用" class="headerlink" title="缓存应用"></a>缓存应用</h3><p>缓存更新时，应该先清缓存，还是先更新数据库</p>
<ul>
<li>先清缓存：线程直接从数据库查到了旧数据</li>
<li>先更新数据库：线程可能从缓存中拿到了旧数据</li>
</ul>
<p>可以用读写锁进行操作</p>
<h3 id="成员属性"><a href="#成员属性" class="headerlink" title="成员属性"></a>成员属性</h3><p>读写锁公用一个Sync同步器，等待队列，state也是同一个。原理和ReetrantLock没什么区别，只是写状态占state的低16位，读状态占state的高16位</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantReadWriteLock</span> <span class="keyword">implements</span> <span class="title class_">ReadWriteLock</span>, java.io.Serializable {</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> Sync sync;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReentrantReadWriteLock</span><span class="params">(<span class="type">boolean</span> fair)</span> {</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">        readerLock = <span class="keyword">new</span> <span class="title class_">ReadLock</span>(<span class="built_in">this</span>);</span><br><span class="line">        writerLock = <span class="keyword">new</span> <span class="title class_">WriteLock</span>(<span class="built_in">this</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p><strong>Sync类的属性：</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> {</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHARED_SHIFT</span>   <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHARED_UNIT</span>    <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);		<span class="comment">// 高16位的1（的单位）</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_COUNT</span>      <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;	<span class="comment">// 16个1，65535，表示最大重入次数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">EXCLUSIVE_MASK</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;	<span class="comment">// 掩码，低位16个1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读锁分配总次数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sharedCount</span><span class="params">(<span class="type">int</span> c)</span>    { <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 写锁分配总次数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">exclusiveCount</span><span class="params">(<span class="type">int</span> c)</span> { <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用于记录读线程自己持有的读锁的次数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">HoldCounter</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">tid</span> <span class="operator">=</span> getThreadId(Thread.currentThread());</span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 线程安全的存放线程各自的HoldCounter对象</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalHoldCounter</span> <span class="keyword">extends</span> <span class="title class_">ThreadLocal</span>&lt;HoldCounter&gt; {</span><br><span class="line">        <span class="keyword">public</span> HoldCounter <span class="title function_">initialValue</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HoldCounter</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 内部类实例：</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HoldCounter cachedHoldCounter;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ThreadLocalHoldCounter readHolds;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 首次获取锁：</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">Thread</span> <span class="variable">firstReader</span> <span class="operator">=</span> <span class="literal">null</span>;	<span class="comment">// 第一个获取读锁的线程</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> firstReaderHoldCount;		<span class="comment">// 记录该线程持有的读锁次数（读重入次数）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造方法：</span></span><br><span class="line">    Sync() {</span><br><span class="line">        readHolds = <span class="keyword">new</span> <span class="title class_">ThreadLocalHoldCounter</span>();</span><br><span class="line">        setState(getState());						<span class="comment">// AQS中，state是volatile修饰的</span></span><br><span class="line">        											<span class="comment">// 重写该值，可以将线程本地缓存写到主内存，确保对其他线程可见性</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="加锁原理"><a href="#加锁原理" class="headerlink" title="加锁原理"></a>加锁原理</h3><h4 id="写锁加锁"><a href="#写锁加锁" class="headerlink" title="写锁加锁"></a>写锁加锁</h4><ul>
<li>t1线程：w.lock（写锁），成功加锁state=0_1</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ReentrantReadWriteLock类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> {</span><br><span class="line">    sync.acquire(<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// AQS类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>大体和ReetrantLock一致，最大的变动与state有关</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sync内部类</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> {</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> exclusiveCount(c);	<span class="comment">// 低16位（写锁）</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) {				<span class="comment">// 不为0，说明有写锁或者读锁</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())	<span class="comment">// 有读锁，所以不能升级，直接false</span></span><br><span class="line">            												<span class="comment">// 有写锁，且不是自己，直接false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)		<span class="comment">// 写锁重入，如果数量超了，报错</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(c + acquires);								<span class="comment">// 写锁重入成功，没有并发，所以不需要CAS</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行到这里，说明没有任何锁</span></span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() ||								<span class="comment">// 判断是否需要阻止获取锁（主要为了公平锁而设置）</span></span><br><span class="line">        !compareAndSetState(c, c + acquires))				<span class="comment">// 尝试获取锁</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;										<span class="comment">// 失败返回false</span></span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NonfairSync类</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">writerShouldBlock</span><span class="params">()</span> {		<span class="comment">// 非公平锁writerShouldBlock总是false, 无需阻塞</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FairSync类</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">writerShouldBlock</span><span class="params">()</span> {		<span class="comment">// 公平锁会检查AQS队列中是否有前驱节点, 没有才去竞争</span></span><br><span class="line">    <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="读锁加锁"><a href="#读锁加锁" class="headerlink" title="读锁加锁"></a>读锁加锁</h4><ul>
<li>t2线程：r.lock（读锁）</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ReentrantReadWriteLock类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> {</span><br><span class="line">    sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// AQS类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireShared</span><span class="params">(<span class="type">int</span> arg)</span> {</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>tryAcquireShared尝试获取共享锁，负数表示失败</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sync内部类</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> unused)</span> {</span><br><span class="line">           </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;				<span class="comment">// 低16位（写锁）有人持有</span></span><br><span class="line">        getExclusiveOwnerThread() != current)	<span class="comment">// 写锁的持有者也不是自己</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;								<span class="comment">// 返回失败						</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> sharedCount(c);						<span class="comment">// 高16位，读锁分配出去的总次数</span></span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;					<span class="comment">// 判断是否需要阻止获取锁（主要为了公平锁而设置）</span></span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;						<span class="comment">// 锁总数有没有超</span></span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) {		<span class="comment">// CAS增加锁计数</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) {									<span class="comment">// 以下加锁成功，如果这是第一个加锁成功的</span></span><br><span class="line">            firstReader = current;						</span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) {			<span class="comment">// 第一个加锁成功的就是自己，然后发生了锁重入</span></span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="type">HoldCounter</span> <span class="variable">rh</span> <span class="operator">=</span> cachedHoldCounter;			<span class="comment">// cachedHoldCounter对象（最后一个获取读锁的线程设置的）</span></span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="literal">null</span> || rh.tid != getThreadId(current))	<span class="comment">// cachedHoldCounter（为null，或者不是自己的）</span></span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();		<span class="comment">// 重写过initialValue方法，第一次这里会创建</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)						</span><br><span class="line">                readHolds.set(rh);						<span class="comment">// 计数为0，加入到readHolds中</span></span><br><span class="line">            rh.count++;									<span class="comment">// 重入+1</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);	<span class="comment">// 逻辑到这里，说明应当阻止获取锁，或者CAS加锁失败</span></span><br><span class="line">    										<span class="comment">// 会不断尝试 for (;;) 获取读锁, 执行过程中无阻塞</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NonfairSync：偏向写锁一些，若AQS中第一个节点是写锁，则不应该尝试获取锁，返回false</span></span><br><span class="line"><span class="comment">// 防止一直有读线程，让写线程饿死</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">readerShouldBlock</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FairSync：等待队列有，则阻止获取锁</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">readerShouldBlock</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>fullTryAcquireShared真正不断获取共享锁</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ReentrantReadWriteLock类</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">fullTryAcquireShared</span><span class="params">(Thread current)</span> {</span><br><span class="line">           </span><br><span class="line">    <span class="type">HoldCounter</span> <span class="variable">rh</span> <span class="operator">=</span> <span class="literal">null</span>;						<span class="comment">// 记录当前线程持有的读锁次数</span></span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) {			<span class="comment">// 说明持有写锁，要是不是自己持有的写锁，直接返回失败</span></span><br><span class="line">            <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) {		<span class="comment">// 同之前一样，判断是否应当阻止获取锁</span></span><br><span class="line">            <span class="keyword">if</span> (firstReader == current) {</span><br><span class="line">                <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="literal">null</span>) {</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="literal">null</span> || rh.tid != getThreadId(current)) {</span><br><span class="line">                        rh = readHolds.get();</span><br><span class="line">                        <span class="keyword">if</span> (rh.count == <span class="number">0</span>)		<span class="comment">// 如果条件成立，说明HoldCounter对象是上一步代码新建的</span></span><br><span class="line">                            					<span class="comment">// 当前线程不是锁重入，在readerShouldBlock返回true时，需要去排队</span></span><br><span class="line">                            readHolds.remove();	<span class="comment">// 防止内存泄露</span></span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;					<span class="comment">// 返回失败</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)					<span class="comment">// 越界判断</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) {		<span class="comment">// 读锁加锁，条件内的逻辑和tryAcquireShared相同</span></span><br><span class="line">            <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) {</span><br><span class="line">                firstReader = current;</span><br><span class="line">                firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) {</span><br><span class="line">                firstReaderHoldCount++;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="literal">null</span>)</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="literal">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                    rh = readHolds.get();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    readHolds.set(rh);</span><br><span class="line">                rh.count++;</span><br><span class="line">                cachedHoldCounter = rh;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>获取读锁失败，进入sync.doAcquireShared(1)流程开始阻塞</li>
<li>首先也是调用addWaiter添加节点。不过，节点被设置为Node.SHARED模式，而非Node.EXCLUSIVE模式</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AQS类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span> {</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();		<span class="comment">// 获取前驱节点</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) {						<span class="comment">// 前驱节点是头节点，就尝试获取锁</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) {</span><br><span class="line">                    setHeadAndPropagate(node, r);	<span class="comment">// 获取成功，将自己设为头节点，唤醒后续连续的共享节点</span></span><br><span class="line">                    p.next = <span class="literal">null</span>; 					<span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;	<span class="comment">// 是否在获取读锁失败后阻塞</span></span><br><span class="line">                parkAndCheckInterrupt())					<span class="comment">// park当前线程</span></span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>t2线程：当前节点设为头节点</li>
<li>检查下一个节点是否是shared，是则将head状态从-1改为0，并唤醒下一个节点。<ul>
<li>t3将恢复运行，唤醒下一个…</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AQS类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setHeadAndPropagate</span><span class="params">(Node node, <span class="type">int</span> propagate)</span> {</span><br><span class="line">    <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">    setHead(node);	<span class="comment">// 自己设为头节点</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// propagate 表示有共享资源（例如共享读锁或信号量），为0就没有资源</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span> ||	</span><br><span class="line">        (h = head) == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;					<span class="comment">// 获取下一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.isShared())		<span class="comment">// 如果当前是最后一个节点，或下一个节点是等待共享锁的节点</span></span><br><span class="line">            doReleaseShared();				<span class="comment">// 唤醒连续的后继所有共享节点</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>doReleaseShared，唤醒连续的，后续所有共享节点</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> {</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) {</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))	<span class="comment">// 读锁是共享的，防止其他线程也在释放锁</span></span><br><span class="line">                    												<span class="comment">// CAS将state改为0，才能unpark</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;										<span class="comment">// 如果已经是0了，改为-3，来解决传播性</span></span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="comment">// 上一步已经将waitState改为0了</span></span><br><span class="line">                <span class="comment">// 万一刚好有一个节点入队，把这个ws设为-1了，所以需要重新循环</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (h == head)	</span><br><span class="line">            <span class="comment">// 唤醒后继节点之后，后继节点没有更换头节点才会退出</span></span><br><span class="line">            <span class="comment">// 在唤醒到队列尾之后头节点将不再改变，才可以结束</span></span><br><span class="line">            <span class="comment">// 会产生一个唤醒的风暴，前面的线程都在唤醒后面的线程</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>如果获取锁没有成功，在doAcquireShared内:</p>
<ul>
<li><p>for循环一次，shouldParkAfterFailedAcquire内把前驱节点的waitStatus改为-1</p>
</li>
<li><p>再for循环一次,尝试tryAcquireShared，不成功就在parkAndCheckInterrupt()处park</p>
</li>
</ul>
</li>
</ul>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/12/17/nkDdfECNQFwUua3.png" alt="image-20231217231852527" style="zoom: 67%;">

<ul>
<li>假如后面又有t3，t4来获取读锁，就变成下面这样了</li>
</ul>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/12/17/8ozqrS2F7kDwcLn.png" alt="image-20231217231940862" style="zoom: 67%;">

<h3 id="解锁原理"><a href="#解锁原理" class="headerlink" title="解锁原理"></a>解锁原理</h3><h4 id="写锁解锁"><a href="#写锁解锁" class="headerlink" title="写锁解锁"></a>写锁解锁</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ReentrantReadWriteLock类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> {</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// AQS类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> {</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) {					<span class="comment">// 尝试释放锁</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)	<span class="comment">// 头节点不为空，且状态不为0，唤醒后继非取消节点</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sync类</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> exclusiveCount(nextc) == <span class="number">0</span>;	<span class="comment">// 因为可重入的原因，计数为0才算释放成功</span></span><br><span class="line">    <span class="keyword">if</span> (free)</span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">    setState(nextc);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="读锁解锁"><a href="#读锁解锁" class="headerlink" title="读锁解锁"></a>读锁解锁</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ReentrantReadWriteLock类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> {</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// AQS类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> {</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) {</span><br><span class="line">        doReleaseShared();	<span class="comment">// 将头节点从-1改为0，并唤醒下一个节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sync类</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> unused)</span> {</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="keyword">if</span> (firstReader == current) {</span><br><span class="line">        <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">            firstReader = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            firstReaderHoldCount--;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="type">HoldCounter</span> <span class="variable">rh</span> <span class="operator">=</span> cachedHoldCounter;</span><br><span class="line">        <span class="keyword">if</span> (rh == <span class="literal">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">            rh = readHolds.get();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> rh.count;</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) {</span><br><span class="line">            readHolds.remove();</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">        }</span><br><span class="line">        --rh.count;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c - SHARED_UNIT;</span><br><span class="line">        <span class="comment">// 读锁的计数不会影响其他读锁进程，但会影响写锁进程，计数为0才是真正的释放</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h2><p>读写锁，JDK8加入，进一步优化读性能</p>
<p>特点：</p>
<ul>
<li>使用读锁、写锁时都必须配合戳使用</li>
<li>不支持条件变量</li>
<li>不支持重入</li>
</ul>
<h3 id="基本使用-4"><a href="#基本使用-4" class="headerlink" title="基本使用"></a>基本使用</h3><ul>
<li>加解读锁</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StampedLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line"><span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.readLock();</span><br><span class="line"></span><br><span class="line">lock.unlockRead(stamp);			<span class="comment">// 类似unpark，解指定的锁</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>加解写锁</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StampedLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line"><span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line"></span><br><span class="line">lock.unlockWrite(stamp);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>乐观锁，可以进行戳校验。通过，则表示期间没有写操作，数据可以安全使用；没通过，需要重新获取读锁</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StampedLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.tryOptimisticRead();</span><br><span class="line"><span class="keyword">if</span> (!lock.validate(stamp)) {</span><br><span class="line">    <span class="comment">// 锁升级</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="优化代码"><a href="#优化代码" class="headerlink" title="优化代码"></a>优化代码</h3><ul>
<li>依靠乐观锁优化</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">StampedLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.tryOptimisticRead();</span><br><span class="line">    <span class="comment">// 戳有效，直接返回数据</span></span><br><span class="line">    <span class="keyword">if</span> (lock.validate(stamp)) {</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 说明其他线程更改了戳，需要锁升级了，从乐观读升级到读锁</span></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        stamp = lock.readLock();</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        lock.unlockRead(stamp);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> val)</span> {</span><br><span class="line">    <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        data = val;</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        lock.unlockWrite(stamp);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><h3 id="基本使用-5"><a href="#基本使用-5" class="headerlink" title="基本使用"></a>基本使用</h3><p>计数器，用来进行线程同步协作</p>
<p>构造器：</p>
<ul>
<li><code>public CountDownLatch(int count)</code>：唤醒需要几步</li>
</ul>
<p>常用API：</p>
<ul>
<li><code>public void await() </code>：让当前线程等待</li>
<li><code>public void countDown()</code>：计数器减1</li>
</ul>
<p>应用：同步多个远程调用结束（比如LOL游戏，10个人都准备好了才能开始）</p>
<h3 id="实现原理-3"><a href="#实现原理-3" class="headerlink" title="实现原理"></a>实现原理</h3><p>共享锁，解锁一次state减1。减到0后唤醒所有阻塞的节点。</p>
<h4 id="阻塞等待"><a href="#阻塞等待" class="headerlink" title="阻塞等待"></a>阻塞等待</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CountDownLatch类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// AQS类，之前有讲过</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>tryAcquireShared方法，在CountDownLatch中的Sync内部类</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sync类</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> {</span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>doAcquireSharedInterruptibly方法，之前也讲过，阻塞挂起</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AQS类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) {						<span class="comment">// 前驱节点是头节点，就可以尝试获取锁</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) {</span><br><span class="line">                    setHeadAndPropagate(node, r);	<span class="comment">// 获取锁成功，将当前节点设为head，并向后传播</span></span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())			<span class="comment">// 阻塞在这里</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">if</span> (failed)									<span class="comment">// 阻塞线程被中断，抛出异常，进入取消节点的逻辑</span></span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>setHeadAndPropagate方法，会唤醒后继节点</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AQS类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setHeadAndPropagate</span><span class="params">(Node node, <span class="type">int</span> propagate)</span> {</span><br><span class="line">    <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">    setHead(node);	<span class="comment">// 当前节点设为head，前驱节点和持有线程设为null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span> || (h = head) == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;				<span class="comment">// 获取后继节点</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.isShared())	<span class="comment">// 当前节点是尾节点，或者后继节点是共享模式</span></span><br><span class="line">            doReleaseShared();			<span class="comment">// 唤醒所有等待共享锁的节点</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="计数减一"><a href="#计数减一" class="headerlink" title="计数减一"></a>计数减一</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CountDownLatch类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countDown</span><span class="params">()</span> {</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// AQS类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> {</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) {	<span class="comment">// 尝试释放共享锁</span></span><br><span class="line">        doReleaseShared();			<span class="comment">// 释放锁成功，唤醒阻塞节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>tryReleaseShared尝试释放锁</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sync内部类</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> {</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)							<span class="comment">// 说明前面已经有线程触发唤醒操作了，返回false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c-<span class="number">1</span>;					<span class="comment">// 计数器减1</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))	<span class="comment">// 自旋CAS</span></span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;				<span class="comment">// 计数器减为0，返回true</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>state等于0，执行doReleaseShared方法，唤醒阻塞的节点</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> {</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) {	<span class="comment">// 队列不为空</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) {	<span class="comment">// 头节点状态为signal（-1），说明后续有待唤醒节点</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;			<span class="comment">// CAS自旋，将其waitState改为0</span></span><br><span class="line">                unparkSuccessor(h);		<span class="comment">// 唤醒后继节点</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp; !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// 读锁解锁部分，有解释过这个问题，此处略过</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// 读锁解锁部分，有解释过这个问题，此处略过</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><h3 id="基本使用-6"><a href="#基本使用-6" class="headerlink" title="基本使用"></a>基本使用</h3><ul>
<li>循环屏障，线程到达这个屏障时会被阻塞；所有线程都到了，触发自己运行一个任务；运行完成后，屏障开门，被拦截的线程又可以继续运行</li>
</ul>
<p>常用方法：</p>
<ul>
<li><code>public CyclicBarrier(int parties, Runnable barrierAction)</code>：用于在线程到达屏障时，执行barrierAction<ul>
<li>parties：代表多少个线程到达屏障开始触发线程任务</li>
<li>barrierAction：线程任务</li>
</ul>
</li>
<li><code>public int await()</code>：线程通知CyclicBarrier本线程已经到达屏障</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">3</span>, () -&gt; {</span><br><span class="line">    System.out.println(<span class="string">"finish"</span>);</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) {</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            cyclicBarrier.await();</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        }</span><br><span class="line">    }).start();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="实现原理-4"><a href="#实现原理-4" class="headerlink" title="实现原理"></a>实现原理</h3><h4 id="成员属性-1"><a href="#成员属性-1" class="headerlink" title="成员属性"></a>成员属性</h4><ul>
<li>全局锁：利用可重入锁实现的工具类</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">trip</span> <span class="operator">=</span> lock.newCondition();	<span class="comment">// 挂起是基于Condition的</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>线程数量</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> parties;				<span class="comment">// 有多少个线程到达屏障</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;	<span class="comment">// 还有多少线程未到位，初始值为parties</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>最后一个线程到位后，需要执行的事件</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>代</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Generation</span> {</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">broken</span> <span class="operator">=</span> <span class="literal">false</span>;							<span class="comment">// 表示当前“代”是否被打破</span></span><br><span class="line">}    												<span class="comment">// 如果被打破，再来到这一代的线程直接抛出异常</span></span><br><span class="line">    												<span class="comment">// 且这一代挂起的线程都会被唤醒，然后抛出异常</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">Generation</span> <span class="variable">generation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Generation</span>();	<span class="comment">// 表示barrier对象，当前代</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>构造方法</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties, Runnable barrierAction)</span> {</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();	<span class="comment">// 小于等于0就没有意义了</span></span><br><span class="line">    <span class="built_in">this</span>.parties = partie</span><br><span class="line">    <span class="built_in">this</span>.count = parties;</span><br><span class="line">    <span class="built_in">this</span>.barrierCommand = barrierAction;					<span class="comment">// 可以为null</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h4><ul>
<li>await方法，阻塞等待所有线程到位</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CyclicBarrier类</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="literal">false</span>, <span class="number">0L</span>);</span><br><span class="line">    } <span class="keyword">catch</span> (TimeoutException toe) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(toe); <span class="comment">// cannot happen</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>dowait方法</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CyclicBarrier类</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dowait</span><span class="params">(<span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span> </span><br><span class="line">    	<span class="keyword">throws</span> InterruptedException, BrokenBarrierException, TimeoutException {</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();									<span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Generation</span> <span class="variable">g</span> <span class="operator">=</span> generation;			<span class="comment">// 获取当前代</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (g.broken)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BrokenBarrierException</span>();		<span class="comment">// 如果当前代已经被打破，直接抛出异常</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) {					<span class="comment">// 如果线程被中断了，打破当前代，然后抛出异常</span></span><br><span class="line">            breakBarrier();							<span class="comment">// broken=true；count=parties；唤醒条件队列中所有线程</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> --count;						<span class="comment">// 假设数量为5，index则为4，3，2，1，0</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) {							<span class="comment">// 条件成立，说明是最后一个到达的线程</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">ranAction</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">command</span> <span class="operator">=</span> barrierCommand;</span><br><span class="line">                <span class="keyword">if</span> (command != <span class="literal">null</span>)</span><br><span class="line">                    command.run();					<span class="comment">// 执行触发的任务</span></span><br><span class="line">                ranAction = <span class="literal">true</span>;</span><br><span class="line">                nextGeneration();					<span class="comment">// 开启新的一代，这里会唤醒所有阻塞线程</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                <span class="keyword">if</span> (!ranAction)						<span class="comment">// 如果执行command异常的话，会进入这里</span></span><br><span class="line">                    breakBarrier();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 自旋，一直到：条件满足；当前代被打破；线程被中断；等待超时</span></span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="keyword">if</span> (!timed)								<span class="comment">// 如果：不需要超时等待</span></span><br><span class="line">                    trip.await();						<span class="comment">// 当前线程释放掉锁，进入trip条件队列挂起自己，等待被唤醒</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)					<span class="comment">// 如果：需要超时等待</span></span><br><span class="line">                    nanos = trip.awaitNanos(nanos);		<span class="comment">// 使用能超时等待的await</span></span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException ie) {</span><br><span class="line">                										<span class="comment">// 被中断后，来到这里</span></span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) {	<span class="comment">// 当前代没有变化，且没有被打破</span></span><br><span class="line">                    breakBarrier();						<span class="comment">// 打破屏障</span></span><br><span class="line">                    <span class="keyword">throw</span> ie;							<span class="comment">// 抛出错误（以便后面finally中unlock）</span></span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    Thread.currentThread().interrupt();	<span class="comment">// 等待中，代变化了，自我打断</span></span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g.broken)								<span class="comment">// 唤醒后的线程，发现当前代被打破了，抛出异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BrokenBarrierException</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g != generation)						<span class="comment">// 线程挂起期间，最后一个线程到位了，触发了开启新一代的逻辑</span></span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) {					<span class="comment">// 等待超时，当前线程主动转移到阻塞队列</span></span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TimeoutException</span>();			<span class="comment">// 抛出超时异常</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        lock.unlock();									<span class="comment">// 解锁</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>breakBarrier()：打破Barrier屏障</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">breakBarrier</span><span class="params">()</span> {</span><br><span class="line">    generation.broken = <span class="literal">true</span>;	<span class="comment">// 表示这一代被打破了，再来到这一代的线程直接抛出错误</span></span><br><span class="line">    count = parties;			<span class="comment">// 重置count</span></span><br><span class="line">    trip.signalAll();			<span class="comment">// 唤醒trip条件队列中所有线程</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>nextGeneration()：开启新的一代</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">nextGeneration</span><span class="params">()</span> {</span><br><span class="line">    trip.signalAll();				<span class="comment">// 唤醒trip条件队列中所有线程</span></span><br><span class="line">    count = parties;				<span class="comment">// 重置count</span></span><br><span class="line">    generation = <span class="keyword">new</span> <span class="title class_">Generation</span>();	<span class="comment">// 开启新的一代</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><h3 id="基本使用-7"><a href="#基本使用-7" class="headerlink" title="基本使用"></a>基本使用</h3><ul>
<li><p>synchronized可以起到锁的作用，但是某个时间段内只能有一个线程允许执行</p>
</li>
<li><p>Semaphore（信号量）可以用来限制【能同时访问共享资源的线程上限】</p>
</li>
<li><p>它是非重入锁</p>
</li>
</ul>
<p>构造方法：</p>
<ul>
<li><code>public Semaphore(int permits)</code>：permits 表示许可线程的数量（state）</li>
<li><code>public Semaphore(int permits, boolean fair)</code>：fair 表示公平性，如果设为 true，下次执行的线程会是等待最久的线程</li>
</ul>
<p>常用API：</p>
<ul>
<li><code>public void acquire()</code>：表示获取许可</li>
<li><code>public void release()</code>：表示释放许可，acquire() 和 release() 方法之间的代码为同步代码</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) {</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            semaphore.acquire();</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            semaphore.release();</span><br><span class="line">        }</span><br><span class="line">    }).start();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="实现原理-5"><a href="#实现原理-5" class="headerlink" title="实现原理"></a>实现原理</h3><h4 id="获取锁"><a href="#获取锁" class="headerlink" title="获取锁"></a>获取锁</h4><ul>
<li>Semaphore的state设为3，假设有5个线程来获取资源</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Semaphore类</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>)</span> {</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(<span class="keyword">permits</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// NonfairSync内部类</span></span><br><span class="line">NonfairSync(<span class="type">int</span> <span class="keyword">permits</span>) {</span><br><span class="line">    <span class="built_in">super</span>(<span class="keyword">permits</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sync内部类</span></span><br><span class="line">Sync(<span class="type">int</span> <span class="keyword">permits</span>) {</span><br><span class="line">    setState(<span class="keyword">permits</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>acquire获取资源</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Semaphore类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// AQS类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)			<span class="comment">// 尝试获取通信证</span></span><br><span class="line">        doAcquireSharedInterruptibly(arg);	<span class="comment">// 进入阻塞</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>tryAcquireShared尝试获取许可</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NonfairSync类</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> {</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// NonfairSync类</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">nonfairTryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> {</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">available</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="type">int</span> <span class="variable">remaining</span> <span class="operator">=</span> available - acquires;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||							<span class="comment">// 剩余state不足直接返回false</span></span><br><span class="line">            compareAndSetState(available, remaining))	<span class="comment">// 如果剩余state大于0，CAS尝试更改，返回是否成功</span></span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>doAcquireSharedInterruptibly带阻塞的获取许可</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AQS类，和之前一样，不赘述了</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) {</span><br><span class="line">                    setHeadAndPropagate(node, r);	<span class="comment">// 将自己设为头，并唤醒后继节点</span></span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h4><ul>
<li>release用于释放锁</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Semaphore类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span> {</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// AQS类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> {</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) {</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sync类</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> {</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> getState();					<span class="comment">// 当前可用资源数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current + releases;</span><br><span class="line">        <span class="keyword">if</span> (next &lt; current)							<span class="comment">// 防止越界</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">"Maximum permit count exceeded"</span>);</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(current, next))		<span class="comment">// 释放锁</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AQS类，之前有讲过，不赘述</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) {</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 设置Node.PROPAGATE的原因之前也讲过，不赘述</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (h == head)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h2><p>用于线程间数据交换</p>
<p>工作流程：</p>
<ul>
<li>两个线程通过exchange方法交换数据</li>
<li>一个线程先到达exchange方法，他会一直等待第二个线程也执行exchange方法。</li>
<li>当两个线程都到达同步点时，两个线程就可以交换数据。</li>
</ul>
<p>常用API：</p>
<ul>
<li><code>public Exchanger()</code>：创建一个新的交换器</li>
<li><code>public V exchange(V x)</code>：等待另一个线程到达此交换点</li>
<li><code>public V exchange(V x, long timeout, TimeUnit unit)</code>：等待一定的时间</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Exchanger&lt;String&gt; exchanger = <span class="keyword">new</span> <span class="title class_">Exchanger</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> exchanger.exchange(<span class="string">"我是A发的消息"</span>);</span><br><span class="line">        System.out.println(<span class="string">"A收到消息："</span> + s);</span><br><span class="line">    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    }</span><br><span class="line">}).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> exchanger.exchange(<span class="string">"我是B发的消息"</span>);</span><br><span class="line">        System.out.println(<span class="string">"B收到消息："</span> + s);</span><br><span class="line">    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    }</span><br><span class="line">}).start();</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>juc</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC系列：（三）同步</title>
    <url>//post/4016/</url>
    <content><![CDATA[<h2 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h2><p>临界资源：一次仅允许一个进程使用的资源</p>
<p>临界区：访问临界资源的代码块</p>
<p>竞态条件：多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测</p>
<p>避免临界区竞态条件发生：</p>
<ul>
<li>阻塞式：synchronized，lock</li>
<li>非阻塞式：原子变量</li>
</ul>
<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><h3 id="使用锁完成同步"><a href="#使用锁完成同步" class="headerlink" title="使用锁完成同步"></a>使用锁完成同步</h3><p>synchronized是可重入、不公平的重量级锁</p>
<p><strong>同步代码块：</strong></p>
<ul>
<li>锁对象建议使用共享资源</li>
<li>实例方法使用：this</li>
<li>静态方法使用：类名.class</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(锁对象){</span><br><span class="line">	<span class="comment">// 访问共享资源的核心代码</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p><strong>同步方法：</strong></p>
<ul>
<li><p>synchronized修饰的方法的不具备继承性，所以子类是线程不安全的</p>
<ul>
<li>如果子类的方法也被synchronized修饰，两个锁对象其实是一把锁，而且是<strong>子类对象作为锁</strong></li>
</ul>
</li>
<li><p>实例方法：默认用，this作为的锁对象</p>
</li>
<li><p>静态方法：默认用，类名 .class作为的锁对象</p>
</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同步方法</span></span><br><span class="line">修饰符 <span class="keyword">synchronized</span> 返回值类型 方法名(方法参数) { </span><br><span class="line">	方法体；</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 同步静态方法</span></span><br><span class="line">修饰符 <span class="keyword">static</span> <span class="keyword">synchronized</span> 返回值类型 方法名(方法参数) { </span><br><span class="line">	方法体；</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="锁原理"><a href="#锁原理" class="headerlink" title="锁原理"></a>锁原理</h3><ul>
<li>每个 Java 对象都可以关联一个Monitor对象（Monitor也是class，实例存储在堆中）</li>
<li>如果使用synchronized给对象上锁，对象头的Mark World指向Monitor对象（重量级锁）</li>
<li>Mark Word结构如下（最后两位是锁标志位）</li>
</ul>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/12/04/waGxJmrc8kpDeYW.png" alt="image-20231204193333591" style="zoom: 67%;">

<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/12/04/j4WOHuyvwUYKTA8.png" alt="image-20231204193342067" style="zoom:67%;">

<p><strong>工作流程：</strong></p>
<ol>
<li>开始时，Monitor中，Owner为空</li>
<li>当Thread-1执行synchronized时<ul>
<li>将Monitor的Owner设为Thread-2</li>
<li>obj对象的Mark Word指向Monitor</li>
<li>obj对象原有的Mark Word存入线程栈中的锁记录中（轻量级锁部分有讲）</li>
</ul>
</li>
<li>在Thread-1上锁的过程中，后续执行synchronized的线程，会进入EntryList中（BLOCKED状态）</li>
<li>在Thread-1执行完同步代码后，根据obj对象头找到Monitor<ul>
<li>将Monitor的Owner设为空</li>
<li>obj对象的Mark Word还原</li>
</ul>
</li>
<li>唤醒EntryList中等待的线程来竞争</li>
<li>WaitSet中的Thread，是之前获得过锁，但条件不满足进入WAITING状态的线程（wait-notify机制）</li>
</ol>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/12/04/OAT2ZoIcVGiUqDt.png" alt="image-20231204200257780" style="zoom: 67%;">

<p><strong>字节码：</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncTest</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">syncBlock</span><span class="params">()</span>{</span><br><span class="line">        <span class="comment">// 代码块</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>){</span><br><span class="line">            System.out.println(<span class="string">"hello block"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方法上加synchronized</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">syncMethod</span><span class="params">()</span>{</span><br><span class="line">        System.out.println(<span class="string">"hello method"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"> <span class="comment"># syncBlock()方法</span></span><br><span class="line"> 0 aload_0</span><br><span class="line"> 1 dup</span><br><span class="line"> 2 astore_1</span><br><span class="line"> 3 monitorenter				<span class="comment"># monitorenter指令进入同步块</span></span><br><span class="line"> 4 getstatic 				<span class="comment">#7 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;</span></span><br><span class="line"> 7 ldc						<span class="comment">#23 &lt;hello block&gt;</span></span><br><span class="line"> 9 invokevirtual			<span class="comment">#17 &lt;java/io/PrintStream.println : (Ljava/lang/String;)V&gt;</span></span><br><span class="line">12 aload_1</span><br><span class="line">13 monitorexit				<span class="comment"># monitorexit指令退出同步块（正常退出）</span></span><br><span class="line">14 goto 22 (+8)</span><br><span class="line">17 astore_2</span><br><span class="line">18 aload_1</span><br><span class="line">19 monitorexit				<span class="comment"># monitorexit指令退出同步块（异常也能退出；异常表中有写，出现异常会跳到17）</span></span><br><span class="line">20 aload_2</span><br><span class="line">21 athrow</span><br><span class="line">22 <span class="built_in">return</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># syncMethod()函数</span></span><br><span class="line">public synchronized void c();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (0x0021) ACC_PUBLIC, ACC_SYNCHRONIZED	<span class="comment"># 标记了ACC_SYNCHRONIZED，底层还是monitor实现的</span></span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: getstatic     <span class="comment">#7                  // Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">         3: ldc           <span class="comment">#25                 // String hello method</span></span><br><span class="line">         5: invokevirtual <span class="comment">#17                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">         8: <span class="built_in">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 29: 0</span><br><span class="line">        line 30: 8</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       9     0  this   Lorg/example/Test;</span><br></pre></td></tr></table></figure></div>

<h3 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h3><p>synchronized是可重入、不公平的<strong>重量级锁</strong>，可以进行优化</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁	// 随着竞争增加，只能锁升级，不能降级</span><br></pre></td></tr></table></figure></div>

<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>意义：偏向于第一个获取锁的线程，之后重新获取该锁不再需要同步操作</p>
<ul>
<li>锁对象第一次被获取时，obj对象的Mark Word末尾标记为101；使用CAS操作，将线程ID记录到Mark Word中</li>
<li>以后这个线程进入同步块，如果线程ID还是自己的，证明没有竞争，就不再需要任何同步操作</li>
<li>一旦另一个线程尝试获取锁对象，偏向状态就宣告结束，Mark Word恢复到未锁定或者轻量级锁状态</li>
</ul>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/12/04/j4WOHuyvwUYKTA8.png" alt="image-20231204193342067" style="zoom:67%;">

<p><strong>对象创建时：</strong></p>
<ul>
<li><p>默认开启偏向锁，对象创建后，Mark Word后三位为101，thread，epoch，age都为0</p>
</li>
<li><p>JDK8默认延迟4s开启偏向锁（避免刚开始，好多线程都来抢锁）</p>
<ul>
<li><code>-XX:BiasedLockingStartupDelay=0</code> 设置延迟时间</li>
<li><code>-XX:-UseBiasedLocking</code> 禁用偏向锁</li>
</ul>
</li>
<li><p>如果一个对象计算过hashCode，就再也无法进入偏向状态了</p>
</li>
</ul>
<p><strong>撤销偏向锁的状态：</strong></p>
<ul>
<li>调用对象的hashCode方法（偏向锁对象的Mark Word存储的是线程ID，调用hashCode将导致偏向锁被撤销）</li>
<li>其他线程尝试获取锁，偏向锁升级为轻量锁</li>
<li>偏向锁状态执行obj.notify()会升级为轻量级锁</li>
<li>调用obj.wait()会升级为重量级锁</li>
</ul>
<p><strong>批量重偏向：</strong></p>
<ul>
<li><p>为了解决：一个线程创建大量对象并执行同步操作，另一个线程将这些对象作为锁对象进行操作，导致大量的偏向锁撤销操作</p>
</li>
<li><p>具体方法：</p>
<ul>
<li>以class为单位，维护一个偏向锁撤销计数器，每一次该class的对象发生偏向锁撤销时，该计数器+1</li>
<li>当计数器值达到阈值（默认20），JVM认为该class偏向锁有问题，进行批量重偏向</li>
</ul>
</li>
</ul>
<p><strong>批量撤销：</strong></p>
<ul>
<li>应用场景：在明显多线程竞争剧烈的场景下，使用偏向锁是不合适的</li>
<li>具体方法：<ul>
<li>当计数器值达到阈值（默认40），JVM就认为该class的使用场景存在多线程竞争，会标记该class为不可偏向</li>
<li>之后对于该class的锁，直接走轻量级锁的逻辑</li>
</ul>
</li>
</ul>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>意义：一个对象有多个线程要加锁，但加锁的时间是错开的（没有竞争），可以使用轻量级锁来优化</p>
<p><strong>进入同步代码块时：</strong></p>
<ul>
<li>如果锁对象为无锁状态，JVM在当前线程的栈中创建一个锁记录（Lock Record），存储锁对象的Mark Word拷贝</li>
</ul>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/12/04/5jA7RzrLT9fDOtB.png" alt="image-20231204211443069" style="zoom: 67%;">

<p><strong>加锁时：</strong></p>
<ul>
<li>当前线程使用CAS操作，把当前线程对象Mark Word的锁标志为“00”</li>
<li>如果CAS成功，Mark Word中的指针指向栈中的锁对象，锁对象中的指针指向Mark Word</li>
</ul>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/12/04/cS1WMFubpQ2Hgn7.png" alt="image-20231204211605472" style="zoom:67%;">

<ul>
<li>如果CAS失败，有两种情况<ul>
<li>其他线程已经持有该轻量级锁，表明有竞争，进入锁膨胀过程</li>
<li>线程自己执行了锁重入，就加一条Lock Record作为重入的计数</li>
</ul>
</li>
</ul>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/12/04/NvSdoeMPCyHJiAU.png" alt="image-20231204211641711" style="zoom:67%;">

<p><strong>解锁时：</strong></p>
<ul>
<li>如果有取值为null的锁记录，表示有重入，这时重置锁记录，表示重入计数减1</li>
<li>如果锁记录的值不为null，使用 CAS 将 Mark Word 的值恢复给对象头<ul>
<li>成功，则解锁成功</li>
<li>失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</li>
</ul>
</li>
</ul>
<h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>在尝试加轻量级锁的过程中，CAS 操作无法成功。可能是其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁</p>
<ul>
<li>当Thread-1进行轻量级加锁时，Thread-0已经对该对象加了轻量级锁了（有竞争）</li>
</ul>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/12/04/Ta8c6K9RmuANlpC.png" alt="image-20231204212805898" style="zoom:67%;">

<ul>
<li>Thread-1加锁失败，进入锁膨胀流程</li>
<li>为锁对象申请Monitor锁</li>
<li>通过对象头获取到持锁线程，将Monitor的Owner置为Thread-0，将对象头指向重量级锁地址</li>
<li>自己进入Monitor的EntryList（BLOCKED状态）</li>
</ul>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/12/04/59xLkA1O8uhISgD.png" alt="image-20231204213052498" style="zoom:67%;">

<ul>
<li>当Thread-0退出同步块解锁时，使用CAS将Mark Word的值恢复给对象头失败<ul>
<li>这时进入重量级解锁流程，即按照Monitor地址找到Monitor对象，设置Owner为 null，唤醒EntryList中BLOCKED线程</li>
</ul>
</li>
</ul>
<h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>重量级锁竞争时，尝试获取锁的线程不会立即阻塞，可以使用自旋（默认10次）来进行优化</p>
<p><strong>注意事项：</strong></p>
<ul>
<li><p>单核CPU自旋就是浪费时间，多核才有意义</p>
</li>
<li><p>自旋失败后进入阻塞状态</p>
</li>
<li><p>JDK7之后不能控制是否开启自旋功能，由 JVM控制</p>
</li>
</ul>
<p><strong>手动模拟自旋锁：</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpinLock</span> {</span><br><span class="line">    AtomicReference&lt;Thread&gt; atomicReference = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">while</span> (!atomicReference.compareAndSet(<span class="literal">null</span>, thread)) {</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> {</span><br><span class="line">		atomicReference.compareAndSet(thread, <span class="literal">null</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>JVM的JIT编译器的优化。通过逃逸分析来支持。如果堆上的共享数据不可能逃逸出去被其它线程访问到，可以将它们的锁进行消除</p>
<h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>如果虚拟机探测到一串的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部</p>
<ul>
<li>看似没有锁，其实有很多锁</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">concatString</span><span class="params">(String s1, String s2, String s3)</span> {</span><br><span class="line">    <span class="keyword">return</span> s1 + s2 + s3;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>StringBuffer的append方法是synchronized修饰的</li>
<li>扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，只需要加锁一次就可以</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">concatString</span><span class="params">(String s1, String s2, String s3)</span> {</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    sb.append(s3);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="多把锁"><a href="#多把锁" class="headerlink" title="多把锁"></a>多把锁</h3><p>将锁的粒度细化：</p>
<ul>
<li>好处，可以增强并发度</li>
<li>坏处，容易发生死锁</li>
</ul>
<h3 id="活跃性"><a href="#活跃性" class="headerlink" title="活跃性"></a>活跃性</h3><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p><strong>四个必要条件：</strong></p>
<ol>
<li>互斥</li>
<li>不可剥夺</li>
<li>请求与保持</li>
<li>循环等待</li>
</ol>
<p>打破任意一个都可以破坏死锁</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">    <span class="keyword">synchronized</span>(resources1){</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (resources2){</span><br><span class="line">            System.out.println(<span class="string">"Thread-1 do sth"</span>);</span><br><span class="line">        }</span><br><span class="line">}).start();</span><br><span class="line">    </span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">    <span class="keyword">synchronized</span>(resources2){</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (resources1){</span><br><span class="line">            System.out.println(<span class="string">"Thread-2 do sth"</span>);</span><br><span class="line">        }</span><br><span class="line">    }}</span><br><span class="line">}).start();</span><br></pre></td></tr></table></figure></div>

<p><strong>定位死锁的方法：</strong></p>
<ul>
<li>使用jps定位进程ID，再用 <code>jstack 进程ID</code> 定位死锁，找到死锁的线程去查看源码，解决优化</li>
</ul>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">C:\Users\xdy&gt;jps</span><br><span class="line">67392 Jps</span><br><span class="line">24836</span><br><span class="line">43272</span><br><span class="line">63688 RemoteMavenServer36</span><br><span class="line">69448 Main2</span><br><span class="line">54684 Launcher</span><br><span class="line"></span><br><span class="line">C:\Users\xdy&gt;jstack 69448</span><br></pre></td></tr></table></figure></div>

<ul>
<li>Linux下，可以通过top定位到CPU占用高的Java进程。再利用<code>top -Hp 进程ID</code>定位是哪个线程。最后用<code>jstack 进程ID</code>查看这个线程的线程栈</li>
</ul>
<p><strong>避免死锁：</strong></p>
<ul>
<li>注意加锁的顺序</li>
</ul>
<h4 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h4><p>两个线程并没有被阻塞，但是互相改变，最后谁也没法结束</p>
<ul>
<li>比如一个线程++，另一个–</li>
</ul>
<h4 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h4><p>一个线程优先级太低，一直得不到CPU调度执行</p>
<h2 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait-notify"></a>wait-notify</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>需要获取对象锁后才可以调用 <code>obj.wait()</code>，notify随机唤醒一个线程，notifyAll唤醒所有线程去竞争CPU</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Object类API</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span>		<span class="comment">// 唤醒正在等待对象监视器的单个线程。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span>	<span class="comment">// 唤醒正在等待对象监视器的所有线程。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span>		<span class="comment">// 导致当前线程等待，直到另一个线程调用该对象的 notify() 方法或 notifyAll()方法。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span>	<span class="comment">// 有时限的等待, 到n毫秒后结束等待，或是被唤醒</span></span><br></pre></td></tr></table></figure></div>

<p><strong>对比Thread.sleep:</strong></p>
<ul>
<li><code>Thread.sleep()</code>用来控制自己，暂停一段时间，将执行机会让给别的线程；<code>obj.wait()</code>用于线程间通信</li>
<li><code>Thread.sleep()</code>不会释放锁；<code>obj.wait()</code>会放弃对象锁</li>
<li><code>Thread.sleep()</code>可以在任何地方用；<code>obj.wait()</code>必须在同步代码中用（先获取锁）</li>
</ul>
<h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/12/05/dZ73xjowIVe9mqz.png" alt="image-20231205154745911" style="zoom: 67%;">

<ol>
<li><p>调用wait方法，线程即可进入WaitSet变为WAITING状态</p>
</li>
<li><p>BLOCKED和WAITING的线程都处于阻塞状态，不占用CPU时间</p>
<ul>
<li><p>BLOCKED线程会在Owner线程释放锁时唤醒</p>
</li>
<li><p>WAITING线程会在Owner线程调用notify或notifyAll时唤醒，进入EntryList重新竞争</p>
</li>
</ul>
</li>
</ol>
<h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><p>问题：虚假唤醒，notify只能随机唤醒WaitSet中的一个线程，可能无法唤醒正确的线程</p>
<p>解决方法：采用notifyAll，使用while + wait保证能执行</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (room) {</span><br><span class="line">    <span class="keyword">while</span> (!condition) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            room.wait();</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// do sth</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="park-unpark"><a href="#park-unpark" class="headerlink" title="park-unpark"></a>park-unpark</h2><h3 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h3><p>LockSupport类方法：</p>
<ul>
<li><code>LockSupport.park()</code>：挂起原语，暂停当前线程</li>
<li><code>LockSupport.unpark(暂停的线程对象)</code>：恢复某个线程的运行</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先park再unpark；先unpark再park，最终结果是一样的，都能恢复线程的运行</span></span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    System.out.println(<span class="string">"park..."</span>);</span><br><span class="line">    LockSupport.park();</span><br><span class="line">    System.out.println(<span class="string">"resume..."</span>);</span><br><span class="line">},<span class="string">"t1"</span>);</span><br><span class="line"></span><br><span class="line">t1.start();</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">LockSupport.unpark(t1);</span><br></pre></td></tr></table></figure></div>

<h3 id="出现原因"><a href="#出现原因" class="headerlink" title="出现原因"></a>出现原因</h3><p>LockSupport出现就是为了增强wait-notify的功能：</p>
<ul>
<li>wait-notify必须配合Object Monitor一起使用，而 park-unpark 不需要</li>
<li>park-unpark以线程为单位来阻塞和唤醒线程，而notify只能随机唤醒一个等待线程，notifyAll是唤醒所有等待线程</li>
<li>park-unpark可以先unpark，wait-notify不能先notify</li>
<li>wait会释放锁资源，park不会释放锁资源，只会阻塞当前线程释放CPU</li>
</ul>
<h3 id="底层原理-1"><a href="#底层原理-1" class="headerlink" title="底层原理"></a>底层原理</h3><p>类似生产者消费者</p>
<p><strong>如果先park：</strong></p>
<ol>
<li><p>当前线程调用<code>Unsafe.park()</code>方法</p>
<ul>
<li><p>检查<code>_counter</code>（当前为0），此时获得<code>_mutex</code>互斥锁</p>
</li>
<li><p>线程进入<code>_cond</code>条件变量，挂起</p>
</li>
</ul>
</li>
<li><p>其他地方调用<code>Unsafe.unpark(thread0)</code>方法</p>
<ul>
<li><p>设置_counter为1</p>
</li>
<li><p>唤醒<code>_cond</code>条件变量中的Thread-0，Thread-0恢复运行</p>
</li>
<li><p>设置_counter为0</p>
</li>
</ul>
</li>
</ol>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/12/05/8ZMxeCBD9djql4s.png" alt="image-20231205201445173">

<p><strong>如果先unpark：</strong></p>
<ol>
<li>其他地方调用<code>Unsafe.unpark(thread0)</code>方法<ul>
<li>设置_counter为1</li>
</ul>
</li>
<li>当前线程调用<code>Unsafe.park()</code>方法<ul>
<li>检查<code>_counter</code>（当前为1），无需挂起，继续运行</li>
<li>设置_counter为0</li>
</ul>
</li>
</ol>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/12/05/wj6Ieabt3Hdv92K.png" alt="image-20231205201454512">

<h2 id="安全分析"><a href="#安全分析" class="headerlink" title="安全分析"></a>安全分析</h2><ul>
<li><p>线程安全：多个线程调用同一个实例的方法时，是线程安全的</p>
</li>
<li><p>即使每个方法是原子的，但多个方法的组合不是原子的，只能保证调用的方法内部安全：</p>
</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Hashtable</span> <span class="variable">table</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程1，线程2</span></span><br><span class="line"><span class="keyword">if</span> (table.get(<span class="string">"key"</span>) == <span class="literal">null</span>) {</span><br><span class="line">	table.put(<span class="string">"key"</span>, value);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>常见线程安全类：<code>String</code>，<code>Integer</code>，<code>StringBuffer</code>，<code>Random</code>，<code>Vector</code>，<code>Hashtable</code>，<code>java.util.concurrent</code>包<ul>
<li><code>String</code>，<code>Integer</code> 等都是不可变类，内部的状态不可以改变，所以方法是线程安全</li>
<li>replace等方法底层是新建一个对象，复制过去</li>
</ul>
</li>
</ul>
<h2 id="同步模式"><a href="#同步模式" class="headerlink" title="同步模式"></a>同步模式</h2><h3 id="保护性暂停"><a href="#保护性暂停" class="headerlink" title="保护性暂停"></a>保护性暂停</h3><p><strong>单任务版：</strong></p>
<p>Guarded Suspension，用在一个线程等待另一个线程的执行结果</p>
<ul>
<li>有一个结果需要从一个线程传递到另一个线程，让它们关联同一个<code>GuardedObject</code></li>
<li>join的实现、Future的实现，采用的就是此模式</li>
<li>注意，由于虚假唤醒，我们需要使用while将wait包裹起来</li>
</ul>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/12/05/CPEX3xAaFwUGKyS.png" alt="image-20231205210005209" style="zoom:67%;">

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GuardedObject</span> {</span><br><span class="line">    <span class="keyword">private</span> Object response;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(<span class="type">long</span> millis)</span> {</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) {</span><br><span class="line">            <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            <span class="type">long</span> <span class="variable">timePassed</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (response == <span class="literal">null</span>) {</span><br><span class="line">                <span class="type">long</span> <span class="variable">waitTime</span> <span class="operator">=</span> millis - timePassed;</span><br><span class="line">                <span class="keyword">if</span> (waitTime &lt;= <span class="number">0</span>) {</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    lock.wait(waitTime);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">                timePassed = System.currentTimeMillis() - begin;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">complete</span><span class="params">(Object response)</span> {</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) {</span><br><span class="line">            <span class="built_in">this</span>.response = response;</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">GuardedObject</span> <span class="variable">guard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GuardedObject</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    guard.complete(<span class="string">"123"</span>);</span><br><span class="line"></span><br><span class="line">}).start();</span><br><span class="line"></span><br><span class="line"><span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> guard.get(<span class="number">2000</span>);	<span class="comment">// 阻塞获取object的值，最多等待2000毫秒</span></span><br></pre></td></tr></table></figure></div>

<p><strong>多任务版：</strong></p>
<ul>
<li>其实就是给每个guard一个id，并且将所有gurad保存在一个Map中</li>
</ul>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/12/06/VItCTwHZSR4ixv2.png" alt="image-20231206165809904" style="zoom:67%;">

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mailboxes</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer, GuardedObject&gt; boxes = <span class="keyword">new</span> <span class="title class_">Hashtable</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//产生唯一的id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">generateId</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> id++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GuardedObject <span class="title function_">getGuardedObject</span><span class="params">(<span class="type">int</span> id)</span> {</span><br><span class="line">        <span class="keyword">return</span> boxes.remove(id);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GuardedObject <span class="title function_">createGuardedObject</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">GuardedObject</span> <span class="variable">go</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GuardedObject</span>(generateId());</span><br><span class="line">        boxes.put(go.getId(), go);</span><br><span class="line">        <span class="keyword">return</span> go;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Integer&gt; <span class="title function_">getIds</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> boxes.keySet();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GuardedObject</span> {</span><br><span class="line">    <span class="comment">// getter，setter，构造函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他代码和之前一样</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">        <span class="type">GuardedObject</span> <span class="variable">guardedObject</span> <span class="operator">=</span> Mailboxes.createGuardedObject();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> guardedObject.get(<span class="number">10000</span>);</span><br><span class="line">        System.out.println(<span class="string">"object = "</span> + object);</span><br><span class="line">    }).start();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Integer id : Mailboxes.getIds()) {</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">finalId</span> <span class="operator">=</span> id;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">        <span class="type">GuardedObject</span> <span class="variable">guard</span> <span class="operator">=</span> Mailboxes.getGuardedObject(finalId);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        guard.complete(<span class="string">"hello"</span> + finalId);</span><br><span class="line">    }).start();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="顺序输出"><a href="#顺序输出" class="headerlink" title="顺序输出"></a>顺序输出</h3><ul>
<li><p>顺序输出2，1，2，1（也有可能多个2连在一起）</p>
</li>
<li><p>t2给t1发放许可（多次连续调用unpark只会发放一个许可）</p>
</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        LockSupport.park();</span><br><span class="line">        System.out.println(<span class="string">"1"</span>);</span><br><span class="line">    }</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        System.out.println(<span class="string">"2"</span>);</span><br><span class="line">        LockSupport.unpark(t1);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure></div>

<h3 id="交替输出"><a href="#交替输出" class="headerlink" title="交替输出"></a>交替输出</h3><ul>
<li>暂时略过</li>
</ul>
<h2 id="异步模式"><a href="#异步模式" class="headerlink" title="异步模式"></a>异步模式</h2><ul>
<li>暂时略过</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>juc</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC系列：（六）线程池</title>
    <url>//post/11329/</url>
    <content><![CDATA[<h2 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h2><p>线程池作用：<strong>线程复用</strong></p>
<ul>
<li>降低资源消耗：减少了创建和销毁线程的次数</li>
<li>提高响应速度：任务到达，如果有线程可以直接用</li>
<li>提高可管理性：使用线程池可以进行统一的分配，管理</li>
</ul>
<h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>阻塞队列的实现（<code>java.util.concurrent.BlockingQueue</code>接口）：</p>
<ul>
<li><code>ArrayBlockQueue</code>：数组结构，有界阻塞队列</li>
<li><code>LinkedBlockingQueue</code>：链表结构，无界阻塞队列（有界，默认大小<code>Integer.MAX_VALUE</code>）</li>
<li><code>PriorityBlockQueue</code>：支持优先级排序的，无界阻塞队列</li>
<li><code>DelayedWorkQueue</code>：使用优先级队列实现的，延迟无界阻塞队列</li>
<li><code>SynchronousQueue</code>：不存储元素的阻塞队列，每一个生产线程会阻塞到有一个put的线程放入元素为止</li>
<li><code>LinkedTransferQueue</code>：链表结构，无界阻塞队列</li>
<li><code>LinkedBlockingDeque</code>：链表结构，双向阻塞队列</li>
</ul>
<p>阻塞队列：</p>
<ul>
<li>阻塞添加<code>put()</code>：队列已满时，添加元素的线程会被阻塞</li>
<li>阻塞删除<code>take()</code>：队列为空时，删除元素的线程会被阻塞</li>
</ul>
<h3 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h3><table>
<thead>
<tr>
<th>方法类型</th>
<th>抛出异常</th>
<th>特殊值（boolean或者null）</th>
<th>阻塞</th>
<th>超时（抛出错误）</th>
</tr>
</thead>
<tbody><tr>
<td>插入（尾）</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e,time,unit)</td>
</tr>
<tr>
<td>移除（头）</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(time,unit)</td>
</tr>
<tr>
<td>检查（队首元素）</td>
<td>element()</td>
<td>peek()</td>
<td>不可用</td>
<td>不可用</td>
</tr>
</tbody></table>
<h3 id="链表阻塞队列"><a href="#链表阻塞队列" class="headerlink" title="链表阻塞队列"></a>链表阻塞队列</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedBlockingQueue</span>&lt;E&gt; </span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractQueue</span>&lt;E&gt; </span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">BlockingQueue</span>&lt;E&gt;, java.io.Serializable {</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; {</span><br><span class="line">        E item;</span><br><span class="line">        <span class="comment">// 真正的后继节点</span></span><br><span class="line">        <span class="comment">// null，表示队尾</span></span><br><span class="line">        <span class="comment">// 自己，发生在出队时</span></span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        Node(E x) { item = x; }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="入队出队"><a href="#入队出队" class="headerlink" title="入队出队"></a>入队出队</h4><ul>
<li>有一个Dummy节点用来占位，item为null</li>
</ul>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/12/12/Jh4oZpkV9UujBdg.png" alt="image-20231212195823591"></p>
<ul>
<li>初始化链表，<code>last = head = new Node&lt;E&gt;(null)</code></li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedBlockingQueue</span><span class="params">(<span class="type">int</span> capacity)</span> {</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    last = head = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(<span class="literal">null</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>节点入队（尾节点入队），<code>last = last.next = node</code></li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(Node&lt;E&gt; node)</span> {</span><br><span class="line">    last = last.next = node;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>节点出队（头节点出队）</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> E <span class="title function_">dequeue</span><span class="params">()</span> {</span><br><span class="line">    Node&lt;E&gt; h = head;</span><br><span class="line">    Node&lt;E&gt; first = h.next;		<span class="comment">// 头节点的后继节点</span></span><br><span class="line">    h.next = h;					<span class="comment">// 旧头节点GC</span></span><br><span class="line">    head = first;				<span class="comment">// 设置新的头节点</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> first.item;			<span class="comment">// 返回的值</span></span><br><span class="line">    first.item = <span class="literal">null</span>;			<span class="comment">// 当前head节点变为Dummy节点</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/12/12/x2PObXwSkBfMpR7.png" alt="image-20231212200606216" style="zoom: 67%;">

<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/12/12/9LCDTNU7OjPwJQx.png" alt="image-20231212200611933" style="zoom:67%;">

<blockquote>
<p>总结：无论如何，head节点总是Dummy节点（item为null）</p>
</blockquote>
<h4 id="加锁分析"><a href="#加锁分析" class="headerlink" title="加锁分析"></a>加锁分析</h4><p>用了两把锁 + dummy节点</p>
<p><strong>线程安全分析：</strong></p>
<ul>
<li>节点总数大于2时（包括dummy节点），<code>putLock</code>保证last节点的线程安全，<code>takeLock</code>保证head节点的安全</li>
<li>节点总数等于2时（一个dummy节点，一个正常节点），仍然是两把锁，不会竞争</li>
<li>节点总数等于1时（一个dummy节点），take线程被<code>noEmpty</code>条件阻塞，有竞争，会阻塞</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于put（阻塞），没满才能put</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notFull</span> <span class="operator">=</span> putLock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于take（阻塞），不为空才能take</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notEmpty</span> <span class="operator">=</span> takeLock.newCondition();</span><br></pre></td></tr></table></figure></div>

<h5 id="put入队"><a href="#put入队" class="headerlink" title="put入队"></a>put入队</h5><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LinkedBlockingQueue类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();	<span class="comment">// 空指针异常</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(e);						<span class="comment">// 把待添加元素封装为node节点</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="built_in">this</span>.putLock;			<span class="comment">// 获取全局putLock</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.count;				<span class="comment">// count维护元素计数</span></span><br><span class="line">    putLock.lockInterruptibly();						<span class="comment">// putLock加锁</span></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) {</span><br><span class="line">            notFull.await();							<span class="comment">// 队满了等待</span></span><br><span class="line">        }</span><br><span class="line">        enqueue(node);									<span class="comment">// 有空位，尾插法入队</span></span><br><span class="line">        c = count.getAndIncrement();					<span class="comment">// count自增</span></span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();							<span class="comment">// put完，发现队列还有空位，唤醒一个其他put线程</span></span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        putLock.unlock();								<span class="comment">// putLock解锁</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();								<span class="comment">// 自增前是0，说明生产了一个元素，唤醒一个take线程</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LinkedBlockingQueue类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">signalNotEmpty</span><span class="params">()</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="built_in">this</span>.takeLock;</span><br><span class="line">    takeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        notEmpty.signal();	<span class="comment">// 调用signal而不是signalAll，是为了减少竞争</span></span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h5 id="take出队"><a href="#take出队" class="headerlink" title="take出队"></a>take出队</h5><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    E x;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.count;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="built_in">this</span>.takeLock;</span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) {</span><br><span class="line">            notEmpty.await();			<span class="comment">// 没有元素可以出队，则阻塞</span></span><br><span class="line">        }</span><br><span class="line">        x = dequeue();					<span class="comment">// 出队</span></span><br><span class="line">        c = count.getAndDecrement();	<span class="comment">// count自减</span></span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">            notEmpty.signal();			<span class="comment">// 如果队列还有元素，唤醒一个take线程</span></span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        takeLock.unlock();				<span class="comment">// takeLock解锁</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();				<span class="comment">// 自减前是满的，说明消费了一个元素，唤醒一个put线程</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">signalNotFull</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="built_in">this</span>.putLock;</span><br><span class="line">    putLock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        notFull.signal();</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="同步阻塞队列"><a href="#同步阻塞队列" class="headerlink" title="同步阻塞队列"></a>同步阻塞队列</h3><p><code>SynchronousQueue</code> 是一个不存储元素的<code>BlockingQueue</code>，<strong>每一个生产者必须阻塞匹配到一个消费者</strong></p>
<h4 id="成员属性"><a href="#成员属性" class="headerlink" title="成员属性"></a>成员属性</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronousQueue</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractQueue</span>&lt;E&gt; {</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前平台CPU数量</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NCPUS</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指定超时时间，当前线程最大自旋数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">maxTimedSpins</span> <span class="operator">=</span> (NCPUS &lt; <span class="number">2</span>) ? <span class="number">0</span> : <span class="number">32</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 未指定超时时间，当前线程最大自旋数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">maxUntimedSpins</span> <span class="operator">=</span> maxTimedSpins * <span class="number">16</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指定超时限制的阈值，小于该值的线程不会被挂起</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">spinForTimeoutThreshold</span> <span class="operator">=</span> <span class="number">1000L</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>转换器</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Transferer&lt;E&gt; transferer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Transferer</span>&lt;E&gt; {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 参数一：可以为null，表示这个是一个REQUEST类型的请求；反之是一个DATA类型的请求</span></span><br><span class="line"><span class="comment">    * 参数二：true表示指定了超时时间；false表示不支持超时，会一直阻塞到匹配或者被打断</span></span><br><span class="line"><span class="comment">    * 参数三：超时时间限制，单位是纳秒</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * 返回值：返回值不为null，表示匹配成功。DATA类型的请求，会返回当前线程put的数据。</span></span><br><span class="line"><span class="comment">    *		 返回值为null，表示请求超时或者被中断。</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="keyword">abstract</span> E <span class="title function_">transfer</span><span class="params">(E e, <span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>构造方法</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">SynchronousQueue</span><span class="params">(<span class="type">boolean</span> fair)</span> {</span><br><span class="line">    <span class="comment">// 非公平同步队列：TransferStack</span></span><br><span class="line">    <span class="comment">// 公平同步队列：TransferQueue</span></span><br><span class="line">    transferer = fair ? <span class="keyword">new</span> <span class="title class_">TransferQueue</span>&lt;E&gt;() : <span class="keyword">new</span> <span class="title class_">TransferStack</span>&lt;E&gt;();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>成员方法</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> {</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="keyword">return</span> transferer.transfer(e, <span class="literal">true</span>, <span class="number">0</span>) != <span class="literal">null</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> transferer.transfer(<span class="literal">null</span>, <span class="literal">true</span>, <span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="非公平（TransferStack）"><a href="#非公平（TransferStack）" class="headerlink" title="非公平（TransferStack）"></a>非公平（TransferStack）</h4><p><code>TransferStack</code>是非公平同步队列</p>
<p>所有请求都被压入栈中，栈顶元素最先匹配，栈底元素存在饥饿的问题</p>
<h5 id="TransferStack类成员变量"><a href="#TransferStack类成员变量" class="headerlink" title="TransferStack类成员变量"></a>TransferStack类成员变量</h5><ul>
<li>请求类型</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">REQUEST</span>    <span class="operator">=</span> <span class="number">0</span>;	<span class="comment">// 表示Node类型为请求类型</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DATA</span>       <span class="operator">=</span> <span class="number">1</span>;	<span class="comment">// 表示Node类型为数据类型</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">FULFILLING</span> <span class="operator">=</span> <span class="number">2</span>;	<span class="comment">// 表示Node类型为匹配中类型</span></span><br><span class="line">									<span class="comment">// 假如栈顶元素为REQUEST，当前请求类型为DATA，入栈会修改为FULFILLING</span></span><br><span class="line">									<span class="comment">// 假如栈顶元素为DATA，当前请求类型为REQUEST，入栈会修改为FULFILLING</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>栈顶元素</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> SNode head;</span><br></pre></td></tr></table></figure></div>

<h5 id="SNode内部类"><a href="#SNode内部类" class="headerlink" title="SNode内部类"></a>SNode内部类</h5><ul>
<li>成员变量</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SNode</span> {</span><br><span class="line">    <span class="keyword">volatile</span> SNode next;        <span class="comment">// 下一个栈帧</span></span><br><span class="line">    <span class="keyword">volatile</span> SNode match;       <span class="comment">// 与当前node匹配的节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread waiter;     <span class="comment">// 挂起前，需要保存线程引用，以便唤醒</span></span><br><span class="line">    Object item;                <span class="comment">// 数据域，不为null表示请求类型为DATA；为null表示请求类型为REQUEST</span></span><br><span class="line">    <span class="type">int</span> mode;					<span class="comment">// 表示当前Node的模式【REQUEST / DATA / FULFILLING】</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>构造方法</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">SNode(Object item) {</span><br><span class="line">    <span class="built_in">this</span>.item = item;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>设置方法：设置Node对象的next字段，此处使用了CAS</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">casNext</span><span class="params">(SNode cmp, SNode val)</span> {</span><br><span class="line">    <span class="comment">// cmp != next，就已经不需要CAS了</span></span><br><span class="line">    <span class="comment">// cmp == next，开始CAS修改Node对象的next字段</span></span><br><span class="line">    <span class="keyword">return</span> cmp == next &amp;&amp; UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, nextOffset, cmp, val);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>匹配方法：为当前Node匹配一个其他Node</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">tryMatch</span><span class="params">(SNode s)</span> {</span><br><span class="line">    <span class="comment">// 当前match为null，使用CAS设置match字段为s</span></span><br><span class="line">    <span class="keyword">if</span> (match == <span class="literal">null</span> &amp;&amp; UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, matchOffset, <span class="literal">null</span>, s)) {</span><br><span class="line">        </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">w</span> <span class="operator">=</span> waiter;			<span class="comment">// 匹配上了，会获取当前Node对应的线程</span></span><br><span class="line">        <span class="keyword">if</span> (w != <span class="literal">null</span>) {			<span class="comment">// 条件成立，说明Node对应，Thread正在阻塞</span></span><br><span class="line">            waiter = <span class="literal">null</span>;</span><br><span class="line">            LockSupport.unpark(w);	<span class="comment">// 使用unpark方式唤醒线程</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> match == s;				<span class="comment">// 匹配成功返回true</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>取消方法：取消节点</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">tryCancel</span><span class="params">()</span> {</span><br><span class="line">    UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, matchOffset, <span class="literal">null</span>, <span class="built_in">this</span>);		<span class="comment">// 通过CAS将match指向自己，表示取消</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> match == <span class="built_in">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h5 id="TransferStack类成员方法"><a href="#TransferStack类成员方法" class="headerlink" title="TransferStack类成员方法"></a>TransferStack类成员方法</h5><ul>
<li>snode方法：填充节点方法</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> SNode <span class="title function_">snode</span><span class="params">(SNode s, Object e, SNode next, <span class="type">int</span> mode)</span> {</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span>) s = <span class="keyword">new</span> <span class="title class_">SNode</span>(e);	<span class="comment">// 引用指向空时，snode方法创建一个SNode对象</span></span><br><span class="line">    s.mode = mode;</span><br><span class="line">    s.next = next;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>transfer方法：核心方法，请求匹配出栈，不匹配则阻塞</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">E <span class="title function_">transfer</span><span class="params">(E e, <span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span> {</span><br><span class="line"></span><br><span class="line">    <span class="type">SNode</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mode</span> <span class="operator">=</span> (e == <span class="literal">null</span>) ? REQUEST : DATA;		<span class="comment">// 判断当前请求类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="type">SNode</span> <span class="variable">h</span> <span class="operator">=</span> head;								<span class="comment">// 栈顶指针</span></span><br><span class="line">        <span class="keyword">if</span> (h == <span class="literal">null</span> || h.mode == mode) {			<span class="comment">// 【case1】：栈顶为空，或者与当前请求无法匹配，入栈</span></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>) {				<span class="comment">// 支持超时，但是超时时间小于0，说明不支持“阻塞等待”</span></span><br><span class="line">                <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.isCancelled())	<span class="comment">// 栈顶是取消状态，则栈顶出栈，设置新的栈顶</span></span><br><span class="line">                    casHead(h, h.next);</span><br><span class="line">                <span class="keyword">else</span>								<span class="comment">// 匹配失败，直接返回null</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (casHead(h, s = snode(s, e, h, mode))) {	<span class="comment">// 入栈</span></span><br><span class="line">                <span class="type">SNode</span> <span class="variable">m</span> <span class="operator">=</span> awaitFulfill(s, timed, nanos);		<span class="comment">// 阻塞等待被匹配，成功返回匹配的节点，失败返回自己</span></span><br><span class="line">                <span class="keyword">if</span> (m == s) {</span><br><span class="line">                    clean(s);									<span class="comment">// 失败出栈</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> ((h = head) != <span class="literal">null</span> &amp;&amp; h.next == s)			<span class="comment">// 协助与之匹配的节点，出栈</span></span><br><span class="line">                    casHead(h, s.next);</span><br><span class="line">                <span class="comment">// 当前node模式为REQUEST类型：返回匹配节点的m.item数据域</span></span><br><span class="line">                <span class="comment">// 当前node模式为DATA类型：返回node.item数据域，当前请求提交的数据e</span></span><br><span class="line">                <span class="keyword">return</span> (E) ((mode == REQUEST) ? m.item : s.item);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (!isFulfilling(h.mode)) {	<span class="comment">// 【case2】：栈顶不是FULFILLING说明没被匹配，当前可以匹配</span></span><br><span class="line">            <span class="keyword">if</span> (h.isCancelled())			<span class="comment">// 头节点是取消节点，协助出栈</span></span><br><span class="line">                casHead(h, h.next);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (casHead(h, s=snode(s, e, h, FULFILLING|mode))) {	<span class="comment">// 入栈当前请求的节点</span></span><br><span class="line">                <span class="keyword">for</span> (;;) {</span><br><span class="line">                    <span class="type">SNode</span> <span class="variable">m</span> <span class="operator">=</span> s.next;			<span class="comment">// m是s的匹配节点</span></span><br><span class="line">                    <span class="keyword">if</span> (m == <span class="literal">null</span>) {			<span class="comment">// 可能m在await过程中被中断，clean了自己</span></span><br><span class="line">                        casHead(s, <span class="literal">null</span>);		<span class="comment">// 清空栈并返回外层自旋</span></span><br><span class="line">                        s = <span class="literal">null</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="type">SNode</span> <span class="variable">mn</span> <span class="operator">=</span> m.next;			<span class="comment">// 获取匹配节点的下一个节点</span></span><br><span class="line">                    <span class="keyword">if</span> (m.tryMatch(s)) {		<span class="comment">// 尝试匹配，匹配成功则将FULLFILLING和m出栈，并唤醒被匹配节点的线程</span></span><br><span class="line">                        casHead(s, mn);</span><br><span class="line">                        <span class="keyword">return</span> (E) ((mode == REQUEST) ? m.item : s.item);</span><br><span class="line">                    } <span class="keyword">else</span></span><br><span class="line">                        s.casNext(m, mn);		<span class="comment">// 匹配失败，出栈m</span></span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> {						<span class="comment">// 【case3】：栈顶是FULFILLING，栈顶和其下节点正在匹配，当前请求需要做协助</span></span><br><span class="line">            <span class="type">SNode</span> <span class="variable">m</span> <span class="operator">=</span> h.next;			<span class="comment">// h和m都是FULFILLING节点</span></span><br><span class="line">            <span class="keyword">if</span> (m == <span class="literal">null</span>)</span><br><span class="line">                casHead(h, <span class="literal">null</span>);		<span class="comment">// 清空栈</span></span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                <span class="type">SNode</span> <span class="variable">mn</span> <span class="operator">=</span> m.next;</span><br><span class="line">                <span class="keyword">if</span> (m.tryMatch(h))		<span class="comment">// m和h匹配，唤醒m中的线程</span></span><br><span class="line">                    casHead(h, mn);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    h.casNext(m, mn);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>awaitFulfill</code>方法：阻塞当前线程，等待被匹配，或者取消当前节点</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">SNode <span class="title function_">awaitFulfill</span><span class="params">(SNode s, <span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> timed ? System.nanoTime() + nanos : <span class="number">0L</span>;	<span class="comment">// 等待的截止时间</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">w</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">spins</span> <span class="operator">=</span> (shouldSpin(s) ?									<span class="comment">// for自旋检查的次数</span></span><br><span class="line">                 (timed ? maxTimedSpins : maxUntimedSpins) : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="keyword">if</span> (w.isInterrupted())										<span class="comment">// 当前线程收到中断信号，设置node状态为取消</span></span><br><span class="line">            s.tryCancel();</span><br><span class="line">        <span class="type">SNode</span> <span class="variable">m</span> <span class="operator">=</span> s.match;											<span class="comment">// 获取与当前s匹配的节点</span></span><br><span class="line">        <span class="keyword">if</span> (m != <span class="literal">null</span>)												<span class="comment">// 可能是正常的匹配，也可能是取消的</span></span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        <span class="keyword">if</span> (timed) {												<span class="comment">// 如果超时就取消节点</span></span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) {</span><br><span class="line">                s.tryCancel();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (spins &gt; <span class="number">0</span>)												<span class="comment">// 如果当前线程可以自旋检查，就自旋并减1</span></span><br><span class="line">            spins = shouldSpin(s) ? (spins-<span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s.waiter == <span class="literal">null</span>)									<span class="comment">// 说明没有自旋次数了，保存线程，准备阻塞</span></span><br><span class="line">            s.waiter = w;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!timed)											<span class="comment">// 没有超时限制，直接阻塞</span></span><br><span class="line">            LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; spinForTimeoutThreshold)					<span class="comment">// nanos &gt; 1000纳秒的情况下，才允许挂起</span></span><br><span class="line">            LockSupport.parkNanos(<span class="built_in">this</span>, nanos);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>



<h4 id="公平（TransferQueue）"><a href="#公平（TransferQueue）" class="headerlink" title="公平（TransferQueue）"></a>公平（TransferQueue）</h4><p>TransferQueue是公平的同步队列，采用FIFO的队列实现，请求节点与队尾模式不同，需要与队头发生匹配</p>
<h5 id="TransferQueue类成员变量"><a href="#TransferQueue类成员变量" class="headerlink" title="TransferQueue类成员变量"></a>TransferQueue类成员变量</h5><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> QNode head;		<span class="comment">// 指向队列的dummy节点</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> QNode tail;		<span class="comment">// 指向队列的尾节点</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> QNode cleanMe;	<span class="comment">// 被清理节点的前驱节点</span></span><br></pre></td></tr></table></figure></div>

<h5 id="QNode内部类"><a href="#QNode内部类" class="headerlink" title="QNode内部类"></a>QNode内部类</h5><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">QNode</span> {</span><br><span class="line">    <span class="keyword">volatile</span> QNode next;	<span class="comment">// 当前节点的下一个节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Object item;	<span class="comment">// 数据域，为null代表是REQUEST类型，不为null表示为DATA类型</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread waiter;	<span class="comment">// 保存对应的线程引用</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> isData;	<span class="comment">// 是否是DATA类型</span></span><br><span class="line"></span><br><span class="line">    QNode(Object item, <span class="type">boolean</span> isData) {	<span class="comment">// 构造方法</span></span><br><span class="line">        <span class="built_in">this</span>.item = item;</span><br><span class="line">        <span class="built_in">this</span>.isData = isData;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">tryCancel</span><span class="params">(Object cmp)</span> {			<span class="comment">// 尝试取消当前node，取消的node的item指向自己</span></span><br><span class="line">        UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, itemOffset, cmp, <span class="built_in">this</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span> {					<span class="comment">// 判断当前node是否被取消</span></span><br><span class="line">        <span class="keyword">return</span> item == <span class="built_in">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isOffList</span><span class="params">()</span> {					<span class="comment">// 判断当前节点是否不在队列中（next指向自己）</span></span><br><span class="line">        <span class="keyword">return</span> next == <span class="built_in">this</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h5 id="TransferQueue类成员方法"><a href="#TransferQueue类成员方法" class="headerlink" title="TransferQueue类成员方法"></a>TransferQueue类成员方法</h5><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">advanceHead</span><span class="params">(QNode h, QNode nh)</span> {</span><br><span class="line">    <span class="comment">// 设置头指针指向新的节点</span></span><br><span class="line">    <span class="keyword">if</span> (h == head &amp;&amp; UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, headOffset, h, nh))</span><br><span class="line">        h.next = h;	<span class="comment">// 老头节点出队</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">advanceTail</span><span class="params">(QNode t, QNode nt)</span> {</span><br><span class="line">    <span class="keyword">if</span> (tail == t)</span><br><span class="line">        <span class="comment">// 更新队尾节点指针</span></span><br><span class="line">        UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, tailOffset, t, nt);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>transfer核心方法</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">E <span class="title function_">transfer</span><span class="params">(E e, <span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="type">QNode</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;					<span class="comment">// s指向当前请求对应的node</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isData</span> <span class="operator">=</span> (e != <span class="literal">null</span>);	<span class="comment">// 是否是Data类型的请求</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="type">QNode</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="type">QNode</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span> || h == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (h == t || t.isData == isData) {		<span class="comment">// 空队列，或者队尾类型和当前一样（说明无法匹配）</span></span><br><span class="line">            <span class="type">QNode</span> <span class="variable">tn</span> <span class="operator">=</span> t.next;					<span class="comment">// 获取队尾t的next节点</span></span><br><span class="line">            <span class="keyword">if</span> (t != tail)						<span class="comment">// 多线程情况下，其他线程可能修改队尾节点</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (tn != <span class="literal">null</span>) {					<span class="comment">// 已经有线程入队了，更新tail</span></span><br><span class="line">                advanceTail(t, tn);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>)			<span class="comment">// 如果允许超时，超时时间小于0，这种方法不支持阻塞等待</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="literal">null</span>)						<span class="comment">// 创建当前Node</span></span><br><span class="line">                s = <span class="keyword">new</span> <span class="title class_">QNode</span>(e, isData);</span><br><span class="line">            <span class="keyword">if</span> (!t.casNext(<span class="literal">null</span>, s))			<span class="comment">// 当前Node添加到队尾</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            advanceTail(t, s);					<span class="comment">// 更新队尾指针</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">x</span> <span class="operator">=</span> awaitFulfill(s, e, timed, nanos);	<span class="comment">// 阻塞等待</span></span><br><span class="line">            <span class="keyword">if</span> (x == s) {						<span class="comment">// 当前node为取消状态，需要出队</span></span><br><span class="line">                clean(t, s);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!s.isOffList()) {				<span class="comment">// 当前node仍在队列中，匹配成功，需要做出队逻辑</span></span><br><span class="line">                advanceHead(t, s);</span><br><span class="line">                <span class="keyword">if</span> (x != <span class="literal">null</span>)</span><br><span class="line">                    s.item = s;</span><br><span class="line">                s.waiter = <span class="literal">null</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> (x != <span class="literal">null</span>) ? (E)x : e;</span><br><span class="line"></span><br><span class="line">        } <span class="keyword">else</span> {										<span class="comment">// 队尾节点与当前请求节点互补匹配</span></span><br><span class="line">            <span class="type">QNode</span> <span class="variable">m</span> <span class="operator">=</span> h.next;							<span class="comment">// 需要和队头进行匹配</span></span><br><span class="line">            <span class="keyword">if</span> (t != tail || m == <span class="literal">null</span> || h != head)	<span class="comment">// 其他线程修改了队尾节点，或者已经把head.next匹配走了</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">Object</span> <span class="variable">x</span> <span class="operator">=</span> m.item;							<span class="comment">// 获取匹配节点的数据保存到x</span></span><br><span class="line">            <span class="keyword">if</span> (isData == (x != <span class="literal">null</span>) ||				<span class="comment">// 判断是否匹配成功</span></span><br><span class="line">                x == m ||</span><br><span class="line">                !m.casItem(x, e)) {</span><br><span class="line">                advanceHead(h, m);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            advanceHead(h, m);							<span class="comment">// 匹配完成，将头节点出队，让这个新的头节点成为dummy节点</span></span><br><span class="line">            LockSupport.unpark(m.waiter);				<span class="comment">// 唤醒该匹配节点的线程</span></span><br><span class="line">            <span class="keyword">return</span> (x != <span class="literal">null</span>) ? (E)x : e;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>awaitFulfill</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Object <span class="title function_">awaitFulfill</span><span class="params">(QNode s, E e, <span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> timed ? System.nanoTime() + nanos : <span class="number">0L</span>;	<span class="comment">// 等待截止时间</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">w</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">spins</span> <span class="operator">=</span> ((head.next == s) ?									<span class="comment">// 自旋次数</span></span><br><span class="line">                 (timed ? maxTimedSpins : maxUntimedSpins) : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="keyword">if</span> (w.isInterrupted())		<span class="comment">// 被打断就取消</span></span><br><span class="line">            s.tryCancel(e);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">x</span> <span class="operator">=</span> s.item;			<span class="comment">// 获取当前Node数据域</span></span><br><span class="line">        <span class="keyword">if</span> (x != e)</span><br><span class="line">            <span class="keyword">return</span> x;				<span class="comment">// 当前请求为REQUEST类型，返回数据</span></span><br><span class="line">        <span class="keyword">if</span> (timed) {				<span class="comment">// 超时检查</span></span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) {</span><br><span class="line">                s.tryCancel(e);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (spins &gt; <span class="number">0</span>)				<span class="comment">// 自旋次数减1</span></span><br><span class="line">            --spins;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s.waiter == <span class="literal">null</span>)	<span class="comment">// 没有自旋次数了，把当前线程封装进waiter</span></span><br><span class="line">            s.waiter = w;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!timed)			<span class="comment">// 阻塞</span></span><br><span class="line">            LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; spinForTimeoutThreshold)</span><br><span class="line">            LockSupport.parkNanos(<span class="built_in">this</span>, nanos);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="操作Pool"><a href="#操作Pool" class="headerlink" title="操作Pool"></a>操作Pool</h2><h3 id="创建方法"><a href="#创建方法" class="headerlink" title="创建方法"></a>创建方法</h3><h4 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h4><p><strong>Executor构造方法：</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,						// 核心线程数，即最小线程数</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,					// 最大线程数</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,					// 存活时间，核心线程数外的线程超时销毁</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,	// 阻塞队列，存放提交的任务</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,			// 线程工厂，创建线程时用到</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span>		<span class="comment">// 拒绝策略（线程达到最大，仍有新任务）</span></span><br></pre></td></tr></table></figure></div>

<p>拒绝策略有四个实现类：</p>
<ul>
<li><code>ThreadPoolExecutor.AbortPolicy</code>：让调用者抛出<code>RejectedExecutionException</code>异常（默认策略）</li>
<li><code>ThreadPoolExecutor.CallerRunsPolicy</code>：将某些任务回退到调用者，让调用者运行</li>
<li><code>ThreadPoolExecutor.DiscardPolicy</code>：直接丢弃任务</li>
<li><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：放弃队列中最早的任务，把当前任务加入队列中尝试再次提交</li>
</ul>
<p>其他框架的拒绝策略：</p>
<ul>
<li>Dubbo：抛出异常前记录日志，并dump线程栈信息，方便定位问题</li>
<li>Netty：创建一个新线程来执行任务</li>
<li>ActiveMQ：超时等待（60s），尝试放入队列</li>
<li>PinPoint：使用一个拒绝链，逐一尝试每种拒绝策略</li>
</ul>
<p><strong>工作原理：</strong></p>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/12/23/tM2C1UuoJHlNfbD.png" alt="image-20231223173100161" style="zoom: 50%;">

<ol>
<li><p>创建线程池（此时还没有创建线程）</p>
</li>
<li><p>当调用execute()方法添加一个任务时：</p>
<ul>
<li><p>如果当前线程数少于corePoolSize，马上创建线程运行任务</p>
</li>
<li><p>如果当前线程数大于等于corePoolSize，将这个任务放入队列</p>
</li>
<li><p>如果队列满了，但运行线程数还小于maximumPoolSize，<strong>创建非核心线程</strong>立即运行这个任务（对阻塞队列的任务来说不公平）</p>
</li>
<li><p>如果队列满了，且运行线程数大于等于maximumPoolSize，线程池会启动拒绝策略</p>
</li>
</ul>
</li>
<li><p>当一个线程完成任务，会从队列中取下一个任务来执行</p>
</li>
<li><p>当线程空闲时间超过keepAliveTime，会销毁线程（令线程数量收缩到corePoolSize大小）</p>
</li>
</ol>
<h4 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h4><p>提供了四种线程池的创建：</p>
<ul>
<li><code>newFixedThreadPool</code>：创建具有n个线程的线程池<ul>
<li>核心线程数 = 最大线程数（所以无需超时时间）</li>
<li>单向链表实现阻塞队列，默认大小<code>Integer.MAX_VALUE</code>（无界的），任务较多可能OOM</li>
<li>适用于任务量已知，相对耗时的长期任务</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>newCachedThreadPool</code>：创建一个可扩容的线程池<ul>
<li>核心线程数是0，最大线程数是29个1，全是救急线程（60s后可以回收）</li>
<li><code>SynchronousQueue</code>作为阻塞队列，没有容量</li>
<li>适合任务数较密集，但每个任务执行时间较短的情况</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>newSingleThreadExecutor</code>：创建只有一个线程的线程池<ul>
<li>保证所有任务按照指定顺序执行</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="开发要求"><a href="#开发要求" class="headerlink" title="开发要求"></a>开发要求</h4><p><strong>阿里巴巴开发手册：</strong></p>
<ul>
<li>线程必须通过线程池提供<ul>
<li>减少内存消耗，避免过度切换</li>
</ul>
</li>
<li>线程池不允许使用Executors去创建，而是通过<code>ThreadPoolExecutor</code>的方式<ul>
<li>更明确线程池的运行规则</li>
<li>避免无界队列导致的OOM</li>
</ul>
</li>
</ul>
<p><strong>线程池多大合适：</strong></p>
<ul>
<li>总线程数是核心线程池数量的两倍<ul>
<li>过小不能充分利用系统资源</li>
<li>过大导致更多上下文切换</li>
</ul>
</li>
<li>核心线程数常用公式<ul>
<li>CPU密集型任务：N+1</li>
<li>IO密集型任务：2N 或者 N/(1-阻塞系数)，阻塞系数在0.8-0.9之间</li>
</ul>
</li>
</ul>
<h3 id="提交方法"><a href="#提交方法" class="headerlink" title="提交方法"></a>提交方法</h3><p><code>ExecutorService</code>类API：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void execute(Runnable command)</code></td>
<td>执行任务（Executor 类 API）</td>
</tr>
<tr>
<td><code>Future&lt;?&gt; submit(Runnable task)</code></td>
<td>提交任务 task()</td>
</tr>
<tr>
<td><code>Future submit(Callable&lt;T&gt; task)</code></td>
<td>提交任务 task，用返回值 Future 获得任务执行结果</td>
</tr>
<tr>
<td><code>List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</code></td>
<td>提交 tasks 中所有任务</td>
</tr>
<tr>
<td><code>List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit)</code></td>
<td>提交 tasks 中所有任务，超时时间针对所有task，超时会取消没有执行完的任务，并抛出超时异常</td>
</tr>
<tr>
<td><code>T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</code></td>
<td>提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消</td>
</tr>
</tbody></table>
<ul>
<li>execute只能执行Runnable类型的任务，没有返回值</li>
<li>submit既能提交Runnable类型任务，也能提交Callable类型任务<ul>
<li>底层封装成FutureTask，然后调用execute执行</li>
</ul>
</li>
<li>execute直接抛出任务执行时的异常</li>
<li>submit会吞掉异常，可通过Future的get方法将任务执行时的异常重新抛出</li>
</ul>
<h3 id="关闭方法"><a href="#关闭方法" class="headerlink" title="关闭方法"></a>关闭方法</h3><p><code>ExecutorService</code>类API：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void shutdown()</code></td>
<td>线程池状态变为SHUTDOWN，等待任务执行完后关闭线程池，不会接收新任务，但已提交任务会执行完，而且也可以添加线程（不绑定任务）</td>
</tr>
<tr>
<td><code>List&lt;Runnable&gt; shutdownNow()</code></td>
<td>线程池状态变为 STOP，用 interrupt 中断正在执行的任务，直接关闭线程池，不会接收新任务，会将队列中的任务返回</td>
</tr>
<tr>
<td><code>boolean isShutdown()</code></td>
<td>不在RUNNING状态的线程池，此执行者已被关闭，方法返回 true</td>
</tr>
<tr>
<td><code>boolean isTerminated()</code></td>
<td>线程池状态是否是TERMINATED，如果所有任务在关闭后完成，返回 true</td>
</tr>
<tr>
<td><code>boolean awaitTermination(long timeout, TimeUnit unit)</code></td>
<td>调用shutdown后，由于调用线程不会等待所有任务运行结束，如果它想在线程池 TERMINATED 后做些事情，可以利用此方法等待</td>
</tr>
</tbody></table>
<h3 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h3><p>execute会直接抛出任务执行时的异常，submit会吞掉异常</p>
<p><strong>方法一：主动捕获异常</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">executorService.submit(() -&gt; {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    }</span><br><span class="line">});</span><br></pre></td></tr></table></figure></div>

<p><strong>方法二：使用Future对象</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">Future&lt;?&gt; future = executorService.submit(() -&gt; {</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    future.get();</span><br><span class="line">} <span class="keyword">catch</span> (ExecutionException e) {</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><h3 id="状态信息"><a href="#状态信息" class="headerlink" title="状态信息"></a>状态信息</h3><p><code>ThreadPoolExecutor</code>使用int的<strong>高3位来表示线程池状态，低29位表示线程数量</strong>。</p>
<p>存储在原子变量<code>ctl</code>中，可以用一次CAS原子操作修改</p>
<ul>
<li>状态表示</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">ctl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BITS</span> <span class="operator">=</span> Integer.SIZE - <span class="number">3</span>;			<span class="comment">// 等于29，表示低29位</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CAPACITY</span>   <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;	<span class="comment">// 29位能装下的最大容量</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>四种状态</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RUNNING</span>    <span class="operator">=</span> -<span class="number">1</span> &lt;&lt; COUNT_BITS;		<span class="comment">// 111</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHUTDOWN</span>   <span class="operator">=</span>  <span class="number">0</span> &lt;&lt; COUNT_BITS;		<span class="comment">// 000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STOP</span>       <span class="operator">=</span>  <span class="number">1</span> &lt;&lt; COUNT_BITS;		<span class="comment">// 001</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TIDYING</span>    <span class="operator">=</span>  <span class="number">2</span> &lt;&lt; COUNT_BITS;		<span class="comment">// 010</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TERMINATED</span> <span class="operator">=</span>  <span class="number">3</span> &lt;&lt; COUNT_BITS;		<span class="comment">// 011</span></span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>状态</th>
<th>高3位</th>
<th>接收新任务</th>
<th>处理阻塞任务队列</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>RUNNING</td>
<td>111</td>
<td>Y</td>
<td>Y</td>
<td></td>
</tr>
<tr>
<td>SHUTDOWN</td>
<td>000</td>
<td>N</td>
<td>Y</td>
<td>不接收新任务，但处理阻塞队列剩余任务</td>
</tr>
<tr>
<td>STOP</td>
<td>001</td>
<td>N</td>
<td>N</td>
<td>中断正在执行的任务，并抛弃阻塞队列任务</td>
</tr>
<tr>
<td>TIDYING</td>
<td>010</td>
<td>-</td>
<td>-</td>
<td>任务全执行完毕，活动线程为 0 即将进入终结</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>011</td>
<td>-</td>
<td>-</td>
<td>终止状态</td>
</tr>
</tbody></table>
<ul>
<li>获取当前线程数量</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">workerCountOf</span><span class="params">(<span class="type">int</span> c)</span>  { <span class="keyword">return</span> c &amp; CAPACITY; }</span><br></pre></td></tr></table></figure></div>

<ul>
<li>构建ctl</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// rs：线程池状态；wc：线程数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ctlOf</span><span class="params">(<span class="type">int</span> rs, <span class="type">int</span> wc)</span> { <span class="keyword">return</span> rs | wc; }</span><br></pre></td></tr></table></figure></div>

<ul>
<li>比较线程池ctl</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RUNNING &lt; SHUTDOWN &lt; STOP &lt; TIDYING &lt; TERMINATED</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">runStateLessThan</span><span class="params">(<span class="type">int</span> c, <span class="type">int</span> s)</span> {	<span class="comment">// 当前状态是否小于某个状态</span></span><br><span class="line">    <span class="keyword">return</span> c &lt; s;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">runStateAtLeast</span><span class="params">(<span class="type">int</span> c, <span class="type">int</span> s)</span> {	<span class="comment">// 当前状态是否大于等于某个状态</span></span><br><span class="line">    <span class="keyword">return</span> c &gt;= s;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isRunning</span><span class="params">(<span class="type">int</span> c)</span> {				<span class="comment">// 当前状态是否是Running</span></span><br><span class="line">    <span class="keyword">return</span> c &lt; SHUTDOWN;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>设置ctl</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ctl值加1，返回true或false</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">compareAndIncrementWorkerCount</span><span class="params">(<span class="type">int</span> expect)</span> {</span><br><span class="line">    <span class="keyword">return</span> ctl.compareAndSet(expect, expect + <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// ctl值减1，返回true或false</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">compareAndDecrementWorkerCount</span><span class="params">(<span class="type">int</span> expect)</span> {</span><br><span class="line">    <span class="keyword">return</span> ctl.compareAndSet(expect, expect - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自旋，将ctl值减1，直至成功</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">decrementWorkerCount</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">do</span> {} <span class="keyword">while</span> (! compareAndDecrementWorkerCount(ctl.get()));</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="成员属性-1"><a href="#成员属性-1" class="headerlink" title="成员属性"></a>成员属性</h3><p><strong>成员变量：</strong></p>
<ul>
<li>线程池中存放Worker的容器</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Worker&gt;();</span><br></pre></td></tr></table></figure></div>

<ul>
<li>线程全局锁</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 增减worker，或者修改线程池状态，需要持有锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br></pre></td></tr></table></figure></div>

<ul>
<li>可重入锁的条件变量</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 外部调用awaitTermination时，会等待当前线程池状态位Terminatation为止</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">termination</span> <span class="operator">=</span> mainLock.newCondition();</span><br></pre></td></tr></table></figure></div>

<ul>
<li>相关参数</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> corePoolSize;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> maximumPoolSize;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> keepAliveTime;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;		<span class="comment">// 创建线程时的线程工厂</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;	<span class="comment">// 超过核心线程数，放入阻塞队列</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;	<span class="comment">// 拒绝策略</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">RejectedExecutionHandler</span> <span class="variable">defaultHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AbortPolicy</span>();	<span class="comment">// 默认策略</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> largestPoolSize;						<span class="comment">// 记录生命周期内线程数最大值</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> completedTaskCount;					<span class="comment">// 记录生命周期内完成任务的总数</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>控制核心线程数量内的线程是否可以回收</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> allowCoreThreadTimeOut;	<span class="comment">// 为true时，即使是核心线程，空闲时间超时也可以回收</span></span><br></pre></td></tr></table></figure></div>

<p><strong>内部类：</strong></p>
<ul>
<li>Worker类<ul>
<li>每个Worker会绑定一个初始任务，启动Worker时优先执行。</li>
<li>Worker继承自AQS，本身具有锁的特性，采用独占锁模式<ul>
<li>（state=0未占用，state&gt;0被占用，state&lt;0表示初始状态，不能被抢锁）</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> {</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">final</span> Thread thread;			<span class="comment">// worker内部封装的工作线程</span></span><br><span class="line">    Runnable firstTask;				<span class="comment">// worker第一个执行的任务</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> completedTasks;	<span class="comment">// 记录当前worker完成的任务数量</span></span><br><span class="line"></span><br><span class="line">    Worker(Runnable firstTask) {	<span class="comment">// 构造方法</span></span><br><span class="line">        setState(-<span class="number">1</span>);				<span class="comment">// 设置AQS独占模式为初始化中状态，不能被抢占锁</span></span><br><span class="line">        <span class="built_in">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="built_in">this</span>.thread = getThreadFactory().newThread(<span class="built_in">this</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> unused)</span> {	<span class="comment">// 不可重入锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) {</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Executor.DefaultThreadFactory类</span></span><br><span class="line"><span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> {</span><br><span class="line">    <span class="comment">// 将当前worker指定为thread的指定方法，线程调用start()会调用r.run()</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(group, r,</span><br><span class="line">                          namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">                          <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">        t.setDaemon(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">        t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>拒绝策略相关的内部类</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">CallerRunsPolicy</span><br><span class="line">AbortPolicy</span><br><span class="line">DiscardPolicy</span><br><span class="line">DiscardOldestPolicy</span><br></pre></td></tr></table></figure></div>

<h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><h4 id="提交方法-1"><a href="#提交方法-1" class="headerlink" title="提交方法"></a>提交方法</h4><p><code>ThreadPoolExecutor</code>=&gt;<code>AbstractExecutorService</code>=&gt;<code>ExecutorService</code>=&gt;<code>Executor</code></p>
<ul>
<li><code>submit()</code>方法，将提交的Runnable或者Callable封装为FutureTask执行。会返回任务对象，通过get阻塞获取结果</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractExecutorService类</span></span><br><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) {</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();		<span class="comment">// 空指针判断</span></span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="literal">null</span>);	<span class="comment">// Runnable对象封装为未来任务对象</span></span><br><span class="line">    execute(ftask);											<span class="comment">// 执行方法</span></span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span> {</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();	<span class="comment">// 空指针判断</span></span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);			<span class="comment">// Callable对象封装为未来任务对象</span></span><br><span class="line">    execute(ftask);										<span class="comment">// 执行方法</span></span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractExecutorService类</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="title function_">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;T&gt;(runnable, value);	<span class="comment">// Runnable封装成FutureTask，并指定返回值</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="title function_">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;T&gt;(callable);			<span class="comment">// Callable直接封装成FutureTask</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>execute()</code>方法，执行任务，但是没有返回值。出现异常会直接抛出<ul>
<li>只能提交Runnable，或者FutureTask</li>
<li>有担保机制，保证线程池至少有一个worker</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ThreadPoolExecutor类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span>)						<span class="comment">// 非空判断</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();							<span class="comment">// 获取ctl最新值</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) {		<span class="comment">// 【case1】当前线程数少于核心线程数</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))			<span class="comment">// 直接创建一个新的worker，当前任务作为firstTask</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();							<span class="comment">// 添加worker失败（存在并发或者线程池状态改变了），重新获取ctl</span></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    												<span class="comment">// 【case2】线程数已达核心线程数，或者addWorker失败</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) {	<span class="comment">// 【case2】线程池是否处于Running状态，成立就将任务放入队列</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get()</span><br><span class="line">        <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))	<span class="comment">// 如果线程池状态被外部修改了，则要把提交的任务删除</span></span><br><span class="line">            reject(command);						<span class="comment">// 任务出队成功，走拒绝策略</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)		<span class="comment">// （担保机制）线程池是running状态，判断线程池中线程数量是否为0</span></span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);					<span class="comment">// （担保机制）保证线程池在running状态，至少有一个worker</span></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))		<span class="comment">// 【case3】offer失败，说明queue满了</span></span><br><span class="line">        reject(command);						<span class="comment">// 走拒绝策略</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="添加线程"><a href="#添加线程" class="headerlink" title="添加线程"></a>添加线程</h4><ul>
<li><code>prestartAllCoreThreads()</code>方法，提前预热，创建所有的核心线程</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ThreadPoolExecutor类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">prestartAllCoreThreads</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (addWorker(<span class="literal">null</span>, <span class="literal">true</span>))</span><br><span class="line">        ++n;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>addWorker()</code>方法：添加线程到线程池，返回true表示成功，且线程启动。<ul>
<li>首先判断线程池是否允许添加线程，允许线程数量+1，然后创建Worker加入线程池</li>
<li>SHUTDOWN状态也能添加线程，但是要求新的Worker没有<code>firstTask</code>，且当前queue不为空，来帮助执行队列中的任务</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ThreadPoolExecutor类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">addWorker</span><span class="params">(Runnable firstTask, <span class="type">boolean</span> core)</span> {</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();							<span class="comment">// 线程池ctl</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);						<span class="comment">// 线程池状态</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; !(rs == SHUTDOWN &amp;&amp; firstTask == <span class="literal">null</span> &amp;&amp; !workQueue.isEmpty()))	<span class="comment">// 如上条件</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);				<span class="comment">// 线程数量</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize))	<span class="comment">// 超过数量上限</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))	<span class="comment">// CAS线程数+1</span></span><br><span class="line">                <span class="keyword">break</span> retry;						<span class="comment">// 成功跳出循环</span></span><br><span class="line">            c = ctl.get();</span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)				<span class="comment">// 失败判断状态有无变化</span></span><br><span class="line">                <span class="keyword">continue</span> retry;						<span class="comment">// 有变化返回外层循环，重新判断</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    												<span class="comment">// 【令牌申请成功】开始创建线程</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerStarted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerAdded</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">Worker</span> <span class="variable">w</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        w = <span class="keyword">new</span> <span class="title class_">Worker</span>(firstTask);					<span class="comment">// 创建Worker（底层使用传入工厂的newTread方法）</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> w.thread;					<span class="comment">// 拿到其中的thread</span></span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span>) {							<span class="comment">// 确保工厂创建Thread没BUG</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();						<span class="comment">// 加互斥锁，要添加worker了</span></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(ctl.get());		<span class="comment">// 获取最新状态</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == <span class="literal">null</span>)) {	<span class="comment">// 确保满足条件</span></span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive())				<span class="comment">// 此时如果线程已经启动了，应该报错</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line">                    workers.add(w);					<span class="comment">// 添加到线程池</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;		<span class="comment">// 更新largestPoolSize</span></span><br><span class="line">                    workerAdded = <span class="literal">true</span>;</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) {						<span class="comment">// 如果已经成功添加到线程池，启动线程</span></span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">if</span> (!workerStarted)							<span class="comment">// 如果启动失败，做清理工作</span></span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> workerStarted;							<span class="comment">// 返回启动是否成功</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ThreadPoolExecutor类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addWorkerFailed</span><span class="params">(Worker w)</span> {</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();			<span class="comment">// 操作线程池，需要先获取全局锁</span></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">if</span> (w != <span class="literal">null</span>)</span><br><span class="line">            workers.remove(w);	<span class="comment">// 移除指定worker</span></span><br><span class="line">        decrementWorkerCount();	<span class="comment">// 线程池计数-1，相当于归还令牌</span></span><br><span class="line">        tryTerminate();			<span class="comment">// 尝试停止线程池</span></span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        mainLock.unlock();		<span class="comment">// 释放全局锁</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="运行方法"><a href="#运行方法" class="headerlink" title="运行方法"></a>运行方法</h4><p><code>Worker</code>=&gt;<code>Runnable &amp; AQS</code></p>
<ul>
<li>Worker实现了Runnable接口，线程启动时会调用Worker的run方法</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ThreadPoolExecutor.Worker类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">    runWorker(<span class="built_in">this</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>runWorker方法，会一直while循环获取任务并执行</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ThreadPoolExecutor类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runWorker</span><span class="params">(Worker w)</span> {</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> w.firstTask;		<span class="comment">// 获取worker的firstTask</span></span><br><span class="line">    w.firstTask = <span class="literal">null</span>;					<span class="comment">// 引用置空</span></span><br><span class="line">    w.unlock();							<span class="comment">// 初始化worker时设置state=-1，表示不允许抢占锁</span></span><br><span class="line">    									<span class="comment">// 设置state=0，exclusiveOwnerThread=null，开始独占模式强锁</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">completedAbruptly</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) {	<span class="comment">// firstTask不是null直接运行，否则去queue获取</span></span><br><span class="line">            w.lock();											<span class="comment">// worker加锁（表示不空闲）</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 说明线程处于STOP/TIDYING/TERMINATION，需要给线程一个中断信号</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) || </span><br><span class="line">                 <span class="comment">// 说明线程处于RUNNING或者SHUTDOWN状态，清除打断标记</span></span><br><span class="line">                 (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted())</span><br><span class="line">                <span class="comment">// 中断线程，标志位为true</span></span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                beforeExecute(wt, task);	<span class="comment">// 钩子方法，任务执行前的前置处理</span></span><br><span class="line">                <span class="type">Throwable</span> <span class="variable">thrown</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    task.run();				<span class="comment">// 执行任务</span></span><br><span class="line">                } <span class="keyword">catch</span> (RuntimeException x) {</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                } <span class="keyword">catch</span> (Error x) {</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                } <span class="keyword">catch</span> (Throwable x) {</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(x);</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    afterExecute(task, thrown);	<span class="comment">// 钩子方法，任务执行的后置处理</span></span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                task = <span class="literal">null</span>;					<span class="comment">// 局部变量task设为null，表示执行完成</span></span><br><span class="line">                w.completedTasks++;				<span class="comment">// 更新worker完成任务数量</span></span><br><span class="line">                w.unlock();						<span class="comment">// 解锁</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        completedAbruptly = <span class="literal">false</span>;				<span class="comment">// 正常退出，completedAbruptly=false</span></span><br><span class="line">        										<span class="comment">// 异常退出，completedAbruptly=true</span></span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        processWorkerExit(w, completedAbruptly);	<span class="comment">// 根据情况，向线程池中添加线程</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>unlock()方法，重置锁</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ThreadPoolExecutor类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> { </span><br><span class="line">    release(<span class="number">1</span>); </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// AQS类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> {</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// ThreadPoolExecutor类</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> unused)</span> {</span><br><span class="line">    setExclusiveOwnerThread(<span class="literal">null</span>);	<span class="comment">// 设置持有者为 null</span></span><br><span class="line">    setState(<span class="number">0</span>);					<span class="comment">// 设置 state = 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>getTask()</code>：获取任务，线程空闲时间超过keepAliveTime就会回收，判断依据时当前线程<strong>阻塞获取任务超过保活时间</strong><ul>
<li>方法返回null，代表当前线程要被回收了，进入退出逻辑</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ThreadPoolExecutor类</span></span><br><span class="line"><span class="keyword">private</span> Runnable <span class="title function_">getTask</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">timedOut</span> <span class="operator">=</span> <span class="literal">false</span>;	<span class="comment">// 超时标记</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();		<span class="comment">// 当前ctl</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);	<span class="comment">// 当前状态</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment">// RUNNING &lt; SHUTDOWN &lt; STOP &lt; TIDYING &lt; TERMINATED</span></span><br><span class="line">        <span class="comment">// 状态为SHUTDOWN且队列为空，或者状态为STOP之后，可以直接返回null了</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) {</span><br><span class="line">            decrementWorkerCount();			<span class="comment">// 自旋的方式让ctl值-1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);			<span class="comment">// 线程池中的线程数量</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 条件一：允许回收核心线程，那就无所谓了，都支持超时回收</span></span><br><span class="line">        <span class="comment">// 条件二：线程数大于核心线程数，有保活时间，去超时获取任务</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">timed</span> <span class="operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 条件一：如果线程数大于最大线程数，直接回收</span></span><br><span class="line">        <span class="comment">// 条件二：允许超时，且已经超时了，直接回收</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) {</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))	<span class="comment">// CAS将ctl减1，返回null，失败继续循环</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 根据是否需要超时回收，workQueue使用带超时的poll，或者take</span></span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">            	workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;			<span class="comment">// 成功直接返回</span></span><br><span class="line">            timedOut = <span class="literal">true</span>;		<span class="comment">// r为null，说明超时了</span></span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException retry) {</span><br><span class="line">            timedOut = <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>processWorkerExit()</code>方法：线程退出线程池，也有担保机制</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ThreadPoolExecutor类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processWorkerExit</span><span class="params">(Worker w, <span class="type">boolean</span> completedAbruptly)</span> {</span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly)		<span class="comment">// 如果是异常退出的</span></span><br><span class="line">        decrementWorkerCount();	<span class="comment">// 发生了异常ctl还没有减1，ctl需要减1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        completedTaskCount += w.completedTasks;	<span class="comment">// 完成的任务数量加1</span></span><br><span class="line">        workers.remove(w);						<span class="comment">// worker从线程池移出</span></span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    tryTerminate();								<span class="comment">// 尝试停止线程池，唤醒下一个线程</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) {			<span class="comment">// 如果是RUNNING或者SHUTDOWN状态【担保机制】</span></span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) {				<span class="comment">// 不是异常退出，是对空闲线程回收</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())	<span class="comment">// 最小允许线程可以是0，但是队列又不为空，需要一个线程完成任务担保</span></span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)			<span class="comment">// 线程池中的线程数量大于min，可以直接返回，不需要添加worker</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        addWorker(<span class="literal">null</span>, <span class="literal">false</span>);						<span class="comment">// 是异常退出，需要添加worker</span></span><br><span class="line">        											<span class="comment">// 不是异常退出，但是线程池中线程不够，需要添加worker</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="停止方法"><a href="#停止方法" class="headerlink" title="停止方法"></a>停止方法</h4><ul>
<li><code>shutdown()</code>方法：停止线程池，会等待执行完成</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ThreadPoolExecutor类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        advanceRunState(SHUTDOWN);	<span class="comment">// 设置状态为SHUTDOWN，如果已经大于SHUTDOWN了则直接返回</span></span><br><span class="line">        interruptIdleWorkers();		<span class="comment">// 中断空闲线程</span></span><br><span class="line">        onShutdown();				<span class="comment">// 空方法，留给子类用</span></span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    }</span><br><span class="line">    tryTerminate();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>shutdownNow()</code>方法：直接关闭线程池，不会等待执行完成<ul>
<li>会返回没完成的任务列表</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ThreadPoolExecutor类</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span> {</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        advanceRunState(STOP);	<span class="comment">// 设置状态为STOP</span></span><br><span class="line">        interruptWorkers();		<span class="comment">// 中断所有线程</span></span><br><span class="line">        tasks = drainQueue();	<span class="comment">// 从阻塞队列中取出未处理的task</span></span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    }</span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;				<span class="comment">// 返回未处理的任务</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>tryTerminate()</code>方法：设置为TERMINATED状态</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ThreadPoolExecutor类</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">tryTerminate</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();		<span class="comment">// 获取ctl的值</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) ||											<span class="comment">// 条件一，RUNNING状态</span></span><br><span class="line">            runStateAtLeast(c, TIDYING) ||							<span class="comment">// 条件二，TIDYING/TERMINATED状态</span></span><br><span class="line">            (runStateOf(c) == SHUTDOWN &amp;&amp; !workQueue.isEmpty()))	<span class="comment">// 条件三，SHUTDOWN状态，阻塞队列不为空</span></span><br><span class="line">            <span class="keyword">return</span>;								<span class="comment">// 直接返回</span></span><br><span class="line">        										</span><br><span class="line">        										<span class="comment">// 执行到这里，说明线程池状态为STOP，或者SHUTDOWN且队列为空</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) {			<span class="comment">// 线程池中线程数量不为0</span></span><br><span class="line">            <span class="comment">// 中断一个空闲线程，将导致阻塞在queue.take/queue.poll处的线程唤醒，最终getTask返回null。</span></span><br><span class="line">            <span class="comment">// 后面执行processWorkerExit退出逻辑时，会再次调用tryTerminate()，唤醒下一个空闲线程</span></span><br><span class="line">            interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">		</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 池中的线程数量为0时，来到这里</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) {	<span class="comment">// 设置状态为TIDYING，线程数为0</span></span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    terminated();							<span class="comment">// 结束线程池</span></span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));			<span class="comment">// 设置线程池状态为TERMINATED，线程数为0</span></span><br><span class="line">                    termination.signalAll();				<span class="comment">// 唤醒所有调用awaitTermination()方法的线程</span></span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>FutureTask是未来任务对象，继承Runnable、Future接口，用于包装Callable对象，实现任务的提交</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Callable&lt;String&gt; stringCallable = () -&gt; <span class="string">"Hello"</span>;</span><br><span class="line">FutureTask&lt;String&gt; task = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(stringCallable);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> task.get();</span><br></pre></td></tr></table></figure></div>

<p>构造方法：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> {</span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="built_in">this</span>.callable = callable;				<span class="comment">// 属性注入</span></span><br><span class="line">    <span class="built_in">this</span>.state = NEW;						<span class="comment">// 状态设为NEW</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FutureTask</span><span class="params">(Runnable runnable, V result)</span> {</span><br><span class="line">    <span class="built_in">this</span>.callable = Executors.callable(runnable, result);	<span class="comment">// 适配器模式</span></span><br><span class="line">    <span class="built_in">this</span>.state = NEW;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Executors类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Callable&lt;T&gt; <span class="title function_">callable</span><span class="params">(Runnable task, T result)</span> {</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RunnableAdapter</span>&lt;T&gt;(task, result);			<span class="comment">// 适配器模式，将Runnable转换为Callable</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Executors类内部类</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">RunnableAdapter</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;T&gt; {</span><br><span class="line">    <span class="keyword">final</span> Runnable task;</span><br><span class="line">    <span class="keyword">final</span> T result;</span><br><span class="line">    </span><br><span class="line">    RunnableAdapter(Runnable task, T result) {				<span class="comment">// 适配器模式，将Runnable转换为Callable</span></span><br><span class="line">        <span class="built_in">this</span>.task = task;</span><br><span class="line">        <span class="built_in">this</span>.result = result;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">call</span><span class="params">()</span> {</span><br><span class="line">        task.run();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="成员属性-2"><a href="#成员属性-2" class="headerlink" title="成员属性"></a>成员属性</h4><p>FutureTask类的成员属性</p>
<ul>
<li>任务状态</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;						<span class="comment">// 当前状态</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NEW</span>          <span class="operator">=</span> <span class="number">0</span>;		<span class="comment">// 任务创建，尚未执行</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COMPLETING</span>   <span class="operator">=</span> <span class="number">1</span>;		<span class="comment">// 任务正在结束，尚未完全结束</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NORMAL</span>       <span class="operator">=</span> <span class="number">2</span>;		<span class="comment">// 任务正常结束</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">EXCEPTIONAL</span>  <span class="operator">=</span> <span class="number">3</span>;		<span class="comment">// 任务执行发生异常</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span>    <span class="operator">=</span> <span class="number">4</span>;		<span class="comment">// 任务被取消</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INTERRUPTING</span> <span class="operator">=</span> <span class="number">5</span>;		<span class="comment">// 任务中断中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INTERRUPTED</span>  <span class="operator">=</span> <span class="number">6</span>;		<span class="comment">// 任务已中断</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>任务对象</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Callable&lt;V&gt; callable;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>存储任务执行的结果</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Object outcome;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>执行任务的线程对象</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Thread runner;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>线程阻塞队列的头节点</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> WaitNode waiters;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>内部类</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">WaitNode</span> {</span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">    <span class="keyword">volatile</span> WaitNode next;</span><br><span class="line">    WaitNode() { thread = Thread.currentThread(); }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="成员方法-1"><a href="#成员方法-1" class="headerlink" title="成员方法"></a>成员方法</h4><p><strong>任务执行：</strong></p>
<ul>
<li><code>FutureTask::run()</code>方法</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// 条件一：状态不是NEW，说明任务已经被别人执行过了。直接返回</span></span><br><span class="line">    <span class="comment">// 条件二：尝试将runner设为自己的线程，失败说明被别人抢去了。直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">        !UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, runnerOffset,</span><br><span class="line">                                     <span class="literal">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="literal">null</span> &amp;&amp; state == NEW) {</span><br><span class="line">            V result;</span><br><span class="line">            <span class="type">boolean</span> ran;				<span class="comment">// 表示是否抛出过异常</span></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = <span class="literal">true</span>;				<span class="comment">// 没有异常</span></span><br><span class="line">            } <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">                result = <span class="literal">null</span>;</span><br><span class="line">                ran = <span class="literal">false</span>;			<span class="comment">// 有异常</span></span><br><span class="line">                setException(ex);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (ran)</span><br><span class="line">                set(result);			<span class="comment">// 设置返回值</span></span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        runner = <span class="literal">null</span>;					<span class="comment">// 任务执行完成，取消线程引用</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)			<span class="comment">// 判断任务是否被中断</span></span><br><span class="line">            handlePossibleCancellationInterrupt(s);	<span class="comment">// 执行中断处理方法，见后面</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>FutureTask::run()</code>方法，设置返回值</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(V v)</span> {</span><br><span class="line">    <span class="comment">// CAS设置当前状态为COMPLETING，失败说明任务被其他线程取消了</span></span><br><span class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, NEW, COMPLETING)) {</span><br><span class="line">        outcome = v;										<span class="comment">// 将值赋给outcome</span></span><br><span class="line">        UNSAFE.putOrderedInt(<span class="built_in">this</span>, stateOffset, NORMAL);	<span class="comment">// 当前任务状态修改为NORMAL</span></span><br><span class="line">        finishCompletion();									<span class="comment">// 见后面</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>FutureTask::setException()</code>方法，设置异常返回值</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">setException</span><span class="params">(Throwable t)</span> {</span><br><span class="line">    <span class="comment">// CAS设置当前状态为COMPLETING</span></span><br><span class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, NEW, COMPLETING)) {</span><br><span class="line">        outcome = t;											<span class="comment">// 异常值赋给outcome，用来往外抛</span></span><br><span class="line">        UNSAFE.putOrderedInt(<span class="built_in">this</span>, stateOffset, EXCEPTIONAL);	<span class="comment">// 当前任务状态修改为EXCEPTIONAL</span></span><br><span class="line">        finishCompletion();										<span class="comment">// 见后面</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>FutureTask::finishCompletion()</code>方法，唤醒get阻塞线程</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">finishCompletion</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="literal">null</span>;) {		<span class="comment">// 遍历所有等待的节点</span></span><br><span class="line">        <span class="comment">// 使用CAS设置waiter为null，防止外部线程使用cancel取消当前任务，触发finishCompletion重复执行</span></span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, waitersOffset, q, <span class="literal">null</span>)) {</span><br><span class="line">            <span class="keyword">for</span> (;;) {</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> q.thread;		<span class="comment">// 获取当前waitNode节点封装的thread</span></span><br><span class="line">                <span class="keyword">if</span> (t != <span class="literal">null</span>) {			<span class="comment">// 当前线程不为null，唤醒get等待获取数据的线程</span></span><br><span class="line">                    q.thread = <span class="literal">null</span>;</span><br><span class="line">                    LockSupport.unpark(t);</span><br><span class="line">                }</span><br><span class="line">                <span class="type">WaitNode</span> <span class="variable">next</span> <span class="operator">=</span> q.next;		<span class="comment">// 获取下一个节点</span></span><br><span class="line">                <span class="keyword">if</span> (next == <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                q.next = <span class="literal">null</span>;				<span class="comment">// 断开链表</span></span><br><span class="line">                q = next;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    done();</span><br><span class="line">    callable = <span class="literal">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>FutureTask::handlePossibleCancellationInterrupt()</code>方法，任务中断处理</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handlePossibleCancellationInterrupt</span><span class="params">(<span class="type">int</span> s)</span> {</span><br><span class="line">    <span class="keyword">if</span> (s == INTERRUPTING)</span><br><span class="line">        <span class="keyword">while</span> (state == INTERRUPTING)</span><br><span class="line">            Thread.<span class="keyword">yield</span>();		<span class="comment">// 需要一直等待中断完成</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p><strong>结果获取：</strong></p>
<ul>
<li><code>FutureTask::get()</code>方法，获取线程执行的返回值。可以有多个线程get</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException {</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> state;			<span class="comment">// 获取当前任务状态</span></span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING)	<span class="comment">// 条件成立，说明还没执行完成</span></span><br><span class="line">        s = awaitDone(<span class="literal">false</span>, <span class="number">0L</span>);	<span class="comment">// 等待完成，最终返回状态</span></span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>FutureTask::awaitDone()</code>方法，get线程封装成<code>WaitNode</code>对象，进入阻塞队列等待</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">awaitDone</span><span class="params">(<span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> timed ? System.nanoTime() + nanos : <span class="number">0L</span>;	<span class="comment">// 等候的DDL</span></span><br><span class="line">    <span class="type">WaitNode</span> <span class="variable">q</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">queued</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) {				<span class="comment">// 返回true说明被打断，会清除打断标记</span></span><br><span class="line">            removeWaiter(q);					<span class="comment">// 当前waitNode出队</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();	<span class="comment">// 抛出错误</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> state;						<span class="comment">// 获取任务状态</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt; COMPLETING) {				<span class="comment">// 条件成立，说明已经有结果了</span></span><br><span class="line">            <span class="keyword">if</span> (q != <span class="literal">null</span>)</span><br><span class="line">                q.thread = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING)			<span class="comment">// 条件成立，说明任务接近完成，这里让线程释放一下cpu，下一次再抢占</span></span><br><span class="line">            Thread.<span class="keyword">yield</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="literal">null</span>)					<span class="comment">// 【第一次自旋】创建WaitNode对象</span></span><br><span class="line">            q = <span class="keyword">new</span> <span class="title class_">WaitNode</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!queued)					<span class="comment">// 【第二次自旋】创建了WaitNode对象，但还没入队</span></span><br><span class="line">            <span class="comment">// waiters指向队首，CAS让waiters指向当前WaitNode（头插法）</span></span><br><span class="line">            queued = UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, waitersOffset, q.next = waiters, q);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (timed) {</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) {</span><br><span class="line">                removeWaiter(q);</span><br><span class="line">                <span class="keyword">return</span> state;</span><br><span class="line">            }</span><br><span class="line">            LockSupport.parkNanos(<span class="built_in">this</span>, nanos);	<span class="comment">// 超时阻塞等待</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            LockSupport.park(<span class="built_in">this</span>);				<span class="comment">// 阻塞等待</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>FutureTask::report()</code>方法，封装运行结果（成员变量outcome）</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> V <span class="title function_">report</span><span class="params">(<span class="type">int</span> s)</span> <span class="keyword">throws</span> ExecutionException {</span><br><span class="line">    <span class="type">Object</span> <span class="variable">x</span> <span class="operator">=</span> outcome;</span><br><span class="line">    <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">        <span class="keyword">return</span> (V)x;							<span class="comment">// 正常结束，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CancellationException</span>();		<span class="comment">// 被取消或中断，抛出异常</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExecutionException</span>((Throwable)x);	<span class="comment">// 说明自定义的Callable方法有异常，抛出outcome异常</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>FutureTask::cancel()</code>方法，任务取消，打断正在执行该任务的线程</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span> {</span><br><span class="line">    <span class="comment">// 条件一：表示当前任务处于运行中，或者队列中</span></span><br><span class="line">    <span class="comment">// 条件二：修改状态，成功才能继续执行，否则返回false</span></span><br><span class="line">    <span class="keyword">if</span> (!(state == NEW &amp;&amp;</span><br><span class="line">          UNSAFE.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, NEW,</span><br><span class="line">                                   mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">if</span> (mayInterruptIfRunning) {		<span class="comment">// 如果任务已经运行允许被打断</span></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> runner;			<span class="comment">// 获取当前FutureTask的thread</span></span><br><span class="line">                <span class="keyword">if</span> (t != <span class="literal">null</span>)</span><br><span class="line">                    t.interrupt();			<span class="comment">// 打断</span></span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                UNSAFE.putOrderedInt(<span class="built_in">this</span>, stateOffset, INTERRUPTED);	<span class="comment">// 设置状态为打断完成</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        finishCompletion();					<span class="comment">// 唤醒所有get阻塞的线程</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h2><h3 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h3><p>Timer实现定时任务</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">TimerTask</span> <span class="variable">task1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimerTask</span>() {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"task1"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">TimerTask</span> <span class="variable">task2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimerTask</span>() {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"task2"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用timer添加两个任务，都是延时1s后执行</span></span><br><span class="line"><span class="comment">// 但由于timer内，只有一个线程来顺序执行任务，因此task1的延时会影响task2的执行</span></span><br><span class="line">timer.schedule(task1, <span class="number">1000</span>);</span><br><span class="line">timer.schedule(task2, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure></div>

<h3 id="Scheduled"><a href="#Scheduled" class="headerlink" title="Scheduled"></a>Scheduled</h3><p>任务调度线程池<code>ScheduledThreadPoolExecutor</code>，继承<code>ThreadPoolExecutor</code></p>
<ul>
<li>使用内部类<code>ScheduledFutureTask</code>，封装任务</li>
<li>使用内部类<code>DelayedWorkQueue</code>，作为线程池队列</li>
<li>重写<code>onShutdown</code>方法，去处理shutdown后的任务</li>
<li>提供<code>decorateTask</code>方法，作为<code>ScheduledFutureTask</code> 的修饰方法，以便开发者进行扩展</li>
</ul>
<p><strong>构造方法：</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">10</span>);</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Executors类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newScheduledThreadPool</span><span class="params">(<span class="type">int</span> corePoolSize)</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(corePoolSize);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// ScheduledThreadPoolExecutor类</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ScheduledThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize)</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最大线程数固定为MAX_VALUE，保活时间keepAliveTime固定为0</span></span><br><span class="line">    <span class="built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS, <span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>());</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p><strong>常用API：</strong></p>
<ul>
<li>返回值都是<code>ScheduledFuture&lt;?&gt;</code></li>
</ul>
<table>
<thead>
<tr>
<th>API</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code> schedule</code></td>
<td><code>Runnable command, long delay, TimeUnit unit</code></td>
<td>执行延时任务</td>
</tr>
<tr>
<td><code>schedule</code></td>
<td><code>Callable&lt;V&gt; callable, long delay, TimeUnit unit</code></td>
<td>执行延时任务</td>
</tr>
<tr>
<td><code>scheduleAtFixedRate</code></td>
<td><code>Runnable command, long initialDelay, long period, TimeUnit unit</code></td>
<td>定时执行周期任务（不考虑执行的耗时）</td>
</tr>
<tr>
<td><code>scheduleWithFixedDelay</code></td>
<td><code>Runnable command, long initialDelay, long delay, TimeUnit unit</code></td>
<td>定时执行周期任务（要考虑执行的耗时）</td>
</tr>
</tbody></table>
<p><strong>基本使用：</strong></p>
<ul>
<li>延迟任务</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">executor.schedule(() -&gt; {</span><br><span class="line">    System.out.println(<span class="string">"task1"</span>);</span><br><span class="line">}, <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>周期任务<code>scheduleAtFixedRate</code>，<strong>一次任务启动到下一次任务启动之间</strong>，只要大于间隔时间，抢占到CPU就会立即执行</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">executor.scheduleAtFixedRate(() -&gt; {</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">}, <span class="number">1000</span>, <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两次打印间隔2s</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>周期任务<code>scheduleWithFixedDelay</code>，<strong>一次任务结束到下一次任务开始间隔</strong>，严格等于<code>initialDelay</code></li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">executor.scheduleWithFixedDelay(() -&gt; {</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">}, <span class="number">1000</span>, <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两次打印间隔3s</span></span><br></pre></td></tr></table></figure></div>

<h2 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h2><p>ForkJoin：线程池的实现，体现的是分治思想，用于并行计算。</p>
<p>任务拆分：将一个大任务拆分为算法上相同的小任务，直至不能拆分，可以直接求解。</p>
<p>跟递归相关的一些计算，比如归并排序，斐波那契数列都可以用分治思想。</p>
<ul>
<li>ForkJoin在分治基础上，加入了多线程，把每个任务的分解和合并交给不同线程来完成，提高了运算效率</li>
<li>ForkJoin使用ForkJoinPool来启动，是一个特殊的线程池，默认创建与CPU核心数大小相同的线程池</li>
<li>任务有返回值继承<code>RecursiveTask</code>，没有返回值继承<code>RecursiveAction</code></li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line"><span class="type">MyTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(<span class="number">100</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> pool.invoke(task);</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyTask</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将任务进行拆分</span></span><br><span class="line">        <span class="type">MyTask</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(n - <span class="number">1</span>);</span><br><span class="line">        t1.fork();</span><br><span class="line">        <span class="keyword">return</span> n + t1.join();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>上一个拆分不是很合理，优化一下</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line"><span class="type">MyTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> pool.invoke(task);</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> begin;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> end;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyTask</span><span class="params">(<span class="type">int</span> begin, <span class="type">int</span> end)</span> {</span><br><span class="line">        <span class="built_in">this</span>.begin = begin;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (begin == end) {</span><br><span class="line">            <span class="keyword">return</span> begin;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (end - begin == <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">return</span> begin + end;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (begin + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">MyTask</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(begin, mid);</span><br><span class="line">        <span class="type">MyTask</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(mid + <span class="number">1</span>, end);</span><br><span class="line">        t1.fork();</span><br><span class="line">        t2.fork();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> t1.join() + t2.join();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>ForkJoinPool实现了工作窃取算法，来提高CPU利用率</p>
<ul>
<li>每个线程都维护了一个双端队列，用来存储需要执行的任务</li>
<li>工作窃取算法：允许空闲的线程，从其他线程双端队列中窃取任务来执行<ul>
<li>窃取的必须是最晚的任务，避免和队列所属线程发生竞争（但是队列中只有一个任务时，还是会发生竞争）</li>
</ul>
</li>
</ul>
<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p><strong>享元模式</strong>：用于减少创建对象的数量，以减少内存占用和提高性能。</p>
<p><strong>异步模式</strong>：让有限的工作线程，轮流异步处理无限多的任务（典型实现：线程池）</p>
<p><strong>工作机制</strong>：享元模式，尝试重用现有的同类对象，如果未匹配才创建新对象</p>
<ul>
<li>自定义连接池：</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></div>



]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>juc</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM系列：尚硅谷JVM笔记总和</title>
    <url>//post/58683/</url>
    <content><![CDATA[<h2 id="JVM和Java体系结构"><a href="#JVM和Java体系结构" class="headerlink" title="JVM和Java体系结构"></a>JVM和Java体系结构</h2><h3 id="Java虚拟机"><a href="#Java虚拟机" class="headerlink" title="Java虚拟机"></a>Java虚拟机</h3><p>Java虚拟机（JVM，Java Virtual Machine）：</p>
<ul>
<li>一台执行Java字节码的虚拟计算机，拥有独立的运行机制</li>
<li>转载字节码到内部，解释/编译为对应平台上的机器指令</li>
</ul>
<p>特点：</p>
<ol>
<li><p>一次编译到处运行</p>
</li>
<li><p>自动内存管理</p>
</li>
<li><p>自动垃圾回收</p>
</li>
</ol>
<h3 id="Java代码执流程"><a href="#Java代码执流程" class="headerlink" title="Java代码执流程"></a>Java代码执流程</h3><pre class="mermaid">flowchart LR
    code("Java源码（.java）") --&gt; a("Java（前端）编译器")
    a --&gt; cls("字节码（.class）")
    subgraph Java虚拟机
        direction TB
        类加载器 --&gt; 字节码校验器
        subgraph 执行引擎
            direction TB
            jsq("解释执行（解释器）")
            jit("编译执行（JIT）")
        end
        字节码校验器 --&gt; 执行引擎
    end
    cls --&gt; Java虚拟机
    Java虚拟机 --&gt; 操作系统</pre>

<h3 id="JVM位置"><a href="#JVM位置" class="headerlink" title="JVM位置"></a>JVM位置</h3><p>JVM运行在操作系统之上，与硬件没有直接的交互</p>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/09/05/JetB8N5IzqZirTV.png" alt="68747470733a2f2f6e706d2e656c656d6563646e2e636f6d2f796f7574686c716c40312e302e382f4a564d2f636861707465725f3030312f303031332e706e67" style="zoom:67%;">

<h3 id="JVM整体结构"><a href="#JVM整体结构" class="headerlink" title="JVM整体结构"></a>JVM整体结构</h3><p>HotSpot VM是目前高性能虚拟机代表之一，采用解释器与即使编译器并存的架构</p>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/09/05/Ajv3IeKnNmSpugs.png" alt="68747470733a2f2f6e706d2e656c656d6563646e2e636f6d2f796f7574686c716c40312e302e382f4a564d2f636861707465725f3030312f303031352e706e67" style="zoom: 67%;">

<p><strong>Class loader</strong>：将字节码文件，加载到内存中，生成Class对象</p>
<p><strong>Runtime Data Area</strong>：JVM内存，上一步加载的Class的实例就是存放在方法区中</p>
<p>​	<strong>堆</strong>，<strong>方法区</strong>：多线程共享</p>
<p>​	<strong>虚拟机栈</strong>，<strong>本地方法栈</strong>，<strong>程序计数器栈</strong>：每个线程一份</p>
<p><strong>执行引擎</strong>：解释器，即时编译器（JIT编译器），垃圾回收器</p>
<h3 id="JVM架构模型"><a href="#JVM架构模型" class="headerlink" title="JVM架构模型"></a>JVM架构模型</h3><p>JVM指令集架构为：<strong>基于栈的指令集架构</strong></p>
<h4 id="基于栈的指令集架构"><a href="#基于栈的指令集架构" class="headerlink" title="基于栈的指令集架构"></a>基于栈的指令集架构</h4><ol>
<li>设计和实现简单</li>
<li>避开寄存器分配难题</li>
<li>零地址指令，指令集更小</li>
<li>不需要硬件支持</li>
</ol>
<h4 id="基于寄存器的指令集架构"><a href="#基于寄存器的指令集架构" class="headerlink" title="基于寄存器的指令集架构"></a>基于寄存器的指令集架构</h4><ol>
<li>典型：X86的二进制指令集</li>
<li>指令集架构完全依赖于硬件</li>
<li>性能优秀，执行高效</li>
<li>花费更少指令，去完成一项操作</li>
<li>以一地址指令、二地址指令和三地址指令为主</li>
</ol>
<h4 id="两种架构举例"><a href="#两种架构举例" class="headerlink" title="两种架构举例"></a>两种架构举例</h4><ul>
<li>基于栈的计算流程（以Java虚拟机为例）：</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">iconst_2	// 常量2入栈</span><br><span class="line">istore_1</span><br><span class="line">iconst_3	// 常量3入栈</span><br><span class="line">istore_2</span><br><span class="line">iload_1</span><br><span class="line">iload_2</span><br><span class="line">iadd		// 常量2，3出栈，执行相加</span><br><span class="line">istore_0	// 结果5入栈</span><br></pre></td></tr></table></figure></div>

<ul>
<li>基于寄存器的计算流程</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov eax,2	// 将eax寄存器的值设为1</span><br><span class="line">add eax,3	// 使eax寄存器的值加3</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>考虑跨平台性与移植性，Java指令集都是根据栈来设计的</p>
<ul>
<li><p>优点：跨平台，指令集小，编译器容易实现</p>
</li>
<li><p>缺点：性能比寄存器差一些</p>
</li>
</ul>
</blockquote>
<h3 id="JVM生命周期"><a href="#JVM生命周期" class="headerlink" title="JVM生命周期"></a>JVM生命周期</h3><h4 id="JVM的启动"><a href="#JVM的启动" class="headerlink" title="JVM的启动"></a>JVM的启动</h4><p>通过<strong>引导类加载器</strong>（bootstrap class loader）创建一个<strong>初始类</strong>（initial class）来完成的。这个初始类由虚拟机的具体实现来指定。</p>
<h4 id="JVM的执行"><a href="#JVM的执行" class="headerlink" title="JVM的执行"></a>JVM的执行</h4><ul>
<li>JVM有一个清晰的任务：执行Java程序</li>
<li>程序开始他才运行，程序结束他就停止</li>
</ul>
<h4 id="JVM的退出"><a href="#JVM的退出" class="headerlink" title="JVM的退出"></a>JVM的退出</h4><ol>
<li>程序正常退出</li>
<li>程序遇到异常或错误而停止</li>
<li>操作系统出现错误导致JVM停止</li>
<li>某线程调用了Runtime类或System类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit()或halt()操作</li>
</ol>
<h3 id="JVM发展历程"><a href="#JVM发展历程" class="headerlink" title="JVM发展历程"></a>JVM发展历程</h3><p><strong>Sun Classic VM</strong></p>
<ul>
<li>1996年Java1.0时出现，世界第一款商用Java虚拟机，JDK1.4时被淘汰</li>
<li>只提供解释器</li>
<li>要使用JIT编译器，需要进行外挂，且会完全接管解释器。<ul>
<li>解释器和JIT编译器无法共存</li>
<li>只使用JIT，需要把所有字节码都翻译成机器指令，翻译时间过长。程序启动的时候，等待时间长。</li>
</ul>
</li>
<li>目前Hotspot内置此虚拟机</li>
</ul>
<p><strong>Exact VM</strong></p>
<ul>
<li>JDK1.2时，Sun提供了此虚拟机</li>
<li>虚拟机可以知道内存中某个位置的数据具体是什么类型</li>
<li>具备现代高性能虚拟机的维形<ul>
<li>热点探测（寻找出热点代码进行缓存）</li>
<li>编译器与解释器混合工作模式</li>
</ul>
</li>
<li>只在Solaris平台短暂使用，终被Hotspot虚拟机替换</li>
</ul>
<p><strong>HotSpot VM（重点）</strong></p>
<ul>
<li><p>JDK1.3时，成为oracle JDK和openJDK的默认虚拟机</p>
</li>
<li><p>HotSpot：热点代码探测技术</p>
<ul>
<li>通过计数器，找到最具编译价值代码，触发即时编译或栈上替换</li>
<li>编译器与解释器协同工作</li>
</ul>
</li>
</ul>
<p><strong>JRockit（商用三大虚拟机之一）</strong></p>
<ul>
<li>即时编译器编译后执行</li>
<li>世界上最快的JVM</li>
</ul>
<p><strong>IBM的J9（商用三大虚拟机之一）</strong></p>
<ul>
<li>号称是世界上最快的Java虚拟机</li>
</ul>
<p><strong>KVM和CDC/CLDC Hotspot</strong></p>
<ul>
<li>面向更低端的设备，比如塞班</li>
</ul>
<p><strong>Azul VM</strong></p>
<ul>
<li>与特定硬件平台绑定</li>
</ul>
<p><strong>Liquid VM</strong></p>
<ul>
<li>运行在自家Hypervisor系统上</li>
<li>不需要操作系统的支持，或者说它自己本身实现了一个专用操作系统的必要功能，如线程调度、文件系统、网络支持等</li>
<li>随着JRockit虚拟机终止开发，Liquid vM项目也停止了</li>
</ul>
<p><strong>Apache Marmony</strong></p>
<ul>
<li>并没有Apache Harmony被大规模商用的案例，但是它的Java类库代码吸纳进了Android SDK</li>
</ul>
<p><strong>Micorsoft JVM</strong></p>
<ul>
<li>微软为了在IE3浏览器中支持Java Applets，开发了Microsoft JVM</li>
</ul>
<p><strong>Taobao JVM</strong></p>
<ul>
<li>目前已经在淘宝、天猫上线，把Oracle官方JVM版本全部替换了</li>
</ul>
<p><strong>Dalvik VM</strong></p>
<ul>
<li><p>执行的是编译以后的dex（Dalvik Executable）文件。执行效率比较高</p>
</li>
<li><p>Android 5.0使用支持提前编译（Ahead of Time Compilation，AoT）的ART VM替换Dalvik VM</p>
</li>
</ul>
<p><strong>Graal VM（未来虚拟机）</strong></p>
<ul>
<li>Run Programs Faster Anywhere</li>
<li>跨语言全栈虚拟机：Java，Scala，Groovy，Kotlin，C，C++，JavaScript，Ruby，Python，R</li>
<li><strong>如果说HotSpot有一天真的被取代，Graalvm希望最大</strong></li>
</ul>
<h3 id="课程学习路线"><a href="#课程学习路线" class="headerlink" title="课程学习路线"></a>课程学习路线</h3><pre class="mermaid">graph TB
    类的加载器 ---&gt; 内存结构
    a["class文件结构"] ---&gt; 内存结构
    执行引擎 ---&gt; 内存结构
    内存结构 ---&gt; 内存的分配与回收
    内存的分配与回收 ---&gt; b["性能监控(命令行、可视化工具)"]
    b ---&gt; 性能优化</pre>



<h2 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h2><p>如果想手写一个Java虚拟机的话，需要考虑哪些结构？</p>
<ul>
<li>类加载器（ClassLoader）</li>
<li>执行引擎</li>
</ul>
<h3 id="ClassLoader作用"><a href="#ClassLoader作用" class="headerlink" title="ClassLoader作用"></a>ClassLoader作用</h3><ol>
<li>从文件系统或网络中加载class文件</li>
<li>Class Loader只负责加载，能否运行由执行引擎决定</li>
<li><strong>加载的类信息放在一块称为“方法区”的内存空间</strong>，除此之外，方法区还会存放运行时常量池信息（比如字符串字面量，数字常量）</li>
</ol>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/09/05/AaOQBScjTl1MDXi.png" alt="68747470733a2f2f6e706d2e656c656d6563646e2e636f6d2f796f7574686c716c40312e302e382f4a564d2f636861707465725f3030322f303030342e706e67" style="zoom: 67%;">

<blockquote>
<p>（补充）加载class文件的方式：</p>
<ol>
<li>从本地系统中直接加载</li>
<li>通过网络获取，典型场景：Web Applet</li>
<li>从zip压缩包中读取，成为日后jar、war格式的基础</li>
<li>运行时计算生成，使用最多的是：动态代理技术</li>
<li>由其他文件生成，典型场景：JSP应用从专有数据库中提取.class文件，比较少见</li>
<li>从加密文件中获取，典型的防Class文件被反编译的保护措施</li>
</ol>
</blockquote>
<h3 id="ClassLoader角色"><a href="#ClassLoader角色" class="headerlink" title="ClassLoader角色"></a>ClassLoader角色</h3><ol>
<li>class file存在硬盘上（纸上的模板），最终需要实例化到JVM中（做好的成品）</li>
<li>class file加载到JVM中，被称为DNA元数据模板，放在方法区中</li>
<li>class file -&gt; DNA元数据模板，需要一个运输工具，也即ClassLoader</li>
</ol>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/09/05/lOfkPuNt19VCJDw.png" alt="img" style="zoom:67%;">

<h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><h4 id="阶段一：Loading"><a href="#阶段一：Loading" class="headerlink" title="阶段一：Loading"></a>阶段一：Loading</h4><ol>
<li>通过类全限定名，获取此类的二进制字节流</li>
<li>将字节流所代表的静态存储结构，转化为方法区的运行时数据结构</li>
<li><strong>在内存中生成一个代表此类的java.lang.Class对象</strong></li>
</ol>
<h4 id="阶段二：Linking"><a href="#阶段二：Linking" class="headerlink" title="阶段二：Linking"></a>阶段二：Linking</h4><h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p>确保Class文件的字节流符合要求。主要包含四种验证：文件格式，元数据，字节码，符号引用</p>
<p>举例：字节码文件开头都是CA FE BA BE</p>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/09/05/MObmSnvhLFXudx9.png" alt="68747470733a2f2f6e706d2e656c656d6563646e2e636f6d2f796f7574686c716c40312e302e382f4a564d2f636861707465725f3030322f303030382e706e67" style="zoom: 33%;">

<h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><ol>
<li><p>为类变量（static）分配内存，并设置初始值（零值）</p>
</li>
<li><p>fianl static编译时就分配好了默认值，此时会显式初始化</p>
</li>
<li><p>类变量分配在<strong>方法区中</strong></p>
</li>
</ol>
<p>举例：变量a在准备阶段会赋初始值0。初始化时才会赋值为1</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></div>

<h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><ol>
<li>将常量池内的符号引用转换为直接引用的过程<ul>
<li>符号引用就是一组符号来描述所引用的目标</li>
<li>直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄</li>
</ul>
</li>
</ol>
<p>举例：<code>javap -v Hello.java</code>反编译后，可以查看符号引用，下面带#的就是符号引用</p>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/09/05/kZlznTrOXqBfUKH.png" alt="68747470733a2f2f6e706d2e656c656d6563646e2e636f6d2f796f7574686c716c40312e302e382f4a564d2f636861707465725f3030322f303032332e706e67" style="zoom:67%;">

<h4 id="阶段三：Initialization"><a href="#阶段三：Initialization" class="headerlink" title="阶段三：Initialization"></a>阶段三：Initialization</h4><ol>
<li>就是执行**类构造器方法<code>&lt;clinit&gt;</code>**的过程<ul>
<li>此方法不需要定义，是javac编译器自动收集类中所有<strong>类变量的赋值动作</strong>和<strong>静态代码块中的语句</strong>合并而来的</li>
<li>执行顺序按照语句在<strong>源码中的顺序</strong>执行</li>
<li>如果没有类变量或者static块，就不会有<code>&lt;clinit&gt;</code>方法了</li>
<li>如果该类有父类，会保证父类的<code>&lt;clinit&gt;</code>先执行</li>
<li>虚拟机保证<code>&lt;clinit&gt;</code>方法在多线程下被同步加锁</li>
</ul>
</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        a = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// initialization时执行，第一次赋值</span></span><br><span class="line">        num = <span class="number">100</span>;</span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// linking时创建num变量，并赋零值</span></span><br><span class="line">    <span class="comment">// initialization时执行，第二次赋值，最终num为1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="ClassLoader分类"><a href="#ClassLoader分类" class="headerlink" title="ClassLoader分类"></a>ClassLoader分类</h3><h4 id="引导类加载器（Bootstrap-ClassLoader）"><a href="#引导类加载器（Bootstrap-ClassLoader）" class="headerlink" title="引导类加载器（Bootstrap ClassLoader）"></a>引导类加载器（Bootstrap ClassLoader）</h4><ul>
<li>C/C++实现，在JVM内部</li>
<li>用来加载Java核心库（<code>JAVA_HOME/jre/lib/rt.jar、resources.jar</code>、或<code>sun.boot.class.path</code>路径下的内容）</li>
<li>用来加载扩展类加载器，系统类加载器，并指定为他们的父加载器</li>
<li>只加载包名为java、javax、sun等开头的类</li>
<li>没有父加载器</li>
</ul>
<h4 id="扩展类加载器（Extension-Class-Loader）"><a href="#扩展类加载器（Extension-Class-Loader）" class="headerlink" title="扩展类加载器（Extension Class Loader）"></a>扩展类加载器（Extension Class Loader）</h4><ul>
<li>Java语言编写，派生自ClassLoader类，父类加载器为引导类加载器</li>
<li>从系统属性<code>java.ext.dirs</code>指定的目录加载类库，或从JDK安装目录<code>jre/lib/ext</code>目录下加载类库<ul>
<li>如果用户创建JAR包放入其中，也会自动加载</li>
</ul>
</li>
</ul>
<h4 id="系统类加载器（System-Class-Loader）"><a href="#系统类加载器（System-Class-Loader）" class="headerlink" title="系统类加载器（System Class Loader）"></a>系统类加载器（System Class Loader）</h4><ul>
<li>Java语言编写，派生自ClassLoader类，父类加载器为扩展类加载器</li>
<li>加载环境变量classpath或系统属性java.class.path指定路径下的类库</li>
<li>是程序中的<strong>默认类加载器</strong>，可以<code>ClassLoader.getSystemClassLoader()</code>来获取</li>
</ul>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/09/06/yZrXTF5VfRtUqxQ.jpg" alt="屏幕截图 2023-09-06 154029" style="zoom: 50%;">

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取系统类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">systemClassLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取其上层，扩展类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">extClassLoader</span> <span class="operator">=</span> systemClassLoader.getParent();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取其上层，引导类加载器（为null，无法获取）</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">bootstrpClassLoader</span> <span class="operator">=</span> extClassLoader.getParent();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取用户自定义类的，类加载器（系统类加载器）</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader1</span> <span class="operator">=</span> Test.class.getClassLoader();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取Java核心类的，类加载器（为null，其实是引导类加载器）</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader2</span> <span class="operator">=</span> String.class.getClassLoader();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="自定义加载器（User-Defined-ClassLoader）"><a href="#自定义加载器（User-Defined-ClassLoader）" class="headerlink" title="自定义加载器（User-Defined ClassLoader）"></a>自定义加载器（User-Defined ClassLoader）</h4><ul>
<li>所有派生于抽象类ClassLoader的类加载器</li>
<li>为什么需要自定义类加载器<ul>
<li>隔离加载类（例如：应用的jar包，中间件的jar包不会冲突）</li>
<li>修改类加载的方式</li>
<li>扩展加载源</li>
<li>防止源码泄露</li>
</ul>
</li>
</ul>
<h4 id="自定义类加载器简单实现"><a href="#自定义类加载器简单实现" class="headerlink" title="自定义类加载器简单实现"></a>自定义类加载器简单实现</h4><ul>
<li><p>开发人员可以继承抽象类java.lang.Classloader，实现自己的类加载器</p>
</li>
<li><p>JDK1.2之前，重写loadClass方法；JDK1.2之后，推荐把自定义类加载逻辑写在findClass中</p>
</li>
<li><p>如果没有太复杂的需求，可以直接继承URLClassLoader，避免去编写findClass()方法及其获取字节流的方式</p>
</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">byte</span>[] result = getClassFromCustomPath(name);</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FileNotFoundException</span>();</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">return</span> defineClass(name, result, <span class="number">0</span>, result.length);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (FileNotFoundException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(name);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] getClassFromCustomPath(String name) {</span><br><span class="line">        <span class="comment">// 从自定义路径中加载指定的类，细节略</span></span><br><span class="line">        <span class="comment">// 如果字节码文件进行了加密，需要在此进行解密</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="ClassLoader常用方法"><a href="#ClassLoader常用方法" class="headerlink" title="ClassLoader常用方法"></a>ClassLoader常用方法</h3><table>
<thead>
<tr>
<th>方法名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>getParent()</td>
<td>返回该类加载器的父·类加载器</td>
</tr>
<tr>
<td>loadClass(String name)</td>
<td>加载名称为name的类，返回java.lang.Class类的实例</td>
</tr>
<tr>
<td>findClass(String name)</td>
<td>查找名称为name的类，返回java.lang.Class类的实例</td>
</tr>
<tr>
<td>findLoadedClass(String name)</td>
<td>查找名称为name的已被加载过的类，返回java.lang.Class类实例</td>
</tr>
<tr>
<td>defineClass(String name, byte[] b, int off, int len)</td>
<td>把字节数组中的内容转换为一个Java类，返回java.lang.Class类实例</td>
</tr>
<tr>
<td>resolveClass(Class&lt;?&gt; c)</td>
<td>连接指定的一个Java类</td>
</tr>
</tbody></table>
<p>获取ClassLoader的方法</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>clazz.getClassLoader()</td>
<td>当前类的ClassLoader</td>
</tr>
<tr>
<td>Thread.currentThread().getContextClassLoader()</td>
<td>当前线程上下文的ClassLoader</td>
</tr>
<tr>
<td>ClassLoader.getSystemClassLoader()</td>
<td>系统的ClassLoader</td>
</tr>
<tr>
<td>DriverManager.getCallerClassLoader()</td>
<td>调用者的ClassLoader</td>
</tr>
</tbody></table>
<h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>JVM对Class文件采用的是<strong>按需加载</strong>方式。加载某个类的class文件时，JVM采用的是<strong>双亲委派机制</strong>，即把请求交给父类处理。</p>
<p><strong>思考问题</strong>：假如我们创建一个java.lang.String类，<code>new String()</code>会被影响吗？</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> {</span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p><strong>答</strong>：<code>java.lang.String</code>由引导类加载器加载，根据双亲委派机制，不会被影响</p>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ol>
<li>类加载器收到了类加载请求，不会直接去执行，而是委托父类的加载器去执行</li>
<li>父类如果还有父类，则进一步向上委托</li>
<li>如果父类加载器可以加载，就成功返回；不能加载，子加载器才会尝试加载</li>
</ol>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/09/06/KXkRve4tj83pVIc.png" alt="68747470733a2f2f6e706d2e656c656d6563646e2e636f6d2f796f7574686c716c40312e302e382f4a564d2f636861707465725f3030322f303032302e706e67" style="zoom:50%;">

<h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul>
<li>避免类的重复加载</li>
<li>保护程序安全：防止核心API被篡改<ul>
<li>java.lang.String：不会被篡改</li>
<li>java.lang.MyTest：无法添加（因为包名java开头，引导类加载器不会加载）</li>
</ul>
</li>
</ul>
<h4 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>加载<code>java.lang.String</code>时，会率先使用引导类加载器。引导类加载器会先加载jdk自带的文件（rt.jar包中的java\lang\String.class）</p>
<p>报错信息说：没有main方法</p>
<p>这样可以保证对java核心源代码的保护，这就是<strong>沙箱安全机制</strong></p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>在JVM中两个class对象是否为同一个？</p>
<ul>
<li><p>类的完整类名必须一致，包括包名</p>
</li>
<li><p>加载这个类的ClassLoader（指ClassLoader实例对象）必须相同</p>
</li>
</ul>
<p>JVM必须知道一个类型是由启动加载器加载的，还是由用户类加载器加载的</p>
<ul>
<li>如果是用户类加载器加载的，那么JVM会<strong>将这个类加载器的引用作为类型信息的一部分，存放在方法区中</strong></li>
<li>当解析一个类型到另一个类型的引用时，JVM需要<strong>保证这两个类型的类加载器是相同的</strong></li>
</ul>
<p>Java程序对类的使用分为主动使用和被动使用</p>
<ul>
<li>主动使用</li>
</ul>
<table>
<thead>
<tr>
<th>加载时机</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>创建实例</td>
<td>创建类的实例</td>
</tr>
<tr>
<td>静态变量</td>
<td>访问（或赋值）类或接口的静态变量</td>
</tr>
<tr>
<td>静态方法</td>
<td>调用静态方法</td>
</tr>
<tr>
<td>反射</td>
<td>反射，如：<code>Class.forName(“com.example.Test”)</code></td>
</tr>
<tr>
<td>初始化子类</td>
<td>初始化一个类的子类</td>
</tr>
<tr>
<td>指明为启动类</td>
<td>JVM启动时被标明为启动类的类</td>
</tr>
<tr>
<td>动态语言支持</td>
<td>JDK7开始提供的动态语言支持：<br>java.lang.invoke.MethodHandle实例的解析结果：<br>REF_getStatic、REF putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化</td>
</tr>
</tbody></table>
<ul>
<li>被动使用：其他对类的使用都是被动使用，不会导致类的初始化（Initialization）</li>
</ul>
<h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><h3 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h3><p>不同的JVM对于内存的划分方式和管理机制存在着部分差异。我们结合JVM虚拟机规范，来探讨一下经典的JVM内存布局</p>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/09/07/bWFewzgZTImoN3f.png" alt="img" style="zoom: 67%;">

<table>
<thead>
<tr>
<th>内存区域</th>
<th>生命周期</th>
</tr>
</thead>
<tbody><tr>
<td>方法区，堆（图中棕色）</td>
<td>一个进程只有一份，生命周期与进程对应</td>
</tr>
<tr>
<td>程序计数器，本地方法栈，虚拟机栈（图中灰色）</td>
<td>每个线程一份，生命周期与线程对应</td>
</tr>
</tbody></table>
<p><strong>Runtime类</strong>：运行时环境，也即被框出来的部分。每个JVM只有一个Runtime实例</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h4><ol>
<li>在Hotspot JVM中，每个线程都与本地线程直接映射<ul>
<li>当一个Java线程准备好执行后，一个操作系统线程也同时创建</li>
<li>Java线程执行终止后，本地线程也会回收</li>
</ul>
</li>
<li>操作系统会将线程调度到任何可用CPU上。一旦本地线程创建成功，就会调用Java线程中的run()方法</li>
</ol>
<h4 id="JVM系统线程"><a href="#JVM系统线程" class="headerlink" title="JVM系统线程"></a>JVM系统线程</h4><p>除了main线程和main创建的线程外，还有很多后台线程（简单了解下）：</p>
<ul>
<li>虚拟机线程：JVM达到安全点才会出现</li>
<li>周期任务线程</li>
<li>GC线程</li>
<li>编译线程</li>
<li>信号调度线程</li>
</ul>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><h3 id="PC-Register介绍"><a href="#PC-Register介绍" class="headerlink" title="PC Register介绍"></a>PC Register介绍</h3><p>程序计数寄存器（Program Counter Register），并非物理意义上的寄存器，而是一种抽象模拟</p>
<ul>
<li><strong>作用</strong>：用来指向下一条指令的地址</li>
<li>它是一块很小的内存空间，运行速度最快</li>
<li>每个线程都有自己的PC计数器，生命周期与线程一致</li>
<li>一个线程只会有一个方法在执行，也即<strong>当前方法</strong><ul>
<li>PC计数器会存储当前线程正在执行的Java方法的JVM指令地址</li>
<li>如果是native方法，则是未指定值（undefined）</li>
</ul>
</li>
<li>它是程序控制流的指示器<ul>
<li>分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成</li>
</ul>
</li>
<li>解释器工作时，改变这个计数器的值，来选取下一条需要执行的指令</li>
<li>在JVM中，唯一没有规定任何OutofMemoryError情况的区域</li>
</ul>
<h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><ul>
<li>源代码</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + j;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">"abc"</span>;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>javap -verbose Test.class</code>反编译（部分代码）</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 0: bipush        10</span><br><span class="line"> 2: istore_1</span><br><span class="line"> 3: bipush        20</span><br><span class="line"> 5: istore_2</span><br><span class="line"> 6: iload_1</span><br><span class="line"> 7: iload_2</span><br><span class="line"> 8: iadd</span><br><span class="line"> 9: istore_3</span><br><span class="line">10: ldc           #7                  // String abc</span><br><span class="line">12: astore        4</span><br><span class="line">14: getstatic     #9                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">17: aload         4</span><br><span class="line">19: invokevirtual #15                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">22: return</span><br></pre></td></tr></table></figure></div>

<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/09/07/RfOXPJUYgVILtCT.png" alt="68747470733a2f2f6e706d2e656c656d6563646e2e636f6d2f796f7574686c716c40312e302e382f4a564d2f636861707465725f3030332f303030392e706e67"></p>
<h3 id="两个面试问题"><a href="#两个面试问题" class="headerlink" title="两个面试问题"></a>两个面试问题</h3><p><strong>为什么使用 PC 寄存器来记录当前线程的执行地址？</strong></p>
<ol>
<li>CPU会不断切换各线程，切换回来后，需要知道从哪里继续</li>
<li>JVM字节码解释器需要通过改变PC寄存器的值，来明确下一条应该执行的指令</li>
</ol>
<p><strong>PC寄存器为什么被设定为私有的？</strong></p>
<ol>
<li>CPU会不断做任务切换，必然导致线程中断和恢复</li>
<li>为了准确记录各线程当前执行的字节码地址，最好为每个线程都分配一个PC寄存器</li>
</ol>
<h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><h3 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h3><ul>
<li><strong>Java虚拟机栈是什么？</strong></li>
</ul>
<p>​	Java虚拟机栈（Java Virtual Machine Stack），也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），<strong>对应着一次次的Java方法调用</strong>，栈是线程私有的</p>
<ul>
<li><p><strong>虚拟机栈的生命周期</strong></p>
<p>生命周期和线程一致</p>
</li>
</ul>
<h3 id="虚拟机栈的特点"><a href="#虚拟机栈的特点" class="headerlink" title="虚拟机栈的特点"></a>虚拟机栈的特点</h3><ul>
<li>快速有效，访问速度仅次于PC寄存器</li>
<li>JVM对虚拟机栈的操作只有两个<ul>
<li>方法执行，对应<strong>入栈</strong></li>
<li>方法结束，对应<strong>出栈</strong></li>
</ul>
</li>
<li>栈不存在垃圾回收问题<ul>
<li>栈不需要GC，但是可能存在OOM</li>
</ul>
</li>
</ul>
<h3 id="虚拟机栈的异常"><a href="#虚拟机栈的异常" class="headerlink" title="虚拟机栈的异常"></a>虚拟机栈的异常</h3><p>Java规定虚拟机栈的大小是动态或者固定不变的</p>
<ul>
<li>如果固定大小：每个线程的虚拟机栈可以在创建时设定，执行时如果超过，JVM将抛出<code>StackOverflowError</code>异常</li>
<li>如果动态扩展：扩展时无法获</li>
<li>得足够内存，或创建时无法获取足够内存创建，JVM将抛出<code>OutofMemoryError</code>异常</li>
</ul>
<h3 id="设置栈大小"><a href="#设置栈大小" class="headerlink" title="设置栈大小"></a>设置栈大小</h3><p>使用-Xss选项，在VM options中设定</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Xss1m</span><br><span class="line">-Xss1024k</span><br><span class="line">-Xss1048576</span><br></pre></td></tr></table></figure></div>

<h3 id="栈的存储单元"><a href="#栈的存储单元" class="headerlink" title="栈的存储单元"></a>栈的存储单元</h3><p><strong>栈中存储什么？</strong></p>
<ol>
<li>每个线程都有自己的栈，栈中数据以<strong>栈帧</strong>（Stack Frame）的格式存在</li>
<li>正在执行的方法，都对应一个栈帧（Stack Frame）</li>
<li>栈帧是一个内存区块，维系着方法执行过程中的各种数据信息</li>
</ol>
<p><strong>栈运行原理</strong></p>
<ol>
<li>JVM对虚拟机栈只能进行<strong>压栈和出栈</strong></li>
<li>一个线程中，只能有一个活动的栈帧<ul>
<li><strong>当前栈帧（Current Frame）</strong></li>
<li><strong>当前方法（Current Method）</strong></li>
<li><strong>当前类（Current Class）</strong></li>
</ul>
</li>
<li>执行引擎运行的字节码指令只针对当前栈帧</li>
<li>如果该方法调用了其他方法，会创建新的栈帧，放在栈顶，成为新的当前帧<ul>
<li>方法返回时，当前栈帧会传回执行结果给前一个栈帧。虚拟机丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧</li>
</ul>
</li>
<li>不同线程的栈帧之间，不允许相互引用</li>
<li>Java方法有两种返回方式<ul>
<li>正常返回：使用return指令</li>
<li>异常返回：执行中出现未捕获的异常</li>
</ul>
</li>
</ol>
<p><strong>栈帧内部结构</strong></p>
<ul>
<li>局部变量表（Local Variables）</li>
<li>操作数栈（Operand Stack）（或表达式栈）</li>
<li>动态链接（Dynamic Linking）（或指向运行时常量池的方法引用）</li>
<li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</li>
<li>一些附加信息</li>
</ul>
<h3 id="局部变量表（Local-Variables）"><a href="#局部变量表（Local-Variables）" class="headerlink" title="局部变量表（Local Variables）"></a>局部变量表（Local Variables）</h3><ol>
<li><strong>定义为一个数字数组，存储方法参数和局部变量</strong><ul>
<li>数据类型包括：基本数据类型、对象引用（reference）、returnAddress返回值类型</li>
</ul>
</li>
<li>线程的私有数据，<strong>不存在数据安全问题</strong></li>
<li><strong>容量大小在编译期就确定下来</strong>，保存在字节码中：方法的Code属性的<strong>maximum local variables</strong>数据项中</li>
<li>只在当前方法中有效</li>
</ol>
<h4 id="Slot的理解"><a href="#Slot的理解" class="headerlink" title="Slot的理解"></a>Slot的理解</h4><ol>
<li>局部变量表，最基础的存储单位是Slot</li>
<li>32位的变量占一个Slot，64位的占两个<ul>
<li>byte，char，short，boolean存储前都转换位int</li>
<li>long，double占两个slot</li>
</ul>
</li>
<li>局部变量表每个Slot都有一个索引（从0开始），通过索引即可访问变量值<ul>
<li>64位变量使用前一个索引访问即可</li>
</ul>
</li>
<li>方法被调用时，方法参数和局部变量，将会<strong>按照顺序被复制</strong>到局部变量表的每一个slot上</li>
<li>如果是构造方法或实例方法，<strong>this将被存放在index为0的slot处</strong></li>
</ol>
<h4 id="Slot的重复利用"><a href="#Slot的重复利用" class="headerlink" title="Slot的重复利用"></a>Slot的重复利用</h4><p>一个栈帧中的Slot可以重复利用。一个局部变量过了其作用域，新的局部变量可以使用之前的槽位</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> {</span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 使用之前的槽位</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="操作数栈（Operand-Stack）"><a href="#操作数栈（Operand-Stack）" class="headerlink" title="操作数栈（Operand Stack）"></a>操作数栈（Operand Stack）</h3><p>也被称为：表达式栈</p>
<h4 id="操作数栈的作用"><a href="#操作数栈的作用" class="headerlink" title="操作数栈的作用"></a>操作数栈的作用</h4><ol>
<li>主要用于<strong>保存计算中间结果</strong>，同时作为变量临时存储的空间</li>
<li>可以视为JVM执行引擎的工作区。方法开始执行时，新的栈帧也随之创建，此时方法操作数栈是空的</li>
<li>操作数栈有明确的栈深度，所需最大深度在编译期就已定义好了，保存在字节码中方法的Code属性中（maxstack）</li>
<li>栈中的元素可以是任意Java类型<ul>
<li>32bit类型占一个栈深度</li>
<li>64bit类型占两个栈深度</li>
</ul>
</li>
<li>如果被调用函数有返回值，其返回值会被压入当前栈帧的操作数栈中<ul>
<li>然后更新PC寄存器中下一条要执行的指令</li>
</ul>
</li>
<li>操作数栈中的元素数据类型，必须与字节码指令的序列严格匹配<ul>
<li>在编译阶段，编译器验证</li>
<li>在类加载过程中，类检验阶段（Linking-检验）的数据流分析阶段再次检验</li>
</ul>
</li>
</ol>
<h4 id="举例说明-1"><a href="#举例说明-1" class="headerlink" title="举例说明"></a>举例说明</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + j;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 0 bipush 15</span><br><span class="line"> 2 istore_1</span><br><span class="line"> 3 bipush 8</span><br><span class="line"> 5 istore_2</span><br><span class="line"> 6 iload_1</span><br><span class="line"> 7 iload_2</span><br><span class="line"> 8 iadd</span><br><span class="line"> 9 istore_3</span><br><span class="line">10 return</span><br></pre></td></tr></table></figure></div>

<ol>
<li>第一条指令，PC寄存器指向0。使用bipush让操作数15入操作数栈</li>
</ol>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/09/18/WkVuarNAOTFi46q.png" alt="68747470733a2f2f6e706d2e656c656d6563646e2e636f6d2f796f7574686c716c40312e302e382f4a564d2f636861707465725f3030342f303032322e706e67" style="zoom:67%;">

<ol start="2">
<li>PC寄存器+1，指向下一行代码。使用istore_1将操作数栈的元素存储到局部变量表1的位置（局部变量表0存的是this）</li>
</ol>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/09/18/o5JPf8XtK76edkB.png" alt="68747470733a2f2f6e706d2e656c656d6563646e2e636f6d2f796f7574686c716c40312e302e382f4a564d2f636861707465725f3030342f303032332e706e67" style="zoom:67%;">

<ol start="3">
<li>同理，bipush将操作数8入栈，istore_2将操作数栈的元素存储到局部变量表2的位置</li>
</ol>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/09/18/dvxuT5UpEjiOtaR.png" alt="68747470733a2f2f6e706d2e656c656d6563646e2e636f6d2f796f7574686c716c40312e302e382f4a564d2f636861707465725f3030342f303032342e706e67" style="zoom: 50%;">

<ol start="4">
<li>使用iload_1，iload_2，从局部变量表中取出两个操作数，放入栈中</li>
</ol>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/09/18/9UFHTDfXl1zbEC5.png" alt="68747470733a2f2f6e706d2e656c656d6563646e2e636f6d2f796f7574686c716c40312e302e382f4a564d2f636861707465725f3030342f303032352e706e67" style="zoom: 50%;">

<ol start="5">
<li>使用iadd，将操作数栈顶端两个元素相加，然后入栈。再使用istore_3将其存储在变量表3的位置</li>
</ol>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/09/18/1NaniqC8JBv52DI.png" alt="68747470733a2f2f6e706d2e656c656d6563646e2e636f6d2f796f7574686c716c40312e302e382f4a564d2f636861707465725f3030342f303032362e706e67" style="zoom:50%;">

<h5 id="关于类型转换"><a href="#关于类型转换" class="headerlink" title="关于类型转换"></a>关于类型转换</h5><blockquote>
<p><code>int j = 8;</code></p>
<ul>
<li><p>8可以存储在byte类型中，所以压入栈的类型为byte（bipush 8）</p>
</li>
<li><p>存储为局部变量时，会转为int类型（istore_4）</p>
</li>
</ul>
<p><code>int j = 800;</code></p>
<ul>
<li>byte存储不了，改为short型（sipush 800）</li>
</ul>
</blockquote>
<h5 id="关于返回值的问题"><a href="#关于返回值的问题" class="headerlink" title="关于返回值的问题"></a>关于返回值的问题</h5><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetSum</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> getSum();</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>getSum()</code>方法字节码指令，最后带着ireturn</li>
</ul>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/09/18/f3HB95QvzNMLxgo.png" alt="image-20230918140426188" style="zoom:50%;">

<ul>
<li><code>testGetSum()</code>方法字节码指令，一上来就加载<code>getSum()</code>方法的返回值</li>
</ul>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/09/18/IKbu7k8s4qladrz.png" alt="image-20230918140524097" style="zoom:50%;">

<h4 id="栈顶缓存技术"><a href="#栈顶缓存技术" class="headerlink" title="栈顶缓存技术"></a>栈顶缓存技术</h4><p>HotSpot JVM的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术</p>
<ul>
<li>将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率</li>
</ul>
<h3 id="动态链接（Dynamic-Linking）"><a href="#动态链接（Dynamic-Linking）" class="headerlink" title="动态链接（Dynamic Linking）"></a>动态链接（Dynamic Linking）</h3><ul>
<li>每个栈帧中都包含一个：指向常量池中，该方法的引用<ul>
<li>包含这个引用的目的，就是为了实现动态链接（Dynamic Linking）</li>
</ul>
</li>
<li>在字节码文件中，所有变量和方法的引用都作为符号引用（Symbolic Reference）保存在class文件的常量池中<ul>
<li>比如：调用一个方法，就是通过常量池中指向方法的符号引用来表示的</li>
<li>动态链接作用就是为了将这些<strong>符号引用</strong>转换为<strong>直接引用</strong></li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> {</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"A"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"B"</span>);</span><br><span class="line">        methodA();</span><br><span class="line">        num++;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 字节码中的常量池</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #2.#3          // java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">   #2 = Class              #4             // java/lang/Object</span><br><span class="line">   #3 = NameAndType        #5:#6          // "&lt;init&gt;":()V</span><br><span class="line">   #4 = Utf8               java/lang/Object</span><br><span class="line">   #5 = Utf8               &lt;init&gt;</span><br><span class="line">   #6 = Utf8               ()V</span><br><span class="line">   #7 = Fieldref           #8.#9          // org/example/Test.num:I</span><br><span class="line">   #8 = Class              #10            // org/example/Test</span><br><span class="line">   #9 = NameAndType        #11:#12        // num:I</span><br><span class="line">  #10 = Utf8               org/example/Test</span><br><span class="line">  #11 = Utf8               num</span><br><span class="line">  #12 = Utf8               I</span><br><span class="line">  #13 = Methodref          #8.#3          // org/example/Test."&lt;init&gt;":()V</span><br><span class="line">  #14 = Methodref          #8.#15         // org/example/Test.methodB:()V</span><br><span class="line">  #15 = NameAndType        #16:#6         // methodB:()V</span><br><span class="line">  #16 = Utf8               methodB</span><br><span class="line">  #17 = Fieldref           #18.#19        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">  #18 = Class              #20            // java/lang/System</span><br><span class="line">  #19 = NameAndType        #21:#22        // out:Ljava/io/PrintStream;</span><br><span class="line">  #20 = Utf8               java/lang/System</span><br><span class="line">  #21 = Utf8               out</span><br><span class="line">  #22 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #23 = String             #24            // A</span><br><span class="line">  #24 = Utf8               A</span><br><span class="line">  #25 = Methodref          #26.#27        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">  #26 = Class              #28            // java/io/PrintStream</span><br><span class="line">  #27 = NameAndType        #29:#30        // println:(Ljava/lang/String;)V</span><br><span class="line">  #28 = Utf8               java/io/PrintStream</span><br><span class="line">  #29 = Utf8               println</span><br><span class="line">  #30 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">  #31 = String             #32            // B</span><br><span class="line">  #32 = Utf8               B</span><br><span class="line">  #33 = Methodref          #8.#34         // org/example/Test.methodA:()V</span><br><span class="line">  #34 = NameAndType        #35:#6         // methodA:()V</span><br><span class="line">  #35 = Utf8               methodA</span><br><span class="line">  #36 = Utf8               Code</span><br><span class="line">  #37 = Utf8               LineNumberTable</span><br><span class="line">  #38 = Utf8               LocalVariableTable</span><br><span class="line">  #39 = Utf8               this</span><br><span class="line">  #40 = Utf8               Lorg/example/Test;</span><br><span class="line">  #41 = Utf8               main</span><br><span class="line">  #42 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #43 = Utf8               args</span><br><span class="line">  #44 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #45 = Utf8               test</span><br><span class="line">  #46 = Utf8               SourceFile</span><br><span class="line">  #47 = Utf8               Test.java</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 字节码中methodB的Code</span><br><span class="line"></span><br><span class="line"> 0 getstatic #17		&lt;java/lang/System.out : Ljava/io/PrintStream;&gt;</span><br><span class="line"> 3 ldc #31 				&lt;B&gt;</span><br><span class="line"> 5 invokevirtual #25 	&lt;java/io/PrintStream.println : (Ljava/lang/String;)V&gt;</span><br><span class="line"> 8 aload_0</span><br><span class="line"> 9 invokevirtual #33 	&lt;org/example/Test.methodA : ()V&gt;</span><br><span class="line">12 aload_0</span><br><span class="line">13 dup</span><br><span class="line">14 getfield #7 			&lt;org/example/Test.num : I&gt;</span><br><span class="line">17 iconst_1</span><br><span class="line">18 iadd</span><br><span class="line">19 putfield #7 			&lt;org/example/Test.num : I&gt;</span><br><span class="line">22 return</span><br></pre></td></tr></table></figure></div>

<ol>
<li><p>methodB()方法通过<code>invokevirtual #33</code>调用了方法A</p>
</li>
<li><p>常量池中：<code>#33 = Methodref #8.#34</code></p>
<ul>
<li><code>#8 = Class #10</code><ul>
<li><code>#10 = Utf8 org/example/Test</code>，找到了类名</li>
</ul>
</li>
<li><code>#34 = NameAndType #35:#6</code><ul>
<li><code>#35 = Utf8 methodA</code>，找到了方法名</li>
<li><code>#6 = Utf8  ()V</code>，方法没有形参，返回值为void</li>
</ul>
</li>
</ul>
</li>
<li><p>结论：通过#33，我们找到了需要调用的methodA()方法，并进行调用</p>
</li>
</ol>
<h3 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h3><h4 id="方法绑定机制"><a href="#方法绑定机制" class="headerlink" title="方法绑定机制"></a>方法绑定机制</h4><p>在JVM中，将被调用方法的<strong>符号引用</strong>转换为<strong>直接引用</strong>，与方法的绑定机制相关</p>
<ul>
<li>静态链接（方法的绑定机制：早期绑定）<ul>
<li>被调用的目标方法在编译期可知，将调用方法的符号引用转换为直接引用</li>
</ul>
</li>
<li>动态链接（方法的绑定机制：晚期绑定）<ul>
<li>如果在编译器无法确定，只能在程序运行期，将符号引用转换为直接引用</li>
</ul>
</li>
</ul>
<h4 id="具体例子"><a href="#具体例子" class="headerlink" title="具体例子"></a>具体例子</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> <span class="keyword">implements</span> <span class="title class_">Huntable</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 1 invokespecial #1 &lt;org/example/Animal.&lt;init&gt; : ()V&gt;</span></span><br><span class="line">        <span class="comment">// 表现为：早期绑定</span></span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(String name)</span> {</span><br><span class="line">        <span class="comment">// 1 invokespecial #7 &lt;org/example/Cat.&lt;init&gt; : ()V&gt;</span></span><br><span class="line">        <span class="comment">// 表现为：早期绑定</span></span><br><span class="line">        <span class="built_in">this</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnimalTest</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showAnimal</span><span class="params">(Animal animal)</span> {</span><br><span class="line">        <span class="comment">// 1 invokevirtual #7 &lt;org/example/Animal.eat : ()V&gt;</span></span><br><span class="line">        <span class="comment">// 表现为：晚期绑定</span></span><br><span class="line">        animal.eat();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showHunt</span><span class="params">(Huntable h)</span> {</span><br><span class="line">        <span class="comment">// 1 invokeinterface #12 &lt;org/example/Huntable.hunt : ()V&gt; count 1</span></span><br><span class="line">        <span class="comment">// 表现为：晚期绑定</span></span><br><span class="line">        h.hunt();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="虚方法与非虚方法"><a href="#虚方法与非虚方法" class="headerlink" title="虚方法与非虚方法"></a>虚方法与非虚方法</h4><p>多态使用的前提：① 类的继承； ② 方法的重写</p>
<ul>
<li>Java中任何一个方法都具备虚函数的特征<ul>
<li>相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）</li>
</ul>
</li>
<li>不希望方法拥有虚函数的特征时，可以使用关键字final来标记</li>
</ul>
<blockquote>
<p><strong>虚方法与非虚方法：</strong></p>
<p>非虚方法</p>
<ul>
<li>编译器就确定了具体的调用版本，运行时不可变</li>
<li>如：静态方法，私有方法，final方法，实例构造器，父类方法</li>
</ul>
<p>虚方法</p>
<ul>
<li>其他所有方法，都是虚方法</li>
</ul>
</blockquote>
<h4 id="普通指令与动态指令"><a href="#普通指令与动态指令" class="headerlink" title="普通指令与动态指令"></a>普通指令与动态指令</h4><p>普通指令</p>
<ul>
<li>invokestatic：调用静态方法，(早期绑定)</li>
<li>invokespecial：调用唯一确认的方法，(早期绑定)</li>
<li>invokevirtual：调用虚方法，(晚期绑定，但是final方法例外)</li>
<li>invokeinterface：调用接口方法，(晚期绑定)</li>
</ul>
<p>动态指令</p>
<ul>
<li>invokedynamic：动态解析出需要调用的方法<ul>
<li>Java7出现</li>
<li>Java8开始有用（Lambda表达式）</li>
</ul>
</li>
</ul>
<blockquote>
<p>动态类型语言 VS 静态类型语言</p>
<ul>
<li>静态类型：判断变量自身的类型</li>
<li>动态类型：变量没有类型信息，变量值才有类型信息</li>
</ul>
</blockquote>
<p><strong>体验动态指令</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Func</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">func</span><span class="params">(String str)</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lambda</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lambda</span><span class="params">(Func func)</span> {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Lambda</span> <span class="variable">lambda</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lambda</span>();</span><br><span class="line">        <span class="comment">// 根据值来确认类型</span></span><br><span class="line">        <span class="type">Func</span> <span class="variable">func</span> <span class="operator">=</span> s -&gt; {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        };</span><br><span class="line">        lambda.lambda(func);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/09/19/ndUfaDpItv5hVs4.png" alt="image-20230919152320322"></p>
<h4 id="方法重写的本质"><a href="#方法重写的本质" class="headerlink" title="方法重写的本质"></a>方法重写的本质</h4><p><strong>当我们执行对象的方法时（如果是虚方法）：</strong></p>
<ol>
<li>对象压入操作数栈</li>
<li>找到操作数栈顶元素的实际类型（记作C）</li>
<li>如果C中找到与常量池中相符的方法，则进行访问权限校验<ul>
<li>通过，返回方法的直接引用，查找结束</li>
<li>不通过，返回<code>java.lang.IllegalAccessError</code>异常</li>
</ul>
</li>
<li>如果找不到相符的方法，按照继承关系依次找</li>
<li>如果最终依然找不到，抛出<code>java.lang.AbstractMethodError</code>异常</li>
</ol>
<p><strong>提升性能：</strong></p>
<ul>
<li>如果每次都要向上层找（动态分派），十分影响效率</li>
<li>JVM会在类的方法区建立一个<strong>虚方法表</strong>（virtual method table）（非虚的方法不会在表中），使用索引表来代替查找。<ul>
<li>每个类都有一个虚方法表，存放虚方法的实际入口</li>
<li><strong>创建时间</strong>：类加载的Linking阶段。类变量初始值准备完成后，JVM会把类的方法表也初始化完毕</li>
</ul>
</li>
<li>虚方法表的例子：</li>
</ul>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/09/20/sv7q8N6G2zBOZDJ.png" alt="image-20230920165158276" style="zoom:50%;">

<h3 id="方法返回地址（return-address）"><a href="#方法返回地址（return-address）" class="headerlink" title="方法返回地址（return address）"></a>方法返回地址（return address）</h3><ol>
<li>存放<strong>调用方PC寄存器的值</strong></li>
<li>无论有无异常，方法退出后都返回到该方法被调用的位置<ul>
<li>方法正常退出：调用方PC寄存器的下一条指令的地址，作为返回地址</li>
<li>方法异常退出：返回地址通过异常表来确定，栈帧中不会有这部分信息</li>
</ul>
</li>
<li>方法退出其实就是当前栈帧出栈的过程<ul>
<li>需要恢复上层方法的：局部变量表，操作数栈</li>
<li>还需：将返回值压入调用者操作数栈，设置PC寄存器</li>
</ul>
</li>
<li>正常完成和异常完成的区别在于：异常完成不会给上级调用者产生任何返回值</li>
</ol>
<p><strong>只有两种方式可以退出方法：</strong></p>
<ol>
<li>正常完成出口：执行引擎遇到方法返回的字节码指令（return），会有返回值传递给上层的方法调用者<ul>
<li>返回不同类型的值，字节码指令不同：<ul>
<li>ireturn（boolean，byte，char，short，int）</li>
<li>lreturn</li>
<li>freturn</li>
<li>dreturn</li>
<li>areturn</li>
<li>return（void，实例初始化方法<init>，类和接口初始化方法<cinit>）</cinit></init></li>
</ul>
</li>
</ul>
</li>
<li>异常完成出口：方法执行过程中遇到了异常，且方法内无法处理<ul>
<li>异常处理，存储在一个异常处理表中，方便在发生异常的时候找到处理异常的代码</li>
</ul>
</li>
</ol>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/09/21/6LRU7jJXrSFzto8.png" alt="image-20230921192724180" style="zoom:50%;">

<blockquote>
<p>4-16行字节码出了异常，就按照19行字节码指令进行处理，针对任何异常类型</p>
</blockquote>
<h3 id="栈帧中的一些附加信息"><a href="#栈帧中的一些附加信息" class="headerlink" title="栈帧中的一些附加信息"></a>栈帧中的一些附加信息</h3><p>栈帧中允许携带与Java虚拟机实现相关的一些附加信息。如：对程序调试提供支持的信息</p>
<h3 id="虚拟机栈的5道面试题"><a href="#虚拟机栈的5道面试题" class="headerlink" title="虚拟机栈的5道面试题"></a>虚拟机栈的5道面试题</h3><p><strong>举例栈溢出的情况？</strong></p>
<ul>
<li>StackOverflowError，可以通过-Xss设置栈的大小</li>
</ul>
<p><strong>调整栈大小，就能保证不溢出吗？</strong></p>
<ul>
<li>不能，比如以前递归5000次StackOverflowError，现在调大栈的大小，可能7000次才会StackOverflowError。调大只会保证出现晚一些，无法一定保证不会溢出</li>
</ul>
<p><strong>分配的栈内存越大越好吗？</strong></p>
<ul>
<li>不是的，会挤占其他的内存空间（比如影响线程的数量）</li>
</ul>
<p><strong>垃圾回收是否会涉及到虚拟机栈？</strong></p>
<ul>
<li>不涉及</li>
</ul>
<p><strong>方法中定义的局部变量是否线程安全？</strong></p>
<ul>
<li>如果对象在方法内部产生，内部消亡，则是线程安全的；反之线程不安全</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// s1是线程安全的（只在方法内部用了）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    s1.append(<span class="string">"a"</span>);</span><br><span class="line">    s1.append(<span class="string">"b"</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// s1是线程不安全的（作为参数传进来，可能被其它线程操作）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(StringBuilder s1)</span>{</span><br><span class="line">    s1.append(<span class="string">"a"</span>);</span><br><span class="line">    s1.append(<span class="string">"b"</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// s1是线程不安全的（有返回值，可能被其它线程操作）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title function_">method3</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    s1.append(<span class="string">"a"</span>);</span><br><span class="line">    s1.append(<span class="string">"b"</span>);</span><br><span class="line">    <span class="keyword">return</span> s1;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// s1是线程安全的（s1自己消亡了，最后返回的只是s1.toString的一个新对象）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">method4</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    s1.append(<span class="string">"a"</span>);</span><br><span class="line">    s1.append(<span class="string">"b"</span>);</span><br><span class="line">    <span class="keyword">return</span> s1.toString();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="本地方法接口"><a href="#本地方法接口" class="headerlink" title="本地方法接口"></a>本地方法接口</h2><h3 id="什么是本地方法"><a href="#什么是本地方法" class="headerlink" title="什么是本地方法"></a>什么是本地方法</h3><p>Native Method：Java调用非Java代码接口，初衷是融合C/C++程序</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IHaveNatives</span> {</span><br><span class="line">    <span class="comment">// 除了不能用abstract修饰，其他关键词都可以用</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">native1</span><span class="params">(<span class="type">int</span> x)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">native2</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">synchronized</span> <span class="type">float</span> <span class="title function_">native3</span><span class="params">(Object o)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">native4</span><span class="params">(<span class="type">int</span>[] ary)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="为什么要使用本地方法"><a href="#为什么要使用本地方法" class="headerlink" title="为什么要使用本地方法"></a>为什么要使用本地方法</h3><ul>
<li><p><strong>与Java环境外的交互</strong></p>
<p>有时Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因</p>
</li>
<li><p><strong>与操作系统的交互</strong></p>
<p>通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用C写的</p>
</li>
<li><p><strong>Sun’s Java</strong></p>
<p>Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互</p>
</li>
</ul>
<blockquote>
<p>目前该方法使用越来越少了，除非是与硬件相关的应用。异构领域间通信很发达，可以使用Socket通信，也可以使用Web Service等</p>
</blockquote>
<h3 id="本地方法栈的理解"><a href="#本地方法栈的理解" class="headerlink" title="本地方法栈的理解"></a>本地方法栈的理解</h3><p><strong>本地方法栈：</strong></p>
<ul>
<li><p>管理本地方法的调用，也是线程私有的</p>
</li>
<li><p>允许被设为固定大小的或可动态扩展的</p>
<ul>
<li>固定大小，超过本地方法栈最大容量：StackOverflowError异常</li>
<li>动态扩展，创建或扩展时没有足够的内存：OutOfMemoryError异常</li>
</ul>
</li>
</ul>
<blockquote>
<p>假如我们调用一个Java方法，方法栈帧会被压入Java虚拟机栈中；</p>
<p>如果我们需要调用本地方法了，本地方法的栈帧会被压入到本地方法栈中，执行引擎通过动态链接的方式调用C的相关的库</p>
</blockquote>
<p><strong>当某一线程调用本地方法时，就进入了一个全新的不受虚拟机限制的世界。他和虚拟机有同样的权限</strong></p>
<ul>
<li>访问虚拟机内部的运行时数据</li>
<li>世界使用本地处理器的寄存器</li>
<li>直接从本地内存的堆中分配任意大小内存</li>
</ul>
<p><strong>并不是所有JVM都支持本地方法</strong></p>
<ul>
<li>Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构</li>
</ul>
<p><strong>在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一</strong></p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="堆的核心概念"><a href="#堆的核心概念" class="headerlink" title="堆的核心概念"></a>堆的核心概念</h3><ol>
<li>一个JVM实例（进程）只有一个堆内存，是Java内存管理的核心区域</li>
<li>在JVM启动时就被创建，空间大小就已确定<ul>
<li>堆空间大小可以调节</li>
</ul>
</li>
<li>堆可以处于物理上不连续的内存空间中，但逻辑上它被视作连续的</li>
<li>所有线程共享Java堆，还可以划分线程私有缓冲区（Thread Local Allocation Buffer，TLAB）</li>
<li>（几乎）所有的对象和数组，都分配在堆上</li>
<li>方法结束后，堆中的对象不会立刻移除，仅在垃圾回收时移除</li>
<li>堆，是GC（Garbage Collection，垃圾回收器）执行垃圾回收的重点区域</li>
</ol>
<h4 id="可视化工具"><a href="#可视化工具" class="headerlink" title="可视化工具"></a>可视化工具</h4><p>启动一个JVM实例</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 虚拟机参数：-Xms10m -Xmx10m</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapDemo1</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(<span class="string">"start"</span>);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Thread.sleep(<span class="number">100000000</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"end"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>JDK14之后，已不再集成visualvm，<a class="link" href="https://blog.csdn.net/LONG_Yi_1994/article/details/108730414">手动安装 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>Eden Space + Survivor 0 + Survivor 1 + Old Gen就是我们堆空间的大小 </p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/09/25/GqVrc8Ptl3NisBK.png" alt="image-20230925164220197"></p>
<h4 id="内存细分"><a href="#内存细分" class="headerlink" title="内存细分"></a>内存细分</h4><p><strong>Java7及之前：</strong></p>
<ul>
<li>新生代，老年代，永久代</li>
</ul>
<p><strong>Java8及以后</strong></p>
<ol>
<li><p>新生代（New Gen）</p>
<ul>
<li><p>Eden Space</p>
</li>
<li><p>Survivor 0</p>
</li>
<li><p>Survivor 1</p>
</li>
</ul>
</li>
<li><p>老年代（Old Gen）</p>
</li>
<li><p>元空间（MetaSpace）</p>
</li>
</ol>
<h3 id="设置堆内存大小与OOM"><a href="#设置堆内存大小与OOM" class="headerlink" title="设置堆内存大小与OOM"></a>设置堆内存大小与OOM</h3><h4 id="设置大小"><a href="#设置大小" class="headerlink" title="设置大小"></a>设置大小</h4><ul>
<li>-Xms：堆起始内存大小，等价于-XX:InitialHeapSize</li>
<li>-Xmx：堆最大内存大小，等价于-XX:MaxHeapSize<ul>
<li>堆超过此大小，会报OutOfMemoryError错误</li>
</ul>
</li>
</ul>
<blockquote>
<p>通常，会将这两个值设为一样。<strong>以便在GC完成后不需要重新分隔堆区的大小，提高性能</strong></p>
<p>默认情况下：初始内存大小=物理内存大小 / 64；最大内存大小=物理内存大小 / 4</p>
</blockquote>
<h4 id="查看大小"><a href="#查看大小" class="headerlink" title="查看大小"></a>查看大小</h4><p><strong>代码查看一下大小</strong></p>
<p>（我的电脑内存40GB）</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">initialMemory</span> <span class="operator">=</span> Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span>;	<span class="comment">// 初始大小</span></span><br><span class="line"><span class="type">long</span> <span class="variable">maxMemory</span> <span class="operator">=</span> Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span>;		<span class="comment">// 最大大小</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"-Xms : "</span> + initialMemory + <span class="string">"M"</span>);	<span class="comment">// 640M</span></span><br><span class="line">System.out.println(<span class="string">"-Xmx : "</span> + maxMemory + <span class="string">"M"</span>);		<span class="comment">// 10168M</span></span><br></pre></td></tr></table></figure></div>

<p><strong>命令行查看大小</strong></p>
<blockquote>
<p>jps：查看java进程</p>
<p>jstat -gc &lt;进程id&gt;：查看进程中内存使用情况</p>
</blockquote>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/09/25/r2udgtFBoKfnVvk.png" alt="image-20230925170955398"></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SOC: S0区总共容量</span><br><span class="line">S1C: S1区总共容量</span><br><span class="line">S0U: S0区使用的量</span><br><span class="line">S1U: S1区使用的量</span><br><span class="line">EC: 伊甸园区总共容量</span><br><span class="line">EU: 伊甸园区使用的量</span><br><span class="line">OC: 老年代总共容量</span><br><span class="line">OU: 老年代使用的量</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>有个细节：S0和S1之间只能二选一，算总量的时候应该：S0C（或者S1C） + EC + OC</p>
</blockquote>
<p><strong>虚拟机选项查看大小</strong></p>
<blockquote>
<p>-XX:+PrintGCDetails</p>
</blockquote>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/09/25/3jVtd8pPv4awZWE.png" alt="image-20230925200811004"></p>
<h4 id="OOM举例"><a href="#OOM举例" class="headerlink" title="OOM举例"></a>OOM举例</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapDemo1</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        ArrayList&lt;Picture&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">            Thread.sleep(<span class="number">5</span>);</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">Picture</span>(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">1024</span> * <span class="number">1024</span>)));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Picture</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] pixels;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Picture</span><span class="params">(<span class="type">int</span> length)</span> {</span><br><span class="line">        <span class="built_in">this</span>.pixels = <span class="keyword">new</span> <span class="title class_">byte</span>[length];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/09/25/954lQPLjt13IVCR.png" alt="image-20230925201428228"></p>
<h3 id="年轻代与老年代"><a href="#年轻代与老年代" class="headerlink" title="年轻代与老年代"></a>年轻代与老年代</h3><ul>
<li><p>存储在JVM中的数据分为两类：</p>
<ul>
<li><p>一类生命周期较短，创建和消亡都非常迅速</p>
</li>
<li><p>另一类生命周期非常长，甚至可能和JVM生命周期一致</p>
</li>
</ul>
</li>
<li><p>Java堆进一步细分，可以划分为：年轻代（YoungGen）和老年代（OldGen）</p>
<ul>
<li>年轻代可以继续细分为：Eden空间，Survivor0空间，Survivor1空间</li>
<li>年轻代内部比例：8 : 1 : 1</li>
</ul>
</li>
<li><p>（几乎）所有Java对象都在Eden区被new出来</p>
<ul>
<li>比如：Eden空间装不下…</li>
</ul>
</li>
<li><p>绝大多数Java对象都是在新生代销毁的（IBM研究80%都是）</p>
</li>
</ul>
<h4 id="相关虚拟机选项"><a href="#相关虚拟机选项" class="headerlink" title="相关虚拟机选项"></a>相关虚拟机选项</h4><blockquote>
<p>一般不会调整</p>
</blockquote>
<p><strong>设置新生代空间大小：</strong></p>
<ul>
<li><code>-Xmn50m</code>：如果和下面设置比例的选项冲突，还是优先使用它</li>
</ul>
<p><strong>年轻代与老年代比例：</strong></p>
<ul>
<li><p>默认：<code>-XX:NewRatio=2</code>，表示新生代占1，老年代占2（新生代占1/3）</p>
</li>
<li><p>可以修改：<code>-XX:NewRatio=2</code>，表示新生代占1，老年代占4（新生代占1/5）</p>
</li>
</ul>
<p><strong>年轻代内部比例：</strong></p>
<ul>
<li>默认：<code>-XX:SurvivorRatio=8</code>，表示8 : 1 : 1（但未必一定是这个比例，因为有自适应策略）</li>
</ul>
<p><strong>使用自适应的内存比例：</strong></p>
<ul>
<li>默认使用：<code>-XX:+UseAdaptiveSizePolicy</code></li>
<li>关闭策略：<code>-XX:-UseAdaptiveSizePolicy</code></li>
</ul>
<h3 id="图解对象分配过程"><a href="#图解对象分配过程" class="headerlink" title="图解对象分配过程"></a>图解对象分配过程</h3><h4 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h4><ol>
<li>new对象先放伊甸园区</li>
<li>如果伊甸园区满了，进行垃圾回收：<ul>
<li>将进行Minor GC，不被引用的对象将被销毁</li>
<li>幸存的对象移动到S0中</li>
</ul>
</li>
<li>下一次伊甸园满了，进行垃圾回收时：<ul>
<li>这一次幸存的对象移动到S1中</li>
<li>S0中也进行垃圾回收，幸存的也移动到S1中</li>
</ul>
</li>
<li>每进入一次垃圾回收，幸存者age加一</li>
<li>在从S0-&gt;S1或者S1-&gt;S0过程中，如果age达到阈值（默认15），会进入老年区（promotion，晋升）<ul>
<li>可以设置参数：<code>-XX:MaxTenuringThreshold=15</code></li>
</ul>
</li>
</ol>
<blockquote>
<p><strong>注意：</strong></p>
<p>伊甸园区满的时候：会触发伊甸园区和幸存者区的垃圾回收</p>
</blockquote>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/09/27/32L5XodfzYKEB8c.png" alt="image-20230927153227794"></p>
<h4 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h4><ul>
<li>伊甸园放得下：分配内存</li>
<li>伊甸园放不下：触发<strong>Minor GC</strong><ul>
<li>幸存者区放得下：放置在S0或S1，达到阈值的对象晋升老年代</li>
<li>幸存者区放不下：直接放到老年代</li>
</ul>
</li>
<li>伊甸园依然放不下（超大对象）：直接放到老年代<ul>
<li>老年代放不下：触发<strong>Major GC</strong></li>
<li>老年代依然放不下：<strong>OOM</strong></li>
</ul>
</li>
</ul>
<h3 id="Minor-GC、Major-GC、Full-GC"><a href="#Minor-GC、Major-GC、Full-GC" class="headerlink" title="Minor GC、Major GC、Full GC"></a>Minor GC、Major GC、Full GC</h3><h4 id="GC的分类"><a href="#GC的分类" class="headerlink" title="GC的分类"></a>GC的分类</h4><p>部分收集（Partial GC）：</p>
<ul>
<li><p>Minor GC：只是新生代（Eden，S0，S1）的垃圾回收</p>
</li>
<li><p>Major GC：只是老年代的垃圾回收</p>
<ul>
<li>目前，只有CMS GC会有单独收集老年代的行为</li>
<li>目前，很多时候Major GC会和Full GC混淆使用，需要具体区分是老年代回收还是整堆回收</li>
</ul>
</li>
<li><p>Mixed GC：整个新生代以及部分老年代的垃圾回收</p>
<ul>
<li>目前，只有G1 GC会有这种行为</li>
</ul>
</li>
</ul>
<p>整堆收集（Full GC）：</p>
<ul>
<li>Full GC：整个Java堆和方法区的垃圾收集</li>
</ul>
<h4 id="Minor-GC的触发机制"><a href="#Minor-GC的触发机制" class="headerlink" title="Minor GC的触发机制"></a>Minor GC的触发机制</h4><ul>
<li>Eden满了触发，Survivor满了不会引发GC</li>
<li>Minor GC触发频率非常高，回收速度也很快</li>
<li>Minor GC会引发STW（Stop The World），暂停其他用户的线程，等垃圾回收结束才会恢复</li>
</ul>
<h4 id="Major-GC的触发条件"><a href="#Major-GC的触发条件" class="headerlink" title="Major GC的触发条件"></a>Major GC的触发条件</h4><ul>
<li><p>指发生在老年代的GC，对象从老年代消失时，我们说”Major GC“或”Full GC“发生了</p>
</li>
<li><p>出现Major GC，经常伴随至少一次的Minor GC</p>
<ul>
<li>但并非绝对的，Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略<ul>
<li>也即：老年代空间不足时，先尝试触发Minor GC，空间还是不足才触发Major GC</li>
</ul>
</li>
</ul>
</li>
<li><p>Major GC的速度比Minor GC慢10倍以上，STW时间更长</p>
</li>
<li><p>Major GC后内存还是不足，报OOM</p>
</li>
</ul>
<h4 id="Full-GC的触发条件"><a href="#Full-GC的触发条件" class="headerlink" title="Full GC的触发条件"></a>Full GC的触发条件</h4><ul>
<li>调用<code>System.gc()</code>，系统建议执行Full GC，但不必然执行</li>
<li>老年代空间不足</li>
<li>方法区空间不足</li>
</ul>
<blockquote>
<p>由于暂停时间长，应当尽量避免Full GC / Major GC</p>
</blockquote>
<h3 id="GC举例与日志分析"><a href="#GC举例与日志分析" class="headerlink" title="GC举例与日志分析"></a>GC举例与日志分析</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -Xms9m -Xmx9m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment">// JDK17使用 -Xms9m -Xmx9m -XX:+UseParallelGC -Xlog:gc*</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCTest</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">"atguigu.com"</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">                list.add(a);</span><br><span class="line">                a = a + a;</span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">            t.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">"遍历次数为："</span> + i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">JDK17的结果</span></span><br><span class="line"></span><br><span class="line">GC(4) Pause Full (Allocation Failure)</span><br><span class="line">GC(4) PSYoungGen: 0K(2560K)-&gt;0K(2560K) Eden: 0K(2048K)-&gt;0K(2048K) From: 0K(512K)-&gt;0K(512K)</span><br><span class="line">GC(4) ParOldGen: 6498K(7168K)-&gt;6492K(7168K)</span><br><span class="line">GC(4) Metaspace: 523K(704K)-&gt;523K(704K) NonClass: 490K(576K)-&gt;490K(576K) Class: 33K(128K)-&gt;33K(128K)</span><br><span class="line">GC(4) Pause Full (Allocation Failure) 6M-&gt;6M(9M) 3.082ms</span><br><span class="line">GC(4) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">遍历次数为：18</span><br><span class="line">Heap</span><br><span class="line">PSYoungGen      total 2560K, used 339K</span><br><span class="line">eden space 2048K, 16% used</span><br><span class="line">from space 512K, 0% used</span><br><span class="line">to   space 512K, 0% used</span><br><span class="line">ParOldGen       total 7168K, used 6492K</span><br><span class="line">object space 7168K, 90% used</span><br><span class="line">Metaspace       used 778K, committed 896K, reserved 1056768K</span><br><span class="line">class space    used 63K, committed 128K, reserved 1048576K</span><br></pre></td></tr></table></figure></div>

<h3 id="堆空间分代思想"><a href="#堆空间分代思想" class="headerlink" title="堆空间分代思想"></a>堆空间分代思想</h3><p>为什么要把Java堆分代？</p>
<ul>
<li><p>分代的唯一理由就是优化GC性能</p>
</li>
<li><p>经研究，70%-99%的对象是临时对象</p>
<ul>
<li>将朝生夕死的对象进行回收，能腾出大量的空间</li>
</ul>
</li>
<li><p>如果没有分代，GC需要对堆的所有区域进行扫描</p>
</li>
</ul>
<h3 id="总结–内存分配策略"><a href="#总结–内存分配策略" class="headerlink" title="总结–内存分配策略"></a>总结–内存分配策略</h3><ol>
<li>如果对象在Eden出生并经过第一次Minor GC后仍然存活，且能被Survivor容纳，将被移动到Survivor空间中，年龄设为1。</li>
<li>对象在Survivor区中每熬过一次MinorGC，年龄就增加1。当它的年龄增加到一定程度（默认为15岁，其实每个JVM、每个GC都有所不同），就会被晋升到老年代</li>
<li>晋升老年代的阀值，可以通过选项**-XX:MaxTenuringThreshold**来设置</li>
</ol>
<p><strong>针对不同年龄段的对象分配原则：</strong></p>
<ul>
<li>优点分配到Eden</li>
<li>大对象直接分配到老年代<ul>
<li>Eden都放不下了</li>
</ul>
</li>
<li>长期存活的对象分配到老年代<ul>
<li>年龄超过阈值的对象</li>
</ul>
</li>
<li>动态年龄判断<strong>（特例）</strong><ul>
<li>如果Survivor区中相同年龄的对象大小的总和，大于Survivor空间的一半。年龄大于等于该年龄的对象可以直接进入老年代，无需达到阈值</li>
<li>避免S0和S1反复倒来倒去</li>
</ul>
</li>
<li>空间分配担保<ul>
<li>-XX:HandlePromptFailure（后面参数设置部分有讲）</li>
</ul>
</li>
</ul>
<h3 id="补充–为对象分配内存：TLAB"><a href="#补充–为对象分配内存：TLAB" class="headerlink" title="补充–为对象分配内存：TLAB"></a>补充–为对象分配内存：TLAB</h3><p>TLAB：Thread Local Allocation Buffer</p>
<p><strong>为什么有TLAB：</strong></p>
<ul>
<li>堆区是线程共享区域</li>
<li>为避免多个线程操作同一地址，需要使用<strong>加锁等机制</strong>，进而影响分配速度</li>
</ul>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/08/mxIDtbTOr98f4Zv.png" alt="image-20231008105930045" style="zoom: 50%;">

<p><strong>什么是TLAB：</strong></p>
<ul>
<li><strong>JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内</strong></li>
<li>多线程分配内存时，可以避免一系列线程安全问题，还能提升内存分配吞吐量，这种内存分配方式称之为<strong>快速分配策略</strong></li>
<li>几乎所有OpenJDK衍生出来的JVM都提供了TLAB的设计</li>
<li>当一个线程TLAB存满时，可以使用公共（蓝色）区域</li>
</ul>
<p><strong>TLAB的一些说明：</strong></p>
<ul>
<li>不是所有的对象都能够在TLAB中成功分配内存，但<strong>JVM将TLAB作为内存分配的首选</strong></li>
<li><code>-XX:+UseTLAB</code>设置是否开启TLAB空间（默认开启）</li>
<li>默认仅占Eden空间的1%，可以通过选项<code>-XX:TLABWasteTargetPercent</code>设置百分比大小</li>
<li>如果在TLAB空间分配内存失败，JVM就会尝试着通过<strong>使用加锁机制确保数据操作的原子性</strong>，直接在Eden空间中分配内存</li>
</ul>
<p><strong>总结：TLAB分配过程</strong></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/08/7fa3OPGANyZhWEX.png" alt="image-20231008110539549"></p>
<h3 id="小结–参数设置"><a href="#小结–参数设置" class="headerlink" title="小结–参数设置"></a>小结–参数设置</h3><blockquote>
<p> <strong>官方文档</strong>：<a class="link" href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-XX:+PrintFlagsInitial</td>
<td>查看所有参数的默认值</td>
</tr>
<tr>
<td>-XX:+PrintFlagsFinal</td>
<td>查看所有参数的最终值</td>
</tr>
<tr>
<td>-Xms</td>
<td>初始堆空间大小（默认物理内存1/64）</td>
</tr>
<tr>
<td>-Xmx</td>
<td>最大堆空间大小（默认物理内存1/4）</td>
</tr>
<tr>
<td>-Xmn</td>
<td>新生代大小（初始和最大都是）</td>
</tr>
<tr>
<td>-XX:NewRatio</td>
<td>新生代大小的占比（默认值2，新生代占1/3）</td>
</tr>
<tr>
<td>-XX:SurvivorRatio</td>
<td>Eden和S0/S1空间的比例（默认8，8:1:1）</td>
</tr>
<tr>
<td>-XX:MaxTenuringThreshold</td>
<td>新生代最大年龄</td>
</tr>
<tr>
<td>-XX:+PrintGCDetails</td>
<td>输出详细的GC日志</td>
</tr>
<tr>
<td>-XX:+PrintGC 或 -verbose:gc</td>
<td>输出简化的GC日志</td>
</tr>
<tr>
<td>-XX:HandlePromotionFailure</td>
<td>是否设置<strong>空间分配担保</strong></td>
</tr>
</tbody></table>
<p><strong>什么是空间分配担保</strong></p>
<p>Minor GC之前，JVM会检查老年代<strong>最大可用的连续空间</strong>，是否大于<strong>新生代所有对象的总空间</strong></p>
<p>如果大于，此次GC是安全的</p>
<p>如果小于：</p>
<ul>
<li>如果<code>HandlePromotionFailure=true</code>，继续检查老年代<strong>最大可用连续空间</strong>是否大于<strong>历次晋升到老年代的平均大小</strong><ul>
<li>如果大于，则尝试进行一次Minor GC，这次GC仍然是有风险的</li>
<li>如果小于，则进行一次Full GC</li>
</ul>
</li>
<li>如果<code>HandlePromotionFailure=false</code>，则进行一次Full GC</li>
</ul>
<blockquote>
<p>jdk7之后，这个参数已经失效了</p>
<p>现在：只要老年代的<strong>连续空间</strong>大于新生代对象<strong>总大小</strong>或者<strong>历次晋升的平均大小</strong>就会进行Minor GC，否则将进行Full GC</p>
<p>也即默认为true</p>
</blockquote>
<p><strong>具体查看某个参数的指令：</strong></p>
<p><code>jps</code>：查看当前运行的进程</p>
<p><code>jinfo -flag SurvivorRatio 进程id</code>：查看某个参数的值</p>
<h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>堆是分配对象唯一选择吗？在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：</p>
<ol>
<li>随着JIT编译期的发展与<strong>逃逸分析技术</strong>逐渐成熟，<strong>栈上分配、标量替换</strong>优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</li>
<li>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是<strong>如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配</strong>。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</li>
<li>此外，前面提到的基于OpenJDK深度定制的TaoBao VM，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。</li>
</ol>
<h4 id="什么是逃逸分析"><a href="#什么是逃逸分析" class="headerlink" title="什么是逃逸分析"></a>什么是逃逸分析</h4><ol>
<li>将堆上的对象分配到栈，需要使用逃逸分析手段。</li>
<li>这是一种可以有效减少Java程序中，同步负载和内存堆分配压力的，跨函数全局数据流分析算法。</li>
<li>通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围，从而决定是否要将这个对象分配到堆上。</li>
<li>逃逸分析的基本行为就是分析对象动态作用域：<ul>
<li>当一个对象在方法中被定义后，<strong>对象只在方法内部使用</strong>，则认为没有发生逃逸。</li>
<li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</li>
</ul>
</li>
</ol>
<h4 id="逃逸举例"><a href="#逃逸举例" class="headerlink" title="逃逸举例"></a>逃逸举例</h4><ol>
<li>没有发生逃逸，可以分配到栈上。方法执行结束，栈空间就被移除（无需GC）</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">my_method</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">V</span>();</span><br><span class="line">    <span class="comment">// use v</span></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    v = <span class="literal">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>StringBuffer sb 发生了逃逸，不能在栈上分配</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title function_">createStringBuffer</span><span class="params">(String s1, String s2)</span> {</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li>想要StringBuffer sb不发生逃逸，进行优化</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createStringBuffer</span><span class="params">(String s1, String s2)</span> {</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p><strong>参数设置：</strong></p>
<ul>
<li><p>在JDK 1.7 版本之后，HotSpot中默认就已经开启了逃逸分析</p>
</li>
<li><p><code>-XX:+DoEscapeAnalysis</code>：显式开启逃逸分析</p>
</li>
<li><p><code>-XX:+PrintEscapeAnalysis</code>：查看逃逸分析的筛选结果</p>
</li>
</ul>
<blockquote>
<p> 总结：能使用局部变量，就不要在方法外部定义</p>
</blockquote>
<h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><h5 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h5><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -Xmx128m -Xms128m -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackAllocation</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) {</span><br><span class="line">            alloc();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 查看执行时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"花费的时间为： "</span> + (end - start) + <span class="string">" ms"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 为了方便查看堆内存中对象个数，线程sleep</span></span><br><span class="line">        Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(); <span class="comment">// 未发生逃逸</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>-XX:-DoEscapeAnalysis</code>关闭逃逸分析，进行了垃圾回收，速度较慢</li>
</ul>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 33280K-&gt;872K(38400K)] 33280K-&gt;880K(125952K), 0.0013246 secs]</span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 34152K-&gt;808K(38400K)] 34160K-&gt;816K(125952K), 0.0007481 secs]</span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 34088K-&gt;808K(38400K)] 34096K-&gt;816K(125952K), 0.0010414 secs]</span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 34088K-&gt;840K(38400K)] 34096K-&gt;848K(125952K), 0.0005889 secs]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">花费的时间为： 27 ms</span></span><br></pre></td></tr></table></figure></div>

<p><code>-XX:+DoEscapeAnalysis</code>开启逃逸分析，没有进行垃圾回收，速度快很多</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">花费的时间为： 2 ms</span></span><br></pre></td></tr></table></figure></div>

<h5 id="同步省略"><a href="#同步省略" class="headerlink" title="同步省略"></a>同步省略</h5><ul>
<li><p>如果一个对象被发现只能从一个线程中被访问到，那么对于这个对象的操作可以不考虑同步</p>
</li>
<li><p>在动态编译同步块的时候，JIT编译器可以<strong>借助逃逸分析</strong>来<strong>判断同步块所使用的锁对象是否只能够被一个线程访问</strong>而没有被发布到其他线程</p>
</li>
<li><p>如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个<strong>取消同步的过程就叫同步省略，也叫锁消除</strong></p>
</li>
</ul>
<p>例如，下面的代码</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void f() {</span><br><span class="line">    Object hollis = new Object();</span><br><span class="line">    synchronized(hollis) {</span><br><span class="line">        System.out.println(hollis);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>但是hollis对象的生命周期只在方法中，并不会被其他线程所访问到。在<strong>JIT编译阶段</strong>会被优化掉，优化成：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void f() {</span><br><span class="line">    Object hellis = new Object();</span><br><span class="line">	System.out.println(hellis);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>通过反编译字节码可以看到，依然有加锁（monitorenter，monitorexit），<strong>同步省略操作是在解释运行时发生的</strong></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/08/6prefdBtDQRchE3.png" alt="image-20231008173809164"></p>
<h5 id="标量替换"><a href="#标量替换" class="headerlink" title="标量替换"></a>标量替换</h5><ul>
<li><p>标量（scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量</p>
</li>
<li><p>相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量</p>
</li>
<li><p>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换</p>
</li>
</ul>
<p><strong>代码举例</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">Point</span> <span class="variable">point</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">"point.x"</span> + point.x + <span class="string">";point.y"</span> + point.y);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>以上代码，经过标量替换后，就会变成</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">"point.x = "</span> + x + <span class="string">"; point.y="</span> + y);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>Point经过逃逸分析后，发现他并没有逃逸，就被替换成两个聚合量了。不再需要分配堆内存，大大减少堆内存的占用。</p>
<p><strong>实际测试</strong></p>
<p><code>-XX:+ElimilnateAllocations</code>：是否开启标量替换（默认打开）</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:-EliminateAllocations</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScalarReplace</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> {</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line">        <span class="keyword">public</span> String name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(); <span class="comment">// 未发生逃逸</span></span><br><span class="line">        u.id = <span class="number">5</span>;</span><br><span class="line">        u.name = <span class="string">"www.atguigu.com"</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) {</span><br><span class="line">            alloc();</span><br><span class="line">        }</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"花费的时间为： "</span> + (end - start) + <span class="string">" ms"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>-XX:-ElimilnateAllocations</code>：关闭标量替换，进行了垃圾回收</li>
</ul>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure)  25600K-&gt;944K(98304K), 0.0008014 secs]</span><br><span class="line">[GC (Allocation Failure)  26544K-&gt;864K(98304K), 0.0007089 secs]</span><br><span class="line">[GC (Allocation Failure)  26464K-&gt;848K(98304K), 0.0008019 secs]</span><br><span class="line">[GC (Allocation Failure)  26448K-&gt;912K(98304K), 0.0007006 secs]</span><br><span class="line">[GC (Allocation Failure)  26512K-&gt;864K(98304K), 0.0006461 secs]</span><br><span class="line">[GC (Allocation Failure)  26464K-&gt;816K(101376K), 0.0007875 secs]</span><br><span class="line">[GC (Allocation Failure)  32560K-&gt;712K(100864K), 0.0005971 secs]</span><br><span class="line">[GC (Allocation Failure)  32456K-&gt;712K(100864K), 0.0008559 secs]</span><br><span class="line">花费的时间为： 43 ms</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>-XX:+ElimilnateAllocations</code>：开启标量替换，未进行垃圾回收</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 花费的时间为： 3 ms</span><br></pre></td></tr></table></figure></div>

<h4 id="逃逸分析并不成熟"><a href="#逃逸分析并不成熟" class="headerlink" title="逃逸分析并不成熟"></a>逃逸分析并不成熟</h4><p>关于逃逸分析的论文在1999年就已经发表了，但直到JDK1.6才有实现，而且这项技术到如今也并不是十分成熟。</p>
<p>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。</p>
<p>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</p>
<p>虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段。</p>
<p>注意到有一些观点，认为通过逃逸分析，<strong>JVM会在栈上分配那些不会逃逸的对象（no）</strong>，这在理论上是可行的，但是取决于JVM设计者的选择。据我所知，<strong>Oracle Hotspot JVM中并未这么做</strong>，这一点在逃逸分析相关的文档里已经说明，<strong>所以可以明确所有的对象实例都是创建在堆上。</strong></p>
<p>目前很多书籍还是基于JDK7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：<strong>对象实例都是分配在堆上。</strong></p>
<h3 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h3><ul>
<li><p>年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。</p>
</li>
<li><p>老年代放置长生命周期的对象，通常都是从Survivor区域筛选拷贝过来的Java对象。当然，也有特殊情况，我们知道普通的对象可能会被分配在TLAB上；如果对象较大，无法分配在 TLAB 上，则JVM会试图直接分配在Eden其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。</p>
</li>
<li><p>当GC只发生在年轻代中，回收年轻代对象的行为被称为Minor GC。当GC发生在老年代时则被称为Major GC或者Full GC。一般的，Minor GC的发生频率要比Major GC高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。</p>
</li>
</ul>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><h3 id="栈-堆-方法区的交互关系"><a href="#栈-堆-方法区的交互关系" class="headerlink" title="栈-堆-方法区的交互关系"></a>栈-堆-方法区的交互关系</h3><p><strong>从线程共享与否来看</strong></p>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/08/Kd7hzyTcmxQpI3w.png" alt="image-20231008195556409" style="zoom:50%;">

<p><strong>从代码角度来看</strong></p>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/08/ux61nPp3ZWMyhBJ.png" alt="image-20231008195848376" style="zoom: 25%;">

<h3 id="方法区的理解"><a href="#方法区的理解" class="headerlink" title="方法区的理解"></a>方法区的理解</h3><blockquote>
<p> <strong>官方文档</strong>：<a class="link" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<ul>
<li><p>可以看作是，一块独立于Java堆的内存空间</p>
</li>
<li><p>方法区主要存放Class，堆主要存放实例化的对象</p>
</li>
<li><p>方法区在JVM启动的时候被创建，它的实际的物理内存和Java堆区一样，都可以是不连续的</p>
</li>
<li><p>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展</p>
</li>
<li><p>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，JVM同样会抛出OOM</p>
<ul>
<li><p>JDK8以前：<code>java.lang.OutofMemoryError:PermGen space</code></p>
</li>
<li><p>JDK8及以后：<code>java.lang.OutOfMemoryError:Metaspace</code></p>
</li>
<li><p>加载大量的第三方的jar包</p>
</li>
<li><p>Tomcat部署的工程过多（30~50个）</p>
</li>
<li><p>大量动态的生成反射类</p>
</li>
</ul>
</li>
<li><p>关闭JVM就会释放这个区域的内存</p>
</li>
</ul>
<h3 id="Hotspot中方法区的演进"><a href="#Hotspot中方法区的演进" class="headerlink" title="Hotspot中方法区的演进"></a>Hotspot中方法区的演进</h3><ul>
<li>JDK8之前，习惯上把方法区称为永久代。JDK8开始使用元空间取代了永久代<ul>
<li>现在来看，使用永久代并不是好的做法，容易导致程序OOM（超过XX:MaxPermSize上限）</li>
</ul>
</li>
<li>永久代/元空间，都是对JVM规范中方法区的实现。区别在于：<strong>元空间不在虚拟机设置的内存中，而是使用本地内存</strong></li>
</ul>
<h3 id="设置方法区大小与OOM"><a href="#设置方法区大小与OOM" class="headerlink" title="设置方法区大小与OOM"></a>设置方法区大小与OOM</h3><p>方法区的大小不必是固定的，JVM可以根据应用的需要动态调整</p>
<p><strong>JDK8及以后（元空间）</strong></p>
<ul>
<li>元空间大小由<code>-XX:MetaspaceSize</code>和<code>-XX:MaxMetaspaceSize</code>指定<ul>
<li>默认值依赖于平台，windows 64位下：</li>
<li>MetaspaceSize约为21MB</li>
<li>MaxMetaspaceSize值为-1，即没有限制</li>
</ul>
</li>
<li>默认情况下，JVM会耗尽所有的可用系统内存。如果元数据区发生溢出，JVM会抛出异常<code>OutOfMemoryError:Metaspace</code></li>
<li>对一个64位的服务器端JVM来说，元空间初始大小一般为21MB。<ul>
<li>一旦触及这个水位线，Full GC将触发并卸载没用的类。这个高水位线将被重置。</li>
<li>如果释放的空间不足，会适当提高该值</li>
<li>如果释放的空间过多，则适当降低改值</li>
</ul>
</li>
<li>为避免频繁GC，建议将<code>-XX:MetaspaceSize</code>设置为一个相对较高的值</li>
</ul>
<h4 id="方法区OOM代码举例"><a href="#方法区OOM代码举例" class="headerlink" title="方法区OOM代码举例"></a>方法区OOM代码举例</h4><p>方法一：借助CGLib使得方法区出现内存溢出</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -XX:MetaspaceSize=10m -XX:MaxMetaspaceSize=10m</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaMethodAreaOOM</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">            <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">            enhancer.setSuperclass(OOMObject.class);</span><br><span class="line">            enhancer.setUseCache(<span class="literal">false</span>);</span><br><span class="line">            enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">MethodInterceptor</span>() {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, </span></span><br><span class="line"><span class="params">                                        Method method, </span></span><br><span class="line"><span class="params">                                        Object[] args, </span></span><br><span class="line"><span class="params">                                        MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable {</span><br><span class="line">                    <span class="keyword">return</span> proxy.invokeSuper(obj, args);</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">            enhancer.create();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">OOMObject</span> {</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>方法二：使用二进制字节码来定义类</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -XX:MetaspaceSize=10m -XX:MaxMetaspaceSize=10m</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OOMTest</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">OOMTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OOMTest</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) {</span><br><span class="line">                <span class="comment">//创建ClassWriter对象，用于生成类的二进制字节码</span></span><br><span class="line">                <span class="type">ClassWriter</span> <span class="variable">classWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(<span class="number">0</span>);</span><br><span class="line">                <span class="comment">//指明版本号，修饰符，类名，包名，父类，接口</span></span><br><span class="line">                classWriter.visit(Opcodes.V1_8, </span><br><span class="line">                                  Opcodes.ACC_PUBLIC, </span><br><span class="line">                                  <span class="string">"Class"</span> + i, </span><br><span class="line">                                  <span class="literal">null</span>, </span><br><span class="line">                                  <span class="string">"java/lang/Object"</span>, </span><br><span class="line">                                  <span class="literal">null</span>);</span><br><span class="line">                <span class="comment">//返回byte[]</span></span><br><span class="line">                <span class="type">byte</span>[] code = classWriter.toByteArray();</span><br><span class="line">                <span class="comment">//类的加载</span></span><br><span class="line">                test.defineClass(<span class="string">"Class"</span> + i, code, <span class="number">0</span>, code.length);<span class="comment">//Class对象</span></span><br><span class="line">                j++;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            System.out.println(j);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="如何解决OOM"><a href="#如何解决OOM" class="headerlink" title="如何解决OOM"></a>如何解决OOM</h4><blockquote>
<p>这个属于调优的问题，这里先简单的说一下</p>
</blockquote>
<ol>
<li><p>要解决OOM异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如Eclipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）</p>
<ul>
<li><p>内存泄漏：大量的引用指向某些对象，但是这些对象以后不会使用了。但是因为它们还和GC ROOT有关联，所以导致以后这些对象也不会被回收</p>
</li>
<li><p>内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GC Roots引用链的信息，就可以比较准确地定位出泄漏代码的位置。</p>
</li>
<li><p>如果不存在内存泄漏（对象确实都还必须存活），那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大。从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</p>
</li>
</ul>
</li>
</ol>
<h3 id="方法区的内部结构"><a href="#方法区的内部结构" class="headerlink" title="方法区的内部结构"></a>方法区的内部结构</h3><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/11/glFuGkTKZNLrcRS.png" alt="image-20231011145650614" style="zoom:50%;">

<p>《深入理解Java虚拟机》书中对方法区（Method Area）存储内容描述如下：</p>
<ul>
<li>它用于存储已被虚拟机加载的<strong>类型信息、常量、静态变量、JIT编译器编译后的代码缓存</strong>等</li>
</ul>
<h4 id="类型-class-信息"><a href="#类型-class-信息" class="headerlink" title="类型(class)信息"></a>类型(class)信息</h4><p>对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储：</p>
<ol>
<li>完整名称（包名.类名）</li>
<li>直接父类的完整有效名（interface或java.lang.Object都没有父类）</li>
<li>类型的修饰符（public，abstract，final的某个子类）</li>
<li>实现接口的有序列表</li>
</ol>
<h4 id="域-Field-信息"><a href="#域-Field-信息" class="headerlink" title="域(Field)信息"></a>域(Field)信息</h4><blockquote>
<p>也即成员变量</p>
</blockquote>
<ol>
<li>所有域的相关信息<ul>
<li>名称</li>
<li>类型</li>
<li>修饰符（public，private，protected，static，final，volatile，transient的某个子集）</li>
</ul>
</li>
<li>域的声明顺序</li>
</ol>
<h4 id="方法-Method-信息"><a href="#方法-Method-信息" class="headerlink" title="方法(Method)信息"></a>方法(Method)信息</h4><ol>
<li>名称</li>
<li>返回类型（包括void，void.class）</li>
<li>参数的数量和类型（按顺序）</li>
<li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集）</li>
<li>方法的字节码，操作数栈大小，局部变量表（abstract和native方法除外）</li>
<li>异常表（abstract和native方法除外）<ul>
<li>记录每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li>
</ul>
</li>
</ol>
<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodInnerStrucTest</span> <span class="keyword">extends</span> <span class="title class_">Object</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;String&gt;, Serializable {</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">"测试方法的内部结构"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器（没有显示声明），方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        System.out.println(<span class="string">"count = "</span> + count);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test2</span><span class="params">(<span class="type">int</span> cal)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">            result = value / cal;</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(String o)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p><code>javap -v -p MethodInnerStrucTest.class &gt; test.txt</code></p>
<ul>
<li>反编译字节码文件，并输出值到文本文件中，便于查看。参数-p确保能查看private权限类型的字段或方法</li>
</ul>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">Classfile /C:/Users/xdy/Desktop/learn-jvm/target/classes/org/example/methodArea/MethodInnerStrucTest.class</span><br><span class="line">  Last modified 2023年10月11日; size 1638 bytes</span><br><span class="line">  SHA-256 checksum 411f5a2ceaa376e17b1e5b2e2102ccb64862c8356379cc9f5684cd6242c20cd9</span><br><span class="line">  Compiled from "MethodInnerStrucTest.java"</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">################################ 类型信息：修饰符，全类名，直接父类，实现的接口 #################################</span></span></span><br><span class="line">public class org.example.methodArea.MethodInnerStrucTest extends java.lang.Object implements java.lang.Comparable&lt;java.lang.String&gt;, java.io.Serializable</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: (0x0021) ACC_PUBLIC, ACC_SUPER</span><br><span class="line">  this_class: #17                         // org/example/methodArea/MethodInnerStrucTest</span><br><span class="line">  super_class: #18                        // java/lang/Object</span><br><span class="line">  interfaces: 2, fields: 2, methods: 6, attributes: 2</span><br><span class="line">Constant pool:</span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">1 = Methodref          <span class="comment">#18.#52        // java/lang/Object."&lt;init&gt;":()V</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">2 = Fieldref           <span class="comment">#17.#53        // org/example/methodArea/MethodInnerStrucTest.num:I</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">3 = Fieldref           <span class="comment">#54.#55        // java/lang/System.out:Ljava/io/PrintStream;</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">4 = Class              <span class="comment">#56            // java/lang/StringBuilder</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">5 = Methodref          <span class="comment">#4.#52         // java/lang/StringBuilder."&lt;init&gt;":()V</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">6 = String             <span class="comment">#57            // count =</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">7 = Methodref          <span class="comment">#4.#58         // java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">8 = Methodref          <span class="comment">#4.#59         // java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">9 = Methodref          <span class="comment">#4.#60         // java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">10 = Methodref          <span class="comment">#61.#62        // java/io/PrintStream.println:(Ljava/lang/String;)V</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">11 = Class              <span class="comment">#63            // java/lang/Exception</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">12 = Methodref          <span class="comment">#11.#64        // java/lang/Exception.printStackTrace:()V</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">13 = Class              <span class="comment">#65            // java/lang/String</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">14 = Methodref          <span class="comment">#17.#66        // org/example/methodArea/MethodInnerStrucTest.compareTo:(Ljava/lang/String;)I</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">15 = String             <span class="comment">#67            // 测试方法的内部结构</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">16 = Fieldref           <span class="comment">#17.#68        // org/example/methodArea/MethodInnerStrucTest.str:Ljava/lang/String;</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">17 = Class              <span class="comment">#69            // org/example/methodArea/MethodInnerStrucTest</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">18 = Class              <span class="comment">#70            // java/lang/Object</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">19 = Class              <span class="comment">#71            // java/lang/Comparable</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">20 = Class              <span class="comment">#72            // java/io/Serializable</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">21 = Utf8               num</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">22 = Utf8               I</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">23 = Utf8               str</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">24 = Utf8               Ljava/lang/String;</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">25 = Utf8               &lt;init&gt;</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">26 = Utf8               ()V</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">27 = Utf8               Code</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">28 = Utf8               LineNumberTable</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">29 = Utf8               LocalVariableTable</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">30 = Utf8               this</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">31 = Utf8               Lorg/example/methodArea/MethodInnerStrucTest;</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">32 = Utf8               test1</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">33 = Utf8               count</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">34 = Utf8               test2</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">35 = Utf8               (I)I</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">36 = Utf8               value</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">37 = Utf8               e</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">38 = Utf8               Ljava/lang/Exception;</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">39 = Utf8               cal</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">40 = Utf8               result</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">41 = Utf8               StackMapTable</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">42 = Class              <span class="comment">#63            // java/lang/Exception</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">43 = Utf8               compareTo</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">44 = Utf8               (Ljava/lang/String;)I</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">45 = Utf8               o</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">46 = Utf8               (Ljava/lang/Object;)I</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">47 = Utf8               &lt;clinit&gt;</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">48 = Utf8               Signature</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">49 = Utf8               Ljava/lang/Object;Ljava/lang/Comparable&lt;Ljava/lang/String;&gt;;Ljava/io/Serializable;</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">50 = Utf8               SourceFile</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">51 = Utf8               MethodInnerStrucTest.java</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">52 = NameAndType        <span class="comment">#25:#26        // "&lt;init&gt;":()V</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">53 = NameAndType        <span class="comment">#21:#22        // num:I</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">54 = Class              <span class="comment">#73            // java/lang/System</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">55 = NameAndType        <span class="comment">#74:#75        // out:Ljava/io/PrintStream;</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">56 = Utf8               java/lang/StringBuilder</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">57 = Utf8               count =</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">58 = NameAndType        <span class="comment">#76:#77        // append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">59 = NameAndType        <span class="comment">#76:#78        // append:(I)Ljava/lang/StringBuilder;</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">60 = NameAndType        <span class="comment">#79:#80        // toString:()Ljava/lang/String;</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">61 = Class              <span class="comment">#81            // java/io/PrintStream</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">62 = NameAndType        <span class="comment">#82:#83        // println:(Ljava/lang/String;)V</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">63 = Utf8               java/lang/Exception</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">64 = NameAndType        <span class="comment">#84:#26        // printStackTrace:()V</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">65 = Utf8               java/lang/String</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">66 = NameAndType        <span class="comment">#43:#44        // compareTo:(Ljava/lang/String;)I</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">67 = Utf8               测试方法的内部结构</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">68 = NameAndType        <span class="comment">#23:#24        // str:Ljava/lang/String;</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">69 = Utf8               org/example/methodArea/MethodInnerStrucTest</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">70 = Utf8               java/lang/Object</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">71 = Utf8               java/lang/Comparable</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">72 = Utf8               java/io/Serializable</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">73 = Utf8               java/lang/System</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">74 = Utf8               out</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">75 = Utf8               Ljava/io/PrintStream;</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">76 = Utf8               append</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">77 = Utf8               (Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">78 = Utf8               (I)Ljava/lang/StringBuilder;</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">79 = Utf8               toString</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">80 = Utf8               ()Ljava/lang/String;</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">81 = Utf8               java/io/PrintStream</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">82 = Utf8               println</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">83 = Utf8               (Ljava/lang/String;)V</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">84 = Utf8               printStackTrace</span></span><br><span class="line">{</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">################################ 域信息 #################################</span></span></span><br><span class="line">  public int num;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: (0x0001) ACC_PUBLIC</span><br><span class="line"></span><br><span class="line">  private static java.lang.String str;</span><br><span class="line">    descriptor: Ljava/lang/String;</span><br><span class="line">    flags: (0x000a) ACC_PRIVATE, ACC_STATIC</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">################### 方法信息（包括构造器），操作数栈大小，参数数量，局部变量表，异常表 ####################</span></span></span><br><span class="line">  public org.example.methodArea.MethodInnerStrucTest();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (0x0001) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">         4: aload_0</span><br><span class="line">         5: bipush        10</span><br><span class="line">         7: putfield      #2                  // Field num:I</span><br><span class="line">        10: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 13: 0</span><br><span class="line">        line 15: 4</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      11     0  this   Lorg/example/methodArea/MethodInnerStrucTest;</span><br><span class="line"></span><br><span class="line">  public void test1();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (0x0001) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=3, locals=2, args_size=1</span><br><span class="line">         0: bipush        20</span><br><span class="line">         2: istore_1</span><br><span class="line">         3: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         6: new           #4                  // class java/lang/StringBuilder</span><br><span class="line">         9: dup</span><br><span class="line">        10: invokespecial #5                  // Method java/lang/StringBuilder."&lt;init&gt;":()V</span><br><span class="line">        13: ldc           #6                  // String count =</span><br><span class="line">        15: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">        18: iload_1</span><br><span class="line">        19: invokevirtual #8                  // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span><br><span class="line">        22: invokevirtual #9                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">        25: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        28: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 20: 0</span><br><span class="line">        line 21: 3</span><br><span class="line">        line 22: 28</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      29     0  this   Lorg/example/methodArea/MethodInnerStrucTest;</span><br><span class="line">            3      26     1 count   I</span><br><span class="line"></span><br><span class="line">  public static int test2(int);</span><br><span class="line">    descriptor: (I)I</span><br><span class="line">    flags: (0x0009) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=3, args_size=1</span><br><span class="line">         0: iconst_0</span><br><span class="line">         1: istore_1</span><br><span class="line">         2: bipush        30</span><br><span class="line">         4: istore_2</span><br><span class="line">         5: iload_2</span><br><span class="line">         6: iload_0</span><br><span class="line">         7: idiv</span><br><span class="line">         8: istore_1</span><br><span class="line">         9: goto          17</span><br><span class="line">        12: astore_2</span><br><span class="line">        13: aload_2</span><br><span class="line">        14: invokevirtual #12                 // Method java/lang/Exception.printStackTrace:()V</span><br><span class="line">        17: iload_1</span><br><span class="line">        18: ireturn</span><br><span class="line">      Exception table:</span><br><span class="line">         from    to  target type</span><br><span class="line">             2     9    12   Class java/lang/Exception</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 25: 0</span><br><span class="line">        line 27: 2</span><br><span class="line">        line 28: 5</span><br><span class="line">        line 31: 9</span><br><span class="line">        line 29: 12</span><br><span class="line">        line 30: 13</span><br><span class="line">        line 32: 17</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            5       4     2 value   I</span><br><span class="line">           13       4     2     e   Ljava/lang/Exception;</span><br><span class="line">            0      19     0   cal   I</span><br><span class="line">            2      17     1 result   I</span><br><span class="line">      StackMapTable: number_of_entries = 2</span><br><span class="line">        frame_type = 255 /* full_frame */</span><br><span class="line">          offset_delta = 12</span><br><span class="line">          locals = [ int, int ]</span><br><span class="line">          stack = [ class java/lang/Exception ]</span><br><span class="line">        frame_type = 4 /* same */</span><br><span class="line"></span><br><span class="line">  public int compareTo(java.lang.String);</span><br><span class="line">    descriptor: (Ljava/lang/String;)I</span><br><span class="line">    flags: (0x0001) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=2, args_size=2</span><br><span class="line">         0: iconst_0</span><br><span class="line">         1: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 37: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       2     0  this   Lorg/example/methodArea/MethodInnerStrucTest;</span><br><span class="line">            0       2     1     o   Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">  public int compareTo(java.lang.Object);</span><br><span class="line">    descriptor: (Ljava/lang/Object;)I</span><br><span class="line">    flags: (0x1041) ACC_PUBLIC, ACC_BRIDGE, ACC_SYNTHETIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=2, args_size=2</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: aload_1</span><br><span class="line">         2: checkcast     #13                 // class java/lang/String</span><br><span class="line">         5: invokevirtual #14                 // Method compareTo:(Ljava/lang/String;)I</span><br><span class="line">         8: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 13: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       9     0  this   Lorg/example/methodArea/MethodInnerStrucTest;</span><br><span class="line"></span><br><span class="line">  static {};</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (0x0008) ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=0, args_size=0</span><br><span class="line">         0: ldc           #15                 // String 测试方法的内部结构</span><br><span class="line">         2: putstatic     #16                 // Field str:Ljava/lang/String;</span><br><span class="line">         5: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 16: 0</span><br><span class="line">}</span><br><span class="line">Signature: #49                          // Ljava/lang/Object;Ljava/lang/Comparable&lt;Ljava/lang/String;&gt;;Ljava/io/Serializable;</span><br><span class="line">SourceFile: "MethodInnerStrucTest.java"</span><br></pre></td></tr></table></figure></div>

<h4 id="final-static类变量"><a href="#final-static类变量" class="headerlink" title="final static类变量"></a>final static类变量</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>静态类变量和类关联在一起，<strong>随着类的加载而加载</strong>（clinit赋值），被所有实例共享</p>
</li>
<li><p>全局常量：static final，<strong>在编译时就会被分配</strong></p>
</li>
</ul>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">clinit时才会被赋值</span></span><br><span class="line">public static int count;</span><br><span class="line">  descriptor: I</span><br><span class="line">  flags: (0x0009) ACC_PUBLIC, ACC_STATIC</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在编译时就被赋值</span></span><br><span class="line">public static final int number;</span><br><span class="line">  descriptor: I</span><br><span class="line">  flags: (0x0019) ACC_PUBLIC, ACC_STATIC, ACC_FINAL</span><br><span class="line">  ConstantValue: int 2 </span><br></pre></td></tr></table></figure></div>

<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">【<span class="comment">#5】就是在引用常量池</span></span></span><br><span class="line">10 invokespecial #5 &lt;java/lang/StringBuilder.&lt;init&gt;&gt;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>方法区中，包含<strong>运行时常量池</strong></p>
</li>
<li><p>字节码文件中，包含<strong>常量池</strong></p>
</li>
</ul>
<p><strong>常量池</strong></p>
<ul>
<li>字节码文件中，包含常量池（Constant Pool Table），包含各种字面量、对类型的符号引用、对域的符号引用、对方法的符号引用</li>
</ul>
<p><strong>为什么需要常量池</strong></p>
<ul>
<li>如果不用常量池，就需要在所有地方全写一遍，造成臃肿</li>
<li>需要用到的结构信息记录在常量池中，并通过<strong>引用的方式</strong>，来加载、调用所需的结构（减少代码大小）</li>
</ul>
<p><strong>常量池中有什么</strong></p>
<ol>
<li>数量值</li>
<li>字符串值</li>
<li>类引用</li>
<li>字段引用</li>
<li>方法引用</li>
</ol>
<p><strong>运行时常量池</strong></p>
<ol>
<li><p>运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。</p>
</li>
<li><p>运行时常量池就是常量池在程序运行时的称呼</p>
</li>
<li><p>JVM为每个已加载的类型（类或接口）都维护一个常量池</p>
</li>
<li><p>运行时常量池，相对于常量池的另一重要特征是：具备动态性（<code>String.intern</code>）</p>
<ul>
<li><p>运行时常量池中包含多种不同的常量，包括：</p>
<ul>
<li><p>编译期就已经明确的数值字面量</p>
</li>
<li><p>运行期解析后才能够获得的方法或者字段引用<strong>（此时不再是常量池中的符号地址了，这里换为真实地址）</strong></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>当创建类或接口的运行时常量池时，如果所需的内存超过了方法区所能提供的最大值，JVM会抛OutofMemoryError异常。</p>
</li>
</ol>
<h3 id="方法区使用举例"><a href="#方法区使用举例" class="headerlink" title="方法区使用举例"></a>方法区使用举例</h3><ul>
<li>原始代码</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodAreaDemo</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> x / y;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">        System.out.println(a + b);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>字节码文件（常量池部分）</li>
</ul>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">1 = Methodref          <span class="comment">#5.#24         // java/lang/Object."&lt;init&gt;":()V</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">2 = Fieldref           <span class="comment">#25.#26        // java/lang/System.out:Ljava/io/PrintStream;</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">3 = Methodref          <span class="comment">#27.#28        // java/io/PrintStream.println:(I)V</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">4 = Class              <span class="comment">#29            // org/example/methodArea/MethodAreaDemo</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">5 = Class              <span class="comment">#30            // java/lang/Object</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">6 = Utf8               &lt;init&gt;</span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">7 = Utf8               ()V</span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">8 = Utf8               Code</span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">9 = Utf8               LineNumberTable</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">10 = Utf8               LocalVariableTable</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">11 = Utf8               this</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">12 = Utf8               Lorg/example/methodArea/MethodAreaDemo;</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">13 = Utf8               main</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">14 = Utf8               ([Ljava/lang/String;)V</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">15 = Utf8               args</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">16 = Utf8               [Ljava/lang/String;</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">17 = Utf8               x</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">18 = Utf8               I</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">19 = Utf8               y</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">20 = Utf8               a</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">21 = Utf8               b</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">22 = Utf8               SourceFile</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">23 = Utf8               MethodAreaDemo.java</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">24 = NameAndType        <span class="comment">#6:#7          // "&lt;init&gt;":()V</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">25 = Class              <span class="comment">#31            // java/lang/System</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">26 = NameAndType        <span class="comment">#32:#33        // out:Ljava/io/PrintStream;</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">27 = Class              <span class="comment">#34            // java/io/PrintStream</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">28 = NameAndType        <span class="comment">#35:#36        // println:(I)V</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">29 = Utf8               org/example/methodArea/MethodAreaDemo</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">30 = Utf8               java/lang/Object</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">31 = Utf8               java/lang/System</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">32 = Utf8               out</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">33 = Utf8               Ljava/io/PrintStream;</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">34 = Utf8               java/io/PrintStream</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">35 = Utf8               println</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">36 = Utf8               (I)V</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>字节码文件（main函数部分）</li>
</ul>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">  descriptor: ([Ljava/lang/String;)V</span><br><span class="line">  flags: (0x0009) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=3, locals=5, args_size=1</span><br><span class="line">       0: sipush        500</span><br><span class="line">       3: istore_1</span><br><span class="line">       4: bipush        100</span><br><span class="line">       6: istore_2</span><br><span class="line">       7: iload_1</span><br><span class="line">       8: iload_2</span><br><span class="line">       9: idiv</span><br><span class="line">      10: istore_3</span><br><span class="line">      11: bipush        50</span><br><span class="line">      13: istore        4</span><br><span class="line">      15: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      18: iload_3</span><br><span class="line">      19: iload         4</span><br><span class="line">      21: iadd</span><br><span class="line">      22: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">      25: return</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line 14: 0</span><br><span class="line">      line 15: 4</span><br><span class="line">      line 16: 7</span><br><span class="line">      line 17: 11</span><br><span class="line">      line 18: 15</span><br><span class="line">      line 19: 25</span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          0      26     0  args   [Ljava/lang/String;</span><br><span class="line">          4      22     1     x   I</span><br><span class="line">          7      19     2     y   I</span><br><span class="line">         11      15     3     a   I</span><br><span class="line">         15      11     4     b   I</span><br></pre></td></tr></table></figure></div>

<ul>
<li>500放入操作数栈中</li>
</ul>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/11/xuVFpGjWPfREY7J.png" alt="image-20231011170048982" style="zoom: 38%;">

<ul>
<li>弹出操作数栈顶，保存到本地变量表中：位置1（因为main是静态方法，所以没有this）</li>
</ul>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/11/gbFfota7AN4SXzV.png" alt="image-20231011170158483" style="zoom: 38%;">

<ul>
<li>100放入操作数栈中</li>
</ul>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/11/paV3By1KgCwrAQM.png" alt="image-20231011170440658" style="zoom: 50%;">

<ul>
<li>弹出操作数栈顶元素，存入本地变量表中：位置2</li>
</ul>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/11/7PQGbNJfLa6ymZl.png" alt="image-20231011170528373" style="zoom:50%;">

<ul>
<li>读取本地变量1，压入操作数栈</li>
</ul>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/11/Rgakb36Q4qv7wM1.png" alt="image-20231011170628102" style="zoom:50%;">

<ul>
<li>读取本地变量2，压入操作数栈</li>
</ul>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/11/WJnmV4Qwy1F95RO.png" alt="image-20231011170731102" style="zoom:50%;">

<ul>
<li>栈顶元素运算，再放回栈顶</li>
</ul>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/11/kfeOlbZzN9XH14t.png" alt="image-20231011170826400" style="zoom:50%;">

<ul>
<li>弹出操作数栈顶元素，存入本地变量表中：位置3</li>
<li>将50压入操作数栈</li>
</ul>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/11/YEBtrz2csCWRANy.png" alt="image-20231011171103267" style="zoom:50%;">

<ul>
<li>弹出操作数栈顶元素，存入本地变量表中：位置4</li>
</ul>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/11/tmi7p13ArLMThuV.png" alt="image-20231011171153663" style="zoom:50%;">

<ul>
<li>获取常量池中的变量，压入操作数栈中<ul>
<li><code>#2 = Fieldref           #25.#26        // java/lang/System.out:Ljava/io/PrintStream;</code></li>
<li><code>#25 = Class              #31            // java/lang/System</code></li>
<li><code>#26 = NameAndType        #32:#33        // out:Ljava/io/PrintStream;</code></li>
</ul>
</li>
</ul>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/11/6CJ571c9pTbAvfW.png" alt="image-20231011171223405" style="zoom:50%;">

<ul>
<li>将本地变量表中：位置3，位置4的元素放入操作数栈中</li>
<li>栈顶元素运算，再放回栈顶</li>
<li>调用方法，方法中的参数会从操作数栈中弹出，压入虚拟机栈；虚拟机会开始执行虚拟机栈最上面的栈帧<ul>
<li><code>#3 = Methodref          #27.#28        // java/io/PrintStream.println:(I)V</code></li>
</ul>
</li>
</ul>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/11/R5yLh9WcfbTJiCZ.png" alt="image-20231011171754077" style="zoom:50%;">

<h3 id="方法区的演进细节"><a href="#方法区的演进细节" class="headerlink" title="方法区的演进细节"></a>方法区的演进细节</h3><p><strong>JDK6</strong></p>
<ul>
<li><p>有永久代（permanent generation），静态变量存储在永久代上</p>
</li>
<li><p>方法区由永久代实现，使用 JVM 虚拟机内存（虚拟的内存）</p>
</li>
</ul>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/11/yR1Wpq6QZ5zVYEC.png" alt="image-20231011172408549" style="zoom:50%;">

<p><strong>JDK7</strong></p>
<ul>
<li><p>有永久代，但已经逐步 “去永久代”</p>
</li>
<li><p><strong>字符串常量池，静态变量移除。保存在堆中</strong></p>
</li>
<li><p>方法区由永久代实现，使用 JVM 虚拟机内存</p>
</li>
</ul>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/11/m8P9UdjxczCiqIH.png" alt="image-20231011172438599" style="zoom:50%;">

<p><strong>JDK8</strong></p>
<ul>
<li><p>无永久代，类型信息、字段、方法、常量保存在本地内存的元空间</p>
</li>
<li><p>字符串常量池、静态变量仍然在堆中</p>
</li>
<li><p>方法区由元空间实现，使用物理机本地内存</p>
</li>
</ul>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/11/OK8wAuV3GsRchdH.png" alt="image-20231011172558701" style="zoom: 50%;">



<h4 id="永久代为什么要被元空间替代？"><a href="#永久代为什么要被元空间替代？" class="headerlink" title="永久代为什么要被元空间替代？"></a>永久代为什么要被元空间替代？</h4><blockquote>
<p><strong>官方文档</strong>：<a class="link" href="http://openjdk.java.net/jeps/122">http://openjdk.java.net/jeps/122 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<ul>
<li>Java8中移除了永久代。其中的元数据被移到了堆之外，元空间（MetaSpace）中</li>
<li>元空间使用物理内存，最大可用空间就是系统可用空间</li>
<li>改动原因：<ul>
<li>永久代很难确定大小。在某些场景下，如果动态加载类过多，容易产生永久代的OOM、</li>
<li>永久代调优很困难<ul>
<li>方法区的垃圾收集主要有两部分，常量池中：废弃的常量，不再用的类型</li>
<li>一般来说，这个区域的回收效果难令人满意，尤其是类型的卸载，条件相当苛刻</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="字符串常量池为什么调整位置"><a href="#字符串常量池为什么调整位置" class="headerlink" title="字符串常量池为什么调整位置"></a>字符串常量池为什么调整位置</h4><ul>
<li>JDK7中将StringTable放到了堆空间中</li>
</ul>
<p>因为永久代的回收效率很低，<strong>在Full GC的时候才会执行永久代的垃圾回收</strong>。</p>
<p>而Full GC是老年代的空间不足、永久代不足时才会触发。</p>
<p>这就导致StringTable回收效率不高，而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。</p>
<p>放到堆里，能及时回收内存。</p>
<h4 id="静态变量放在哪里？"><a href="#静态变量放在哪里？" class="headerlink" title="静态变量放在哪里？"></a>静态变量放在哪里？</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JDK7：-Xms200m -Xmx200m -XX:PermSize=300m -XX:MaxPermSize=300m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> * JDK8：-Xms200m -Xmx200m -XX:MetaspaceSize=300m -XX:MaxMetaspaceSize=300m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticFieldTest</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] arr = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">100</span>]; <span class="comment">// 100MB</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>对象实例（也就是这个<code>new byte[1024 * 1024 * 100]</code>）无论如何都存在堆空间</p>
</li>
<li><p>静态变量（这个对象）在JDK6，JDK7，JDK8存放位置中有所变化</p>
<ul>
<li>JDK6：方法区中（永久代实现）</li>
<li>JDK7：堆空间中</li>
<li>JDK8：堆空间（元空间中）</li>
</ul>
</li>
</ul>
<h3 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h3><ul>
<li>《Java虚拟机规范》对方法区的约束非常宽松，不要求JVM在方法区中实现GC。确实有未实现方法区<strong>类型卸载</strong>的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）。方法区GC效果难令人满意，尤其是类型的卸载，条件相当苛刻。</li>
<li>方法区的GC主要回收两部分，常量池中：<strong>废弃的常量</strong>、<strong>不再使用的类型</strong></li>
</ul>
<h4 id="常量的回收"><a href="#常量的回收" class="headerlink" title="常量的回收"></a>常量的回收</h4><ul>
<li><p>方法区内常量池之中主要存放的两大类常量：<strong>字面量</strong>和<strong>符号引用</strong></p>
<ul>
<li>字面量：如文本字符串、被声明为final的常量值等</li>
<li>符号引用：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符</li>
</ul>
</li>
<li><p>HotSpot虚拟机，对常量池的GC策略：<strong>常量没有被任何地方引用，就可以被回收</strong></p>
</li>
<li><p>回收废弃常量比较简单</p>
</li>
</ul>
<h4 id="类的卸载"><a href="#类的卸载" class="headerlink" title="类的卸载"></a>类的卸载</h4><ul>
<li>判断常量是否废弃很简单，判断类型是否不再使用很困难<ul>
<li>该类所有实例（包括派生类）都被回收</li>
<li>加载该类的类加载器已被回收（这个条件除非特殊设计，不然很难触发）</li>
<li>该类的java.lang.Class对象没有在任何地方被引用（无法在任何地方反射访问此类）</li>
</ul>
</li>
<li>JVM“被允许”对无用的类进行回收（不是必然被回收），HotSpot虚拟机<ul>
<li><code>-Xnoclassgc</code>：不对方法区进行垃圾回收</li>
<li><code>-verbose:class</code>：输出JVM载入类的相关信息</li>
<li><code>-XX:+TraceClassLoading</code>：同上，监控类的加载</li>
<li><code>-XX:+TraceClassUnLoading</code>：监控类的卸载</li>
</ul>
</li>
<li>在大量使用：反射、动态代理、CGLib等字节码框架；动态生成JSP和OSGi等，频繁自定义类加载器的场景中，通常都需要JVM具备类型卸载的能力，以保证不会对方法区造成过大的内存压力</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/12/beZrDIaKn2i8hqw.png" alt="image-20231012201219320" style="zoom:50%;">

<blockquote>
<p> 栈帧中动态链接，指向常量池中当前方法的引用</p>
</blockquote>
<h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><ol>
<li>百度<ul>
<li>三面：说一下JVM内存模型吧，有哪些区？分别干什么的？</li>
</ul>
</li>
<li>蚂蚁金服：<ul>
<li>Java8的内存分代改进</li>
<li>JVM内存分哪几个区，每个区的作用是什么？</li>
<li>一面：JVM内存分布/内存结构？栈和堆的区别？堆的结构？为什么两个survivor区？</li>
<li>二面：Eden和survior的比例分配</li>
</ul>
</li>
<li>小米：<ul>
<li>jvm内存分区，为什么要有新生代和老年代</li>
</ul>
</li>
<li>字节跳动：<ul>
<li>二面：Java的内存分区</li>
<li>二面：讲讲vm运行时数据库区</li>
<li>什么时候对象会进入老年代？</li>
</ul>
</li>
<li>京东：<ul>
<li>JVM的内存结构，Eden和Survivor比例。</li>
<li>JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和survivor。</li>
</ul>
</li>
<li>天猫：<ul>
<li>一面：Jvm内存模型以及分区，需要详细到每个区放什么。</li>
<li>一面：JVM的内存模型，Java8做了什么改</li>
</ul>
</li>
<li>拼多多：<ul>
<li>JVM内存分哪几个区，每个区的作用是什么？</li>
</ul>
</li>
<li>美团：<ul>
<li>java内存分配</li>
<li>jvm的永久代中会发生垃圾回收吗？</li>
<li>一面：jvm内存分区，为什么要有新生代和老年代？</li>
</ul>
</li>
</ol>
<h2 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h2><h3 id="对象的实例化"><a href="#对象的实例化" class="headerlink" title="对象的实例化"></a>对象的实例化</h3><p><strong>对象创建的方式：</strong></p>
<ol>
<li>new，最常见的方式<ul>
<li>变形1：单例类中调用静态类方法，getInstance()</li>
<li>变形2：XxxBuilder/XxxFactory的静态方法</li>
</ul>
</li>
<li>Class的newInstance()方法，使用反射<ul>
<li>必须空参，权限必须public</li>
</ul>
</li>
<li>Constructor的newInstance()方法，使用反射<ul>
<li>可以带参数，权限没有要求</li>
</ul>
</li>
<li>使用clone()，不调用任何构造器，当前类需要实现Cloneable接口</li>
<li>使用反序列化，从文件或网络中获取对象的二进制流</li>
<li>使用第三方库（Objenesis），动态生成对象</li>
</ol>
<p><strong>对象创建的步骤</strong></p>
<ol>
<li>判断对象对应的类是否：加载，链接，初始化<ul>
<li>虚拟机遇到new指令，检查能否在元空间的常量池中定位到此类的符号引用</li>
<li>并检查此类是否已被加载、解析、初始化（类的元信息是否存在）</li>
<li>如果没有，在双亲委派机制下，使用当前类加载器，用包名+类名为key查找对应class文件。找不到文件抛出ClassNotFoundException异常。找到了则进行类加载</li>
</ul>
</li>
<li>为对象分配内存<ul>
<li>如果内存规整：指针碰撞（Bump The Point）<ul>
<li>意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针往空闲内存那边挪动一段与对象大小相等的距离罢了</li>
<li>如果垃圾收集器选择的是Serial ，ParNew这种基于压缩算法的，虚拟机采用这种分配方式</li>
</ul>
</li>
<li>如果内存不规整：空闲列表（Free List）<ul>
<li>维护一个空闲列表，记录上哪些内存块是可用的</li>
<li>分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容</li>
</ul>
</li>
</ul>
</li>
<li>处理并发安全问题<ul>
<li>采用CAS+失败重试，保证更新的原子性（乐观锁）</li>
<li>每个线程预先分配TLAB，通过设置<code>-XX:+UseTLAB</code>参数来设置</li>
</ul>
</li>
<li>初始化分配到的空间（属性的默认初始化，零值）</li>
<li>设置对象的对象头<ul>
<li>将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息，等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。</li>
</ul>
</li>
<li>执行init方法进行初始化<ul>
<li>属性值初始化</li>
<li>代码块初始化</li>
<li>构造器初始化</li>
</ul>
</li>
</ol>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/15/ukJCfvYgxNbVZ7r.png" alt="image-20231015223936110"></p>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p><strong>对象头（Header）</strong></p>
<ol>
<li><p>运行时元数据</p>
<ul>
<li>哈希值（HashCode）：对象在堆空间中都有一个首地址值，引用根据这个地址指向堆中的对象，这就是哈希值起的作用</li>
<li>GC分代年龄</li>
<li>锁状态标志</li>
<li>线程持有的锁</li>
<li>偏向线程ID</li>
<li>偏向时间戳</li>
</ul>
</li>
<li><p>类型指针</p>
<ul>
<li>指向元空间中，对象所属的类型</li>
</ul>
</li>
<li><p>如果是数组对象，还会记录数组长度</p>
</li>
</ol>
<p><strong>实例数据（Instance Data）</strong></p>
<p>父类定义的变量、本身定义的变量</p>
<p>规则：</p>
<ul>
<li>父类变量，出现在子类变量之前</li>
<li>相同宽度的字段总是被分配在一起</li>
<li>如果CompactFields参数为true（默认true），子类窄变量，可能插入到父类变量的空隙</li>
</ul>
<p><strong>对齐填充（Padding）</strong></p>
<p>没作用，仅是占位符</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/15/BF2P874QxCtG3Kd.png" alt="image-20231015224856096"></p>
<h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>JVM如何让通过<strong>栈帧中的对象引用</strong>，访问到<strong>堆空间中的对象实例</strong>的呢？</p>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/16/iKB8jCFU4MmqGHp.png" alt="image-20231016112719345" style="zoom: 67%;">

<h3 id="对象访问的方式"><a href="#对象访问的方式" class="headerlink" title="对象访问的方式"></a>对象访问的方式</h3><ul>
<li>使用直接指针</li>
</ul>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/16/9soSWhN2aedlUqc.png" alt="image-20231016113123346" style="zoom: 67%;">

<ul>
<li><p>使用句柄访问（使用句柄池）</p>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/16/e1PtFXqTQ56IELk.png" alt="屏幕截图 2023-10-16 112924" style="zoom:67%;"></li>
</ul>
<h2 id="直接内存（了解）"><a href="#直接内存（了解）" class="headerlink" title="直接内存（了解）"></a>直接内存（了解）</h2><blockquote>
<p>JDK8引入元空间，就是使用的直接内存</p>
</blockquote>
<ul>
<li>不是虚拟运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域</li>
<li>直接内存是在Java堆外的、直接向系统申请的内存区间</li>
<li>来源于NIO，通过存储在堆中的DirectByteBuffer操作Native内存</li>
<li>读写性能更高<ul>
<li>出于性能考虑，<strong>读写频繁</strong>的场合考虑使用直接内存</li>
<li>Java的NIO库允许Java程序使用直接内存，用于数据缓存</li>
</ul>
</li>
<li>也可能导致<code>OutOfMemoryError: Direct buffer memory</code>异常<ul>
<li>大小受限于系统内存大小</li>
</ul>
</li>
<li>缺点：<ul>
<li>分配回收成本较高</li>
<li>不受JVM内存回收管理</li>
</ul>
</li>
<li>也可以设置直接内存的最大值<ul>
<li>可以通过<code>-XX:MaxDirectMemorySize=10m</code>设置</li>
<li>如果不指定，默认和堆最大值<code>-Xmx</code>一致</li>
</ul>
</li>
</ul>
<h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferTest</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BUFFER</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 直接分配内存空间</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(BUFFER);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过任务管理器可以看到，内存被占用了1G</span></span><br><span class="line">        System.out.println(<span class="string">"直接内存分配完毕"</span>)</span><br><span class="line">        scanner.next();</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 通过任务管理器可以看到，内存被释放了1G</span></span><br><span class="line">        System.out.println(<span class="string">"直接内存开始释放"</span>);</span><br><span class="line">        byteBuffer = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        scanner.next();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><p>访问直接内存读写性能更高。使用JVM时，读取内存，应用需要从用户态切换到内核态。</p>
<ul>
<li><p>读内存时：应用需要，先从用户态的虚拟机内存中读取数据，而此数据需要从内核态的物理内存上获取</p>
</li>
<li><p>写内存时：应用需要，先写到用户态的虚拟机内存空间上，然后copy到内核态的本地物理内存上</p>
</li>
</ul>
<p>使用直接内存，则<strong>不会有用户态和内核态的copy</strong>，避免中间商赚差价，读写速度更快</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试：将一个文件复制三次</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferTest1</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_100Mb</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> <span class="string">"D:\\data.nsp"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) {</span><br><span class="line">            <span class="type">String</span> <span class="variable">dest</span> <span class="operator">=</span> <span class="string">"D:\\data"</span> + i + <span class="string">".nsp"</span>;</span><br><span class="line">            sum += directBuffer(src, dest);</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"总时间sum = "</span> + sum);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>使用JVM内存做Buffer</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 总时间sum = 26416</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">io</span><span class="params">(String src, String dest)</span> {</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span> (</span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(src);</span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dest);</span><br><span class="line">    ) {</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[_100Mb];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(buffer)) != -<span class="number">1</span>) {</span><br><span class="line">            fos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    }</span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">return</span> end - start;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>使用直接内存地址做Buffer</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 总时间sum = 11260</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">directBuffer</span><span class="params">(String src, String dest)</span> {</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span> (</span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(src);</span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dest);</span><br><span class="line"></span><br><span class="line">            <span class="type">FileChannel</span> <span class="variable">inChannel</span> <span class="operator">=</span> fis.getChannel();</span><br><span class="line">            <span class="type">FileChannel</span> <span class="variable">outChannel</span> <span class="operator">=</span> fos.getChannel();</span><br><span class="line">    ) {</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(_100Mb);</span><br><span class="line">        <span class="keyword">while</span> (inChannel.read(byteBuffer) != -<span class="number">1</span>) {</span><br><span class="line">            byteBuffer.flip(); <span class="comment">// 修改为读数据模式</span></span><br><span class="line">            outChannel.write(byteBuffer);</span><br><span class="line">            byteBuffer.clear(); <span class="comment">// 清空</span></span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    }</span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">return</span> end - start;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="直接内存溢出实验"><a href="#直接内存溢出实验" class="headerlink" title="直接内存溢出实验"></a>直接内存溢出实验</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -Xmx20m -XX:MaxDirectMemorySize=10m</span></span><br><span class="line"><span class="comment">// 没有OOM：使用UnSafe API分配的内存不受-XX:MaxDirectMemorySize参数的控制</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxDirectMemorySizeTest</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException {</span><br><span class="line">        <span class="type">Field</span> <span class="variable">unsafeField</span> <span class="operator">=</span> Unsafe.class.getDeclaredFields()[<span class="number">0</span>];</span><br><span class="line">        unsafeField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe) unsafeField.get(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">            unsafe.allocateMemory(_1MB);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -Xmx20m -XX:MaxDirectMemorySize=10m</span></span><br><span class="line"><span class="comment">// Exception in thread "main" java.lang.OutOfMemoryError: Direct buffer memory</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxDirectMemorySizeTest</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException {</span><br><span class="line">        ByteBuffer.allocateDirect(<span class="number">128</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h2><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/16/azHEeovJcZ7T8UC.png" alt="45792140-cf44-4732-be5b-fe310e7eeb4f" style="zoom:67%;">

<ul>
<li>执行引擎包括：解释器、即时编译器、垃圾回收器</li>
<li>执行引擎的任务：将字节码指令翻译/解释为对应平台上的本地机器指令</li>
</ul>
<h3 id="执行引擎的工作流程"><a href="#执行引擎的工作流程" class="headerlink" title="执行引擎的工作流程"></a>执行引擎的工作流程</h3><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/16/O1b7X2tqdnL5Wsv.png" alt="1b540604-7281-467c-b981-acecdbdb93d2" style="zoom:67%;">

<ul>
<li>执行什么字节码指令：依赖PC寄存器<ul>
<li>执行完成后，PC寄存器更新为下一条需要被执行的指令地址</li>
</ul>
</li>
<li>执行过程中，执行引擎会通过：<ul>
<li>局部变量表中的对象引用，准确定位存储在堆中的<strong>对象实例</strong></li>
<li>对象头中的元数据指针，准确定位存储在方法区的<strong>对象类型信息</strong></li>
</ul>
</li>
</ul>
<h3 id="代码编译和执行的过程"><a href="#代码编译和执行的过程" class="headerlink" title="代码编译和执行的过程"></a>代码编译和执行的过程</h3><ol>
<li>黄色部分：编译生成字节码的过程，javac编译器（前端编译器）完成，与JVM无关</li>
<li>后面绿色，蓝色部分：解释执行与即时编译，JVM完成</li>
</ol>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/17/SALcbsheNpGInHT.png" alt="image-20231017112501619" style="zoom:50%;">

<ol start="3">
<li>javac编译器（前端编译器）流程：</li>
</ol>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/17/1AtecroJOXBxs5R.png" alt="image-20231017112659310" style="zoom:50%;">

<ol start="4">
<li>java字节码执行由JVM执行引擎来完成，流程如下：</li>
</ol>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/17/UVxXyr5suYw8MAv.png" alt="image-20231017112750802" style="zoom:50%;">

<h4 id="什么是解释器？什么是JIT编译器？"><a href="#什么是解释器？什么是JIT编译器？" class="headerlink" title="什么是解释器？什么是JIT编译器？"></a>什么是解释器？什么是JIT编译器？</h4><ol>
<li>解释器：当JVM启动时，会根据预定义的规范对字节码采用<strong>逐行解释的方式执行</strong>，将字节码“翻译”为本地机器指令执行</li>
<li>JIT编译器：就是虚拟机将源代码<strong>一次性编译成机器语言</strong>，但并不是马上执行</li>
</ol>
<h4 id="为什么Java是半编译半解释语言？"><a href="#为什么Java是半编译半解释语言？" class="headerlink" title="为什么Java是半编译半解释语言？"></a>为什么Java是半编译半解释语言？</h4><ol>
<li>现在JVM在执行时，通常会将解释执行与编译执行结合起来进行</li>
<li>JIT编译器将字节码翻译成本地代码后，可以做缓存操作，存储在方法区的JIT代码缓存中（执行效率更高了），并且在翻译成本地代码的过程中可以做优化</li>
</ol>
<h3 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h3><p><strong>为什么要有解释器：</strong></p>
<ul>
<li>JVM设计者们的初衷：跨平台特性，避免由静态编译的方式生成本地机器指令，从而诞生了逐行解释的想法（不产生中间产品）</li>
</ul>
<p><strong>解释器的分类：</strong></p>
<ul>
<li>Java发展历史中，出现了<strong>字节码解释器</strong>和<strong>模板解释器</strong><ul>
<li>字节码解释器：通过纯软件代码，模拟字节码的执行，效率低下</li>
<li>模板解释器：将每一条字节码与一个模板函数关联，模板函数中直接产生执行的机器码，大幅度提高了性能</li>
</ul>
</li>
<li>HotSpot VM中，解释器主要由<strong>Interpreter模块</strong>和<strong>Code模块</strong>构成<ul>
<li>Interpreter模块：实现解释器的核心功能</li>
<li>Code模块：用于管理HotSpot VM在运行时生成的本地机器指令</li>
</ul>
</li>
</ul>
<p><strong>解释器的现状：</strong></p>
<ul>
<li>Python、Perl、Ruby等高级语言也是使用解释器的</li>
<li>为了解决低效的问题，JVM平台支持JIT技术<ul>
<li>避免函数被解释执行，将整个函数编译成机器码，效率大幅度提升</li>
</ul>
</li>
</ul>
<h3 id="JIT编译器"><a href="#JIT编译器" class="headerlink" title="JIT编译器"></a>JIT编译器</h3><ul>
<li>HotSpot VM是高性能虚拟机的代表作之一，<strong>它采用解释器与即时编译器并存的架构</strong></li>
</ul>
<blockquote>
<p> 比如：JRockit只部署在服务器上，已经砍掉了解释器</p>
</blockquote>
<p><strong>为什么还需要解释器:</strong></p>
<ul>
<li>看重启动时间的场景，需要两者并存的架构，来换取一个平衡</li>
<li>此模式下，解释器可以首先发挥作用，省去编译时间；随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，提高执行效率</li>
<li>在编译器进行激进优化不成立的时候，作为编译器的“逃生门”（后备方案）</li>
</ul>
<p><strong>阿里的案例：</strong></p>
<ul>
<li>机器在热机状态（运行了一段时间）可以承受的负载要大于冷机状态</li>
<li>程序员分批发布时，误分为两批发布。本来热机状态一半的机器可以勉强承载流量。但由于刚启动的JVM均是解释执行，还没有进行热点代码统计和JIT动态编译，导致机器启动之后，当前1/2发布成功的服务器马上全部宕机，<strong>此故障说明了JIT的存在</strong></li>
</ul>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/17/Tqy54szQFxh7eKi.png" alt="image-20231017190532771" style="zoom:50%;">

<h4 id="编译器相关概念"><a href="#编译器相关概念" class="headerlink" title="编译器相关概念"></a>编译器相关概念</h4><ol>
<li>前端编译器：把.java文件转变为.class</li>
<li>JVM的后端运行期编译器（JIT编译器）：把字节码转变为机器码</li>
<li>静态提前编译器（AOT编译器）：直接把.java文件编译成本地机器码（后续发展的趋势）</li>
</ol>
<blockquote>
<p>典型的编译器：</p>
<ol>
<li>前端编译器：Sun的javac、Eclipse JDT的增量式编译器（ECJ）</li>
<li>JIT编译器：HotSpot VM的C1、C2编译器</li>
<li>AOT编译器：GNU Compiler for the Java（GCJ）、Excelsior JET</li>
</ol>
</blockquote>
<h4 id="热点代码及探测方式"><a href="#热点代码及探测方式" class="headerlink" title="热点代码及探测方式"></a>热点代码及探测方式</h4><ul>
<li><p>在运行时，JIT编译器针对<strong>频繁被调用的热点代码</strong>做出优化，直接编译为机器指令，以提升性能</p>
<ul>
<li>这种编译方式发生在方法的执行过程中，因此也被称之为栈上替换（OSR编译，On StackReplacement）</li>
</ul>
</li>
<li><p>目前HotSpot VM所采用的热点探测方式是<strong>基于计数器的热点探测</strong></p>
</li>
<li><p>每个函数都建立两个不同类型的计数器</p>
<ul>
<li>调用计数器：方法的调用次数</li>
<li>回边计数器：方法体中，循环体执行的次数</li>
</ul>
</li>
</ul>
<p><strong>方法调用计数器：</strong></p>
<ul>
<li><p>统计方法调用的次数，达到阈值触发JIT编译</p>
<ul>
<li>阈值可以用<code>-XX:CompileThreshold</code>来设定</li>
</ul>
</li>
<li><p>方法被调用时，会检查是否存在被JIT编译过的版本</p>
<ul>
<li>存在，执行编译后的本地代码</li>
<li>不存在，计数器加一<ul>
<li>超过阈值，向JIT编译器提交此方法的代码编译请求</li>
<li>未超过阈值，对字节码解释执行</li>
</ul>
</li>
</ul>
</li>
<li><p>存在<strong>热度衰减</strong>：超过一定的时间，如果调用次数不足以让它提交给JIT编译器编译，那此方法的调用计数器就会减少一半</p>
<ul>
<li>可以用<code>-XX:-UseCounterDecay</code>关闭热度衰减（这样绝大多数方法都会被编译成本地方法）</li>
<li>可以用<code>-XX:CounterHalfLifeTime</code>参数设置半衰期时间，单位是秒</li>
</ul>
</li>
</ul>
<p><strong>回边计数器：</strong></p>
<p>统计方法中循环体代码执行的次数，字节码中遇到控制流向后跳转的指令称为“回边”（Back Edge）。建立回边计数器统计的目的就是为了触发OSR编译</p>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/18/tiG6rmZPBKqS7A3.png" alt="image-20231018131353630" style="zoom: 67%;">

<h3 id="HotSpot中的程序执行"><a href="#HotSpot中的程序执行" class="headerlink" title="HotSpot中的程序执行"></a>HotSpot中的程序执行</h3><p><strong>设置程序执行的方式：</strong></p>
<ul>
<li><code>-Xint</code>：完全采用解释器模式执行</li>
<li><code>-Xcomp</code>：完全采用JIT编译器模式执行。编译出问题，解释器会介入</li>
<li><code>-Xmixed</code>：采用解释器+编译器混合的模式执行</li>
</ul>
<blockquote>
<p>-Xint  : 6520ms	-Xcomp : 950ms	-Xmixed : 936ms</p>
<p>实验结论：只用解释器执行是真的慢</p>
</blockquote>
<p><strong>HotSpotVM JIT分类</strong>：</p>
<ol>
<li><code>-client</code>：Java虚拟机运行在Client模式下，并使用C1编译器<ul>
<li>C1编译器：对字节码进行简单可靠的优化，编译速度快</li>
</ul>
</li>
<li><code>-server</code>：Java虚拟机运行在Server模式下，并使用C2编译器<ul>
<li>C2编译器：进行较激进的优化，编译慢但执行效率高</li>
</ul>
</li>
</ol>
<p><strong>CI和C2编译器不同的优化策略：</strong></p>
<ul>
<li>C1编译器：<ul>
<li>方法内联：将引用函数代码，编译到引用处</li>
<li>去虚拟化：对唯一实现的方法进行内联</li>
<li>冗余消除：在运行期间，把一些不会执行的代码折叠掉</li>
</ul>
</li>
<li>C2编译器，优化主要是在全局层面，逃逸分析是优化的基础；基于逃逸分析的优化有：<ul>
<li>标量替换：用标量值代替聚合对象的属性值</li>
<li>栈上分配：未逃逸的对象，分配在栈上</li>
<li>同步消除：清除同步操作，通常指synchronized</li>
</ul>
</li>
</ul>
<blockquote>
<p>逃逸分析只有在C2（server）模式下才会触发</p>
</blockquote>
<p><strong>分层编译策略：</strong></p>
<p>不开启性能监控：程序解释执行可以触发C1编译，将字节码编译成机器码</p>
<p>开启性能监控：C2编译会根据性能监控信息进行激进优化</p>
<blockquote>
<p>Java7之后，<code>-server</code>会默认开启分层编译策略，C1和C2协作来完成编译任务</p>
</blockquote>
<p><strong>Graal编译器：</strong></p>
<ul>
<li>自JDK10起，HotSpot又加入了一个全新的即时编译器：Graal编译器</li>
<li>编译效果短短几年时间就追平了C2编译器，未来可期（对应还出现了Graal虚拟机，是有可能替代Hotspot的虚拟机的）</li>
<li>目前，带着实验状态标签，需要使用开关参数去激活才能使用<code>-XX:+UnlockExperimentalvMOptions -XX:+UseJVMCICompiler</code></li>
</ul>
<p><strong>AOT编译器：</strong></p>
<ul>
<li><p>JDK9引入了AOT编译器（静态提前编译器，Ahead of Time Compiler）</p>
<ul>
<li>AOT编译指的则是，<strong>在程序运行之前</strong>，将字节码转换为机器码</li>
</ul>
</li>
<li><p>JDK9引入了实验性AOT编译工具jaotc。借助Graal编译器，将输入的Java类文件转换为机器码，存放至生成的动态共享库之中</p>
<ul>
<li><code>.java</code> -&gt; <code>.class</code> - (使用jaotc) -&gt; <code>.so</code></li>
</ul>
</li>
<li><p>优点：</p>
<ol>
<li>已经预编译成二进制库，可以直接执行</li>
<li>不必等待JIT编译器预热，减少Java”第一次运行慢“的不良体验</li>
</ol>
</li>
<li><p>缺点：</p>
<ol>
<li>破坏Java”一次编译，到处运行“，必须为每个硬件和系统编译对应的包</li>
<li>降低了Java链接过程中的动态性，加载的代码在编译器就必须全部知道</li>
</ol>
</li>
</ul>
<h2 id="StringTable"><a href="#StringTable" class="headerlink" title="StringTable"></a>StringTable</h2><h3 id="String基本特性"><a href="#String基本特性" class="headerlink" title="String基本特性"></a>String基本特性</h3><ol>
<li>String被声明为final的，不可被继承</li>
<li>String实现了Serializable接口，表示是支持序列化的</li>
<li>String实现了Comparable接口，表示可以比大小</li>
<li>JDK8之前定义<code>final char[]</code>用于存储数据，JDK9改为<code>final byte[]</code></li>
<li>String具有不可变性，无论是修改还是赋值，都需要重新指定内存区域来赋值</li>
</ol>
<p><strong>为什么改为byte[]：</strong></p>
<blockquote>
<p>官方文档：<a class="link" href="http://openjdk.java.net/jeps/254">http://openjdk.java.net/jeps/254 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<ol>
<li>每个char字符使用两个字节（16位），大量的拉丁字符只需要一个字节存储，浪费空间</li>
<li>之前使用UTF-16的char[]数组来存储，现在改为byte[]数组+编码标记字段来存储<ul>
<li>如果是ISO-8859-1/Latin-1，只需要一个字节存</li>
<li>如果是其它字符集，比如UTF-8，仍然用两个字节存</li>
</ul>
</li>
</ol>
<h4 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a>底层结构</h4><ol>
<li>String的String Pool（字符串常量池）是一个固定大小的HashTable。如果放进String Pool的String非常多，就会造成Hash冲突严重，导致链表会很长。而链表长了后，会导致调用<code>String.intern()</code>方法时性能下降</li>
<li><code>-XX:StringTablesize</code>可设置StringTable的长度<ul>
<li>JDK6中长度是固定的，就是1009</li>
<li>JDK7中默认长度60013，StringTablesize设置不做限制</li>
<li>JDK8中默认长度60013，StringTablesize最小为1009</li>
</ul>
</li>
</ol>
<h3 id="String内存分配"><a href="#String内存分配" class="headerlink" title="String内存分配"></a>String内存分配</h3><p>Java有8种基本类型+String类型，8种基本类型的常量池是系统协调的，而String的常量池比较特殊</p>
<ul>
<li>双引号声明的字符串会直接存储在常量池种：<code>String info = "xuedongyun"</code></li>
<li>不是使用双引号声明的字符串，可以使用<code>intern()</code>方法</li>
</ul>
<p>字符串常量池存储位置</p>
<ul>
<li><p>JDK6之前，存储在永久代</p>
</li>
<li><p>JDK7，存储在堆中</p>
</li>
<li><p>JDK8，依然存储在堆中，永久代变成元空间</p>
</li>
</ul>
<p><strong>StringTable为什么要调整位置？</strong></p>
<blockquote>
<p> <strong>官方文档</strong>：<a class="link" href="https://www.oracle.com/java/technologies/javase/jdk7-relnotes.html#jdk7changes">https://www.oracle.com/java/technologies/javase/jdk7-relnotes.html#jdk7changes <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<ol>
<li>为什么要调整位置？<ul>
<li>永久代的默认空间大小较小</li>
<li>永久代垃圾回收频率较低，大量字符串无法及时回收。容易Full GC产生STW，或者OOM: PermGen Space</li>
<li>堆中空间足够大，字符串可被及时回收</li>
</ul>
</li>
<li>intern字符串在堆中分配，与其他被创建的对象一起分配，可能需要调整堆的大小</li>
</ol>
<p><strong>OOM实验：</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">	JDK8：-XX:MetaspaceSize=6m -XX:MaxMetaspaceSize=6m -Xms6m -Xmx6m</span></span><br><span class="line"><span class="comment">	Exception in thread "main" java.lang.OutOfMemoryError: Java heap space</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">short</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>){</span><br><span class="line">            set.add(String.valueOf(i++).intern());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="String基本操作"><a href="#String基本操作" class="headerlink" title="String基本操作"></a>String基本操作</h3><p><strong>举例1：</strong></p>
<p>完全相同的字符串字面量，必须指向同一个String类实例</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"1"</span>);</span><br><span class="line">        System.out.println(<span class="string">"2"</span>);</span><br><span class="line">        System.out.println(<span class="string">"3"</span>);</span><br><span class="line">        System.out.println(<span class="string">"4"</span>);</span><br><span class="line">        System.out.println(<span class="string">"5"</span>);</span><br><span class="line">        System.out.println(<span class="string">"6"</span>);</span><br><span class="line">        System.out.println(<span class="string">"7"</span>);</span><br><span class="line">        System.out.println(<span class="string">"8"</span>);</span><br><span class="line">        System.out.println(<span class="string">"9"</span>);</span><br><span class="line">        System.out.println(<span class="string">"10"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如下的字符串"1" 到 "10"不会再次加载</span></span><br><span class="line">        System.out.println(<span class="string">"1"</span>);</span><br><span class="line">        System.out.println(<span class="string">"2"</span>);</span><br><span class="line">        System.out.println(<span class="string">"3"</span>);</span><br><span class="line">        System.out.println(<span class="string">"4"</span>);</span><br><span class="line">        System.out.println(<span class="string">"5"</span>);</span><br><span class="line">        System.out.println(<span class="string">"6"</span>);</span><br><span class="line">        System.out.println(<span class="string">"7"</span>);</span><br><span class="line">        System.out.println(<span class="string">"8"</span>);</span><br><span class="line">        System.out.println(<span class="string">"9"</span>);</span><br><span class="line">        System.out.println(<span class="string">"10"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>程序启动时加载了2144个字符串常量</p>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/18/YNU1cyWKZIuftka.png" alt="image-20231018203027571" style="zoom: 40%;">

<p>程序结束时，加载了2155个字符串常量（多了”1”到”10”，以及回车符）</p>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/18/IP3nVXCTx5H7ypK.png" alt="image-20231018211546309" style="zoom:40%;">

<p><strong>举例2：</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Memory</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">Memory</span> <span class="variable">mem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Memory</span>();</span><br><span class="line">        mem.foo(obj);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(Object param)</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> param.toString();</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/19/lNCEYiTM1c6g8QK.png" alt="image-20231019201153466" style="zoom: 67%;">

<h3 id="字符串拼接操作"><a href="#字符串拼接操作" class="headerlink" title="字符串拼接操作"></a>字符串拼接操作</h3><ul>
<li>常量与常量的拼接，结果在常量池，原理是编译期优化</li>
<li>拼接前后，只要有一个是变量，结果就在堆中。变量拼接的原理是StringBuilder</li>
<li>对拼接的结果调用<code>intern()</code>方法<ul>
<li>常量池中存在，返回字符串在常量池中的地址</li>
<li>常量池中不存在，在常量池中创建一份，再返回地址</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">"a"</span> + <span class="string">"b"</span>;</span><br><span class="line"><span class="comment">// 最终编译成：String a = "ab";</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">"a"</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> s1 + <span class="string">"b"</span>;</span><br><span class="line"><span class="comment">// 出现了变量，相当于堆空间中new String()。使用StringBuilder拼接，结果在堆中;</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> s.intern();</span><br><span class="line"><span class="comment">// 调用intern方法，如果常量池中存在则返回常量池中的地址；如果不存在则在常量池中创建一份，返回此对象地址</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>改进空间：</p>
<ul>
<li>在实际开发中，如果确定长度不高于highLevel，建议使用构造器实例化：<ul>
<li><code>StringBuilder s = new StringBuilder(highLevel);</code></li>
</ul>
</li>
<li>避免频繁扩容，提升性能</li>
</ul>
</blockquote>
<h3 id="intern-的使用"><a href="#intern-的使用" class="headerlink" title="intern()的使用"></a>intern()的使用</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title function_">intern</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>intern是一个native方法，调用底层C的方法</li>
<li>StringTable最初是空的，由String类私有地维护，调用intern方法时：<ul>
<li>如果池中包含equals(object)方法确定相同的字符串：返回该字符串对象地址</li>
<li>否则：添加字符串对象到池中，返回该字符串对象地址</li>
</ul>
</li>
</ul>
<p><strong>new String(“ab”)会创建几个对象？</strong></p>
<ul>
<li>两个对象，一个对象是new关键词在堆空间创建的；另一个对象是字符串常量池中的对象”ab”</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringNewTest</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"ab"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">0 new #2 &lt;java/lang/String&gt;						# 在堆中创建了一个String对象</span><br><span class="line">3 dup</span><br><span class="line">4 ldc #3 &lt;ab&gt;									# 在字符串常量池中放入"ab"（如果之前没有的话）</span><br><span class="line">6 invokespecial #4 &lt;java/lang/String.&lt;init&gt;&gt;</span><br><span class="line">9 astore_1</span><br><span class="line">10 return</span><br></pre></td></tr></table></figure></div>

<p><strong>new String(“a”) + new String(“b”)会创建几个对象？</strong></p>
<ul>
<li>对象1：new StringBuilder()</li>
<li>对象2：new String(“a”)</li>
<li>对象3：常量池中的”a”（如果之前没有的话）</li>
<li>对象4：new String(“b”)</li>
<li>对象5：常量池中的”b”（如果之前没有的话）</li>
<li>对象6：new String(“ab”)，<strong>由StringBuilder的toString()创建，但没有常量池中生成</strong></li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringNewTest</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"a"</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"b"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">0 new #2 &lt;java/lang/StringBuilder&gt;						# StringBuilder对象</span><br><span class="line">3 dup</span><br><span class="line">4 invokespecial #3 &lt;java/lang/StringBuilder.&lt;init&gt;&gt;</span><br><span class="line">7 new #4 &lt;java/lang/String&gt;								# String对象，"a"</span><br><span class="line">10 dup</span><br><span class="line">11 ldc #5 &lt;a&gt;											# 常量池中的对象，"a"</span><br><span class="line">13 invokespecial #6 &lt;java/lang/String.&lt;init&gt;&gt;</span><br><span class="line">16 invokevirtual #7 &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line">19 new #4 &lt;java/lang/String&gt;							# String对象，"b"</span><br><span class="line">22 dup</span><br><span class="line">23 ldc #8 &lt;b&gt;											# 常量池中的对象，"b"</span><br><span class="line">25 invokespecial #6 &lt;java/lang/String.&lt;init&gt;&gt;</span><br><span class="line">28 invokevirtual #7 &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line">31 invokevirtual #9 &lt;java/lang/StringBuilder.toString&gt;	# StringBuilder执行toString方法，创建了String对象</span><br><span class="line">34 astore_1							</span><br><span class="line">35 return</span><br></pre></td></tr></table></figure></div>

<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/19/4bcqXehA1gHUkYw.png" alt="image-20231019203253046"></p>
<p><strong>JDK7之后intern的变化：</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringIntern</span> {</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"1"</span>);		<span class="comment">// 堆空间中new了对象，常量池中也放入了"1"</span></span><br><span class="line">        s.intern();						<span class="comment">// 调用此方法之前，常量池中已经有"1"了</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">"1"</span>;				<span class="comment">// 直接返回常量池中的地址</span></span><br><span class="line">        System.out.println(s == s2);	<span class="comment">// JDK6:false, JDK7:false, JDK8:false</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"1"</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"1"</span>);	<span class="comment">// s3变量的地址为堆空间中的new String("11")，常量池中没有</span></span><br><span class="line">        s3.intern();									<span class="comment">// 字符串常量池中生成"11"</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">"11"</span>;								<span class="comment">// 直接返回常量池中的地址</span></span><br><span class="line">        System.out.println(s3 == s4);	<span class="comment">// JDK6:false, JDK7:true, JDK8:true</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>JDK7以后，由于StringTable放到堆空间中了。调用s3.intern()方法时，如果常量池中没有，为了节省空间，会在常量池中直接记录s3的地址</p>
<p>JDK7以后，不用重新创建并放入一个”11”对象了</p>
</blockquote>
<p><strong>性能测试：</strong></p>
<p>直接<code>new String</code>：程序需要维护大量存放在堆空间中的String实例，内存占用高</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/19/AWfclNdPkVaezmU.png" alt="image-20231019205325275"></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">arr[i] = <span class="keyword">new</span> <span class="title class_">String</span>(String.valueOf(data[i % data.length]));</span><br></pre></td></tr></table></figure></div>

<p>使用<code>intern()</code>：直接指向常量池中的字符串，内存占用也更低</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/19/nDlQmN3LJGgsVzw.png" alt="image-20231019205336938"></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">arr[i] = <span class="keyword">new</span> <span class="title class_">String</span>(String.valueOf(data[i % data.length])).intern();</span><br></pre></td></tr></table></figure></div>

<h3 id="StringTable垃圾回收测试"><a href="#StringTable垃圾回收测试" class="headerlink" title="StringTable垃圾回收测试"></a>StringTable垃圾回收测试</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -Xms15m -Xmx15m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringGCTest</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) {</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(i).intern();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>Number of entries 和 Number of literals 明显没有 100000</li>
</ul>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/20/2DOYdHKfJ1EeFvT.png" alt="image-20231020133405706"></p>
<ul>
<li>年轻代发生了垃圾回收</li>
</ul>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/20/rXp12GDmHdW8fsR.png" alt="image-20231020133529809"></p>
<h3 id="G1中的String去重操作（了解）"><a href="#G1中的String去重操作（了解）" class="headerlink" title="G1中的String去重操作（了解）"></a>G1中的String去重操作（了解）</h3><blockquote>
<p><strong>官方文档</strong>：<a class="link" href="http://openjdk.java.net/jeps/192">http://openjdk.java.net/jeps/192 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<p><strong>String去重操作的背景：</strong></p>
<ul>
<li>注意：不是指字符串常量池的去重，常量池本身就没有重复的</li>
<li>背景：对很多Java程序做测试，结果：<ul>
<li>堆存活数据中，String对象占了25%</li>
<li>堆存活数据中重复的String对象占了13.5%</li>
<li>String对象平局长度45</li>
</ul>
</li>
<li>堆上存在重复的String对象，是一种内存的浪费</li>
</ul>
<p><strong>String去重操作的实现：</strong></p>
<ol>
<li>垃圾收集器工作时，会访问堆上存活的对象。每一个对象，都会检查是否是候选要去重的String对象</li>
<li>如果是，把对象的引用插入到队列中等待处理。一个去重线程在后台运行，处理这个队列</li>
<li>使用一个HashTable来记录所有的被String对象使用的不重复的char数组。去重时会查这个HashTable，看堆上是否存在一摸一样的char数组</li>
<li>如果存在，String对象会被调整引用那个数组，释放对原来数组的引用（最终被垃圾回收器回收掉）</li>
<li>如果不存在，char数组会被插入到Hashtable，以后就可以共享这个数组了</li>
</ol>
<p><strong>命令行选项：</strong></p>
<ul>
<li><p><code>-XX:+UseStringDeduplication</code>：开启String去重，默认是不开启的，需要手动开启</p>
</li>
<li><p><code>-XX:+PrintStringDeduplicationStatistics</code>：打印详细的去重统计信息</p>
</li>
<li><p><code>-XX:StringDeduplicationAgeThreshold=threshold</code> ：达到这个年龄的String对象被认为是去重的候选对象</p>
</li>
</ul>
<h2 id="垃圾回收概述"><a href="#垃圾回收概述" class="headerlink" title="垃圾回收概述"></a>垃圾回收概述</h2><p>垃圾收集和内存动态分配，是Java区别于C++的最大差异</p>
<p>下面是一些大厂面试题</p>
<p><strong>蚂蚁金服：</strong></p>
<ol>
<li>你知道哪几种垃圾回收器，各自的优缺点，重点讲一下CMS和G1？</li>
<li>JVM GC算法有哪些，目前的JDK版本采用什么回收算法？</li>
<li>G1回收器讲下回收过程GC是什么？为什么要有GC？</li>
<li>GC的两种判定方法？CMS收集器与G1收集器的特点</li>
</ol>
<p><strong>百度：</strong></p>
<ol>
<li>说一下GC算法，分代回收说下</li>
<li>垃圾收集策略和算法</li>
</ol>
<p><strong>天猫：</strong></p>
<ol>
<li>JVM GC原理，JVM怎么回收内存</li>
<li>CMS特点，垃圾回收算法有哪些？各自的优缺点，他们共同的缺点是什么？</li>
</ol>
<p><strong>滴滴：</strong></p>
<ol>
<li>Java的垃圾回收器都有哪些，说下G1的应用场景，平时你是如何搭配使用垃圾回收器的</li>
</ol>
<p><strong>京东：</strong></p>
<ol>
<li>你知道哪几种垃圾收集器，各自的优缺点，重点讲下CMS和G1，</li>
<li>包括原理，流程，优缺点。垃圾回收算法的实现原理</li>
</ol>
<p><strong>阿里：</strong></p>
<ol>
<li>讲一讲垃圾回收算法。</li>
<li>什么情况下触发垃圾回收？</li>
<li>如何选择合适的垃圾收集算法？</li>
<li>JVM有哪三种垃圾回收器？</li>
</ol>
<p><strong>字节跳动：</strong></p>
<ol>
<li>常见的垃圾回收器算法有哪些，各有什么优劣？</li>
<li>System.gc()和Runtime.gc()会做什么事情？</li>
<li>Java GC机制？GC Roots有哪些？</li>
<li>Java对象的回收方式，回收算法。</li>
<li>CMS和G1了解么，CMS解决什么问题，说一下回收的过程。</li>
<li>CMS回收停顿了几次，为什么要停顿两次?</li>
</ol>
<h3 id="什么是垃圾"><a href="#什么是垃圾" class="headerlink" title="什么是垃圾"></a>什么是垃圾</h3><p>程序中，没有任何指针指向的对象。如果不及时清理，可能导致内存溢出。</p>
<h3 id="为什么需要GC"><a href="#为什么需要GC" class="headerlink" title="为什么需要GC"></a>为什么需要GC</h3><ul>
<li>如果不进行垃圾回收，<strong>内存迟早都会被消耗完</strong></li>
<li>垃圾回收也可以清除内存里的碎片。碎片整理将所占用的堆内存移到堆的一端，<strong>以便JVM将整理出的内存分配给新的对象</strong></li>
</ul>
<blockquote>
<p>没有GC不能保证程序的正常进行，经常GC导致STW影响性能，所以才需尝试对GC进行优化</p>
</blockquote>
<h3 id="Java垃圾回收机制"><a href="#Java垃圾回收机制" class="headerlink" title="Java垃圾回收机制"></a>Java垃圾回收机制</h3><blockquote>
<p><strong>官网介绍</strong>：<a class="link" href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/23/AtSfeUuDVc1yzBG.png" alt="68747470733a2f2f6e706d2e656c656d6563646e2e636f6d2f796f7574686c716c40312e302e382f4a564d2f636861707465725f3031302f303030332e706e67" style="zoom: 67%;">

<ul>
<li>垃圾回收可以对年轻代回收，也可以对老年代回收，甚至是全栈和方法区的回收</li>
<li>频繁收集You区</li>
<li>较少收集Old区</li>
<li>基本不收集Perm区/元空间</li>
</ul>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="标记阶段"><a href="#标记阶段" class="headerlink" title="标记阶段"></a>标记阶段</h3><p>目的：判断对象是否存活</p>
<p>方法：引用计数算法，可达性算法</p>
<p><strong>引用技术算法：</strong></p>
<ul>
<li>每个对象保存一个整型引用计数器，用于记录被引用的情况</li>
<li>任何对象引用了A，则A的计数器就加1；引用失效时，引用计数器就减1。计数器为0表示对象可回收</li>
<li>优点：<ul>
<li>实现简单，效率高</li>
</ul>
</li>
<li>缺点：<ul>
<li>增加存储开销</li>
<li>需要更新计数器，增加时间开销</li>
<li>严重问题：无法处理循环引用</li>
</ul>
</li>
</ul>
<blockquote>
<p>可以证明，Java没有使用这一类算法</p>
</blockquote>
<p><strong>可达性分析算法：</strong></p>
<ul>
<li>也称为根搜索算法、追踪性垃圾收集</li>
<li>有效解决循环引用问题</li>
<li>以根对象集合（GCRoots）为起始点，搜索对象是否可达，搜索路径称为引用链<ul>
<li>只有能被访问的对象才是存活对象</li>
</ul>
</li>
</ul>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/24/Uot7YIvLjPGEVZX.png" alt="image-20231024163134602" style="zoom:50%;">

<p><strong>GCRoots可以是哪些元素：</strong></p>
<blockquote>
<p><strong>总结：</strong>虚拟机栈、本地方法栈、方法区、字符串常量池等地方对堆空间进行引用的，都可以作为GC Roots进行可达性分析</p>
<p><strong>小技巧：</strong>一个指针保存了堆中的对象，但自己不在堆中，那它就是Root</p>
</blockquote>
<ol>
<li>虚拟机栈中引用的对象</li>
<li>本地方法栈中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象<ul>
<li>比如StringTable里的引用</li>
</ul>
</li>
<li>所有被同步锁synchronized持有的对象</li>
<li>JVM内部的引用<ul>
<li>基本数据类型对应的Class对象，一些常驻的异常对象（如：NullPointerException、OutofMemoryError），系统类加载器</li>
</ul>
</li>
<li>反映JVM内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等</li>
</ol>
<p>其他：根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。比如：<strong>分代收集</strong>和局部回收（PartialGC）。如果只针对Java堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入GC Roots集合中去考虑，才能保证可达性分析的准确性。</p>
<h3 id="对象finalization机制"><a href="#对象finalization机制" class="headerlink" title="对象finalization机制"></a>对象finalization机制</h3><ul>
<li>Java语言提供了对象终止（finalization）机制，允许自定义<strong>对象销毁前的处理逻辑</strong><ul>
<li>垃圾回收对象前，总会先调用这个对象的finalization方法</li>
</ul>
</li>
<li>finalization方法允许在子类被重写，<strong>用于对象在被回收时释放资源</strong></li>
<li>永远不要主动调用某个对象的finalization方法，应交由垃圾回收机制调用</li>
</ul>
<p><strong>对象的三种状态：</strong></p>
<ol>
<li>可触及：从根节点开始可达</li>
<li>可复活：对象的所有引用都被释放，但是对象可能在finalize中复活</li>
<li>不可触及的：对象finalize被调用，没有复活；不可触及的对象不可能被复活，因为finalize只会被调用一次</li>
</ol>
<p><strong>判断对象是否可回收：</strong></p>
<ol>
<li>从对象到GCRoot没有引用链条</li>
<li>判断是否有必要执行finalization方法<ul>
<li>没有重写，或者已经被调用了：判定为不可触及</li>
<li>重写了，没执行。对象被插到F-Queue队列中。JVM创建的低优先级的Finalizer线程触发其执行</li>
<li>GC会对F-Queue队列中的对象进行二次标记<ul>
<li>如果对象与引用链上的任何对象建立了联系，会被移出“即将回收”集合</li>
<li>不然，变成不可触及的状态</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>JVisual VM查看Finalizer线程：</strong></p>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/24/2nNLcQ615BagPAd.png" alt="image-20231024172944511" style="zoom:50%;">

<p><strong>对象复活代码演示：</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CanReliveObj</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CanReliveObj obj; <span class="comment">// 类变量，属于GC Root</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此方法只能被调用一次</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable {</span><br><span class="line">        <span class="built_in">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">"调用finalize()"</span>);</span><br><span class="line">        obj = <span class="built_in">this</span>; <span class="comment">// 当前待回收的对象在finalize()方法中与引用链上的一个对象obj建立了联系</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    obj = <span class="keyword">new</span> <span class="title class_">GCTest</span>();</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 第一次，由于调用了finalize，复活</span></span><br><span class="line">    System.out.println(<span class="string">"第1次 gc"</span>);</span><br><span class="line">    obj = <span class="literal">null</span>;</span><br><span class="line">    System.gc();</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">null</span>) {</span><br><span class="line">        System.out.println(<span class="string">"obj is dead"</span>);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        System.out.println(<span class="string">"obj is still alive"</span>);</span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 第二次，代码一摸一样，但是自救失败（finalize方法只会执行一次）</span></span><br><span class="line">    System.out.println(<span class="string">"第2次 gc"</span>);</span><br><span class="line">    obj = <span class="literal">null</span>;</span><br><span class="line">    System.gc();</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">null</span>) {</span><br><span class="line">        System.out.println(<span class="string">"obj is dead"</span>);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        System.out.println(<span class="string">"obj is still alive"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>第一次自救成功，第二次自救失败（finalize方法只会执行一次）</p>
</blockquote>
<h3 id="MAT进行GCRoots溯源"><a href="#MAT进行GCRoots溯源" class="headerlink" title="MAT进行GCRoots溯源"></a>MAT进行GCRoots溯源</h3><ul>
<li>MAT是Memory Analyzer的简称，是一款功能强大的Java堆内存分析器，用于查找内存泄露、查看内存消耗情况</li>
<li>MAT是基于Eclipse开发的</li>
<li>下载地址：<a class="link" href="http://www.eclipse.org/mat/">http://www.eclipse.org/mat/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
<blockquote>
<p>在内存分析方面，MAT更好用一些</p>
</blockquote>
<p><strong>实验代码：</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCRootsTest</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        List&lt;Object&gt; numList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Date</span> <span class="variable">birth</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) {</span><br><span class="line">            numList.add(String.valueOf(i));</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"数据添加完毕，请操作："</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in).next();</span><br><span class="line">        numList = <span class="literal">null</span>;</span><br><span class="line">        birth = <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"numList、birth已置空，请操作："</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in).next();</span><br><span class="line">        System.out.println(<span class="string">"结束"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p><strong>命令行jmap获取dump文件：</strong></p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">C:\Users\xdy&gt;jps</span><br><span class="line">13920 RemoteMavenServer36</span><br><span class="line">28416 Jps</span><br><span class="line">16052 GCRootsTest</span><br><span class="line">28780 Launcher</span><br><span class="line"></span><br><span class="line">C:\Users\xdy&gt;jmap -dump:format=b,live,file=test1.bin 16052</span><br><span class="line">Heap dump file created</span><br></pre></td></tr></table></figure></div>

<p><strong>JVisualVM获取dump文件：</strong></p>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/26/JyOk9jx1CX5lpP6.png" alt="image-20231026163527959" style="zoom: 40%;">

<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/26/MKv3B2o6yQJdVqN.png" alt="image-20231026163638438" style="zoom:40%;">

<p><strong>使用MAT打开文件：</strong></p>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/26/ke7POxUfMLDmNKG.png" alt="image-20231026193544460" style="zoom: 45%;">

<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/26/AmL9tOXfsJC3pWR.png" alt="image-20231026193559037" style="zoom: 45%;">

<p>MAT中划分GCRoot的方式不太一样，不过可以在Thread中找到main线程，可以看到里面有两个ArrayList和Date类型的GCRoot。如果执行完代码后，就会看到已经找不到他们两个了。</p>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/26/Lomg4TA1pP2xeYz.png" alt="image-20231026194243965" style="zoom: 40%;">

<h3 id="JProfiler进行GCRoots溯源"><a href="#JProfiler进行GCRoots溯源" class="headerlink" title="JProfiler进行GCRoots溯源"></a>JProfiler进行GCRoots溯源</h3><ul>
<li>点击“标记当前值”，可以看到从此刻开始某类型的对象增多/减少的量，如果某个对象疯狂增多，肯定有问题</li>
</ul>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/26/vYELQsnKUFiAC1j.png" alt="image-20231026200652397" style="zoom: 40%;">

<ul>
<li>右键，“在堆遍历器中显示所选”，可以看到一些详细信息</li>
</ul>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/26/2tmyzqCWJI3Vvef.png" alt="image-20231026200817738" style="zoom: 40%;">

<ul>
<li>最常用的是“引用中的“Incoming references”（从哪来的）和“Outcoming references”（到哪去的）</li>
</ul>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/26/7vZj5X1zJ8mUyDk.png" alt="image-20231026201108547" style="zoom:40%;">

<ul>
<li>可以看到，此字符串是从System类的out静态类变量来的</li>
</ul>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/26/QujZR6AtqzHFmLX.png" alt="image-20231026201437138" style="zoom:40%;">

<h3 id="JProfiler分析OOM"><a href="#JProfiler分析OOM" class="headerlink" title="JProfiler分析OOM"></a>JProfiler分析OOM</h3><ul>
<li>让OOM时生成dump文件</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//-Xms8m -Xmx8m -XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapOOM</span> {</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>]; <span class="comment">// 1MB</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        ArrayList&lt;HeapOOM&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">                list.add(<span class="keyword">new</span> <span class="title class_">HeapOOM</span>());</span><br><span class="line">                count++;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (Throwable e) {</span><br><span class="line">            System.out.println(<span class="string">"count = "</span> + count);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>生成了dump文件，可以直接打开</li>
</ul>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">Dumping heap to java_pid13508.hprof ...</span><br><span class="line">Heap dump file created [7775055 bytes in 0.011 secs]</span><br><span class="line">count = 6</span><br><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at org.example.gc.HeapOOM.&lt;init&gt;(HeapOOM.java:16)</span><br><span class="line">	at org.example.gc.HeapOOM.main(HeapOOM.java:24)</span><br></pre></td></tr></table></figure></div>

<ul>
<li>可以从最大对象中看到，是ArrayList最大</li>
</ul>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/26/fAmPekZrRJycgzH.png" alt="image-20231026210649196" style="zoom: 40%;">

<ul>
<li>也可以从线程中，看到是main线程出现的OOM异常，以及出问题的代码行数</li>
</ul>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/26/ik8XPCcheQvxlDN.png" alt="image-20231026211033994" style="zoom:40%;">

<h3 id="清除阶段"><a href="#清除阶段" class="headerlink" title="清除阶段"></a>清除阶段</h3><p><strong>标记清除算法：</strong></p>
<p>当堆空间耗尽时STW时：</p>
<ul>
<li>标记：从根节点遍历，标记所有被引用的对象</li>
<li>清除：对堆从头到尾进行线性的遍历，清除所有不可达对象</li>
</ul>
<blockquote>
<p>缺点：</p>
<ul>
<li>效率低</li>
<li>需要停止整个应用</li>
<li>清理出来的空间不是连续的，产生碎片，需要维护一个空闲列表</li>
</ul>
</blockquote>
<blockquote>
<p>何为清除：</p>
<ul>
<li>不是真的置空，而是把地址保存在空闲地址列表里</li>
<li>如果内存规整<ul>
<li>采用指针碰撞的方式，进行内存分配</li>
</ul>
</li>
<li>如果内存不规整<ul>
<li>虚拟机需要维护一个空闲列表</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>复制算法：</strong></p>
<ul>
<li><p>活着的内存空间分为两块，每次只使用其中一块</p>
</li>
<li><p>将存活的对象复制到未使用的内存块中，清空正在使用的内存块</p>
</li>
<li><p>新生代就用到了复制算法，Eden区和S0区存活的对象整体复制到S1区</p>
</li>
</ul>
<blockquote>
<p>优点：</p>
<ul>
<li>没有标记清除的过程，简单高效</li>
<li>不会出现碎片问题</li>
</ul>
<p>缺点：</p>
<ul>
<li>需要两倍空间</li>
<li>GC需要维护区域之间对象引用的关系，内存占用和时间开销都较大（参考：对象句柄访问）</li>
</ul>
</blockquote>
<blockquote>
<p>应用场景：</p>
<ul>
<li>垃圾对象多，存活对象少，复制算法的效率将会很高</li>
</ul>
</blockquote>
<p><strong>标记压缩算法：</strong></p>
<ul>
<li>第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象</li>
<li>第二阶段将所有存活对象压到内存的一端，之后清理边界外的空间</li>
<li>老年代使用的垃圾回收策略</li>
</ul>
<blockquote>
<p>优点：</p>
<ul>
<li><p>没有内存碎片问题</p>
</li>
<li><p>没有内存减半的问题</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li>效率低</li>
<li>需要调整对象的引用地址（HotSpot虚拟机采用的不是句柄池的方式，而是直接指针）</li>
<li>移动过程中需要STW</li>
</ul>
</blockquote>
<p><strong>对比三种清除算法：</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>标记清除</th>
<th>标记整理</th>
<th>复制</th>
</tr>
</thead>
<tbody><tr>
<td><strong>速率</strong></td>
<td>中等</td>
<td>最慢</td>
<td>最快</td>
</tr>
<tr>
<td><strong>空间开销</strong></td>
<td>少（但会堆积碎片）</td>
<td>少（不堆积碎片）</td>
<td>通常需要活对象的2倍空间（不堆积碎片）</td>
</tr>
<tr>
<td><strong>移动对象</strong></td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
</tbody></table>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p><strong>为什么使用分代收集算法：</strong></p>
<ul>
<li>不同的对象的生命周期是不一样的，可以采取不同的收集方式，以便提高回收效率。一般是分为新生代和老年代</li>
<li>在Java程序运行的过程中，会产生大量的对象:<ul>
<li>比如Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，生命周期比较长。</li>
<li>但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：String对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</li>
</ul>
</li>
</ul>
<p><strong>几乎所有的GC都采用分代收集算法：</strong></p>
<p>在HotSpot中:</p>
<ul>
<li><p>年轻代（Young Gen）</p>
<ul>
<li><p>区域小，对象生命周期短，存活率低，回收频繁。</p>
</li>
<li><p>适合使用复制算法，空间问题，通过HotSpot中的两个survivor的设计得到缓解。</p>
</li>
</ul>
</li>
<li><p>老年代（Tenured Gen）</p>
<ul>
<li>区域较大，对象生命周期长，存活率高，回收不频繁。</li>
</ul>
</li>
<li><p>标记-清除，标记-整理，混合实现。</p>
<ul>
<li>标记阶段（Mark）的开销，与存活对象的数量成正比。</li>
<li>清除阶段（Sweep）的开销，与管理区域的大小成正相关。</li>
<li>压缩阶段（Compact）的开销，与存活对象的数据成正比。</li>
</ul>
</li>
</ul>
<blockquote>
<p>以HotSpot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。</p>
<p>对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old回收器作为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用Serial Old执行Full GC以达到对老年代内存的整理。</p>
</blockquote>
<h3 id="增量收集算法"><a href="#增量收集算法" class="headerlink" title="增量收集算法"></a>增量收集算法</h3><p>STW会导致所有线程都被挂起，等待一段时间</p>
<p><strong>增量收集算法思想：</strong></p>
<ul>
<li>每次垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成</li>
<li>依然是传统标记-清除算法，但是允许GC以分阶段的方式完成标记、清除、复制等工作</li>
</ul>
<blockquote>
<p>优点：</p>
<ul>
<li>减少了系统停顿的时间</li>
</ul>
<p>缺点：</p>
<ul>
<li>线程切换和上下文转换有消耗，造成系统整体吞吐量下降</li>
</ul>
</blockquote>
<h3 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h3><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/27/jqSdclmYVkCJrn9.png" alt="image-20231027121035582" style="zoom:50%;">

<p>主要针对G1收集器来说</p>
<ul>
<li>堆空间越大，一次GC时所需要的时间就越长</li>
<li>将大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，从而减少一次GC所产生的停顿</li>
<li>分代算法按照生命周期划分成两个部分，而分区算法将堆空间划分成连续的不同小区间<ul>
<li>每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间</li>
</ul>
</li>
</ul>
<h2 id="垃圾回收相关概念说明"><a href="#垃圾回收相关概念说明" class="headerlink" title="垃圾回收相关概念说明"></a>垃圾回收相关概念说明</h2><h3 id="System-gc-的理解"><a href="#System-gc-的理解" class="headerlink" title="System.gc()的理解"></a>System.gc()的理解</h3><ul>
<li><code>System.gc()</code>或者<code>Runtime.getRuntime().gc()</code>，会显示触发Full GC，同时对老年代和新生代进行回收</li>
<li>但是，不能确保立即执行</li>
<li>一般情况下，无需手动调用</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemGCTest</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SystemGCTest</span>();</span><br><span class="line">        System.gc(); <span class="comment">// 只有他，未必保证能看到输出的字符串</span></span><br><span class="line">        </span><br><span class="line">        System.runFinalization(); <span class="comment">// 会强制调用，失去引用的对象的finalize方法</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable {</span><br><span class="line">        <span class="built_in">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">"finalize执行了"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p><strong>一些例子分析：</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -Xms256m -Xmx256m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalVarGC</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localvarGC1</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];<span class="comment">//10MB</span></span><br><span class="line">        System.gc();</span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localvarGC2</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        buffer = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localvarGC3</span><span class="params">()</span> {</span><br><span class="line">        {</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        }</span><br><span class="line">        System.gc();</span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localvarGC4</span><span class="params">()</span> {</span><br><span class="line">        {</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localvarGC5</span><span class="params">()</span> {</span><br><span class="line">        localvarGC1();</span><br><span class="line">        System.gc();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>localvarGC1()</code>：没回收</li>
</ul>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先进行了YoungGC，对象并没有被回收掉</span></span><br><span class="line">[GC (System.gc()) [PSYoungGen: 15516K-&gt;10744K(76288K)]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进行了FullGC，buffer对象被放到老年代了</span></span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 10744K-&gt;0K(76288K)] [ParOldGen: 220K-&gt;10885K(175104K)]</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>localvarGC2()</code>：回收了</li>
</ul>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先进行了YoungGC，buffer对象直接被回收了</span></span><br><span class="line">[GC (System.gc()) [PSYoungGen: 15516K-&gt;824K(76288K)]</span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 824K-&gt;0K(76288K)] [ParOldGen: 8K-&gt;645K(175104K)]</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>localvarGC3()</code>：没回收</li>
</ul>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先进行了YoungGC，对象并没有被回收掉</span></span><br><span class="line">[GC (System.gc()) [PSYoungGen: 15516K-&gt;10736K(76288K)]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进行了FullGC，buffer对象被放到老年代了</span></span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 10736K-&gt;0K(76288K)] [ParOldGen: 276K-&gt;10885K(175104K)]</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>原因：从字节码可以看到，局部变量表槽数为2。但是实际去看发现只有一个槽位存储了this。GC时，buffer其实还占用着槽位，所以没有回收</p>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/30/BerY3QaS7TXfiD4.png" alt="image-20231030162454073" style="zoom: 67%;">

<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/30/d7lkpP46vU5uRM8.png" alt="image-20231030162508690" style="zoom:55%;">
</blockquote>
<ul>
<li><code>localvarGC4()</code>：回收了</li>
</ul>
<blockquote>
<p>原因：新创建了局部变量<code>int value</code>，槽位复用，buffer无法再占用原本的槽位了</p>
</blockquote>
<ul>
<li><code>localvarGC5()</code>：回收了</li>
</ul>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">[GC (System.gc()) [PSYoungGen: 15516K-&gt;10744K(76288K)]</span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 10744K-&gt;0K(76288K)] [ParOldGen: 248K-&gt;10885K(175104K)]</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 0K-&gt;0K(76288K)]</span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 0K-&gt;0K(76288K)] [ParOldGen: 10885K-&gt;645K(175104K)] </span><br></pre></td></tr></table></figure></div>

<h3 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h3><p>内存溢出（OOM）：没有空闲内存，且垃圾回收也无法提供更多内存</p>
<p><strong>原因分析：</strong></p>
<ol>
<li>JVM堆内存设置不够<ul>
<li>通过参数<code>-Xms</code> 、<code>-Xmx</code>来调整</li>
</ul>
</li>
<li>代码创建了大量的大对象，且长时间不能被回收<ul>
<li>潜台词：在抛出<code>OutOfMemoryError</code>之前，会触发GC，尽可能清理出空间</li>
<li>也不是一定会触发GC：如果分配一个超大对象，比堆的最大值都大，将直接抛出错误</li>
</ul>
</li>
</ol>
<h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h3><ul>
<li>对象不会被程序用到了，但GC又不能回收它们</li>
<li>广泛意义上的内存泄露：不需要的对象，但是生命周期很长</li>
</ul>
<p><strong>常见例子：</strong></p>
<ol>
<li>单例模式：单例模式的对象的生命周期和应用程序一样长，如果单例对象持有对外部对象的引用，这个外部对象将不能回收</li>
<li>外部资源未close()：数据库连接，网络连接，io操作等资源，如果不手动close会导致无法回收</li>
</ol>
<h3 id="Stop-The-World"><a href="#Stop-The-World" class="headerlink" title="Stop The World"></a>Stop The World</h3><p>GC事件发生过程中，整个应用程序线程都会被暂停</p>
<ul>
<li>枚举根节点（GC Roots），会导致所有Java执行线程停顿<ul>
<li>系统冻结在某个时间点上</li>
</ul>
</li>
<li>任何GC都会有STW</li>
</ul>
<h3 id="垃圾回收的并行与并发"><a href="#垃圾回收的并行与并发" class="headerlink" title="垃圾回收的并行与并发"></a>垃圾回收的并行与并发</h3><p><strong>GC中的并行：</strong></p>
<ol>
<li>并行：多条GC线程并行工作，但此时用户线程处于等待状态<ul>
<li>如：ParNew、Parallel Scavenge、Parallel Old</li>
</ul>
</li>
<li>串行：相较于并行的概念，GC单线程执行</li>
</ol>
<p><strong>GC中的并发：</strong></p>
<ul>
<li>用户线程与GC线程同时执行，GC执行时不会停止用户程序的运行<ul>
<li>用户程序继续运行，垃圾回收线程运行于另一个CPU核心</li>
<li>如：CMS、G1</li>
</ul>
</li>
</ul>
<h3 id="安全点与安全区域（了解）"><a href="#安全点与安全区域（了解）" class="headerlink" title="安全点与安全区域（了解）"></a>安全点与安全区域（了解）</h3><p><strong>安全点（Safepoint）：</strong></p>
<ol>
<li><p>程序执行时，在特定位置才能停下来开始GC，这些位置称为安全点</p>
</li>
<li><p>安全点的选择很重要：</p>
<ul>
<li><p>太少可能导致GC等待的时间太长，</p>
</li>
<li><p>太频繁可能导致运行时的性能问题</p>
</li>
<li><p>大部分指令的执行时间都非常短暂，通常会根据是否具有<strong>让程序长时间执行</strong>的特征为标准。比如：选择一些执行时间较长的指令作为Safe Point，<strong>如方法调用、循环跳转和异常跳转等</strong></p>
</li>
</ul>
</li>
</ol>
<p><strong>安全区域（Safe Region）：</strong></p>
<ol>
<li>安全点机制保证程序执行时，一小段时间就能遇到可进入GC的点。但是如果程序不执行呢？<ul>
<li>列如：线程处于Sleep或Blocked状态</li>
</ul>
</li>
<li>安全区域指，<strong>一段代码片段中，对象的引用状态不会变化</strong>，此区域任何位置GC都是安全的</li>
</ol>
<p><strong>安全区域的执行流程：</strong></p>
<ol>
<li>当线程运行到安全区时，首先标识已经进入了安全区。如果这段时间内发生GC，JVM会忽略标识为Safe Region状态的线程</li>
<li>当线程即将离开Safe Region时，会检查JVM是否已经完成根节点枚举（即GC Roots的枚举）。如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开Safe Region的信号为止</li>
</ol>
<h3 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h3><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/31/eOJAiW1FEuoDyBs.png" alt="image-20231031201937203" style="zoom: 67%;">

<h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><ul>
<li>99%都是强引用，也是默认的引用类型</li>
<li>只要强引用的对象是可达的，JVM宁可OOM也不回收它<ul>
<li>强引用是造成内存泄露的主要原因</li>
</ul>
</li>
</ul>
<h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><blockquote>
<p>内存不足即回收</p>
</blockquote>
<ul>
<li>内存足够，不会回收软引用可达的对象；内存不够，才会回收</li>
<li>将要OOM前，会将此类对象列入回收范围中二次回收，空间还不够才会OOM</li>
<li>构造软引用时，会指定一个引用队列，以跟踪对象的回收情况</li>
<li>软引用常用来实现缓存</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">SoftReference&lt;User&gt; userSoftRef = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;User&gt;(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">"songhk"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上等价于</span></span><br><span class="line"><span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>,<span class="string">"songhk"</span>);</span><br><span class="line">SoftReference&lt;User&gt; userSoftRef = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;User&gt;(u1);</span><br><span class="line">u1 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存紧张时，会得到null</span></span><br><span class="line">userSoftRef.get()</span><br></pre></td></tr></table></figure></div>

<h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><blockquote>
<p>发现即回收</p>
</blockquote>
<ul>
<li>在GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象<ul>
<li>比起软引用，GC回收时无需检查是否需要回收，弱引用对象更容易、更快被GC回收</li>
</ul>
</li>
<li>GC线程通常优先级较低，有时弱引用还是会存在一段时间的</li>
<li>同样的，构造软引用时，会指定一个引用队列，以跟踪对象的回收情况</li>
<li>适合保存可有可无的缓存数据，内存不足缓存数据会被回收；内存充足时又可以存在相当长的时间</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 声明强引用</span></span><br><span class="line">WeakReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>; <span class="comment">// 销毁强引用</span></span><br></pre></td></tr></table></figure></div>

<h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><ul>
<li>也称“幽灵引用”或“幻影引用”，是最弱的引用</li>
<li>如果对象仅持有虚引用，那么和没有引用几乎是一样的，随时都可能被GC回收</li>
<li>不能单独使用，也无法通过虚引用来获取被引用的对象，get()总是null</li>
<li>唯一目的在于跟踪垃圾回收过程，比如：能在这个对象被收集器回收时收到一个系统通知</li>
<li>虚引用必须和引用队列一起使用<ul>
<li>虚引用在创建时必须提供一个引用队列作为参数</li>
<li>当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 声明强引用</span></span><br><span class="line"><span class="type">ReferenceQueue</span> <span class="variable">phantomQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>(); <span class="comment">// 声明引用队列</span></span><br><span class="line">PhantomReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(obj, phantomQueue); <span class="comment">// 声明虚引用（还需要传入引用队列）</span></span><br><span class="line">obj = <span class="literal">null</span>; </span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceTest</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReferenceTest obj;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReferenceQueue&lt;ReferenceTest&gt; phantomQueue = <span class="literal">null</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 用于检测队列中有无值（也即是否被GC）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CheckRefQueue</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">                <span class="keyword">if</span> (phantomQueue != <span class="literal">null</span>) {</span><br><span class="line">                    PhantomReference&lt;ReferenceTest&gt; ref = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        ref = (PhantomReference&lt;ReferenceTest&gt;) phantomQueue.remove();</span><br><span class="line">                    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">if</span> (ref != <span class="literal">null</span>) {</span><br><span class="line">                        System.out.println(<span class="string">"ReferenceTest被GC了"</span>);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        <span class="type">CheckRefQueue</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CheckRefQueue</span>();</span><br><span class="line">        t.setDaemon(<span class="literal">true</span>);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        obj = <span class="keyword">new</span> <span class="title class_">ReferenceTest</span>();</span><br><span class="line">        phantomQueue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line">        PhantomReference&lt;ReferenceTest&gt; phantomRef = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(obj, phantomQueue);</span><br><span class="line"></span><br><span class="line">        System.out.println(phantomRef.get()); <span class="comment">// 为null，虚引用无法获取值</span></span><br><span class="line"></span><br><span class="line">        obj = <span class="literal">null</span>;</span><br><span class="line">        System.gc(); <span class="comment">// 一旦obj对象被GC，就会将虚引用存放到引用队列中。</span></span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="终结器引用"><a href="#终结器引用" class="headerlink" title="终结器引用"></a>终结器引用</h4><ul>
<li><p>用于实现对象的finalize()方法，也可以称为终结器引用</p>
</li>
<li><p>无需手动编码，其内部配合引用队列使用</p>
</li>
<li><p>在GC时，终结器引用入队。由Finalizer线程通过终结器引用找到被引用对象调用它的finalize()方法，第二次GC时把他进行回收</p>
</li>
</ul>
<h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><h3 id="垃圾回收器分类"><a href="#垃圾回收器分类" class="headerlink" title="垃圾回收器分类"></a>垃圾回收器分类</h3><p><strong>按GC线程数分：</strong></p>
<ol>
<li><p>串行回收：只有一个CPU用于执行GC操作，会有STW</p>
</li>
<li><p>并行回收：多个CPU同时执行GC操作，会有STW</p>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/31/MlWrj1HiQIXCLUJ.png" alt="image-20231031210255409" style="zoom: 50%;"></li>
</ol>
<p><strong>按工作模式分：</strong></p>
<ol>
<li>并发式：与应用程序线程交替工作，以减少停顿时间</li>
<li>独占式：一旦运行，就停止所有用户线程，直至垃圾回收结束</li>
</ol>
<p><strong>按碎片处理方式分：</strong></p>
<ol>
<li>压缩式：回收完成后，对存活对象进行压缩整理；分配空间时使用指针碰撞</li>
<li>非压缩式：不进行压缩；分配空间时使用空闲列表</li>
</ol>
<p><strong>按工作的区间：</strong></p>
<ol>
<li>年轻代垃圾回收器</li>
<li>老年代垃圾回收器</li>
</ol>
<h3 id="评估性能指标"><a href="#评估性能指标" class="headerlink" title="评估性能指标"></a>评估性能指标</h3><p><strong>吞吐量（throughout）：</strong></p>
<ul>
<li>吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾回收时间)</li>
</ul>
<p><strong>暂停时间（pause time）：</strong></p>
<ul>
<li>执行垃圾回收时，程序工作线程被暂停的时间</li>
</ul>
<blockquote>
<p>吞吐量 VS 暂停时间</p>
<ul>
<li>吞吐量越高越好，暂停时间越低越好</li>
<li>这两者矛盾<ul>
<li>如果选择高吞吐量，则需要降低内存回收的执行频率</li>
<li>如果选择低暂停时间，则需要频繁执行内存回收</li>
</ul>
</li>
<li>现在的标准：最大吞吐量优先情况下，降低暂停时间</li>
</ul>
</blockquote>
<h3 id="不同垃圾回收器"><a href="#不同垃圾回收器" class="headerlink" title="不同垃圾回收器"></a>不同垃圾回收器</h3><ol>
<li>1999年随JDK1.3.1一起来的是串行方式的<strong>Serial GC</strong>，它是第一款GC。<strong>ParNew</strong>垃圾收集器是Serial收集器的多线程版本</li>
<li>2002年2月26日，<strong>Parallel GC</strong>和<strong>Concurrent Mark Sweep GC</strong>跟随JDK1.4.2一起发布·</li>
<li>Parallel GC在JDK6之后成为HotSpot默认GC。</li>
<li>2012年，在JDK1.7u4版本中，<strong>G1</strong>可用。</li>
<li>2017年，JDK9中G1变成默认的垃圾收集器，以替代CMS。</li>
<li>2018年3月，JDK10中G1垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。</li>
<li>2018年9月，JDK11发布。引入Epsilon 垃圾回收器，又被称为 “No-Op(无操作)“ 回收器。同时，引入ZGC：可伸缩的低延迟垃圾回收器（Experimental）</li>
<li>2019年3月，JDK12发布。增强G1，自动返回未用堆内存给操作系统。同时，引入Shenandoah GC：低停顿时间的GC（Experimental）。</li>
<li>2019年9月，JDK13发布。增强ZGC，自动返回未用堆内存给操作系统。</li>
<li>2020年3月，JDK14发布。删除CMS垃圾回收器。扩展ZGC在macOS和Windows上的应用</li>
</ol>
<p><strong>7款经典的垃圾回收器：</strong></p>
<ul>
<li>串行回收器：Serial，Serial Old</li>
<li>并行回收器：ParNew，Parallel Scavenge，Parallel Old</li>
<li>并发回收器：CMS，G1</li>
</ul>
<p><strong>垃圾回收器的组合关系:</strong></p>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/11/01/vepsqJWNY3K8u2U.png" alt="image-20231101163507605" style="zoom:50%;">

<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/11/01/3gjYQCdN2tZs6L8.png" alt="image-20231101163812869" style="zoom: 67%;">

<ul>
<li>两个收集器之间有连线，表明可以搭配使用<ul>
<li>Serial Old作为CMS出现“Concurrent Mode Failure”失败的后备方案</li>
<li>红色虚线：JDK8声明为废弃；JDK9完全移除</li>
<li>绿色虚线：JDK14完全启用</li>
<li>青色虚线：JDK14删除CMS垃圾回收器</li>
</ul>
</li>
<li>为什么有很多垃圾收集器？<ul>
<li>Java应用场景很多，移动端、服务端等等</li>
<li>没有完美的收集器，只有最适合场景的收集器</li>
</ul>
</li>
</ul>
<p><strong>查看默认的垃圾收集器：</strong></p>
<ol>
<li><code>-XX:+PrintCommandLineFlags</code>：查看命令行相关参数（包含使用的垃圾收集器）</li>
<li><code>jinfo -flag &lt;相关垃圾回收器参数&gt; &lt;进程ID&gt;</code>：使用命令行参数</li>
</ol>
<ul>
<li>JDK8下，使用JVM参数查看：看到有<code>-XX:+UseParallelGC</code>，说明使用了 ParallelGC（默认和Parallel Old绑定使用）</li>
</ul>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">XX:InitialHeapSize=666046592 </span><br><span class="line">-XX:MaxHeapSize=10656745472 </span><br><span class="line">-XX:+PrintCommandLineFlags </span><br><span class="line">-XX:+UseCompressedClassPointers </span><br><span class="line">-XX:+UseCompressedOops </span><br><span class="line">-XX:-UseLargePagesIndividualAllocation </span><br><span class="line">-XX:+UseParallelGC </span><br></pre></td></tr></table></figure></div>

<ul>
<li>JDK8下，使用命令行查看</li>
</ul>
<div class="highlight-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\<span class="title">xdy</span>&gt;<span class="title">jps</span></span></span><br><span class="line"><span class="function">29720 <span class="title">Main</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Users</span>\<span class="title">xdy</span>&gt;<span class="title">jinfo</span> -<span class="title">flag</span> <span class="title">UseParallelGC</span> 29720</span></span><br><span class="line"><span class="function">-<span class="title">XX</span>:+<span class="title">UseParallelGC</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Users</span>\<span class="title">xdy</span>&gt;<span class="title">jinfo</span> -<span class="title">flag</span> <span class="title">UseParallelOldGC</span> 29720</span></span><br><span class="line"><span class="function">-<span class="title">XX</span>:+<span class="title">UseParallelOldGC</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Users</span>\<span class="title">xdy</span>&gt;<span class="title">jinfo</span> -<span class="title">flag</span> <span class="title">UseG1GC</span> 29720</span></span><br><span class="line"><span class="function">-<span class="title">XX</span>:-<span class="title">UseG1GC</span></span></span><br></pre></td></tr></table></figure></div>

<h4 id="Serial回收器：串行回收"><a href="#Serial回收器：串行回收" class="headerlink" title="Serial回收器：串行回收"></a>Serial回收器：串行回收</h4><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/11/01/fpykVz61MOhWqtH.png" alt="image-20231101210108510" style="zoom:50%;">

<ul>
<li><p>最简单最基本的垃圾回收器，JDK1.3之前新生代的唯一选择</p>
</li>
<li><p>HotSpot虚拟机中，使用<code>-XX:+UseSerialGC</code>参数可以指定年轻代和老年代都使用串行收集器</p>
<ul>
<li>新生代用Serial GC，老年代用Serial Old GC</li>
</ul>
</li>
<li><p><strong>Serial</strong>是HotSpot中，Client模式下，默认的新生代垃圾收集器</p>
<ul>
<li>采用复制算法，串行回收，STW机制</li>
</ul>
</li>
<li><p><strong>Serial Old</strong>是HotSpot中，Client模式下，默认的老年代垃圾收集器</p>
<ul>
<li>唯一的不同是使用标记-压缩算法</li>
</ul>
</li>
<li><p><strong>Serial Old</strong>在HotSpot中，Server模式下，有两个作用</p>
<ul>
<li>与新生代的Parallel Scavenge配合使用</li>
<li>作为老年代CMS收集器的后备方案</li>
</ul>
</li>
</ul>
<blockquote>
<p>这个垃圾收集器是一个“单线程”的：只使用一个线程完成垃圾收集工作，且垃圾收集的过程中必须停止其他工作线程（STW）</p>
</blockquote>
<p><strong>优势：</strong></p>
<ul>
<li>简单高效，没有额外线程开销</li>
<li>用户桌面应用中，可用内存一般不大，可以在较短时间完成垃圾收集，使用串行收集器是可以接受的</li>
</ul>
<h4 id="ParNew回收器：并行回收"><a href="#ParNew回收器：并行回收" class="headerlink" title="ParNew回收器：并行回收"></a>ParNew回收器：并行回收</h4><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/11/01/YjsaSKqbJ2Qihg3.png" alt="image-20231101210200257" style="zoom:50%;">

<ul>
<li>Serial收集器的多线程版本，用于年轻代<ul>
<li>唯一的区别：并行回收</li>
</ul>
</li>
<li>是很多JVM在server模式下，新生代的默认垃圾收集器</li>
<li><code>-XX:+UseParNewGC</code>使用ParNew收集器，仅年轻代使用并行收集器，不影响老年代</li>
<li><code>-XX:ParallelGCThreads</code>限制线程数量，默认和CPU核心数相同</li>
</ul>
<blockquote>
<ul>
<li><p>对于新生代，回收频繁，使用并行的方式高效</p>
</li>
<li><p>对于老年代，回收次数少，使用串行方式节省资源</p>
</li>
</ul>
</blockquote>
<h4 id="Parallel-Scavenge回收器：吞吐量优先"><a href="#Parallel-Scavenge回收器：吞吐量优先" class="headerlink" title="Parallel Scavenge回收器：吞吐量优先"></a>Parallel Scavenge回收器：吞吐量优先</h4><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/11/01/ARS3vOQZTyJs6oU.png" alt="image-20231101211115565" style="zoom:50%;">

<ul>
<li>Java8默认垃圾收集器</li>
<li>与ParNew收集器使用几乎一样的算法（并行回收，复制算法，STW）</li>
<li>它存在的意义：<ul>
<li>目标：达到一个可控制的吞吐量（吞吐量优先）</li>
<li>自适应调节策略：动态调整内存分配，以达到最优的吞吐量</li>
</ul>
</li>
<li>JDK1.6时提供了Parrallel Old收集器，代替Serial Old收集器<ul>
<li>Parrallel Old采用标记-压缩算法，并行回收，STW机制</li>
</ul>
</li>
<li>高吞吐量可以高效利用CPU时间，适合在后台运算而不需要太多交互的任务，例如服务器中<ul>
<li>Parallel和Parallel Old组合，在server模式下的性能很不错</li>
</ul>
</li>
</ul>
<p><strong>相关参数：</strong></p>
<ul>
<li><code>-XX:+UseParallelGC</code>：手动指定年轻代使用Parallel GC</li>
<li><code>-XX:+UseParallelOldGC</code>：手动指定老年代使用ParallelOld GC<ul>
<li>Java8默认使用，以上两个参数会互相激活，一个开启都会开启</li>
</ul>
</li>
<li><code>-XX:ParallelGCThreads</code>：年轻代并行收集器的线程数<ul>
<li>默认情况下，CPU数量小于等于8个，值等于CPU核心数；CPU数量大于8个，值等于3 + (5 * CPU_COUNT) / 8</li>
</ul>
</li>
<li><code>-XX:MaxGCPauseMillis</code>：设置STW的最大时间，单位毫秒<ul>
<li>为了控制时间，，收集器在工作时会调整Java堆大小或者其他一些参数</li>
<li>该参数使用需谨慎</li>
</ul>
</li>
<li><code>-XX:GCTimeRatio</code>：设置垃圾收集时间占总时间的比例，即目标吞吐量<ul>
<li>范围(0, 100)，默认99</li>
<li>与前一个参数矛盾，STW时间越长，Ratio参数就越容易超</li>
</ul>
</li>
<li><code>-XX:+UseAdaptiveSizePolicy</code>：设置开启自适应调节策略<ul>
<li>会自动调整：年轻代大小、Eden和Survivor比例、晋升老年代对象的年龄等参数。以达到堆大小、吞吐量、停顿时间之间的平衡</li>
<li>手动调优困难的场合，使用此模式，仅需指定虚拟机最大堆，目标吞吐量、停顿时间，让虚拟机自己完成工作</li>
</ul>
</li>
</ul>
<h4 id="CMS回收器：低延迟"><a href="#CMS回收器：低延迟" class="headerlink" title="CMS回收器：低延迟"></a>CMS回收器：低延迟</h4><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/11/02/ayJxUN4t19u8Qsz.png" alt="image-20231102152747567" style="zoom:50%;">

<ul>
<li>CMS关注点：尽可能缩短用户停顿时间<ul>
<li>低延时，适合与用户交互的程序，比如B/S系统的服务器</li>
</ul>
</li>
<li>采用标记-清除算法，也会STW</li>
<li>是老年代收集器，新生代只能选择使用ParNew或者Serial</li>
<li>G1出现之前，CMS使用还是很广泛的</li>
</ul>
<p><strong>CMS工作原理：</strong></p>
<ol>
<li>初始标记（Initial Mark）：所有工作线程都会STW，主要任务仅仅是标记出GC Root能直接关联的对象，非常快</li>
<li>并发标记（Concurrent Mark）：从能直接关联的对象开始遍历整个图，不需要停顿用户线程</li>
<li>重新标记（Remark）：正并发期间，程序继续运行，导致的一部分对象标记变动，对此进行修正，会STW但是非常快</li>
<li>并发清除阶段（Concurrent Sweep）：清除已经死亡的对象，由于不需要移动对象，所以可以和用户线程并发</li>
</ol>
<p><strong>CMS分析：</strong></p>
<ol>
<li>并非完全没有STW，而是尽可能减少STW</li>
<li>最耗时的<strong>并发标记</strong>、<strong>并发清除</strong>，都不需要暂停工作，整体的回收是低停顿的</li>
<li>由于垃圾收集阶段用户线程没有中断，所以CMS过程中需要保证有足够的内存<ul>
<li>CMS不能等到老年代完全被填满再收集，<strong>而是当堆内存使用达到阈值时，便开始进行回收</strong></li>
<li>要是CMS运行期间内存无法满足程序需要，会出现“Concurrent Mode Failure”失败</li>
<li>后备方案：临时启用Serial old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了</li>
</ul>
</li>
<li>CMS采用标记-清除算法，使用空闲链表，不可避免地将会产生一些内存碎片</li>
</ol>
<p><strong>优缺点：</strong></p>
<ul>
<li>优点：<ul>
<li>并发收集</li>
<li>低延迟</li>
</ul>
</li>
<li>缺点：<ul>
<li>会产生内存碎片</li>
<li>CMS收集器对CPU资源敏感，因为收集期间占用一部分线程，导致程序变慢</li>
<li>CMS收集器无法处理浮动垃圾，标记阶段如果产生新的对象，需要等下一次GC执行时才能回收</li>
</ul>
</li>
</ul>
<p><strong>CMS参数配置：</strong></p>
<ul>
<li><code>-XX:+UseConcMarkSweepGC</code>：指定使用CMS收集器<ul>
<li>会自动将<code>-XX:+UseParNewGC</code>打开，也即：ParNew（Young区）+CMS（Old区）+Serial Old（Old区备选方案）</li>
</ul>
</li>
<li><code>-XX:CMSInitiatingOccupanyFraction</code>：设置使用率阈值，一旦达到阈值，便开始收集<ul>
<li>JDK5之前默认68，JDK6以上默认92</li>
<li>如果内存增长缓慢，大的阈值可以降低CMS触发频率；如果内存增长很快，则应该降低这个阈值，避免触发Serial Old</li>
</ul>
</li>
<li><code>-XX:+UseCMSCompactAtFullCollection</code>：指定在Full GC后对内存空间进行压缩整理，避免内存碎片，不过停顿时间会变长</li>
<li><code>-XX:CMSFullGCsBeforeCompaction</code>：多少次Full GC，执行一次内存压缩</li>
<li><code>-XX:ParallelCMSThreads</code>：设置CMS的线程数量<ul>
<li>默认启动线程数是：(ParallelGCThreads + 3) / 4。（ParallelGCThreads默认值是核心数）</li>
</ul>
</li>
</ul>
<p><strong>前四种回收器小结：</strong></p>
<ol>
<li>最小化内存和并行开销，选择Serial GC</li>
<li>最大化吞吐量，选择Parallel GC</li>
<li>最小化中断时间，选择CMS GC</li>
</ol>
<p><strong>后续版本中CMS的变化：</strong></p>
<ul>
<li>JDK9新特性：CMS被标记为Deprecate了</li>
<li>JDK14新特性：删除CMS垃圾回收器</li>
</ul>
<h4 id="G1回收器：区域化分代式"><a href="#G1回收器：区域化分代式" class="headerlink" title="G1回收器：区域化分代式"></a>G1回收器：区域化分代式</h4><p><strong>为什么需要G1：</strong></p>
<ul>
<li><p>为了适应：不断扩大的内存和不断增加的处理器数量，进一步降低暂停时间，同时兼顾良好的吞吐量</p>
</li>
<li><p>目标：延迟可控情况下，获得尽可能高的吞吐量</p>
</li>
</ul>
<p><strong>为什么叫Garbage First：</strong></p>
<ol>
<li>把堆内存分割为很多不相关的区域（Region），物理上未必连续<ul>
<li>使用不同Region来表示Eden，S0，S1，老年代等</li>
</ul>
</li>
<li>有计划的避免全区域垃圾收集<ul>
<li>跟踪各个区域垃圾堆积的价值大小（回收获得的空间大小，回收所需时间的经验值）</li>
<li>每次根据允许的收集时间，优先回收价值最大的Region</li>
</ul>
</li>
<li>侧重点：回收垃圾最大量的区间，所以叫垃圾优先（Garbage First）</li>
<li>JDK1.7正式启用，JDK9成为默认垃圾回收器，取代了CMS，以及Parallel+Parallel Old<ul>
<li>在JDK8中，需要手动开启：<code>-XX:+UseG1GC</code></li>
</ul>
</li>
</ol>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/11/02/wtjNTX2L1mb7pyU.png" alt="image-20231102211544254" style="zoom:50%;">

<p><strong>G1优势：</strong></p>
<ol>
<li>并行与并发兼备<ul>
<li>并行：G1在回收期间，可以有多个GC线程同时工作。用户线程STW</li>
<li>并发：G1拥有与用户线程交替执行的能力，部分工作可以和应用线程同时执行</li>
</ul>
</li>
<li>分代收集<ul>
<li>依然区分Eden，Survivor，老年代。但从堆的结构来看，不要求连续，也不再坚持固定大小和数量</li>
<li>G1兼顾年轻代和老年代</li>
</ul>
</li>
<li>空间整合<ul>
<li>CMS：标记-清除，若干次GC后进行一次碎片整理</li>
<li>G1：内存回收以region为单位，Region之间是复制算法，整体是标记-压缩算法，能避免碎片化</li>
</ul>
</li>
<li>可预测的停顿时间模型<ul>
<li>G1跟踪各Region垃圾堆积的价值（回收所得空间大小，回收所需时间，的经验值），在后台维护一个优先列表</li>
<li>根据允许的收集时间，优先回收价值最大的Region</li>
</ul>
</li>
</ol>
<p><strong>G1缺点：</strong></p>
<ol>
<li>相较于CMS，G1还不具有压倒性的优势<ul>
<li>比如：G1为垃圾收集产生的内存占用（Footprint），程序运行时的额外执行负载（overload）都要比CMS要高</li>
</ul>
</li>
<li>小内存上CMS表现大概率优于G1，平衡点大约在6-8G之间</li>
</ol>
<p><strong>G1参数设置：</strong></p>
<ul>
<li><code>-XX:+UseG1GC</code>：指定使用G1垃圾收集器</li>
<li><code>-XX:G1HeapRegionSize</code>：每个Region的大小。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000。</li>
<li><code>-XX:MaxGCPauseMillis</code>：设置期望达到的最大GC停顿时间指标，不保证达到，默认200ms</li>
<li><code>-XX:+ParallelGCThread</code>：设置STW时，GC线程数的值。最多设置为8</li>
<li><code>-XX:ConcGCThreads</code>：设置并发标记的线程数。设置为ParallelGcThreads的1/4左右</li>
<li><code>-XX:InitiatingHeapOccupancyPercent</code>：触发并发GC的占用率阈值。超过此值，就触发GC。默认45</li>
</ul>
<p><strong>G1收集器常见设置步骤：</strong></p>
<ol>
<li>开启G1</li>
<li>设置堆最大内存</li>
<li>设置最大停顿时间</li>
</ol>
<p><strong>G1的适用场景：</strong></p>
<ol>
<li>面向服务端应用（大内存，多处理器）</li>
<li>应用需求：低GC延时</li>
<li>用来替换JDK1.5中的CMS，在以下情况使用G1可能比CMS更好<ul>
<li>超过50%的堆空间，都被活动数据占用</li>
<li>对象分配或年代提升变化很快</li>
<li>GC停顿时间过长（长于0.5至1秒）</li>
</ul>
</li>
<li>HotSpot中，除了G1外，其他垃圾回收器均使用内置的JVM线程执行GC多线程。<ul>
<li>G1可以采用应用线程承担后台GC工作</li>
<li>即：JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收</li>
</ul>
</li>
</ol>
<h3 id="分区Region思想"><a href="#分区Region思想" class="headerlink" title="分区Region思想"></a>分区Region思想</h3><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/11/03/vNDnkIRYG6zLmTp.png" alt="image-20231103151007387"></p>
<p><strong>基本思想：</strong></p>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/11/03/O2I8TwJe5WRZnMb.png" alt="image-20231103153327882" style="zoom:50%;">

<ol>
<li>使用G1时，将堆划分为约2048个大小相同的独立Region块，每个块大约控制在1MB到32MB之间（2的n次幂）<ul>
<li><code>-XX:G1HeapRegionSize</code>来设定</li>
</ul>
</li>
<li>新生代，老年代不再物理隔离，而是一部分Region的集合<ul>
<li>Region可能属于E，S，O，H</li>
<li>H是一种新的内存区域（Humongous），用于存放大对象</li>
<li>H是一组连续的区域，如果超过0.5个Region就放到H</li>
</ul>
</li>
<li>每个Region都是通过指针碰撞来分配空间的<ul>
<li>每个Region都有两个名为TAMS（Top at Mask Start）的指针</li>
</ul>
</li>
<li>Region同样可以使用TLAB来保证并发性</li>
</ol>
<p><strong>设置H区的原因：</strong></p>
<ul>
<li>之前：大对象直接被分配到老年区，但如果是一个短期对象的话，会有负面影响</li>
<li>现在：G1直接寻找连续的H区来存储，为了找到连续区域，有时会不得不启动Full GC<ul>
<li>G1大多数行为，都把H区作为老年代的一部分</li>
</ul>
</li>
</ul>
<h3 id="G1垃圾回收流程"><a href="#G1垃圾回收流程" class="headerlink" title="G1垃圾回收流程"></a>G1垃圾回收流程</h3><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/11/07/YkLVPRH1WrCuqxG.png" alt="image-20231107154636980" style="zoom:50%;">

<p><strong>主要包括三个环节：</strong></p>
<ul>
<li>年轻代GC（Young GC）</li>
<li>老年代并发标记（Concurrent Marking）</li>
<li>混合回收（Mixed GC）</li>
<li>（如果需要）单线程、独占式、高强度的Full GC，作为一种失败的后备选项</li>
</ul>
<p><strong>回收流程：</strong></p>
<ol>
<li>当Eden区用尽，开始年轻代GC<ul>
<li>并行独占式收集器</li>
<li>存活对象移动到Survivor区，或者老年区</li>
</ul>
</li>
<li>当堆内存达到一定值（默认45%），开始老年代并发标记</li>
<li>标记完成后，开始混合回收过程<ul>
<li>从老年区移动存活对象到空闲区间，空闲区间成为了老年代的一部分</li>
<li>不需要整个老年代被回收，只需要回收一部分Region</li>
</ul>
</li>
</ol>
<h4 id="年轻代GC"><a href="#年轻代GC" class="headerlink" title="年轻代GC"></a>年轻代GC</h4><ul>
<li>JVM启动时，G1先准备好Eden区，程序运行过程中不断创建对象到Eden区中；Eden区耗尽会启动一次Young GC</li>
<li>Young GC只回收Eden和Survivor区</li>
<li>先STW，再创建回收集（需要被回收的Region的集合，Young GC的回收集包括年轻代的所有分段）</li>
</ul>
<img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/11/07/Fypx8QE74DhNPXW.png" alt="image-20231107205205079" style="zoom:50%;">

<p><strong>图片的意思：</strong></p>
<ol>
<li>回收完E和S区，存活对象复制到新的S区</li>
<li>S区达到阈值可以晋升为O区</li>
</ol>
<p><strong>细致过程：</strong></p>
<ol>
<li>第一阶段，扫描根：<ul>
<li>扫描GC Root，会连同RSet记录的外部引用一起，作为存活对象的入口</li>
</ul>
</li>
<li>第二阶段，更新RSet</li>
<li>第三阶段，处理RSet：<ul>
<li>识别被老年代对象指向的Eden中的对象</li>
</ul>
</li>
<li>第四阶段，复制对象：<ul>
<li>E区和S区中存活的对象，复制到新S区中空的内存分段</li>
<li>年龄未达阈值，年龄加一，达到阈值会被复制到Old区中空的内存分段去</li>
<li>如果S区空间不够，E区的部分数据会直接晋升到Old区</li>
</ul>
</li>
<li>第五阶段，处理引用：<ul>
<li>处理Soft，Weak，Phantom，Final，JNI Weak 等引用</li>
<li>最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</li>
</ul>
</li>
</ol>
<p><strong>备注：</strong></p>
<ol>
<li>对于应用程序的引用赋值语句 oldObject.field（这个是老年代）=object（这个是新生代），JVM会在之前和之后执行特殊的操作以在dirty card queue中入队一个保存了对象引用信息的card。在年轻代回收的时候，G1会对Dirty Card Queue中所有的card进行处理，以更新RSet，保证RSet实时准确的反映引用关系。</li>
<li>为什么不在引用赋值语句处直接更新RSet？这是为了性能的需要，RSet的处理需要线程同步，开销会很大，使用队列性能会好很多。</li>
</ol>
<h4 id="并发标记"><a href="#并发标记" class="headerlink" title="并发标记"></a>并发标记</h4><ol>
<li><p>初始标记：标记从根节点直接可达的对象</p>
<ul>
<li>只扫描直接可达对象，节省时间</li>
<li>这个阶段是STW的</li>
<li>会触发一次Young GC</li>
</ul>
</li>
<li><p>根区域扫描：</p>
<ul>
<li>扫描S区直接可达的老年代对象，并标记被引用的对象</li>
<li>必须在Young GC之前完成，因为Young GC会使用复制算法对Survivor区进行GC</li>
</ul>
</li>
<li><p>并发标记：</p>
<ul>
<li>在整个堆中进行并发标记），可能会被Young GC中断</li>
<li>若区域对象都是垃圾，此区域会被立即回收</li>
<li>并发标记过程中，会计算每个区域的对象活性（存活对象的比例）</li>
</ul>
</li>
<li><p>再次标记：</p>
<ul>
<li>由于应用程序持续进行，需要修正上一次的标记结果</li>
<li>是STW的</li>
<li>G1中采用了比CMS更快的原始快照算法：Snapshot-At-The-Beginning（SATB）</li>
</ul>
</li>
<li><p>独占清理：</p>
<ul>
<li>计算各个区域的存活对象和GC回收比例，并进行排序</li>
<li>识别可以混合回收的区域，为下阶段做铺垫</li>
<li>是STW的</li>
</ul>
</li>
<li><p>并发清理阶段：</p>
<ul>
<li>识别并清理完全空闲的区域</li>
</ul>
</li>
</ol>
<h4 id="混合回收"><a href="#混合回收" class="headerlink" title="混合回收"></a>混合回收</h4><ul>
<li><p>当越来越多对象晋升到老年代时，为避免内存耗尽，会触发混合回收（Mixed GC）</p>
</li>
<li><p>除了回收整个Young Region，还会回收部分Old Region</p>
</li>
<li><p>Mixed GC不等于Full GC</p>
</li>
</ul>
<p><strong>混合回收的细节：</strong></p>
<ul>
<li>并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来<ul>
<li>默认情况下，这些老年代的内存分段会分8次（可以通过-XX:G1MixedGCCountTarget设置）被回收</li>
<li>意思就是一个Region会被分为8个内存段</li>
</ul>
</li>
<li>混合回收的回收集（Collection Set）包括八分之一的老年代内存分段，Eden区内存分段，Survivor区内存分段<ul>
<li>和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段</li>
</ul>
</li>
<li>由于老年代中的内存分段默认分8次回收，G1会优先回收垃圾多的内存分段。<ul>
<li>垃圾占内存分段比例越高的，越会被先回收</li>
<li>阈值会决定内存分段是否被回收。XX:G1MixedGCLiveThresholdPercent，默认为65%，意思是垃圾占内存分段比例要达到65%才会被回收</li>
<li>如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间</li>
</ul>
</li>
<li>混合回收并不一定要进行8次。有一个阈值-XX:G1HeapWastePercent，默认值为10%，意思是允许整个堆内存中有10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于10%，则不再进行混合回收。因为GC会花费很多的时间但是回收到的内存却很少。</li>
</ul>
<h4 id="可选：Full-GC"><a href="#可选：Full-GC" class="headerlink" title="可选：Full GC"></a>可选：Full GC</h4><ol>
<li>G1的初衷就是要避免Full GC的出现。<strong>STW+单线程</strong>，性能非常差</li>
<li>要避免Full GC的发生，一旦发生Full GC，需要对JVM参数进行调整<ul>
<li>堆内存太小，复制存活对象时空间不够，增大内存来解决</li>
</ul>
</li>
</ol>
<p>导致G1 Full GC的原因可能有两个：</p>
<ol>
<li>Evacuation的时候没有足够的to-space来存放晋升的对象；</li>
<li>并发处理过程完成之前空间耗尽。</li>
</ol>
<h4 id="G1优化建议"><a href="#G1优化建议" class="headerlink" title="G1优化建议"></a>G1优化建议</h4><ol>
<li>年轻代的大小<ul>
<li>避免使用-Xmn或-XX:NewRatio等选项显式设置年轻代大小。默认使用可预测的暂停时间目标，让G1自己去调整</li>
</ul>
</li>
<li>暂停时间目标不要太苛刻<ul>
<li>G1的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间</li>
<li>评估G1吞吐量时，暂停时间目标不要太严苛。目标太严苛，表明你愿意承受更多的垃圾回收开销，这会影响吞吐量</li>
</ul>
</li>
</ol>
<h3 id="Remembered-Set（记忆集）"><a href="#Remembered-Set（记忆集）" class="headerlink" title="Remembered Set（记忆集）"></a>Remembered Set（记忆集）</h3><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/11/07/8rpNf4e2wSJInAU.png" alt="image-20231107162256120" style="zoom:50%;">

<p>问题：一个Region中的对象，可能被任意其他Region中的对象引用，判断对象存活是否需要扫描整个Java堆？</p>
<ul>
<li>其他分代收集器也有这个问题，回收新生代时需不需要扫描老年代？</li>
</ul>
<p><strong>解决方法：</strong></p>
<ul>
<li>所有分代收集器，JVM都会使用Remembered Set（记忆集）来避免全堆扫描</li>
<li>每个Region都有一个Remembered Set</li>
<li>每次Reference类型数据进行写操作时，都会产生一个Write Barrier暂时中断操作</li>
<li>检查将要写入的引用指向的对象，是否与该Reference类型数据在不同的Region<ul>
<li>如果是其他收集器，那就检查老年代对象是否引用了新生代对象</li>
</ul>
</li>
<li>如果不同，通过CardTable将相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中</li>
<li>当垃圾回收时，在GC根节点范围内加入Remembered Set即可</li>
</ul>
<h3 id="垃圾回收器总结"><a href="#垃圾回收器总结" class="headerlink" title="垃圾回收器总结"></a>垃圾回收器总结</h3><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/11/14/t7nJif8ACqB3SKe.png" alt="image-20231114152942124" style="zoom: 67%;">

<p><strong>GC发展阶段：</strong></p>
<p>Serial =&gt; Parallel（并行）=&gt; CMS（并发）=&gt; G1 =&gt; ZGC</p>
<p><strong>如何选择垃圾回收器：</strong></p>
<ol>
<li>调整堆的大小，让JVM自适应完成</li>
<li>如果内存小于100M，使用<strong>串行</strong>收集器</li>
<li>如果是单核单机程序，没有停顿时间的要求，<strong>串行</strong>收集器</li>
<li>如果是多CPU，需要高吞吐量，允许停顿时间超过1秒，选择<strong>并行</strong>或者JVM自己选择</li>
<li>如果是多CPU，追求低停顿时间，使用<strong>并发</strong>收集器</li>
<li>官方推荐G1，性能高</li>
</ol>
<p><strong>面试：</strong></p>
<ul>
<li>如何判断一个对象能不能回收</li>
<li>垃圾回收算法有哪些</li>
<li>垃圾回收工作流程</li>
<li>多多关注垃圾回收器这一章的各种参数</li>
</ul>
<h3 id="GC日志分析"><a href="#GC日志分析" class="headerlink" title="GC日志分析"></a>GC日志分析</h3><p><strong>内存分配与垃圾回收的参数列表：</strong></p>
<ul>
<li><p>-XX:+PrintGC ：输出GC日志。类似：-verbose:gc</p>
</li>
<li><p>-XX:+PrintGCDetails ：输出GC的详细日志</p>
</li>
<li><p>-XX:+PrintGCTimestamps ：输出GC的时间戳（以基准时间的形式）</p>
</li>
<li><p>-XX:+PrintGCDatestamps ：输出GC的时间戳（以日期的形式，如2013-05-04T21: 53: 59.234 +0800）</p>
</li>
<li><p>-XX:+PrintHeapAtGC ：在进行GC的前后打印出堆的信息</p>
</li>
<li><p>-Xloggc:…/logs/gc.log ：日志文件的输出路径</p>
</li>
</ul>
<h4 id="verbose-gc"><a href="#verbose-gc" class="headerlink" title="-verbose:gc"></a>-verbose:gc</h4><p>是一个JVM参数，只会显示总的GC堆的变化，如下：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/11/14/BMIa8icgs3fStZK.png" alt="img"></p>
<ul>
<li><p><strong>GC，Full GC</strong>：GC的类型，GC只在新生代进行，Full GC包括永久代，新生代，老年代</p>
</li>
<li><p><strong>Allocation Failure</strong>：GC发生的原因</p>
</li>
<li><p><strong>80832K-&gt;19298K：</strong>堆在GC前的大小和GC后的大小</p>
</li>
<li><p><strong>228840K：</strong>堆现在的大小</p>
</li>
<li><p><strong>0.0084018 secs</strong>：GC持续的时间</p>
</li>
</ul>
<h4 id="PrintGCDetails"><a href="#PrintGCDetails" class="headerlink" title="PrintGCDetails"></a>PrintGCDetails</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/11/14/GSg2NiQ8WDMbfaF.png" alt="img"></p>
<ul>
<li><strong>GC，Full GC</strong>：同样是GC的类型</li>
<li><strong>Allocation Failure</strong>：GC发生的原因</li>
<li><strong>PSYoungGen</strong>：使用了Parallel Scavenge并行垃圾收集器，新生代前后的大小变化</li>
<li><strong>ParOldGen</strong>：使用了Parallel Old并行垃圾收集器，老年代前后的大小变化</li>
<li><strong>MetaSpace</strong>：元数据区GC前后大小的变化，JDK1.8引入了元数据区以替代永久代</li>
<li><strong>0.02 secs</strong>：GC花费的时间</li>
<li><strong>Times</strong>：user-垃圾回收花费的所有CPU时间，sys-花费在等待系统调用或系统事件的时间，real-GC从开始到结束的时间，包括阔其他进程占用时间片的实际时间</li>
</ul>
<h4 id="PrintGCTimestamps"><a href="#PrintGCTimestamps" class="headerlink" title="PrintGCTimestamps"></a>PrintGCTimestamps</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/11/14/nGRCh9rwX6ysNUu.png" alt="image-20231114165705194"></p>
<ul>
<li><strong>GC，Full GC</strong>：GC的类型</li>
<li>收集器的名字<ul>
<li>**[DefNew]**：使用Serial收集器，默认新生代收集器</li>
<li>**[ParNew]**：使用ParNew收集器</li>
<li>**[PSYoungGen]**：使用Parallel scavenge收集器</li>
<li>G1会显示<strong>garbage-first heap</strong></li>
</ul>
</li>
<li>Allocation Failure：引起GC的原因（年轻代中没有足够的空间能够存储新的数据）</li>
<li>[ PSYoungGen: 5986K-&gt;696K(8704K) ] 5986K-&gt;704K (9216K)<ul>
<li>中括号内：年轻代，回收前大小，回收后大小，（年轻代总大小）</li>
<li>括号外：年轻代和老年代，回收前大小，回收后大小，（年轻代和老年代总大小）</li>
</ul>
</li>
<li>user代表用户态回收耗时，sys内核态回收耗时，real实际耗时<ul>
<li>由于多核线程切换的原因，时间总和可能会超过real时间</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
</search>
