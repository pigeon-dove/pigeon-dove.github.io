<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="keywords" content="java,前端,python,AI"><meta name="author" content="布鸽不鸽"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://npm.elemecdn.com" crossorigin><link rel="canonical" href="https://xuedongyun.cn/post/54344/"><meta name="robots" content="index,follow"><meta name="googlebot" content="index,follow"><meta name="revisit-after" content="1 days"><meta name="description" content="前言SpringBoot3.0开始强制使用JDK17，想必会迎来一波JDK8到JKD17的更新热潮。本文总结了JDK8-JDK17所有重要的更新内容，以供查阅。 原文地址：https:&#x2F;&#x2F;xuedongyun.cn&#x2F;post&#x2F;54344&#x2F; 带资源的try JDK7新特性   在try的后面可以增加()，括号中可以声明流对象并初始化 try中的代码执行完毕，自动把流对象释放，不用写finally了"><meta property="og:type" content="article"><meta property="og:title" content="JDK8到JDK17新特性"><meta property="og:url" content="https://xuedongyun.cn/post/54344/index.html"><meta property="og:site_name" content="冬云的博客"><meta property="og:description" content="前言SpringBoot3.0开始强制使用JDK17，想必会迎来一波JDK8到JKD17的更新热潮。本文总结了JDK8-JDK17所有重要的更新内容，以供查阅。 原文地址：https:&#x2F;&#x2F;xuedongyun.cn&#x2F;post&#x2F;54344&#x2F; 带资源的try JDK7新特性   在try的后面可以增加()，括号中可以声明流对象并初始化 try中的代码执行完毕，自动把流对象释放，不用写finally了"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2023-04-22T14:18:51.000Z"><meta property="article:modified_time" content="2023-06-09T07:05:48.852Z"><meta property="article:author" content="布鸽不鸽"><meta property="article:tag" content="java基础"><meta name="twitter:card" content="summary"><link rel="icon" type="image/png" href="/image/favicon.ico" sizes="192x192"><link rel="apple-touch-icon" sizes="180x180" href="/image/favicon.ico"><meta name="theme-color" content="#A31F34"><link rel="shortcut icon" href="/image/favicon.ico"><title>JDK8到JDK17新特性 - 冬云的博客</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="//npm.elemecdn.com/hexo-theme-redefine@2.3.0/source/fonts/fonts.css"><link rel="stylesheet" href="//npm.elemecdn.com/hexo-theme-redefine@2.3.0/source/fonts/Satoshi/satoshi.css"><link rel="stylesheet" href="//npm.elemecdn.com/hexo-theme-redefine@2.3.0/source/fonts/Chillax/chillax.css"><script id="hexo-configurations">let Global = window.Global || {};
    Global.hexo_config = {"hostname":"xuedongyun.cn","root":"/","language":"zh-CN","path":"search.xml"};
    Global.theme_config = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":true,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","font":{"enable":false,"family":null,"url":null}},"toc":{"enable":true,"max_depth":4,"number":false,"expand":true,"init_open":true},"copyright":true,"lazyload":true,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":true},"scroll_progress":{"bar":false,"percentage":true},"website_counter":{"url":"https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"open_graph":true,"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"https://s2.loli.net/2023/04/26/5keLlFDntNaz81Z.webp","dark":"https://s2.loli.net/2023/04/26/5keLlFDntNaz81Z.webp"},"title":"程序员的个人修养","subtitle":{"text":["Hello World!","Across the Great Wall we can reach every corner in the world"],"hitokoto":{"enable":false,"api":"https://v1.hitokoto.cn"},"typing_speed":50,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"links":{"github":null,"instagram":null,"zhihu":null,"twitter":null,"email":null},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":true,"type":"fixed","audios":[{"name":"One Last Kiss","artist":"宇多田ヒカル","url":"/music/OneLastKiss.mp3","cover":"/image/OneLastKiss.webp"},{"name":"水星记","artist":"郭顶","cover":"/image/水星记.webp","url":"/music/水星记.mp3"},{"name":"平凡之路","artist":"朴树","cover":"/image/平凡之路.webp","url":"/music/平凡之路.mp3"}]},"mermaid":{"enable":true,"version":"9.3.0"}},"version":"2.3.0","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":50},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"java":{"path":"/categories/java/","icon":"fa-regular fa-server"},"MySQL":{"path":"/categories/mysql/","icon":"fa-regular fa-hard-drive"},"Redis":{"path":"/categories/redis/","icon":"fa-regular fa-memory"},"算法题":{"path":"/categories/算法题/","icon":"fa-regular fa-laptop-code"},"工具和应用":{"path":"/categories/工具和应用/","icon":"fa-regular fa-toolbox"}},"search":{"enable":true,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":"Fly Me To The Moon","links":{"博客搭建系列":{"path":"/tags/博客搭建系列"},"SpringBoot源码系列":{"path":"/tags/SpringBoot源码系列"},"Java设计模式系列":{"path":"/tags/java设计模式系列"},"Redis实战系列":{"path":"/tags/Redis实战系列"}}},"article_date_format":"auto","categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2022/4/19 20:56:00"};
    Global.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"};
    Global.data_config = {"masonry":false};</script><link rel="stylesheet" href="//npm.elemecdn.com/hexo-theme-redefine@2.3.0/source/fontawesome/fontawesome.min.css"><link rel="stylesheet" href="//npm.elemecdn.com/hexo-theme-redefine@2.3.0/source/fontawesome/brands.min.css"><link rel="stylesheet" href="//npm.elemecdn.com/hexo-theme-redefine@2.3.0/source/fontawesome/solid.min.css"><link rel="stylesheet" href="//npm.elemecdn.com/hexo-theme-redefine@2.3.0/source/fontawesome/regular.min.css"><meta name="generator" content="Hexo 6.3.0"><style>mjx-container[jax=SVG]{direction:ltr}mjx-container[jax=SVG]>svg{overflow:visible}mjx-container[jax=SVG][display=true]{display:block;text-align:center;margin:1em 0}mjx-container[jax=SVG][justify=left]{text-align:left}mjx-container[jax=SVG][justify=right]{text-align:right}g[data-mml-node=merror]>g{fill:red;stroke:red}g[data-mml-node=merror]>rect[data-background]{fill:#ff0;stroke:none}g[data-mml-node=mtable]>line[data-line]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>rect[data-frame]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>.mjx-dashed{stroke-dasharray:140}g[data-mml-node=mtable]>.mjx-dotted{stroke-linecap:round;stroke-dasharray:0,140}g[data-mml-node=mtable]>svg{overflow:visible}[jax=SVG] mjx-tool{display:inline-block;position:relative;width:0;height:0}[jax=SVG] mjx-tool>mjx-tip{position:absolute;top:0;left:0}mjx-tool>mjx-tip{display:inline-block;padding:.2em;border:1px solid #888;font-size:70%;background-color:#f8f8f8;color:#000;box-shadow:2px 2px 5px #aaa}g[data-mml-node=maction][data-toggle]{cursor:pointer}mjx-status{display:block;position:fixed;left:1em;bottom:1em;min-width:25%;padding:.2em .4em;border:1px solid #888;font-size:90%;background-color:#f8f8f8;color:#000}foreignObject[data-mjx-xml]{font-family:initial;line-height:normal;overflow:visible}.MathJax path{stroke-width:3}mjx-container[display=true]{overflow:auto hidden}mjx-container[display=true]+br{display:none}</style></head><body><div class="progress-bar-container"><span class="pjax-progress-bar"></span> <span class="swup-progress-icon"><i class="fa-solid fa-circle-notch fa-spin"></i></span></div><main class="page-container" id="swup"><div class="main-content-container"><div class="main-content-header"><header class="navbar-container"><div class="navbar-content"><div class="left"><a class="logo-title" href="/">冬云的博客</a></div><div class="right"><div class="desktop"><ul class="navbar-list"><li class="navbar-item"><a href="/"><i class="fa-regular fa-house"></i> 首页</a></li><li class="navbar-item"><a href="/categories/java/"><i class="fa-regular fa-server"></i> JAVA</a></li><li class="navbar-item"><a href="/categories/mysql/"><i class="fa-regular fa-hard-drive"></i> MYSQL</a></li><li class="navbar-item"><a href="/categories/redis/"><i class="fa-regular fa-memory"></i> REDIS</a></li><li class="navbar-item"><a href="/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"><i class="fa-regular fa-laptop-code"></i> 算法题</a></li><li class="navbar-item"><a href="/categories/%E5%B7%A5%E5%85%B7%E5%92%8C%E5%BA%94%E7%94%A8/"><i class="fa-regular fa-toolbox"></i> 工具和应用</a></li><li class="navbar-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></div><div class="icon-item navbar-bar"><div class="navbar-bar-middle"></div></div></div></div></div><div class="navbar-drawer"><ul class="drawer-navbar-list"><li class="drawer-navbar-item flex-center"><a href="/"><i class="fa-regular fa-house"></i> 首页</a></li><li class="drawer-navbar-item flex-center"><a href="/categories/java/"><i class="fa-regular fa-server"></i> JAVA</a></li><li class="drawer-navbar-item flex-center"><a href="/categories/mysql/"><i class="fa-regular fa-hard-drive"></i> MYSQL</a></li><li class="drawer-navbar-item flex-center"><a href="/categories/redis/"><i class="fa-regular fa-memory"></i> REDIS</a></li><li class="drawer-navbar-item flex-center"><a href="/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"><i class="fa-regular fa-laptop-code"></i> 算法题</a></li><li class="drawer-navbar-item flex-center"><a href="/categories/%E5%B7%A5%E5%85%B7%E5%92%8C%E5%BA%94%E7%94%A8/"><i class="fa-regular fa-toolbox"></i> 工具和应用</a></li></ul></div><div class="window-mask"></div></header></div><div class="main-content-body"><div class="main-content"><div class="post-page-container"><div class="article-content-container"><div class="article-title"><h1 class="article-title-regular">JDK8到JDK17新特性</h1></div><div class="article-header"><div class="avatar"><img src="https://s2.loli.net/2023/04/20/q9CpkwWALQae6Mj.jpg"></div><div class="info"><div class="author"><span class="name">布鸽不鸽</span> <span class="author-label">Lv4</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fa-regular fa-pen-fancy"></i>&nbsp; <span class="desktop">2023-04-22 22:18:51</span> <span class="mobile">2023-04-22 22:18:51</span> <span class="hover-info">创建</span> </span><span class="article-date article-meta-item"><i class="fa-regular fa-wrench"></i>&nbsp; <span class="desktop">2023-06-09 15:05:48</span> <span class="mobile">2023-06-09 15:05:48</span> <span class="hover-info">更新</span> </span><span class="article-categories article-meta-item"><i class="fa-regular fa-folders"></i>&nbsp;<ul><li><a href="/categories/java/">java</a>&nbsp;</li></ul></span><span class="article-tags article-meta-item"><i class="fa-regular fa-tags"></i>&nbsp;<ul><li><a href="/tags/java%E5%9F%BA%E7%A1%80/">java基础</a>&nbsp;</li></ul></span><span class="article-wordcount article-meta-item"><i class="fa-regular fa-typewriter"></i>&nbsp;<span>4.8k 字</span> </span><span class="article-min2read article-meta-item"><i class="fa-regular fa-clock"></i>&nbsp;<span>21 分钟</span> </span><span class="article-pv article-meta-item"><i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content markdown-body"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>SpringBoot3.0开始强制使用JDK17，想必会迎来一波JDK8到JKD17的更新热潮。本文总结了JDK8-JDK17所有重要的更新内容，以供查阅。</p><p>原文地址：<a href="https://xuedongyun.cn/post/54344/">https://xuedongyun.cn/post/54344/</a></p><h2 id="带资源的try"><a href="#带资源的try" class="headerlink" title="带资源的try"></a>带资源的try</h2><blockquote><p>JDK7新特性</p></blockquote><ul><li>在try的后面可以增加()，括号中可以声明流对象并初始化</li><li>try中的代码执行完毕，自动把流对象释放，不用写finally了</li></ul><blockquote><p>说明：</p><ul><li><p>声明的类必须实现<code>AutoCloseable</code>或<code>Closeable</code>接口，实现了其中的<code>close</code>方法。Java7几乎把所有的资源类都实现了这些接口。</p></li><li><p>写到括号中的变量默认是final的，无法更改。</p></li></ul></blockquote><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">"d:/1.txt"</span>);</span><br><span class="line">    <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fis, <span class="string">"utf-8"</span>);</span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line"></span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">"1.txt"</span>);</span><br><span class="line">    <span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(fos, <span class="string">"gbk"</span>);</span><br><span class="line">    <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(osw);</span><br><span class="line">) {</span><br><span class="line">    String str;</span><br><span class="line">    <span class="keyword">while</span> ((str = br.readLine()) != <span class="literal">null</span>) {</span><br><span class="line">        bw.write(str);</span><br><span class="line">        bw.newLine();</span><br><span class="line">    }</span><br><span class="line">} <span class="keyword">catch</span> (FileNotFoundException e) {</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">} <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><blockquote><p>JDK9语法有增强</p></blockquote><p>此时可以在外部初始化变量，括号中引用外部名称即可，用分号隔开。</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStreamReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in);</span><br><span class="line"><span class="type">OutputStreamWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out);</span><br><span class="line"><span class="keyword">try</span> (reader; writer) {</span><br><span class="line">    <span class="comment">// 主要流程</span></span><br><span class="line">} <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><blockquote><p>JDK8新特性</p></blockquote><p>在启动线程时，需要传入一个实现<code>java.lang.Runnable</code>接口的对象，来定义线程中的工作。通常，我们使用匿名内部类来实现。</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Hello from thread"</span>);</span><br><span class="line">    }</span><br><span class="line">}).start();</span><br></pre></td></tr></table></figure></div><p>但是本质上，我们需要的其实只是一个函数。lambda表达式就是为解决这个问题而出现的。</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; com1 = (Integer o1, Integer o2) -&gt; {</span><br><span class="line">    <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型推断：类型可以由编译器推理出来，可以不写</span></span><br><span class="line">Comparator&lt;Integer&gt; com1 = (o1, o2) -&gt; {</span><br><span class="line">    <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><ul><li>只包含<strong>一个抽象方法</strong>的接口称为函数式接口（当然可以包含其他非抽象方法）</li><li>可以用lambda表达式创建接口的对象</li><li>可以在接口上标注<code>@FunctionalInterface</code>注解，用于检查是否满足条件</li></ul><blockquote><p>函数式编程思想：</p><ul><li>函数是一等公民，注重获取结果</li></ul></blockquote><h3 id="内置的函数式接口"><a href="#内置的函数式接口" class="headerlink" title="内置的函数式接口"></a>内置的函数式接口</h3><ul><li><p>之前常见的函数式接口</p><ul><li><code>java.lang.Runnable</code>，方法：<code>public void run()</code></li><li><code>java.lang.Iterable&lt;T&gt;</code>，方法：<code>public Iterator&lt;T&gt; iterate()</code></li><li><code>java.lang.Comparable&lt;T&gt;</code>，方法：<code>public int compareTo(T t)</code></li><li><code>java.util.Comparator&lt;T&gt;</code>，方法：<code>public int compare(T t1, T t2)</code></li></ul></li><li><p>四大核心函数接口</p></li></ul><table><thead><tr><th>函数式接口</th><th>称谓</th><th>抽象方法</th><th>用途</th></tr></thead><tbody><tr><td><code>Consumer&lt;T&gt;</code></td><td>消费型接口</td><td><code>void accept(T t)</code></td><td>对类型为T的对象进行操作</td></tr><tr><td><code>Supplier&lt;T&gt;</code></td><td>供给型接口</td><td><code>T get()</code></td><td>返回类型为T的对象</td></tr><tr><td><code>Function&lt;T, R&gt;</code></td><td>函数型接口</td><td><code>R apply(T t)</code></td><td>对对象进行操作，返回结果</td></tr><tr><td><code>Predicate&lt;T&gt;</code></td><td>判断型接口</td><td><code>boolean test(T t)</code></td><td>判断对象是否满足某条件</td></tr></tbody></table><ul><li>消费型接口</li></ul><table><thead><tr><th>函数式接口</th><th>抽象方法</th><th>描述</th></tr></thead><tbody><tr><td><code>BiConsumer&lt;T,U&gt;</code></td><td><code>void accept(T t, U u)</code></td><td>接收两个对象，用于完成功能</td></tr><tr><td><code>DoubleConsumer</code></td><td><code>void accept(double value)</code></td><td>接收一个double值</td></tr><tr><td><code>IntConsumer</code></td><td><code>void accept(int value)</code></td><td>接收一个int值</td></tr><tr><td><code>LongConsumer</code></td><td><code>void accept(long value)</code></td><td>接收一个long值</td></tr><tr><td><code>ObjDoubleConsumer&lt;T&gt;</code></td><td><code>void accept(T t, double value)</code></td><td>接收一个对象和一个double值</td></tr><tr><td><code>ObjIntConsumer&lt;T&gt;</code></td><td><code>void accept(T t, int value)</code></td><td>接收一个对象和一个int值</td></tr><tr><td><code>ObjLongConsumer&lt;T&gt;</code></td><td><code>void accept(T t, long value)</code></td><td>接收一个对象和一个long值</td></tr></tbody></table><ul><li>供给型接口</li></ul><table><thead><tr><th>接口名</th><th>抽象方法</th><th>描述</th></tr></thead><tbody><tr><td><code>BooleanSupplier</code></td><td><code>boolean getAsBoolean()</code></td><td>返回一个boolean值</td></tr><tr><td><code>DoubleSupplier</code></td><td><code>double getAsDouble()</code></td><td>返回一个double值</td></tr><tr><td><code>IntSupplier</code></td><td><code>int getAsInt()</code></td><td>返回一个int值</td></tr><tr><td><code>LongSupplier</code></td><td><code>long getAsLong()</code></td><td>返回一个long值</td></tr></tbody></table><ul><li>判断型接口</li></ul><table><thead><tr><th>接口名</th><th>抽象方法</th><th>描述</th></tr></thead><tbody><tr><td><code>BiPredicate&lt;T,U&gt;</code></td><td><code>boolean test(T t, U u)</code></td><td>接收两个对象</td></tr><tr><td><code>DoublePredicate</code></td><td><code>boolean test(double value)</code></td><td>接收一个double值</td></tr><tr><td><code>IntPredicate</code></td><td><code>boolean test(int value)</code></td><td>接收一个int值</td></tr><tr><td><code>LongPredicate</code></td><td><code>boolean test(long value)</code></td><td>接收一个long值</td></tr></tbody></table><ul><li>函数型接口（看套路总结即可）</li></ul><table><thead><tr><th>接口名</th><th>抽象方法</th><th>描述</th></tr></thead><tbody><tr><td><code>UnaryOperator&lt;T&gt;</code></td><td><code>T apply(T t)</code></td><td>接收T类型，返回T类型</td></tr><tr><td><code>DoubleFunction&lt;R&gt;</code></td><td><code>R apply(double value)</code></td><td>接收double，返回R类型</td></tr><tr><td><code>IntFunction&lt;R&gt;</code></td><td><code>R apply(int value)</code></td><td>接收int，返回R类型</td></tr><tr><td><code>LongFunction&lt;R&gt;</code></td><td><code>R apply(long value)</code></td><td>接收long，返回类型</td></tr><tr><td><code>ToDoubleFunction&lt;T&gt;</code></td><td><code>double applyAsDouble(T value)</code></td><td>接收T类型，返回double</td></tr><tr><td><code>ToIntFunction&lt;T&gt;</code></td><td><code>int applyAsInt(T value)</code></td><td>接收T类型，返回int</td></tr><tr><td><code>ToLongFunction&lt;T&gt;</code></td><td><code>long applyAsLong(T value)</code></td><td>接收类型T，返回long</td></tr><tr><td><code>DoubleToIntFunction</code></td><td><code>int applyAsInt(double value)</code></td><td>接收double，返回int</td></tr><tr><td><code>DoubleToLongFunction</code></td><td><code>long applyAsLong(double value)</code></td><td>接收double，返回long</td></tr><tr><td><code>IntToDoubleFunction</code></td><td><code>double applyAsDouble(int value)</code></td><td>接收int，返回double</td></tr><tr><td><code>IntToLongFunction</code></td><td><code>long applyAsLong(int value)</code></td><td>接收int，返回long</td></tr><tr><td><code>LongToDoubleFunction</code></td><td><code>double applyAsDouble(long value)</code></td><td>接收long，返回double</td></tr><tr><td><code>LongToIntFunction</code></td><td><code>int applyAsInt(long value)</code></td><td>接收long，返回int</td></tr><tr><td><code>DoubleUnaryOperator</code></td><td><code>double applyAsDouble(double operand)</code></td><td>接收double，返回double</td></tr><tr><td><code>IntUnaryOperator</code></td><td><code>int applyAsInt(int operand)</code></td><td>接收int，返回int</td></tr><tr><td><code>LongUnaryOperator</code></td><td><code>long applyAsLong(long operand)</code></td><td>接收long，返回long</td></tr><tr><td><code>BiFunction&lt;T,U,R&gt;</code></td><td><code>R apply(T t, U u)</code></td><td>接收T类型和U类型，返回一个R类型</td></tr><tr><td><code>BinaryOperator&lt;T&gt;</code></td><td><code>T apply(T t, T u)</code></td><td>接收两个T类型，返回T类型</td></tr><tr><td><code>ToDoubleBiFunction&lt;T,U&gt;</code></td><td><code>double applyAsDouble(T t, U u)</code></td><td>接收T类型和U类型，返回double</td></tr><tr><td><code>ToIntBiFunction&lt;T,U&gt;</code></td><td><code>int applyAsInt(T t, U u)</code></td><td>接收T类型和U类型，返回int</td></tr><tr><td><code>ToLongBiFunction&lt;T,U&gt;</code></td><td><code>long applyAsLong(T t, U u)</code></td><td>接收T类型和U类型，返回long</td></tr><tr><td><code>DoubleBinaryOperator</code></td><td><code>double applyAsDouble(double left, double right)</code></td><td>接收两个double，返回double</td></tr><tr><td><code>IntBinaryOperator</code></td><td><code>int applyAsInt(int left, int right)</code></td><td>接收两个int，返回int</td></tr><tr><td><code>LongBinaryOperator</code></td><td><code>long applyAsLong(long left, long right)</code></td><td>接收两个long，返回long</td></tr></tbody></table><blockquote><p>命名套路：</p><p>Operator：参数返回值类型一致</p><p>Fucntion：参数返回值类型不一致</p><ul><li><p><code>Int</code>-UnaryOperator</p></li><li><p><code>Int</code>-Function</p></li><li><p><code>To-Int</code>-Function</p></li><li><p><code>Double-To-Int</code>-Function</p></li><li><p><code>Bi</code>-Function</p><ul><li><code>To-Int-Bi</code>-Function</li></ul></li><li><p><code>Binary</code>-Operator</p><ul><li><code>Int-Binary-</code>Operator</li></ul></li></ul></blockquote><h2 id="方法引用与构造器引用"><a href="#方法引用与构造器引用" class="headerlink" title="方法引用与构造器引用"></a>方法引用与构造器引用</h2><blockquote><p>JDK8新特性</p></blockquote><p>本质：使用已有方法赋值lambda表达式，只要类型一致就成立</p><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>当要传给lambda体的操作，已经有实现的方法时：</p><ul><li><code>对象::实例方法</code></li><li><code>类::静态方法</code></li><li><code>类::实例方法</code></li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; con = System.out::println;</span><br></pre></td></tr></table></figure></div><h3 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h3><p>当Lambda表达式是为了创建一个对象，且满足Lambda表达式形参时：</p><ul><li><code>类名::new</code></li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;Employee&gt; sup = Employee::<span class="keyword">new</span>;</span><br></pre></td></tr></table></figure></div><h3 id="数组构造引用"><a href="#数组构造引用" class="headerlink" title="数组构造引用"></a>数组构造引用</h3><p>当Lambda表达式是为了创建一个数组对象，且满足Lambda表达式形参时：</p><ul><li><code>数组类型名::new</code></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer,String[]&gt; func = String[]::new;</span><br><span class="line">String[] arr = func.apply(10); // 数组的形参是数组大小</span><br></pre></td></tr></table></figure></div><h2 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h2><blockquote><p>JDK8新特性</p></blockquote><ul><li>使用Stream API对集合进行操作，就类似于使用SQL执行数据库查询</li><li>Stream和Collection的区别<ul><li>Collection是一种静态的内存数据结构，核心是数据</li><li>Stream是有关计算的，核心是计算</li></ul></li><li>Stream操作流程：创建-&gt;中间操作-&gt;终止操作</li></ul><h3 id="创建Stream实例"><a href="#创建Stream实例" class="headerlink" title="创建Stream实例"></a>创建Stream实例</h3><p><strong>方法一：通过集合</strong></p><p>java8种Collection接口被扩展，提供了两个新的方法</p><ul><li><code>default Stream&lt;E&gt; stream()</code>: 返回一个顺序流</li><li><code>default Stream&lt;E&gt; parallelStream()</code>: 返回一个并行流</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = list.stream();</span><br></pre></td></tr></table></figure></div><p><strong>方法二：通过数组</strong></p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Arrays.stream(arr); </span><br></pre></td></tr></table></figure></div><p><strong>方法三：通过Stream.of()创建</strong></p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure></div><p><strong>方法四：创建无限流</strong></p><p>可以使用<code>Stream.iterate()</code>和<code>Stream.generate()</code>，创建无限流</p><ul><li>迭代：<code>public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f)</code></li><li>生成：<code>public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)</code></li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.iterate(<span class="number">0</span>, x -&gt; x + <span class="number">2</span>);</span><br><span class="line">stream.limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">Stream&lt;Double&gt; stream1 = Stream.generate(Math::random);</span><br><span class="line">stream1.limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure></div><h3 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h3><p>除非流水线上除法终止操作，否则中间操作不会执行任何处理。所有操作会一次性全部处理</p><ul><li><strong>筛选和切片</strong></li></ul><table><thead><tr><th><strong>方 法</strong></th><th><strong>描 述</strong></th></tr></thead><tbody><tr><td><code>filter(Predicatep)</code></td><td>接收Lambda，从流中排除某些元素</td></tr><tr><td><code>distinct()</code></td><td>筛选，通过流所生成元素的<code>hashCode()</code>和<code>equals()</code>去除重复元素</td></tr><tr><td><code>limit(long maxSize)</code></td><td>截断流，使其元素不超过给定数量</td></tr><tr><td><code>skip(long n)</code></td><td>跳过元素，返回一个扔掉了前 n 个元素的流。<br>若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补</td></tr></tbody></table><ul><li><strong>映射</strong></li></ul><table><thead><tr><th><strong>方法</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>map(Function f)</code></td><td>函数被应用到每个元素上，将其映射成新的元素</td></tr><tr><td><code>mapToDouble(ToDoubleFunction f)</code></td><td>函数被应用到每个元素上，产生新的<code>DoubleStream</code></td></tr><tr><td><code>mapToInt(ToIntFunction f)</code></td><td>函数被应用到每个元素上，产生新的<code>IntStream</code></td></tr><tr><td><code>mapToLong(ToLongFunction f)</code></td><td>函数被应用到每个元素上，产生新的<code>LongStream</code></td></tr><tr><td><code>flatMap(Function f)</code></td><td>将流中的每个值都换成另一个流，然后把所有流连接成一个流</td></tr></tbody></table><ul><li><strong>排序</strong></li></ul><table><thead><tr><th><strong>方法</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>sorted()</code></td><td>产生一个新流，其中按自然顺序排序</td></tr><tr><td><code>sorted(Comparator com)</code></td><td>产生一个新流，其中按比较器顺序排序</td></tr></tbody></table><h3 id="终止操作"><a href="#终止操作" class="headerlink" title="终止操作"></a>终止操作</h3><ul><li>匹配和查找</li></ul><table><thead><tr><th><strong>方法</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>allMatch(Predicate p)</code></td><td>检查是否匹配所有元素</td></tr><tr><td><code>anyMatch(Predicate p)</code></td><td>检查是否至少匹配一个元素</td></tr><tr><td><code>noneMatch(Predicate p)</code></td><td>检查是否没有匹配所有元素</td></tr><tr><td><code>findFirst()</code></td><td>返回第一个元素</td></tr><tr><td><code>findAny()</code></td><td>返回当前流中的任意元素</td></tr><tr><td><code>count()</code></td><td>返回流中元素总数</td></tr><tr><td><code>max(Comparator c)</code></td><td>返回流中最大值</td></tr><tr><td><code>min(Comparator c)</code></td><td>返回流中最小值</td></tr><tr><td><code>forEach(Consumer c)</code></td><td>内部迭代<br>(使用<code>Collection</code>接口需要用户去做迭代，称为外部迭代)</td></tr></tbody></table><ul><li>归约</li></ul><table><thead><tr><th><strong>方法</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>reduce(T identity, BinaryOperator b)</code></td><td>带初始值，可以将流中元素反复结合起来，得到一个值。返回<code>T</code></td></tr><tr><td><code>reduce(BinaryOperator b)</code></td><td>不带初始值，可以将流中元素反复结合起来，得到一个值。返回<code>Optional&lt;T&gt;</code></td></tr></tbody></table><ul><li>收集</li></ul><table><thead><tr><th><strong>方 法</strong></th><th><strong>描 述</strong></th></tr></thead><tbody><tr><td><code>collect(Collector c)</code></td><td>将流转换为其他形式。接收参数：Collector接口的实现</td></tr></tbody></table><p>Collectors类中帮我们实现了很多静态方法，可以帮助我们很方便的实现收集</p><table><thead><tr><th><strong>方法</strong></th><th><strong>返回类型</strong></th><th><strong>作用</strong></th><th>举例</th></tr></thead><tbody><tr><td><code>toList</code></td><td><code>Collector&lt;T, ?, List&lt;T&gt;&gt;</code></td><td>收集到List</td><td><code>.stream().collect(Collectors.toList());</code></td></tr><tr><td><code>toSet</code></td><td><code>Collector&lt;T, ?, Set&lt;T&gt;&gt;</code></td><td>收集到Set</td><td><code>.stream().collect(Collectors.toSet());</code></td></tr><tr><td><code>toCollection</code></td><td><code>Collector&lt;T, ?, C&gt;</code></td><td>收集到创建的集合</td><td><code>.stream().collect(Collectors.toCollection(ArrayList::new));</code></td></tr><tr><td><code>counting</code></td><td><code>Collector&lt;T, ?, Long&gt;</code></td><td>计算元素的个数</td><td><code>.stream().collect(Collectors.counting());</code></td></tr><tr><td><code>summingInt</code></td><td><code>Collector&lt;T, ?, Integer&gt;</code></td><td>对Integer属性求和</td><td><code>.stream().collect(Collectors.summingInt(Employee::getSalary));</code></td></tr><tr><td><code>averagingInt</code></td><td><code>Collector&lt;T, ?, Double&gt;</code></td><td>对Integer属性平均</td><td><code>.stream().collect(Collectors.averagingInt(Employee::getSalary));</code></td></tr><tr><td><code>summarizingInt</code></td><td><code>Collector&lt;T, ?, IntSummaryStatistics&gt;</code></td><td>收集流中Integer属性的统计值。如：平均值</td><td><code>.stream().collect(Collectors.summarizingInt(Employee::getSalary));</code></td></tr><tr><td><code>joining</code></td><td><code>Collector&lt;CharSequence, ?, String&gt;</code></td><td>连接流中每个字符串</td><td><code>.stream().map(Employee::getName).collect(Collectors.joining());</code></td></tr><tr><td><code>maxBy</code></td><td><code>Collector&lt;T, ?, Optional&lt;T&gt;&gt;</code></td><td>根据比较器选择最大值</td><td><code>.stream().collect(Collectors.maxBy(comparingInt(Employee::getSalary)));</code></td></tr><tr><td><code>minBy</code></td><td><code>Collector&lt;T, ?, Optional&lt;T&gt;&gt;</code></td><td>根据比较器选择最小值</td><td><code>.stream().collect(Collectors.minBy(comparingInt(Employee::getSalary)));</code></td></tr><tr><td><code>reducing</code></td><td><code>Collector&lt;T, ?, Optional&lt;T&gt;&gt;</code></td><td>从一个作为累加器的初始值开始，利用<code>BinaryOperator</code>逐个结合，从而归约成单个值</td><td><code>.stream().collect(Collectors.reducing(0, Employee::getSalar, Integer::sum));</code></td></tr><tr><td><code>collectingAndThen</code></td><td><code>Collector&lt;T,A,R&gt;</code></td><td>包裹另一个收集器，对其结果转换函数</td><td><code>.stream().collect(Collectors.collectingAndThen(Collectors.toList(), List::size));</code></td></tr><tr><td><code>groupingBy</code></td><td><code>Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt;</code></td><td>根据某属性值对流分组，属性为K，结果为V</td><td><code>.stream().collect(Collectors.groupingBy(Employee::getStatus));</code></td></tr><tr><td><code>partitioningBy</code></td><td><code>Collector&lt;T, ?, Map&lt;Boolean, List&lt;T&gt;&gt;&gt;</code></td><td>根据true或false进行分区</td><td><code>.stream().collect(Collectors.partitioningBy(Employee::getManage));</code></td></tr></tbody></table><h2 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a>Optional类</h2><blockquote><p>JDK8新特性</p></blockquote><p><code>Optional&lt;T&gt;</code> 类<code>java.util.Optional</code> 是一个容器类，它可以保存类型T的值，代表这个值存在。或者仅仅保存null，表示这个值不存在。如果值存在，则isPresent()方法会返回true，调用get()方法会返回该对象。</p><ul><li>创建Optional类的方法：</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; Optional&lt;T&gt; <span class="title function_">empty</span><span class="params">()</span>;				<span class="comment">// 创建空的Optional实例</span></span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; Optional&lt;T&gt; <span class="title function_">of</span><span class="params">(T value)</span>;			<span class="comment">// 创建Optional实例，value必须非空</span></span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; Optional&lt;T&gt; <span class="title function_">ofNullable</span><span class="params">(T value)</span>;	<span class="comment">// 创建Optional实例，value可以为空，也可能为非空</span></span><br></pre></td></tr></table></figure></div><ul><li>判断Optional容器中是否包含对象：</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">boolean isPresent();	// 判断值是否存在</span><br><span class="line">void ifPresent(Consumer&lt;? super T&gt; consumer) //若值存在，就对它进行Consumer指定的操作</span><br></pre></td></tr></table></figure></div><ul><li>获取Optional容器的对象</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">T <span class="title function_">get</span><span class="params">()</span>				<span class="comment">// 存在则返回值，否则抛异常</span></span><br><span class="line">T <span class="title function_">orElse</span><span class="params">(T other)</span>	<span class="comment">// 存在则返回值，为空就用指定的默认值</span></span><br><span class="line">T <span class="title function_">orElseGet</span><span class="params">(Supplier&lt;? extends T&gt; other)</span>	<span class="comment">// 存在则返回值，为空就用Supplier接口提供的值</span></span><br><span class="line">T <span class="title function_">orElseThrow</span><span class="params">(Supplier&lt;? extends X&gt; exceptionSupplier)</span> <span class="comment">// 存在则返回值，为空就用抛出你指定的异常类型</span></span><br></pre></td></tr></table></figure></div><blockquote><p>JDK9-11新增了特性</p></blockquote><table><thead><tr><th><strong>新增方法</strong></th><th><strong>描述</strong></th><th><strong>新增的版本</strong></th></tr></thead><tbody><tr><td><code>boolean isEmpty()</code></td><td>判断value是否为空</td><td>JDK 11</td></tr><tr><td><code>ifPresentOrElse(Consumer&lt;? super T&gt; action, Runnable emptyAction)</code></td><td>非空执行参数1；<br>否则空执行参数2</td><td>JDK 9</td></tr><tr><td><code>Optional&lt;T&gt; or(Supplier&lt;? extends Optional&lt;? extends T&gt;&gt; supplier)</code></td><td>非空返回对应的Optional；<br>否则返回参数封装的Optional</td><td>JDK 9</td></tr><tr><td><code>Stream&lt;T&gt; stream()</code></td><td>非空返回仅此value的Stream；<br>否则返回空Stream</td><td>JDK 9</td></tr><tr><td><code>T orElseThrow()</code></td><td>非空返回value；<br>否则抛异常<br>NoSuchElementException</td><td>JDK 10</td></tr></tbody></table><h2 id="可以创建空Stream"><a href="#可以创建空Stream" class="headerlink" title="可以创建空Stream"></a>可以创建空Stream</h2><blockquote><p>JDK9新特性</p></blockquote><p>Java8中Stream不能完全为空，否则会报空指针异常。Java9中的<code>ofNullable</code>方法允许创建一个单元素Stream，可以包含空元素</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以</span></span><br><span class="line">Stream&lt;String&gt; stringStream = Stream.of(<span class="string">"AA"</span>, <span class="string">"BB"</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="type">Long</span> <span class="variable">num</span> <span class="operator">=</span> stringStream.collect(Collectors.counting()); <span class="comment">// 3</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 不可以</span></span><br><span class="line">Stream&lt;String&gt; stringStream = Stream.of(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以</span></span><br><span class="line">Stream&lt;String&gt; stringStream = Stream.ofNullable(<span class="literal">null</span>);</span><br><span class="line"><span class="type">Long</span> <span class="variable">num</span> <span class="operator">=</span> stringStream.collect(Collectors.counting()); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以</span></span><br><span class="line">Stream&lt;String&gt; stringStream = Stream.ofNullable(<span class="string">"AA"</span>);</span><br><span class="line"><span class="type">Long</span> <span class="variable">num</span> <span class="operator">=</span> stringStream.collect(Collectors.counting()); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></div><h2 id="iterator终止方式"><a href="#iterator终止方式" class="headerlink" title="iterator终止方式"></a>iterator终止方式</h2><blockquote><p>JDK9新特性</p></blockquote><p>定义了重载的新的iterator方法，可以定义终止条件</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以前需要靠limit</span></span><br><span class="line">Stream.iterate(<span class="number">1</span>,i -&gt; i + <span class="number">1</span>).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在可以定义终止条件</span></span><br><span class="line">Stream.iterate(<span class="number">1</span>,i -&gt; i &lt; <span class="number">100</span>,i -&gt; i + <span class="number">1</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure></div><h2 id="jshell命令"><a href="#jshell命令" class="headerlink" title="jshell命令"></a>jshell命令</h2><blockquote><p>JDK9新特性</p></blockquote><ul><li>jShell命令是Java的REPL工具（交互式编程环境，read-evaluate-print-loop），可以像python那样一行一行执行</li><li>命令行输入<code>jshell</code>即可开始使用</li></ul><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jshell</span><br></pre></td></tr></table></figure></div><ul><li>不是很常用，略过</li></ul><h2 id="String存储结构和API变更"><a href="#String存储结构和API变更" class="headerlink" title="String存储结构和API变更"></a>String存储结构和API变更</h2><blockquote><p>JDK9新特性</p></blockquote><h3 id="存储结构变化"><a href="#存储结构变化" class="headerlink" title="存储结构变化"></a>存储结构变化</h3><p>产生背景：</p><blockquote><p>The current implementation of the String class stores characters in a char array, using two bytes (sixteen bits) for each character. Data gathered from many different applications indicates that strings are a major component of heap usage and, moreover, that most String objects contain only Latin-1 characters. Such characters require only one byte of storage, hence half of the space in the internal char arrays of such String objects is going unused.</p></blockquote><p>使用说明：</p><blockquote><p>We propose to change the internal representation of the String class from a UTF-16 char array to a byte array plus an encoding-flag field. The new String class will store characters encoded either as ISO-8859-1/Latin-1 (one byte per character), or as UTF-16 (two bytes per character), based upon the contents of the string. The encoding flag will indicate which encoding is used.</p></blockquote><p>对StringBuilder，StringBuffer等来说也是如此</p><blockquote><p>String-related classes such as AbstractStringBuilder, StringBuilder, and StringBuffer will be updated to use the same representation, as will the HotSpot VM’s intrinsic string operations.</p></blockquote><p>结论：String 不用 char[] 来存储，改成了 byte[] 加上编码标记，节约了一些空间</p><h3 id="API变化"><a href="#API变化" class="headerlink" title="API变化"></a>API变化</h3><h4 id="新增字符串处理方法"><a href="#新增字符串处理方法" class="headerlink" title="新增字符串处理方法"></a>新增字符串处理方法</h4><blockquote><p>JDK11新特性</p></blockquote><table><thead><tr><th><strong>描述</strong></th><th><strong>举例</strong></th></tr></thead><tbody><tr><td>判断字符串是否为空白</td><td><code>.isBlank()</code></td></tr><tr><td>去除首尾空白</td><td><code>.strip()</code></td></tr><tr><td>去除尾部空格</td><td><code>.stripTrailing()</code></td></tr><tr><td>去除首部空格</td><td><code>.stripLeading()</code></td></tr><tr><td>复制字符串</td><td><code>.repeat(3)</code></td></tr><tr><td>字符串按行分为流</td><td><code>Stream&lt;String&gt; lines = str.lines();</code></td></tr></tbody></table><h4 id="实现了Constable接口"><a href="#实现了Constable接口" class="headerlink" title="实现了Constable接口"></a>实现了Constable接口</h4><blockquote><p>JDK12新特性</p></blockquote><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, </span><br><span class="line">									Comparable&lt;String&gt;, </span><br><span class="line">									CharSequence, </span><br><span class="line">									Constable, </span><br><span class="line">									ConstantDesc {}</span><br></pre></td></tr></table></figure></div><ul><li>Constable接口</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Constable定义了方法，用于返回Optianl对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Constable</span> {</span><br><span class="line">	Optional&lt;? <span class="keyword">extends</span> <span class="title class_">ConstantDesc</span>&gt; describeConstable();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><ul><li><code>JDK12</code>实现接口的，其实就是用了<code>Optional.of</code></li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Optional&lt;String&gt; <span class="title function_">describeConstable</span><span class="params">()</span> {</span><br><span class="line">	<span class="keyword">return</span> Optional.of(<span class="built_in">this</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; optional = str.describeConstable();</span><br></pre></td></tr></table></figure></div><h4 id="transform方法"><a href="#transform方法" class="headerlink" title="transform方法"></a>transform方法</h4><blockquote><p>JDK12新特性</p></blockquote><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;R&gt; R <span class="title function_">transform</span><span class="params">(Function&lt;? <span class="built_in">super</span> String, ? extends R&gt; f)</span> {</span><br><span class="line">	<span class="keyword">return</span> f.apply(<span class="built_in">this</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p>例代码子：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有一点类似流中的map</span></span><br><span class="line"><span class="string">"foo"</span>.transform(input -&gt; input + <span class="string">" bar"</span>).transform(String::toUpperCase)</span><br></pre></td></tr></table></figure></div><h2 id="局部变量类型推断"><a href="#局部变量类型推断" class="headerlink" title="局部变量类型推断"></a>局部变量类型推断</h2><blockquote><p>JDK10新特性</p></blockquote><p>本特性允许开发人员省略通常不必要的类型声明</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 局部变量</span></span><br><span class="line"><span class="type">var</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增强for循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> v : list) {</span><br><span class="line">    System.out.println(v);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通for循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) {</span><br><span class="line">    System.out.println(i);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值类型含复杂泛型结构</span></span><br><span class="line"><span class="comment">//Iterator&lt;Map.Entry&lt;Integer, Student&gt;&gt; iterator = set.iterator();</span></span><br><span class="line"><span class="type">var</span> <span class="variable">iterator</span> <span class="operator">=</span> set.iterator();</span><br></pre></td></tr></table></figure></div><blockquote><p>注意：</p><ul><li>var不是关键词，而是一个类型名</li><li>var不会改变Java是一门静态类型语言的事实。编译器负责推断出结果，将结果写入字节码文件。</li></ul></blockquote><h2 id="文本块"><a href="#文本块" class="headerlink" title="文本块"></a>文本块</h2><blockquote><p>JDK13新特性</p></blockquote><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以前</span></span><br><span class="line"><span class="string">"line1\nline2\nline3\n"</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 现在</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">line1</span></span><br><span class="line"><span class="string">line2</span></span><br><span class="line"><span class="string">line3</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 如果最后不需要换行</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">line1</span></span><br><span class="line"><span class="string">line2</span></span><br><span class="line"><span class="string">line3"""</span></span><br></pre></td></tr></table></figure></div><blockquote><p>JDK14预览版增加了两个新的语法，JDK15转正</p></blockquote><ul><li><code>\</code>：取消换行</li><li><code>\s</code>：表示一个空格</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql2</span> <span class="operator">=</span> <span class="string">"""</span></span><br><span class="line"><span class="string">        SELECT id,NAME,email \</span></span><br><span class="line"><span class="string">        FROM customers\s\</span></span><br><span class="line"><span class="string">        WHERE id &gt; 4 \</span></span><br><span class="line"><span class="string">        ORDER BY email DESC</span></span><br><span class="line"><span class="string">        """</span>;</span><br></pre></td></tr></table></figure></div><h2 id="switch表达式"><a href="#switch表达式" class="headerlink" title="switch表达式"></a>switch表达式</h2><blockquote><p>JDK12预览版特性，JDK14转正</p></blockquote><ul><li>使用<code>case L -&gt;</code></li><li>省略了break语句</li><li>可以将多个case合并在一起</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Fruit</span> <span class="variable">fruit</span> <span class="operator">=</span> Fruit.GRAPE;</span><br><span class="line"><span class="keyword">switch</span>(fruit){</span><br><span class="line">    <span class="keyword">case</span> PEAR -&gt; System.out.println(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">case</span> APPLE,MANGO,GRAPE -&gt; System.out.println(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">case</span> ORANGE,PAPAYA -&gt; System.out.println(<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">default</span> -&gt; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">"No Such Fruit:"</span> + fruit);</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div><ul><li>更进一步，还可以处理返回值</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Fruit</span> <span class="variable">fruit</span> <span class="operator">=</span> Fruit.GRAPE;</span><br><span class="line"><span class="type">int</span> <span class="variable">numberOfLetters</span> <span class="operator">=</span> <span class="keyword">switch</span>(fruit){</span><br><span class="line">    <span class="keyword">case</span> PEAR -&gt; <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">case</span> APPLE,MANGO,GRAPE -&gt; <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">case</span> ORANGE,PAPAYA -&gt; <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">default</span> -&gt; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">"No Such Fruit:"</span> + fruit);</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div><ul><li>JDK13中引入了yield语句。switch语句应使用yield，而不是return。return会直接跳出当前方法，而yield只会跳出当前switch块。</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">x</span> <span class="operator">=</span> <span class="string">"3"</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">switch</span> (x) {</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"1"</span> -&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"2"</span> -&gt; <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">default</span> -&gt; {</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div><blockquote><p>JDK17预览特性：switch的模式匹配</p></blockquote><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自动完成模式匹配，大大简化代码</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">switch</span> (o) {</span><br><span class="line">    <span class="keyword">case</span> Integer i -&gt; String.format(<span class="string">"int %d"</span>, i);</span><br><span class="line">    <span class="keyword">case</span> Long l    -&gt; String.format(<span class="string">"long %d"</span>, l);</span><br><span class="line">    <span class="keyword">case</span> Double d  -&gt; String.format(<span class="string">"double %f"</span>, d);</span><br><span class="line">    <span class="keyword">case</span> String s  -&gt; String.format(<span class="string">"String %s"</span>, s);</span><br><span class="line">    <span class="keyword">default</span>        -&gt; o.toString();</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div><h2 id="instanceof的模式匹配"><a href="#instanceof的模式匹配" class="headerlink" title="instanceof的模式匹配"></a>instanceof的模式匹配</h2><blockquote><p>JDK14预览版特性，JDK16转正</p></blockquote><p>实现简洁的类型安全代码。使用该方法，可以减少Java中显示强制转换的数量。</p><ul><li>旧写法</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) {</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) obj; <span class="comment">//需要强转</span></span><br><span class="line">    str.contains(..);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><ul><li>现在的写法</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String str) {</span><br><span class="line">    str.contains(..);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><h2 id="Record"><a href="#Record" class="headerlink" title="Record"></a>Record</h2><blockquote><p>JDK14预览版推出，JDK16转正</p></blockquote><p>用<code>record</code> 声明一个类时，该类将自动拥有以下功能：</p><ul><li>获取成员变量的简单方法，比如例题中的 name() 和 partner() 。注意区别于我们平常getter()的写法。</li><li>一个 equals 方法的实现，执行比较时会比较该类的所有成员属性。</li><li>重写 hashCode() 方法。</li><li>一个可以打印该类所有成员属性的 toString() 方法。</li><li>包含所有参数的构造方法。</li></ul><p>此外：</p><ul><li><p>还可以定义静态字段、静态方法、构造器或实例方法。</p></li><li><p>不能定义实例字段；类不能声明为abstract；不能声明显式的父类等。</p></li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不可以将record定义的类声明为abstract</span></span><br><span class="line"><span class="comment">//不可以给record定义的类声明显式的父类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">Person</span><span class="params">(String name,Person partner)</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">//还可以声明静态的属性、静态的方法、构造器、实例方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String nation;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">showNation</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">return</span> nation;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span>{</span><br><span class="line">        <span class="built_in">this</span>(name,<span class="literal">null</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getNameInUpperCase</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">return</span> name.toUpperCase();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不可以声明非静态的属性</span></span><br><span class="line">    <span class="comment">// private int id;</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><h2 id="其它结构变化"><a href="#其它结构变化" class="headerlink" title="其它结构变化"></a>其它结构变化</h2><h3 id="下划线使用的限制"><a href="#下划线使用的限制" class="headerlink" title="下划线使用的限制"></a>下划线使用的限制</h3><blockquote><p>JDK9新特性</p></blockquote><p>现在不允许使用”_”作为变量名</p><h3 id="更简化的编译运行程序"><a href="#更简化的编译运行程序" class="headerlink" title="更简化的编译运行程序"></a>更简化的编译运行程序</h3><blockquote><p>JDK11新特性</p></blockquote><p>以前</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 编译</span><br><span class="line">javac JavaStack.java</span><br><span class="line"></span><br><span class="line">// 运行</span><br><span class="line">java JavaStack</span><br></pre></td></tr></table></figure></div><p>现在</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java JavaStack.java</span><br></pre></td></tr></table></figure></div><h2 id="GC方面新特性"><a href="#GC方面新特性" class="headerlink" title="GC方面新特性"></a>GC方面新特性</h2><ul><li>此部分待更新</li></ul><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a class="link" target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/458509231">https://zhuanlan.zhihu.com/p/458509231 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p><a class="link" target="_blank" rel="noopener" href="https://blog.csdn.net/best_luxi/article/details/122543074/">https://blog.csdn.net/best_luxi/article/details/122543074/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p><a class="link" target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1PY411e7J6">https://www.bilibili.com/video/BV1PY411e7J6 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></div><div class="post-copyright-info"><div class="article-copyright-info-container"><ul><li><strong>标题:</strong> JDK8到JDK17新特性</li><li><strong>作者:</strong> 布鸽不鸽</li><li><strong>创建于:</strong> 2023-04-22 22:18:51</li><li><strong>更新于:</strong> 2023-06-09 15:05:48</li><li><strong>链接:</strong> https://xuedongyun.cn//post/54344/</li><li><strong>版权声明:</strong> 本文章采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0</a> 进行许可。</li></ul></div></div><ul class="post-tags-box"><li class="tag-item"><a href="/tags/java%E5%9F%BA%E7%A1%80/">#java基础</a>&nbsp;</li></ul><div class="article-nav"><div class="article-prev"><a class="prev" rel="prev" href="/post/63124/"><span class="left arrow-icon flex-center"><i class="fa-solid fa-chevron-left"></i> </span><span class="title flex-center"><span class="post-nav-title-item">SpringBoot源码系列（1）：版本仲裁</span> <span class="post-nav-item">上一篇</span></span></a></div><div class="article-next"><a class="next" rel="next" href="/post/9962/"><span class="title flex-center"><span class="post-nav-title-item">hexo踩坑：hexo使用过程中遇到的问题</span> <span class="post-nav-item">下一篇</span> </span><span class="right arrow-icon flex-center"><i class="fa-solid fa-chevron-right"></i></span></a></div></div><div class="comment-container"><div class="comments-container pjax"><div id="comment-anchor"></div><div class="comment-area-title"><i class="fa-solid fa-comments"></i>&nbsp;评论</div><div id="waline"></div><script type="module" data-swup-reload-script>import { init } from 'https://evan.beee.top/js/waline.mjs';

        function loadWaline() {
            init({
                el: '#waline',
                serverURL: 'https://comment.xuedongyun.cn/',
                lang: 'zh-CN',
                dark: 'body[class~="dark-mode"]',
                requiredMeta: ['nick','mail'], // cannot customize by theme config, change it yourself
            });
        }

        if ('true') {
            const loadWalineTimeout = setTimeout(() => {
                loadWaline();
                clearTimeout(loadWalineTimeout);
            }, 1000);
        } else {
            window.addEventListener('DOMContentLoaded', loadWaline);
        }</script></div></div></div><div class="toc-content-container"><div class="post-toc-wrap"><div class="post-toc"><div class="toc-title">此页目录</div><div class="page-title">JDK8到JDK17新特性</div><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%A6%E8%B5%84%E6%BA%90%E7%9A%84try"><span class="nav-text">带资源的try</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">Lambda表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="nav-text">函数式接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E7%BD%AE%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="nav-text">内置的函数式接口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E4%B8%8E%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8"><span class="nav-text">方法引用与构造器引用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="nav-text">方法引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8"><span class="nav-text">构造器引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E6%9E%84%E9%80%A0%E5%BC%95%E7%94%A8"><span class="nav-text">数组构造引用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Stream-API"><span class="nav-text">Stream API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BAStream%E5%AE%9E%E4%BE%8B"><span class="nav-text">创建Stream实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C"><span class="nav-text">中间操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%88%E6%AD%A2%E6%93%8D%E4%BD%9C"><span class="nav-text">终止操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Optional%E7%B1%BB"><span class="nav-text">Optional类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E4%BB%A5%E5%88%9B%E5%BB%BA%E7%A9%BAStream"><span class="nav-text">可以创建空Stream</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#iterator%E7%BB%88%E6%AD%A2%E6%96%B9%E5%BC%8F"><span class="nav-text">iterator终止方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jshell%E5%91%BD%E4%BB%A4"><span class="nav-text">jshell命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%92%8CAPI%E5%8F%98%E6%9B%B4"><span class="nav-text">String存储结构和API变更</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%8F%98%E5%8C%96"><span class="nav-text">存储结构变化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#API%E5%8F%98%E5%8C%96"><span class="nav-text">API变化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B0%E5%A2%9E%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95"><span class="nav-text">新增字符串处理方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E4%BA%86Constable%E6%8E%A5%E5%8F%A3"><span class="nav-text">实现了Constable接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#transform%E6%96%B9%E6%B3%95"><span class="nav-text">transform方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD"><span class="nav-text">局部变量类型推断</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E6%9C%AC%E5%9D%97"><span class="nav-text">文本块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#switch%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">switch表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#instanceof%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="nav-text">instanceof的模式匹配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Record"><span class="nav-text">Record</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E5%AE%83%E7%BB%93%E6%9E%84%E5%8F%98%E5%8C%96"><span class="nav-text">其它结构变化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8B%E5%88%92%E7%BA%BF%E4%BD%BF%E7%94%A8%E7%9A%84%E9%99%90%E5%88%B6"><span class="nav-text">下划线使用的限制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E7%AE%80%E5%8C%96%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F"><span class="nav-text">更简化的编译运行程序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GC%E6%96%B9%E9%9D%A2%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-text">GC方面新特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3"><span class="nav-text">参考文档</span></a></li></ol></div></div></div></div></div></div><div class="main-content-footer"><footer class="footer"><div class="info-container"><div class="copyright-info">&copy; <span>2022</span> - 2023&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration:0.5s;color:#f54545"></i>&nbsp;&nbsp;<a href="/">布鸽不鸽</a></div><script data-swup-reload-script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="website-count info-item"><span id="busuanzi_container_site_uv" class="busuanzi_container_site_uv">访问人数&nbsp;<span id="busuanzi_value_site_uv" class="busuanzi_value_site_uv"></span> </span><span id="busuanzi_container_site_pv" class="busuanzi_container_site_pv">总访问量&nbsp;<span id="busuanzi_value_site_pv" class="busuanzi_value_site_pv"></span></span></div><div class="theme-info info-item"><span class="powered-by-container">由 <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" href="https://hexo.io">Hexo</a> 驱动</span><br><span class="theme-version-container">主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.3.0</a></span></div><div>博客已运行 <span class="odometer" id="runtime_days"></span> 天 <span class="odometer" id="runtime_hours"></span> 小时 <span class="odometer" id="runtime_minutes"></span> 分钟 <span class="odometer" id="runtime_seconds"></span> 秒</div><script data-swup-reload-script>try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}</script></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="article-tools-list"><li class="right-bottom-tools page-aside-toggle"><i class="fa-regular fa-outdent"></i></li><li class="go-comment"><i class="fa-regular fa-comments"></i></li></ul></div></div><div class="right-side-tools-container"><div class="side-tools-container"><ul class="hidden-tools-list"><li class="right-bottom-tools tool-font-adjust-plus flex-center"><i class="fa-regular fa-magnifying-glass-plus"></i></li><li class="right-bottom-tools tool-font-adjust-minus flex-center"><i class="fa-regular fa-magnifying-glass-minus"></i></li><li class="right-bottom-tools tool-expand-width flex-center"><i class="fa-regular fa-expand"></i></li><li class="right-bottom-tools tool-dark-light-toggle flex-center"><i class="fa-regular fa-moon"></i></li><li class="right-bottom-tools tool-scroll-to-bottom flex-center"><i class="fa-regular fa-arrow-down"></i></li></ul><ul class="visible-tools-list"><li class="right-bottom-tools toggle-tools-list flex-center"><i class="fa-regular fa-cog fa-spin"></i></li><li class="right-bottom-tools tool-scroll-to-top flex-center"><i class="arrow-up fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><div class="image-viewer-container"><img src=""></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fa-solid fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa-solid fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="https://npm.elemecdn.com/hexo-theme-redefine@2.3.0/source/js/libs/Swup.min.js"></script><script src="https://npm.elemecdn.com/hexo-theme-redefine@2.3.0/source/js/libs/SwupSlideTheme.min.js"></script><script src="https://npm.elemecdn.com/hexo-theme-redefine@2.3.0/source/js/libs/SwupScriptsPlugin.min.js"></script><script src="https://npm.elemecdn.com/hexo-theme-redefine@2.3.0/source/js/libs/SwupProgressPlugin.min.js"></script><script src="https://npm.elemecdn.com/hexo-theme-redefine@2.3.0/source/js/libs/SwupScrollPlugin.min.js"></script><script>const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
        ],
        containers: ["#swup"],
    });

    swup.on("pageView", () => {
        Global.refresh();
    });

    // if (document.readyState === "complete") {
    //
    // } else {
    //     document.addEventListener("DOMContentLoaded", () => init());
    // }</script><script src="https://npm.elemecdn.com/hexo-theme-redefine@2.3.0/source/js/utils.js"></script><script src="https://npm.elemecdn.com/hexo-theme-redefine@2.3.0/source/js/main.js"></script><script src="https://npm.elemecdn.com/hexo-theme-redefine@2.3.0/source/js/layouts/navbarShrink.js"></script><script src="https://npm.elemecdn.com/hexo-theme-redefine@2.3.0/source/js/tools/scrollTopBottom.js"></script><script src="https://npm.elemecdn.com/hexo-theme-redefine@2.3.0/source/js/tools/lightDarkSwitch.js"></script><script src="https://npm.elemecdn.com/hexo-theme-redefine@2.3.0/source/js/layouts/categoryList.js"></script><script src="https://npm.elemecdn.com/hexo-theme-redefine@2.3.0/source/js/tools/localSearch.js"></script><script src="https://npm.elemecdn.com/hexo-theme-redefine@2.3.0/source/js/tools/codeBlock.js"></script><script src="https://npm.elemecdn.com/hexo-theme-redefine@2.3.0/source/js/layouts/lazyload.js"></script><script src="https://npm.elemecdn.com/hexo-theme-redefine@2.3.0/source/js/tools/runtime.js"></script><script src="https://npm.elemecdn.com/hexo-theme-redefine@2.3.0/source/js/libs/odometer.min.js"></script><link rel="stylesheet" href="//npm.elemecdn.com/hexo-theme-redefine@2.3.0/source/assets/odometer-theme-minimal.css"><script src="https://npm.elemecdn.com/hexo-theme-redefine@2.3.0/source/js/libs/Typed.min.js"></script><script src="https://npm.elemecdn.com/hexo-theme-redefine@2.3.0/source/js/plugins/typed.js"></script><script src="https://npm.elemecdn.com/hexo-theme-redefine@2.3.0/source/js/libs/mermaid.min.js"></script><script src="https://npm.elemecdn.com/hexo-theme-redefine@2.3.0/source/js/plugins/mermaid.js"></script><div class="post-scripts" data-swup-reload-script><script src="https://npm.elemecdn.com/hexo-theme-redefine@2.3.0/source/js/tools/tocToggle.js"></script><script src="https://npm.elemecdn.com/hexo-theme-redefine@2.3.0/source/js/layouts/toc.js"></script><script src="https://npm.elemecdn.com/hexo-theme-redefine@2.3.0/source/js/libs/anime.min.js"></script><script src="https://npm.elemecdn.com/hexo-theme-redefine@2.3.0/source/js/plugins/tabs.js"></script></div><div id="aplayer"></div><script src="https://npm.elemecdn.com/hexo-theme-redefine@2.3.0/source/js/libs/APlayer.min.js"></script><script src="https://npm.elemecdn.com/hexo-theme-redefine@2.3.0/source/js/plugins/aplayer.js"></script></body></html>