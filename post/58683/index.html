<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="keywords" content="java,前端,python,AI"><meta name="author" content="布鸽不鸽"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="canonical" href="https://xuedongyun.cn/post/58683/"><meta name="robots" content="index,follow"><meta name="googlebot" content="index,follow"><meta name="revisit-after" content="1 days"><meta name="description" content="JVM和Java体系结构Java虚拟机Java虚拟机（JVM，Java Virtual Machine）：  一台执行Java字节码的虚拟计算机，拥有独立的运行机制 转载字节码到内部，解释&#x2F;编译为对应平台上的机器指令  特点：  一次编译到处运行  自动内存管理  自动垃圾回收   Java代码执流程flowchart LR     code(&quot;Java源码（.java）&quot;) --&gt; a(&quot;"><meta property="og:type" content="article"><meta property="og:title" content="JVM系列：尚硅谷JVM笔记总和"><meta property="og:url" content="https://xuedongyun.cn/post/58683/index.html"><meta property="og:site_name" content="冬云的博客"><meta property="og:description" content="JVM和Java体系结构Java虚拟机Java虚拟机（JVM，Java Virtual Machine）：  一台执行Java字节码的虚拟计算机，拥有独立的运行机制 转载字节码到内部，解释&#x2F;编译为对应平台上的机器指令  特点：  一次编译到处运行  自动内存管理  自动垃圾回收   Java代码执流程flowchart LR     code(&quot;Java源码（.java）&quot;) --&gt; a(&quot;"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://s2.loli.net/2023/09/05/JetB8N5IzqZirTV.png"><meta property="og:image" content="https://s2.loli.net/2023/09/05/Ajv3IeKnNmSpugs.png"><meta property="og:image" content="https://s2.loli.net/2023/09/05/AaOQBScjTl1MDXi.png"><meta property="og:image" content="https://s2.loli.net/2023/09/05/lOfkPuNt19VCJDw.png"><meta property="og:image" content="https://s2.loli.net/2023/09/05/MObmSnvhLFXudx9.png"><meta property="og:image" content="https://s2.loli.net/2023/09/05/kZlznTrOXqBfUKH.png"><meta property="og:image" content="https://s2.loli.net/2023/09/06/yZrXTF5VfRtUqxQ.jpg"><meta property="og:image" content="https://s2.loli.net/2023/09/06/KXkRve4tj83pVIc.png"><meta property="og:image" content="https://s2.loli.net/2023/09/07/bWFewzgZTImoN3f.png"><meta property="og:image" content="https://s2.loli.net/2023/09/07/RfOXPJUYgVILtCT.png"><meta property="og:image" content="https://s2.loli.net/2023/09/18/WkVuarNAOTFi46q.png"><meta property="og:image" content="https://s2.loli.net/2023/09/18/o5JPf8XtK76edkB.png"><meta property="og:image" content="https://s2.loli.net/2023/09/18/dvxuT5UpEjiOtaR.png"><meta property="og:image" content="https://s2.loli.net/2023/09/18/9UFHTDfXl1zbEC5.png"><meta property="og:image" content="https://s2.loli.net/2023/09/18/1NaniqC8JBv52DI.png"><meta property="og:image" content="https://s2.loli.net/2023/09/18/f3HB95QvzNMLxgo.png"><meta property="og:image" content="https://s2.loli.net/2023/09/18/IKbu7k8s4qladrz.png"><meta property="og:image" content="https://s2.loli.net/2023/09/19/ndUfaDpItv5hVs4.png"><meta property="og:image" content="https://s2.loli.net/2023/09/20/sv7q8N6G2zBOZDJ.png"><meta property="og:image" content="https://s2.loli.net/2023/09/21/6LRU7jJXrSFzto8.png"><meta property="og:image" content="https://s2.loli.net/2023/09/25/GqVrc8Ptl3NisBK.png"><meta property="og:image" content="https://s2.loli.net/2023/09/25/r2udgtFBoKfnVvk.png"><meta property="og:image" content="https://s2.loli.net/2023/09/25/3jVtd8pPv4awZWE.png"><meta property="og:image" content="https://s2.loli.net/2023/09/25/954lQPLjt13IVCR.png"><meta property="og:image" content="https://s2.loli.net/2023/09/27/32L5XodfzYKEB8c.png"><meta property="og:image" content="https://s2.loli.net/2023/10/08/mxIDtbTOr98f4Zv.png"><meta property="og:image" content="https://s2.loli.net/2023/10/08/7fa3OPGANyZhWEX.png"><meta property="og:image" content="https://s2.loli.net/2023/10/08/6prefdBtDQRchE3.png"><meta property="og:image" content="https://s2.loli.net/2023/10/08/Kd7hzyTcmxQpI3w.png"><meta property="og:image" content="https://s2.loli.net/2023/10/08/ux61nPp3ZWMyhBJ.png"><meta property="og:image" content="https://s2.loli.net/2023/10/11/glFuGkTKZNLrcRS.png"><meta property="og:image" content="https://s2.loli.net/2023/10/11/xuVFpGjWPfREY7J.png"><meta property="og:image" content="https://s2.loli.net/2023/10/11/gbFfota7AN4SXzV.png"><meta property="og:image" content="https://s2.loli.net/2023/10/11/paV3By1KgCwrAQM.png"><meta property="og:image" content="https://s2.loli.net/2023/10/11/7PQGbNJfLa6ymZl.png"><meta property="og:image" content="https://s2.loli.net/2023/10/11/Rgakb36Q4qv7wM1.png"><meta property="og:image" content="https://s2.loli.net/2023/10/11/WJnmV4Qwy1F95RO.png"><meta property="og:image" content="https://s2.loli.net/2023/10/11/kfeOlbZzN9XH14t.png"><meta property="og:image" content="https://s2.loli.net/2023/10/11/YEBtrz2csCWRANy.png"><meta property="og:image" content="https://s2.loli.net/2023/10/11/tmi7p13ArLMThuV.png"><meta property="og:image" content="https://s2.loli.net/2023/10/11/6CJ571c9pTbAvfW.png"><meta property="og:image" content="https://s2.loli.net/2023/10/11/R5yLh9WcfbTJiCZ.png"><meta property="og:image" content="https://s2.loli.net/2023/10/11/yR1Wpq6QZ5zVYEC.png"><meta property="og:image" content="https://s2.loli.net/2023/10/11/m8P9UdjxczCiqIH.png"><meta property="og:image" content="https://s2.loli.net/2023/10/11/OK8wAuV3GsRchdH.png"><meta property="og:image" content="https://s2.loli.net/2023/10/12/beZrDIaKn2i8hqw.png"><meta property="og:image" content="https://s2.loli.net/2023/10/15/ukJCfvYgxNbVZ7r.png"><meta property="og:image" content="https://s2.loli.net/2023/10/15/BF2P874QxCtG3Kd.png"><meta property="og:image" content="https://s2.loli.net/2023/10/16/iKB8jCFU4MmqGHp.png"><meta property="og:image" content="https://s2.loli.net/2023/10/16/9soSWhN2aedlUqc.png"><meta property="og:image" content="https://s2.loli.net/2023/10/16/e1PtFXqTQ56IELk.png"><meta property="og:image" content="https://s2.loli.net/2023/10/16/azHEeovJcZ7T8UC.png"><meta property="og:image" content="https://s2.loli.net/2023/10/16/O1b7X2tqdnL5Wsv.png"><meta property="og:image" content="https://s2.loli.net/2023/10/17/SALcbsheNpGInHT.png"><meta property="og:image" content="https://s2.loli.net/2023/10/17/1AtecroJOXBxs5R.png"><meta property="og:image" content="https://s2.loli.net/2023/10/17/UVxXyr5suYw8MAv.png"><meta property="og:image" content="https://s2.loli.net/2023/10/17/Tqy54szQFxh7eKi.png"><meta property="og:image" content="https://s2.loli.net/2023/10/18/tiG6rmZPBKqS7A3.png"><meta property="og:image" content="https://s2.loli.net/2023/10/18/YNU1cyWKZIuftka.png"><meta property="og:image" content="https://s2.loli.net/2023/10/18/IP3nVXCTx5H7ypK.png"><meta property="og:image" content="https://s2.loli.net/2023/10/19/lNCEYiTM1c6g8QK.png"><meta property="og:image" content="https://s2.loli.net/2023/10/19/4bcqXehA1gHUkYw.png"><meta property="og:image" content="https://s2.loli.net/2023/10/19/AWfclNdPkVaezmU.png"><meta property="og:image" content="https://s2.loli.net/2023/10/19/nDlQmN3LJGgsVzw.png"><meta property="og:image" content="https://s2.loli.net/2023/10/20/2DOYdHKfJ1EeFvT.png"><meta property="og:image" content="https://s2.loli.net/2023/10/20/rXp12GDmHdW8fsR.png"><meta property="og:image" content="https://s2.loli.net/2023/10/23/AtSfeUuDVc1yzBG.png"><meta property="og:image" content="https://s2.loli.net/2023/10/24/Uot7YIvLjPGEVZX.png"><meta property="og:image" content="https://s2.loli.net/2023/10/24/2nNLcQ615BagPAd.png"><meta property="og:image" content="https://s2.loli.net/2023/10/26/JyOk9jx1CX5lpP6.png"><meta property="og:image" content="https://s2.loli.net/2023/10/26/MKv3B2o6yQJdVqN.png"><meta property="og:image" content="https://s2.loli.net/2023/10/26/ke7POxUfMLDmNKG.png"><meta property="og:image" content="https://s2.loli.net/2023/10/26/AmL9tOXfsJC3pWR.png"><meta property="og:image" content="https://s2.loli.net/2023/10/26/Lomg4TA1pP2xeYz.png"><meta property="og:image" content="https://s2.loli.net/2023/10/26/vYELQsnKUFiAC1j.png"><meta property="og:image" content="https://s2.loli.net/2023/10/26/2tmyzqCWJI3Vvef.png"><meta property="og:image" content="https://s2.loli.net/2023/10/26/7vZj5X1zJ8mUyDk.png"><meta property="og:image" content="https://s2.loli.net/2023/10/26/QujZR6AtqzHFmLX.png"><meta property="og:image" content="https://s2.loli.net/2023/10/26/fAmPekZrRJycgzH.png"><meta property="og:image" content="https://s2.loli.net/2023/10/26/ik8XPCcheQvxlDN.png"><meta property="og:image" content="https://s2.loli.net/2023/10/27/jqSdclmYVkCJrn9.png"><meta property="og:image" content="https://s2.loli.net/2023/10/30/BerY3QaS7TXfiD4.png"><meta property="og:image" content="https://s2.loli.net/2023/10/30/d7lkpP46vU5uRM8.png"><meta property="og:image" content="https://s2.loli.net/2023/10/31/eOJAiW1FEuoDyBs.png"><meta property="og:image" content="https://s2.loli.net/2023/10/31/MlWrj1HiQIXCLUJ.png"><meta property="og:image" content="https://s2.loli.net/2023/11/01/vepsqJWNY3K8u2U.png"><meta property="og:image" content="https://s2.loli.net/2023/11/01/3gjYQCdN2tZs6L8.png"><meta property="og:image" content="https://s2.loli.net/2023/11/01/fpykVz61MOhWqtH.png"><meta property="og:image" content="https://s2.loli.net/2023/11/01/YjsaSKqbJ2Qihg3.png"><meta property="og:image" content="https://s2.loli.net/2023/11/01/ARS3vOQZTyJs6oU.png"><meta property="og:image" content="https://s2.loli.net/2023/11/02/ayJxUN4t19u8Qsz.png"><meta property="og:image" content="https://s2.loli.net/2023/11/02/wtjNTX2L1mb7pyU.png"><meta property="og:image" content="https://s2.loli.net/2023/11/03/vNDnkIRYG6zLmTp.png"><meta property="og:image" content="https://s2.loli.net/2023/11/03/O2I8TwJe5WRZnMb.png"><meta property="og:image" content="https://s2.loli.net/2023/11/07/YkLVPRH1WrCuqxG.png"><meta property="og:image" content="https://s2.loli.net/2023/11/07/Fypx8QE74DhNPXW.png"><meta property="og:image" content="https://s2.loli.net/2023/11/07/8rpNf4e2wSJInAU.png"><meta property="og:image" content="https://s2.loli.net/2023/11/14/t7nJif8ACqB3SKe.png"><meta property="og:image" content="https://s2.loli.net/2023/11/14/BMIa8icgs3fStZK.png"><meta property="og:image" content="https://s2.loli.net/2023/11/14/GSg2NiQ8WDMbfaF.png"><meta property="og:image" content="https://s2.loli.net/2023/11/14/nGRCh9rwX6ysNUu.png"><meta property="article:published_time" content="2024-01-10T06:57:32.297Z"><meta property="article:modified_time" content="2024-01-10T06:58:17.972Z"><meta property="article:author" content="布鸽不鸽"><meta property="article:tag" content="jvm"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://s2.loli.net/2023/09/05/JetB8N5IzqZirTV.png"><link rel="icon" type="image/png" href="/image/favicon.ico" sizes="192x192"><link rel="apple-touch-icon" sizes="180x180" href="/image/favicon.ico"><meta name="theme-color" content="#A31F34"><link rel="shortcut icon" href="/image/favicon.ico"><title>JVM系列：尚硅谷JVM笔记总和 - 冬云的博客</title><link rel="stylesheet" href="//evan.beee.top/projects/hexo-theme-redefine@2.6.0/source/fonts/Chillax/chillax.css"><style>:root{--preloader-background-color:#fff;--preloader-text-color:#000}@media (prefers-color-scheme:dark){:root{--preloader-background-color:#202124;--preloader-text-color:#fff}}@media (prefers-color-scheme:light){:root{--preloader-background-color:#fff;--preloader-text-color:#000}}@media (max-width:600px){.ml13{font-size:2.6rem!important}}.preloader{display:flex;flex-direction:column;gap:1rem;align-items:center;justify-content:center;position:fixed;padding:12px;top:0;right:0;bottom:0;left:0;width:100vw;height:100vh;background-color:var(--preloader-background-color);z-index:1100;transition:opacity .2s ease-in-out}.ml13{font-size:3.2rem;color:var(--preloader-text-color);letter-spacing:-1px;font-weight:500;font-family:Chillax-Variable,sans-serif;text-align:center}.ml13 .word{display:inline-flex;flex-wrap:wrap;white-space:nowrap}.ml13 .letter{display:inline-block;line-height:1em}</style><div class="preloader"><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.0/source/js/libs/anime.min.js"></script><h1 class="ml13">冬云的博客</h1><script>var textWrapper = document.querySelector('.ml13');
        // Split text into words
        var words = textWrapper.textContent.trim().split(' ');

        // Clear the existing content
        textWrapper.innerHTML = '';

        // Wrap each word and its letters in spans
        words.forEach(function(word) {
            var wordSpan = document.createElement('span');
            wordSpan.classList.add('word');
            wordSpan.innerHTML = word.replace(/\S/g, "<span class='letter'>$&</span>");
            textWrapper.appendChild(wordSpan);
            textWrapper.appendChild(document.createTextNode(' ')); // Add space between words
        });


        anime.timeline({loop: true})
            .add({
                targets: '.ml13 .letter',
                translateY: [100,0],
                translateZ: 0,
                opacity: [0,1],
                easing: "easeOutExpo",
                duration: 1400,
                delay: (el, i) => 300 + 30 * i
            }).add({
            targets: '.ml13 .letter',
            translateY: [0,-100],
            opacity: [1,0],
            easing: "easeInExpo",
            duration: 1200,
            delay: (el, i) => 100 + 30 * i
        });

        let themeStatus = JSON.parse(localStorage.getItem('REDEFINE-THEME-STATUS'))?.isDark;

        // If the theme status is not found in local storage, check the preferred color scheme
        if (themeStatus === undefined || themeStatus === null) {
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                themeStatus = 'dark';
            } else {
                themeStatus = 'light';
            }
        }

        // Now you can use the themeStatus variable in your code
        if (themeStatus) {
            document.documentElement.style.setProperty('--preloader-background-color', '#202124');
            document.documentElement.style.setProperty('--preloader-text-color', '#fff');
        } else {
            document.documentElement.style.setProperty('--preloader-background-color', '#fff');
            document.documentElement.style.setProperty('--preloader-text-color', '#000');
        }

        window.addEventListener('load', function () {
            hidePreloaderAfterTimeout(1000); // Hide after 1000 milliseconds once the window has loaded
        });

        // Backup failsafe: Hide preloader after a maximum of 5000 milliseconds, regardless of the window load event
        hidePreloaderAfterTimeout(5000);

        function hidePreloaderAfterTimeout(delay) {
            setTimeout(function () {
                var preloader = document.querySelector('.preloader');
                preloader.style.opacity = '0';
                setTimeout(function () {
                    preloader.style.display = 'none';
                }, 200);
            }, delay);
        }</script></div><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="//evan.beee.top/projects/hexo-theme-redefine@2.6.0/source/assets/build/styles.css"><link rel="stylesheet" href="//evan.beee.top/projects/hexo-theme-redefine@2.6.0/source/fonts/fonts.css"><link rel="stylesheet" href="//evan.beee.top/projects/hexo-theme-redefine@2.6.0/source/fonts/Satoshi/satoshi.css"><script id="hexo-configurations">window.config={hostname:"xuedongyun.cn",root:"/",language:"zh-CN",path:"search.xml"},window.theme={articles:{style:{font_size:"16px",line_height:1.5,image_border_radius:"14px",image_alignment:"center",image_caption:!1,link_icon:!0,title_alignment:"left"},word_count:{enable:!0,count:!0,min2read:!0},author_label:{enable:!0,auto:!1,list:[]},code_block:{copy:!0,style:"mac",font:{enable:!1,family:null,url:null}},toc:{enable:!0,max_depth:3,number:!1,expand:!0,init_open:!0},copyright:{enable:!0,default:"cc_by_nc_sa"},lazyload:!0,recommendation:{enable:!1,title:"推荐阅读",limit:3,mobile_limit:2,placeholder:"/images/wallhaven-wqery6-light.webp",skip_dirs:[]}},colors:{primary:"#A31F34",secondary:null},global:{fonts:{chinese:{enable:!1,family:null,url:null},english:{enable:!1,family:null,url:null}},content_max_width:"1000px",sidebar_width:"210px",hover:{shadow:!0,scale:!0},scroll_progress:{bar:!1,percentage:!0},website_counter:{url:"https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",enable:!0,site_pv:!0,site_uv:!0,post_pv:!0},single_page:!0,preloader:!0,open_graph:!0,google_analytics:{enable:!1,id:null}},home_banner:{enable:!0,style:"fixed",image:{light:"https://s2.loli.net/2023/04/26/5keLlFDntNaz81Z.webp",dark:"https://s2.loli.net/2023/04/26/5keLlFDntNaz81Z.webp"},title:"程序员的个人修养",subtitle:{text:["Hello World!","Across the Great Wall we can reach every corner in the world"],hitokoto:{enable:!1,api:"https://v1.hitokoto.cn"},typing_speed:50,backing_speed:80,starting_delay:500,backing_delay:1500,loop:!0,smart_backspace:!0},text_color:{light:"#fff",dark:"#d1d1b6"},text_style:{title_size:"2.8rem",subtitle_size:"1.5rem",line_height:1.2},custom_font:{enable:!1,family:null,url:null},social_links:{enable:!1,links:{github:null,instagram:null,zhihu:null,twitter:null,email:null},qrs:{weixin:null}}},plugins:{feed:{enable:!1},aplayer:{enable:!0,type:"fixed",audios:[{name:"One Last Kiss",artist:"宇多田ヒカル",url:"/music/OneLastKiss.mp3",cover:"/image/OneLastKiss.webp"},{name:"水星记",artist:"郭顶",cover:"/image/水星记.webp",url:"/music/水星记.mp3"},{name:"平凡之路",artist:"朴树",cover:"/image/平凡之路.webp",url:"/music/平凡之路.mp3"}]},mermaid:{enable:!0,version:"9.3.0"}},version:"2.6.0",navbar:{auto_hide:!1,color:{left:"#f78736",right:"#367df7",transparency:50},links:{Home:{path:"/",icon:"fa-regular fa-house"},java:{path:"/categories/java/",icon:"fa-regular fa-server"},MySQL:{path:"/categories/mysql/",icon:"fa-regular fa-hard-drive"},Redis:{path:"/categories/redis/",icon:"fa-regular fa-memory"},MQ:{path:"/categories/MQ/",icon:"fa-regular fa-pipe-circle-check"},"算法题":{path:"/categories/算法题/",icon:"fa-regular fa-laptop-code"},"工具和应用":{path:"/categories/工具和应用/",icon:"fa-regular fa-toolbox"}},search:{enable:!0,preload:!0}},page_templates:{friends_column:2,tags_style:"blur"},home:{sidebar:{enable:!0,position:"left",first_item:"menu",announcement:"Fly Me To The Moon",links:{"博客搭建系列":{path:"/tags/博客搭建系列"},"SpringBoot源码系列":{path:"/tags/SpringBoot源码系列"},"Java设计模式系列":{path:"/tags/java设计模式系列"},"Redis实战系列":{path:"/tags/Redis实战系列"}}},article_date_format:"auto",categories:{enable:!0,limit:3},tags:{enable:!0,limit:3}},footerStart:"2022/4/19 20:56:00"},window.lang_ago={second:"%s 秒前",minute:"%s 分钟前",hour:"%s 小时前",day:"%s 天前",week:"%s 周前",month:"%s 个月前",year:"%s 年前"},window.data={masonry:!1}</script><link rel="stylesheet" href="//evan.beee.top/projects/hexo-theme-redefine@2.6.0/source/fontawesome/fontawesome.min.css"><link rel="stylesheet" href="//evan.beee.top/projects/hexo-theme-redefine@2.6.0/source/fontawesome/brands.min.css"><link rel="stylesheet" href="//evan.beee.top/projects/hexo-theme-redefine@2.6.0/source/fontawesome/solid.min.css"><link rel="stylesheet" href="//evan.beee.top/projects/hexo-theme-redefine@2.6.0/source/fontawesome/regular.min.css"><meta name="generator" content="Hexo 6.3.0"><style>mjx-container[jax=SVG]{direction:ltr}mjx-container[jax=SVG]>svg{overflow:visible}mjx-container[jax=SVG][display=true]{display:block;text-align:center;margin:1em 0}mjx-container[jax=SVG][justify=left]{text-align:left}mjx-container[jax=SVG][justify=right]{text-align:right}g[data-mml-node=merror]>g{fill:red;stroke:red}g[data-mml-node=merror]>rect[data-background]{fill:#ff0;stroke:none}g[data-mml-node=mtable]>line[data-line]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>rect[data-frame]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>.mjx-dashed{stroke-dasharray:140}g[data-mml-node=mtable]>.mjx-dotted{stroke-linecap:round;stroke-dasharray:0,140}g[data-mml-node=mtable]>svg{overflow:visible}[jax=SVG] mjx-tool{display:inline-block;position:relative;width:0;height:0}[jax=SVG] mjx-tool>mjx-tip{position:absolute;top:0;left:0}mjx-tool>mjx-tip{display:inline-block;padding:.2em;border:1px solid #888;font-size:70%;background-color:#f8f8f8;color:#000;box-shadow:2px 2px 5px #aaa}g[data-mml-node=maction][data-toggle]{cursor:pointer}mjx-status{display:block;position:fixed;left:1em;bottom:1em;min-width:25%;padding:.2em .4em;border:1px solid #888;font-size:90%;background-color:#f8f8f8;color:#000}foreignObject[data-mjx-xml]{font-family:initial;line-height:normal;overflow:visible}.MathJax path{stroke-width:3}mjx-container[display=true]{overflow:auto hidden}mjx-container[display=true]+br{display:none}</style></head><body><div class="progress-bar-container"><span class="pjax-progress-bar"></span></div><main class="page-container" id="swup"><div class="main-content-container"><div class="main-content-header"><header class="navbar-container"><div class="navbar-content"><div class="left"><a class="logo-title" href="/">冬云的博客</a></div><div class="right"><div class="desktop"><ul class="navbar-list"><li class="navbar-item"><a href="/"><i class="fa-regular fa-house fa-fw"></i> 首页</a></li><li class="navbar-item"><a href="/categories/java/"><i class="fa-regular fa-server fa-fw"></i> JAVA</a></li><li class="navbar-item"><a href="/categories/mysql/"><i class="fa-regular fa-hard-drive fa-fw"></i> MYSQL</a></li><li class="navbar-item"><a href="/categories/redis/"><i class="fa-regular fa-memory fa-fw"></i> REDIS</a></li><li class="navbar-item"><a href="/categories/MQ/"><i class="fa-regular fa-pipe-circle-check fa-fw"></i> MQ</a></li><li class="navbar-item"><a href="/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"><i class="fa-regular fa-laptop-code fa-fw"></i> 算法题</a></li><li class="navbar-item"><a href="/categories/%E5%B7%A5%E5%85%B7%E5%92%8C%E5%BA%94%E7%94%A8/"><i class="fa-regular fa-toolbox fa-fw"></i> 工具和应用</a></li><li class="navbar-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></div><div class="icon-item navbar-bar"><div class="navbar-bar-middle"></div></div></div></div></div><div class="navbar-drawer h-screen w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between"><ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start"><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/"><span>首页 </span><i class="fa-regular fa-house fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/categories/java/"><span>JAVA </span><i class="fa-regular fa-server fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/categories/mysql/"><span>MYSQL </span><i class="fa-regular fa-hard-drive fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/categories/redis/"><span>REDIS </span><i class="fa-regular fa-memory fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/categories/MQ/"><span>MQ </span><i class="fa-regular fa-pipe-circle-check fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"><span>算法题 </span><i class="fa-regular fa-laptop-code fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/categories/%E5%B7%A5%E5%85%B7%E5%92%8C%E5%BA%94%E7%94%A8/"><span>工具和应用 </span><i class="fa-regular fa-toolbox fa-sm fa-fw"></i></a></li></ul><div class="statistics flex justify-around my-2.5"><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">11</div><div class="label text-third-text-color text-sm">标签</div></a><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">17</div><div class="label text-third-text-color text-sm">分类</div></a><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">49</div><div class="label text-third-text-color text-sm">文章</div></a></div></div><div class="window-mask"></div></header></div><div class="main-content-body"><div class="main-content"><div class="post-page-container flex relative justify-between box-border w-full h-full"><div class="article-content-container"><div class="article-title relative w-full"><div class="w-full flex items-center pt-6 justify-start"><h1 class="article-title-regular text-second-text-color text-4xl md:text-6xl font-bold px-2 sm:px-6 md:px-8 py-3">JVM系列：尚硅谷JVM笔记总和</h1></div></div><div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8"><div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]"><img src="https://s2.loli.net/2023/04/20/q9CpkwWALQae6Mj.jpg"></div><div class="info flex flex-col justify-between"><div class="author flex items-center"><span class="name text-default-text-color text-lg font-semibold">布鸽不鸽</span> <span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">Lv4</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fa-regular fa-pen-fancy"></i>&nbsp; <span class="desktop">2024-01-10 14:57:32</span> <span class="mobile">2024-01-10 14:57:32</span> <span class="hover-info">创建</span> </span><span class="article-date article-meta-item"><i class="fa-regular fa-wrench"></i>&nbsp; <span class="desktop">2024-01-10 14:58:17</span> <span class="mobile">2024-01-10 14:58:17</span> <span class="hover-info">更新</span> </span><span class="article-categories article-meta-item"><i class="fa-regular fa-folders"></i>&nbsp;<ul><li><a href="/categories/java/">java</a>&nbsp;</li></ul></span><span class="article-tags article-meta-item"><i class="fa-regular fa-tags"></i>&nbsp;<ul><li><a href="/tags/jvm/">jvm</a>&nbsp;</li></ul></span><span class="article-wordcount article-meta-item"><i class="fa-regular fa-typewriter"></i>&nbsp;<span>37.8k 字</span> </span><span class="article-min2read article-meta-item"><i class="fa-regular fa-clock"></i>&nbsp;<span>147 分钟</span> </span><span class="article-pv article-meta-item"><i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8"><h2 id="JVM和Java体系结构"><a href="#JVM和Java体系结构" class="headerlink" title="JVM和Java体系结构"></a>JVM和Java体系结构</h2><h3 id="Java虚拟机"><a href="#Java虚拟机" class="headerlink" title="Java虚拟机"></a>Java虚拟机</h3><p>Java虚拟机（JVM，Java Virtual Machine）：</p><ul><li>一台执行Java字节码的虚拟计算机，拥有独立的运行机制</li><li>转载字节码到内部，解释/编译为对应平台上的机器指令</li></ul><p>特点：</p><ol><li><p>一次编译到处运行</p></li><li><p>自动内存管理</p></li><li><p>自动垃圾回收</p></li></ol><h3 id="Java代码执流程"><a href="#Java代码执流程" class="headerlink" title="Java代码执流程"></a>Java代码执流程</h3><pre class="mermaid">flowchart LR
    code("Java源码（.java）") --&gt; a("Java（前端）编译器")
    a --&gt; cls("字节码（.class）")
    subgraph Java虚拟机
        direction TB
        类加载器 --&gt; 字节码校验器
        subgraph 执行引擎
            direction TB
            jsq("解释执行（解释器）")
            jit("编译执行（JIT）")
        end
        字节码校验器 --&gt; 执行引擎
    end
    cls --&gt; Java虚拟机
    Java虚拟机 --&gt; 操作系统</pre><h3 id="JVM位置"><a href="#JVM位置" class="headerlink" title="JVM位置"></a>JVM位置</h3><p>JVM运行在操作系统之上，与硬件没有直接的交互</p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/09/05/JetB8N5IzqZirTV.png" alt="68747470733a2f2f6e706d2e656c656d6563646e2e636f6d2f796f7574686c716c40312e302e382f4a564d2f636861707465725f3030312f303031332e706e67" style="zoom:67%"><h3 id="JVM整体结构"><a href="#JVM整体结构" class="headerlink" title="JVM整体结构"></a>JVM整体结构</h3><p>HotSpot VM是目前高性能虚拟机代表之一，采用解释器与即使编译器并存的架构</p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/09/05/Ajv3IeKnNmSpugs.png" alt="68747470733a2f2f6e706d2e656c656d6563646e2e636f6d2f796f7574686c716c40312e302e382f4a564d2f636861707465725f3030312f303031352e706e67" style="zoom:67%"><p><strong>Class loader</strong>：将字节码文件，加载到内存中，生成Class对象</p><p><strong>Runtime Data Area</strong>：JVM内存，上一步加载的Class的实例就是存放在方法区中</p><p>​	<strong>堆</strong>，<strong>方法区</strong>：多线程共享</p><p>​	<strong>虚拟机栈</strong>，<strong>本地方法栈</strong>，<strong>程序计数器栈</strong>：每个线程一份</p><p><strong>执行引擎</strong>：解释器，即时编译器（JIT编译器），垃圾回收器</p><h3 id="JVM架构模型"><a href="#JVM架构模型" class="headerlink" title="JVM架构模型"></a>JVM架构模型</h3><p>JVM指令集架构为：<strong>基于栈的指令集架构</strong></p><h4 id="基于栈的指令集架构"><a href="#基于栈的指令集架构" class="headerlink" title="基于栈的指令集架构"></a>基于栈的指令集架构</h4><ol><li>设计和实现简单</li><li>避开寄存器分配难题</li><li>零地址指令，指令集更小</li><li>不需要硬件支持</li></ol><h4 id="基于寄存器的指令集架构"><a href="#基于寄存器的指令集架构" class="headerlink" title="基于寄存器的指令集架构"></a>基于寄存器的指令集架构</h4><ol><li>典型：X86的二进制指令集</li><li>指令集架构完全依赖于硬件</li><li>性能优秀，执行高效</li><li>花费更少指令，去完成一项操作</li><li>以一地址指令、二地址指令和三地址指令为主</li></ol><h4 id="两种架构举例"><a href="#两种架构举例" class="headerlink" title="两种架构举例"></a>两种架构举例</h4><ul><li>基于栈的计算流程（以Java虚拟机为例）：</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">iconst_2	// 常量2入栈</span><br><span class="line">istore_1</span><br><span class="line">iconst_3	// 常量3入栈</span><br><span class="line">istore_2</span><br><span class="line">iload_1</span><br><span class="line">iload_2</span><br><span class="line">iadd		// 常量2，3出栈，执行相加</span><br><span class="line">istore_0	// 结果5入栈</span><br></pre></td></tr></table></figure></div><ul><li>基于寄存器的计算流程</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov eax,2	// 将eax寄存器的值设为1</span><br><span class="line">add eax,3	// 使eax寄存器的值加3</span><br></pre></td></tr></table></figure></div><blockquote><p>考虑跨平台性与移植性，Java指令集都是根据栈来设计的</p><ul><li><p>优点：跨平台，指令集小，编译器容易实现</p></li><li><p>缺点：性能比寄存器差一些</p></li></ul></blockquote><h3 id="JVM生命周期"><a href="#JVM生命周期" class="headerlink" title="JVM生命周期"></a>JVM生命周期</h3><h4 id="JVM的启动"><a href="#JVM的启动" class="headerlink" title="JVM的启动"></a>JVM的启动</h4><p>通过<strong>引导类加载器</strong>（bootstrap class loader）创建一个<strong>初始类</strong>（initial class）来完成的。这个初始类由虚拟机的具体实现来指定。</p><h4 id="JVM的执行"><a href="#JVM的执行" class="headerlink" title="JVM的执行"></a>JVM的执行</h4><ul><li>JVM有一个清晰的任务：执行Java程序</li><li>程序开始他才运行，程序结束他就停止</li></ul><h4 id="JVM的退出"><a href="#JVM的退出" class="headerlink" title="JVM的退出"></a>JVM的退出</h4><ol><li>程序正常退出</li><li>程序遇到异常或错误而停止</li><li>操作系统出现错误导致JVM停止</li><li>某线程调用了Runtime类或System类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit()或halt()操作</li></ol><h3 id="JVM发展历程"><a href="#JVM发展历程" class="headerlink" title="JVM发展历程"></a>JVM发展历程</h3><p><strong>Sun Classic VM</strong></p><ul><li>1996年Java1.0时出现，世界第一款商用Java虚拟机，JDK1.4时被淘汰</li><li>只提供解释器</li><li>要使用JIT编译器，需要进行外挂，且会完全接管解释器。<ul><li>解释器和JIT编译器无法共存</li><li>只使用JIT，需要把所有字节码都翻译成机器指令，翻译时间过长。程序启动的时候，等待时间长。</li></ul></li><li>目前Hotspot内置此虚拟机</li></ul><p><strong>Exact VM</strong></p><ul><li>JDK1.2时，Sun提供了此虚拟机</li><li>虚拟机可以知道内存中某个位置的数据具体是什么类型</li><li>具备现代高性能虚拟机的维形<ul><li>热点探测（寻找出热点代码进行缓存）</li><li>编译器与解释器混合工作模式</li></ul></li><li>只在Solaris平台短暂使用，终被Hotspot虚拟机替换</li></ul><p><strong>HotSpot VM（重点）</strong></p><ul><li><p>JDK1.3时，成为oracle JDK和openJDK的默认虚拟机</p></li><li><p>HotSpot：热点代码探测技术</p><ul><li>通过计数器，找到最具编译价值代码，触发即时编译或栈上替换</li><li>编译器与解释器协同工作</li></ul></li></ul><p><strong>JRockit（商用三大虚拟机之一）</strong></p><ul><li>即时编译器编译后执行</li><li>世界上最快的JVM</li></ul><p><strong>IBM的J9（商用三大虚拟机之一）</strong></p><ul><li>号称是世界上最快的Java虚拟机</li></ul><p><strong>KVM和CDC/CLDC Hotspot</strong></p><ul><li>面向更低端的设备，比如塞班</li></ul><p><strong>Azul VM</strong></p><ul><li>与特定硬件平台绑定</li></ul><p><strong>Liquid VM</strong></p><ul><li>运行在自家Hypervisor系统上</li><li>不需要操作系统的支持，或者说它自己本身实现了一个专用操作系统的必要功能，如线程调度、文件系统、网络支持等</li><li>随着JRockit虚拟机终止开发，Liquid vM项目也停止了</li></ul><p><strong>Apache Marmony</strong></p><ul><li>并没有Apache Harmony被大规模商用的案例，但是它的Java类库代码吸纳进了Android SDK</li></ul><p><strong>Micorsoft JVM</strong></p><ul><li>微软为了在IE3浏览器中支持Java Applets，开发了Microsoft JVM</li></ul><p><strong>Taobao JVM</strong></p><ul><li>目前已经在淘宝、天猫上线，把Oracle官方JVM版本全部替换了</li></ul><p><strong>Dalvik VM</strong></p><ul><li><p>执行的是编译以后的dex（Dalvik Executable）文件。执行效率比较高</p></li><li><p>Android 5.0使用支持提前编译（Ahead of Time Compilation，AoT）的ART VM替换Dalvik VM</p></li></ul><p><strong>Graal VM（未来虚拟机）</strong></p><ul><li>Run Programs Faster Anywhere</li><li>跨语言全栈虚拟机：Java，Scala，Groovy，Kotlin，C，C++，JavaScript，Ruby，Python，R</li><li><strong>如果说HotSpot有一天真的被取代，Graalvm希望最大</strong></li></ul><h3 id="课程学习路线"><a href="#课程学习路线" class="headerlink" title="课程学习路线"></a>课程学习路线</h3><pre class="mermaid">graph TB
    类的加载器 ---&gt; 内存结构
    a["class文件结构"] ---&gt; 内存结构
    执行引擎 ---&gt; 内存结构
    内存结构 ---&gt; 内存的分配与回收
    内存的分配与回收 ---&gt; b["性能监控(命令行、可视化工具)"]
    b ---&gt; 性能优化</pre><h2 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h2><p>如果想手写一个Java虚拟机的话，需要考虑哪些结构？</p><ul><li>类加载器（ClassLoader）</li><li>执行引擎</li></ul><h3 id="ClassLoader作用"><a href="#ClassLoader作用" class="headerlink" title="ClassLoader作用"></a>ClassLoader作用</h3><ol><li>从文件系统或网络中加载class文件</li><li>Class Loader只负责加载，能否运行由执行引擎决定</li><li><strong>加载的类信息放在一块称为“方法区”的内存空间</strong>，除此之外，方法区还会存放运行时常量池信息（比如字符串字面量，数字常量）</li></ol><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/09/05/AaOQBScjTl1MDXi.png" alt="68747470733a2f2f6e706d2e656c656d6563646e2e636f6d2f796f7574686c716c40312e302e382f4a564d2f636861707465725f3030322f303030342e706e67" style="zoom:67%"><blockquote><p>（补充）加载class文件的方式：</p><ol><li>从本地系统中直接加载</li><li>通过网络获取，典型场景：Web Applet</li><li>从zip压缩包中读取，成为日后jar、war格式的基础</li><li>运行时计算生成，使用最多的是：动态代理技术</li><li>由其他文件生成，典型场景：JSP应用从专有数据库中提取.class文件，比较少见</li><li>从加密文件中获取，典型的防Class文件被反编译的保护措施</li></ol></blockquote><h3 id="ClassLoader角色"><a href="#ClassLoader角色" class="headerlink" title="ClassLoader角色"></a>ClassLoader角色</h3><ol><li>class file存在硬盘上（纸上的模板），最终需要实例化到JVM中（做好的成品）</li><li>class file加载到JVM中，被称为DNA元数据模板，放在方法区中</li><li>class file -&gt; DNA元数据模板，需要一个运输工具，也即ClassLoader</li></ol><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/09/05/lOfkPuNt19VCJDw.png" alt="img" style="zoom:67%"><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><h4 id="阶段一：Loading"><a href="#阶段一：Loading" class="headerlink" title="阶段一：Loading"></a>阶段一：Loading</h4><ol><li>通过类全限定名，获取此类的二进制字节流</li><li>将字节流所代表的静态存储结构，转化为方法区的运行时数据结构</li><li><strong>在内存中生成一个代表此类的java.lang.Class对象</strong></li></ol><h4 id="阶段二：Linking"><a href="#阶段二：Linking" class="headerlink" title="阶段二：Linking"></a>阶段二：Linking</h4><h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p>确保Class文件的字节流符合要求。主要包含四种验证：文件格式，元数据，字节码，符号引用</p><p>举例：字节码文件开头都是CA FE BA BE</p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/09/05/MObmSnvhLFXudx9.png" alt="68747470733a2f2f6e706d2e656c656d6563646e2e636f6d2f796f7574686c716c40312e302e382f4a564d2f636861707465725f3030322f303030382e706e67" style="zoom:33%"><h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><ol><li><p>为类变量（static）分配内存，并设置初始值（零值）</p></li><li><p>fianl static编译时就分配好了默认值，此时会显式初始化</p></li><li><p>类变量分配在<strong>方法区中</strong></p></li></ol><p>举例：变量a在准备阶段会赋初始值0。初始化时才会赋值为1</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></div><h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><ol><li>将常量池内的符号引用转换为直接引用的过程<ul><li>符号引用就是一组符号来描述所引用的目标</li><li>直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄</li></ul></li></ol><p>举例：<code>javap -v Hello.java</code>反编译后，可以查看符号引用，下面带#的就是符号引用</p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/09/05/kZlznTrOXqBfUKH.png" alt="68747470733a2f2f6e706d2e656c656d6563646e2e636f6d2f796f7574686c716c40312e302e382f4a564d2f636861707465725f3030322f303032332e706e67" style="zoom:67%"><h4 id="阶段三：Initialization"><a href="#阶段三：Initialization" class="headerlink" title="阶段三：Initialization"></a>阶段三：Initialization</h4><ol><li>就是执行**类构造器方法<code>&lt;clinit&gt;</code>**的过程<ul><li>此方法不需要定义，是javac编译器自动收集类中所有<strong>类变量的赋值动作</strong>和<strong>静态代码块中的语句</strong>合并而来的</li><li>执行顺序按照语句在<strong>源码中的顺序</strong>执行</li><li>如果没有类变量或者static块，就不会有<code>&lt;clinit&gt;</code>方法了</li><li>如果该类有父类，会保证父类的<code>&lt;clinit&gt;</code>先执行</li><li>虚拟机保证<code>&lt;clinit&gt;</code>方法在多线程下被同步加锁</li></ul></li></ol><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        a = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// initialization时执行，第一次赋值</span></span><br><span class="line">        num = <span class="number">100</span>;</span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// linking时创建num变量，并赋零值</span></span><br><span class="line">    <span class="comment">// initialization时执行，第二次赋值，最终num为1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><h3 id="ClassLoader分类"><a href="#ClassLoader分类" class="headerlink" title="ClassLoader分类"></a>ClassLoader分类</h3><h4 id="引导类加载器（Bootstrap-ClassLoader）"><a href="#引导类加载器（Bootstrap-ClassLoader）" class="headerlink" title="引导类加载器（Bootstrap ClassLoader）"></a>引导类加载器（Bootstrap ClassLoader）</h4><ul><li>C/C++实现，在JVM内部</li><li>用来加载Java核心库（<code>JAVA_HOME/jre/lib/rt.jar、resources.jar</code>、或<code>sun.boot.class.path</code>路径下的内容）</li><li>用来加载扩展类加载器，系统类加载器，并指定为他们的父加载器</li><li>只加载包名为java、javax、sun等开头的类</li><li>没有父加载器</li></ul><h4 id="扩展类加载器（Extension-Class-Loader）"><a href="#扩展类加载器（Extension-Class-Loader）" class="headerlink" title="扩展类加载器（Extension Class Loader）"></a>扩展类加载器（Extension Class Loader）</h4><ul><li>Java语言编写，派生自ClassLoader类，父类加载器为引导类加载器</li><li>从系统属性<code>java.ext.dirs</code>指定的目录加载类库，或从JDK安装目录<code>jre/lib/ext</code>目录下加载类库<ul><li>如果用户创建JAR包放入其中，也会自动加载</li></ul></li></ul><h4 id="系统类加载器（System-Class-Loader）"><a href="#系统类加载器（System-Class-Loader）" class="headerlink" title="系统类加载器（System Class Loader）"></a>系统类加载器（System Class Loader）</h4><ul><li>Java语言编写，派生自ClassLoader类，父类加载器为扩展类加载器</li><li>加载环境变量classpath或系统属性java.class.path指定路径下的类库</li><li>是程序中的<strong>默认类加载器</strong>，可以<code>ClassLoader.getSystemClassLoader()</code>来获取</li></ul><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/09/06/yZrXTF5VfRtUqxQ.jpg" alt="屏幕截图 2023-09-06 154029" style="zoom:50%"><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取系统类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">systemClassLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取其上层，扩展类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">extClassLoader</span> <span class="operator">=</span> systemClassLoader.getParent();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取其上层，引导类加载器（为null，无法获取）</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">bootstrpClassLoader</span> <span class="operator">=</span> extClassLoader.getParent();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取用户自定义类的，类加载器（系统类加载器）</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader1</span> <span class="operator">=</span> Test.class.getClassLoader();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取Java核心类的，类加载器（为null，其实是引导类加载器）</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader2</span> <span class="operator">=</span> String.class.getClassLoader();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><h4 id="自定义加载器（User-Defined-ClassLoader）"><a href="#自定义加载器（User-Defined-ClassLoader）" class="headerlink" title="自定义加载器（User-Defined ClassLoader）"></a>自定义加载器（User-Defined ClassLoader）</h4><ul><li>所有派生于抽象类ClassLoader的类加载器</li><li>为什么需要自定义类加载器<ul><li>隔离加载类（例如：应用的jar包，中间件的jar包不会冲突）</li><li>修改类加载的方式</li><li>扩展加载源</li><li>防止源码泄露</li></ul></li></ul><h4 id="自定义类加载器简单实现"><a href="#自定义类加载器简单实现" class="headerlink" title="自定义类加载器简单实现"></a>自定义类加载器简单实现</h4><ul><li><p>开发人员可以继承抽象类java.lang.Classloader，实现自己的类加载器</p></li><li><p>JDK1.2之前，重写loadClass方法；JDK1.2之后，推荐把自定义类加载逻辑写在findClass中</p></li><li><p>如果没有太复杂的需求，可以直接继承URLClassLoader，避免去编写findClass()方法及其获取字节流的方式</p></li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">byte</span>[] result = getClassFromCustomPath(name);</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FileNotFoundException</span>();</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">return</span> defineClass(name, result, <span class="number">0</span>, result.length);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (FileNotFoundException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(name);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] getClassFromCustomPath(String name) {</span><br><span class="line">        <span class="comment">// 从自定义路径中加载指定的类，细节略</span></span><br><span class="line">        <span class="comment">// 如果字节码文件进行了加密，需要在此进行解密</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><h3 id="ClassLoader常用方法"><a href="#ClassLoader常用方法" class="headerlink" title="ClassLoader常用方法"></a>ClassLoader常用方法</h3><table><thead><tr><th>方法名称</th><th>描述</th></tr></thead><tbody><tr><td>getParent()</td><td>返回该类加载器的父·类加载器</td></tr><tr><td>loadClass(String name)</td><td>加载名称为name的类，返回java.lang.Class类的实例</td></tr><tr><td>findClass(String name)</td><td>查找名称为name的类，返回java.lang.Class类的实例</td></tr><tr><td>findLoadedClass(String name)</td><td>查找名称为name的已被加载过的类，返回java.lang.Class类实例</td></tr><tr><td>defineClass(String name, byte[] b, int off, int len)</td><td>把字节数组中的内容转换为一个Java类，返回java.lang.Class类实例</td></tr><tr><td>resolveClass(Class&lt;?&gt; c)</td><td>连接指定的一个Java类</td></tr></tbody></table><p>获取ClassLoader的方法</p><table><thead><tr><th>方法名称</th><th>描述</th></tr></thead><tbody><tr><td>clazz.getClassLoader()</td><td>当前类的ClassLoader</td></tr><tr><td>Thread.currentThread().getContextClassLoader()</td><td>当前线程上下文的ClassLoader</td></tr><tr><td>ClassLoader.getSystemClassLoader()</td><td>系统的ClassLoader</td></tr><tr><td>DriverManager.getCallerClassLoader()</td><td>调用者的ClassLoader</td></tr></tbody></table><h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>JVM对Class文件采用的是<strong>按需加载</strong>方式。加载某个类的class文件时，JVM采用的是<strong>双亲委派机制</strong>，即把请求交给父类处理。</p><p><strong>思考问题</strong>：假如我们创建一个java.lang.String类，<code>new String()</code>会被影响吗？</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> {</span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p><strong>答</strong>：<code>java.lang.String</code>由引导类加载器加载，根据双亲委派机制，不会被影响</p><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ol><li>类加载器收到了类加载请求，不会直接去执行，而是委托父类的加载器去执行</li><li>父类如果还有父类，则进一步向上委托</li><li>如果父类加载器可以加载，就成功返回；不能加载，子加载器才会尝试加载</li></ol><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/09/06/KXkRve4tj83pVIc.png" alt="68747470733a2f2f6e706d2e656c656d6563646e2e636f6d2f796f7574686c716c40312e302e382f4a564d2f636861707465725f3030322f303032302e706e67" style="zoom:50%"><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul><li>避免类的重复加载</li><li>保护程序安全：防止核心API被篡改<ul><li>java.lang.String：不会被篡改</li><li>java.lang.MyTest：无法添加（因为包名java开头，引导类加载器不会加载）</li></ul></li></ul><h4 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p>加载<code>java.lang.String</code>时，会率先使用引导类加载器。引导类加载器会先加载jdk自带的文件（rt.jar包中的java\lang\String.class）</p><p>报错信息说：没有main方法</p><p>这样可以保证对java核心源代码的保护，这就是<strong>沙箱安全机制</strong></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>在JVM中两个class对象是否为同一个？</p><ul><li><p>类的完整类名必须一致，包括包名</p></li><li><p>加载这个类的ClassLoader（指ClassLoader实例对象）必须相同</p></li></ul><p>JVM必须知道一个类型是由启动加载器加载的，还是由用户类加载器加载的</p><ul><li>如果是用户类加载器加载的，那么JVM会<strong>将这个类加载器的引用作为类型信息的一部分，存放在方法区中</strong></li><li>当解析一个类型到另一个类型的引用时，JVM需要<strong>保证这两个类型的类加载器是相同的</strong></li></ul><p>Java程序对类的使用分为主动使用和被动使用</p><ul><li>主动使用</li></ul><table><thead><tr><th>加载时机</th><th>说明</th></tr></thead><tbody><tr><td>创建实例</td><td>创建类的实例</td></tr><tr><td>静态变量</td><td>访问（或赋值）类或接口的静态变量</td></tr><tr><td>静态方法</td><td>调用静态方法</td></tr><tr><td>反射</td><td>反射，如：<code>Class.forName(“com.example.Test”)</code></td></tr><tr><td>初始化子类</td><td>初始化一个类的子类</td></tr><tr><td>指明为启动类</td><td>JVM启动时被标明为启动类的类</td></tr><tr><td>动态语言支持</td><td>JDK7开始提供的动态语言支持：<br>java.lang.invoke.MethodHandle实例的解析结果：<br>REF_getStatic、REF putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化</td></tr></tbody></table><ul><li>被动使用：其他对类的使用都是被动使用，不会导致类的初始化（Initialization）</li></ul><h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><h3 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h3><p>不同的JVM对于内存的划分方式和管理机制存在着部分差异。我们结合JVM虚拟机规范，来探讨一下经典的JVM内存布局</p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/09/07/bWFewzgZTImoN3f.png" alt="img" style="zoom:67%"><table><thead><tr><th>内存区域</th><th>生命周期</th></tr></thead><tbody><tr><td>方法区，堆（图中棕色）</td><td>一个进程只有一份，生命周期与进程对应</td></tr><tr><td>程序计数器，本地方法栈，虚拟机栈（图中灰色）</td><td>每个线程一份，生命周期与线程对应</td></tr></tbody></table><p><strong>Runtime类</strong>：运行时环境，也即被框出来的部分。每个JVM只有一个Runtime实例</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h4><ol><li>在Hotspot JVM中，每个线程都与本地线程直接映射<ul><li>当一个Java线程准备好执行后，一个操作系统线程也同时创建</li><li>Java线程执行终止后，本地线程也会回收</li></ul></li><li>操作系统会将线程调度到任何可用CPU上。一旦本地线程创建成功，就会调用Java线程中的run()方法</li></ol><h4 id="JVM系统线程"><a href="#JVM系统线程" class="headerlink" title="JVM系统线程"></a>JVM系统线程</h4><p>除了main线程和main创建的线程外，还有很多后台线程（简单了解下）：</p><ul><li>虚拟机线程：JVM达到安全点才会出现</li><li>周期任务线程</li><li>GC线程</li><li>编译线程</li><li>信号调度线程</li></ul><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><h3 id="PC-Register介绍"><a href="#PC-Register介绍" class="headerlink" title="PC Register介绍"></a>PC Register介绍</h3><p>程序计数寄存器（Program Counter Register），并非物理意义上的寄存器，而是一种抽象模拟</p><ul><li><strong>作用</strong>：用来指向下一条指令的地址</li><li>它是一块很小的内存空间，运行速度最快</li><li>每个线程都有自己的PC计数器，生命周期与线程一致</li><li>一个线程只会有一个方法在执行，也即<strong>当前方法</strong><ul><li>PC计数器会存储当前线程正在执行的Java方法的JVM指令地址</li><li>如果是native方法，则是未指定值（undefined）</li></ul></li><li>它是程序控制流的指示器<ul><li>分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成</li></ul></li><li>解释器工作时，改变这个计数器的值，来选取下一条需要执行的指令</li><li>在JVM中，唯一没有规定任何OutofMemoryError情况的区域</li></ul><h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><ul><li>源代码</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + j;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">"abc"</span>;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><ul><li><code>javap -verbose Test.class</code>反编译（部分代码）</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> 0: bipush        10</span><br><span class="line"> 2: istore_1</span><br><span class="line"> 3: bipush        20</span><br><span class="line"> 5: istore_2</span><br><span class="line"> 6: iload_1</span><br><span class="line"> 7: iload_2</span><br><span class="line"> 8: iadd</span><br><span class="line"> 9: istore_3</span><br><span class="line">10: ldc           #7                  // String abc</span><br><span class="line">12: astore        4</span><br><span class="line">14: getstatic     #9                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">17: aload         4</span><br><span class="line">19: invokevirtual #15                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">22: return</span><br></pre></td></tr></table></figure></div><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/09/07/RfOXPJUYgVILtCT.png" alt="68747470733a2f2f6e706d2e656c656d6563646e2e636f6d2f796f7574686c716c40312e302e382f4a564d2f636861707465725f3030332f303030392e706e67"></p><h3 id="两个面试问题"><a href="#两个面试问题" class="headerlink" title="两个面试问题"></a>两个面试问题</h3><p><strong>为什么使用 PC 寄存器来记录当前线程的执行地址？</strong></p><ol><li>CPU会不断切换各线程，切换回来后，需要知道从哪里继续</li><li>JVM字节码解释器需要通过改变PC寄存器的值，来明确下一条应该执行的指令</li></ol><p><strong>PC寄存器为什么被设定为私有的？</strong></p><ol><li>CPU会不断做任务切换，必然导致线程中断和恢复</li><li>为了准确记录各线程当前执行的字节码地址，最好为每个线程都分配一个PC寄存器</li></ol><h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><h3 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h3><ul><li><strong>Java虚拟机栈是什么？</strong></li></ul><p>​	Java虚拟机栈（Java Virtual Machine Stack），也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），<strong>对应着一次次的Java方法调用</strong>，栈是线程私有的</p><ul><li><p><strong>虚拟机栈的生命周期</strong></p><p>生命周期和线程一致</p></li></ul><h3 id="虚拟机栈的特点"><a href="#虚拟机栈的特点" class="headerlink" title="虚拟机栈的特点"></a>虚拟机栈的特点</h3><ul><li>快速有效，访问速度仅次于PC寄存器</li><li>JVM对虚拟机栈的操作只有两个<ul><li>方法执行，对应<strong>入栈</strong></li><li>方法结束，对应<strong>出栈</strong></li></ul></li><li>栈不存在垃圾回收问题<ul><li>栈不需要GC，但是可能存在OOM</li></ul></li></ul><h3 id="虚拟机栈的异常"><a href="#虚拟机栈的异常" class="headerlink" title="虚拟机栈的异常"></a>虚拟机栈的异常</h3><p>Java规定虚拟机栈的大小是动态或者固定不变的</p><ul><li>如果固定大小：每个线程的虚拟机栈可以在创建时设定，执行时如果超过，JVM将抛出<code>StackOverflowError</code>异常</li><li>如果动态扩展：扩展时无法获</li><li>得足够内存，或创建时无法获取足够内存创建，JVM将抛出<code>OutofMemoryError</code>异常</li></ul><h3 id="设置栈大小"><a href="#设置栈大小" class="headerlink" title="设置栈大小"></a>设置栈大小</h3><p>使用-Xss选项，在VM options中设定</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-Xss1m</span><br><span class="line">-Xss1024k</span><br><span class="line">-Xss1048576</span><br></pre></td></tr></table></figure></div><h3 id="栈的存储单元"><a href="#栈的存储单元" class="headerlink" title="栈的存储单元"></a>栈的存储单元</h3><p><strong>栈中存储什么？</strong></p><ol><li>每个线程都有自己的栈，栈中数据以<strong>栈帧</strong>（Stack Frame）的格式存在</li><li>正在执行的方法，都对应一个栈帧（Stack Frame）</li><li>栈帧是一个内存区块，维系着方法执行过程中的各种数据信息</li></ol><p><strong>栈运行原理</strong></p><ol><li>JVM对虚拟机栈只能进行<strong>压栈和出栈</strong></li><li>一个线程中，只能有一个活动的栈帧<ul><li><strong>当前栈帧（Current Frame）</strong></li><li><strong>当前方法（Current Method）</strong></li><li><strong>当前类（Current Class）</strong></li></ul></li><li>执行引擎运行的字节码指令只针对当前栈帧</li><li>如果该方法调用了其他方法，会创建新的栈帧，放在栈顶，成为新的当前帧<ul><li>方法返回时，当前栈帧会传回执行结果给前一个栈帧。虚拟机丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧</li></ul></li><li>不同线程的栈帧之间，不允许相互引用</li><li>Java方法有两种返回方式<ul><li>正常返回：使用return指令</li><li>异常返回：执行中出现未捕获的异常</li></ul></li></ol><p><strong>栈帧内部结构</strong></p><ul><li>局部变量表（Local Variables）</li><li>操作数栈（Operand Stack）（或表达式栈）</li><li>动态链接（Dynamic Linking）（或指向运行时常量池的方法引用）</li><li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</li><li>一些附加信息</li></ul><h3 id="局部变量表（Local-Variables）"><a href="#局部变量表（Local-Variables）" class="headerlink" title="局部变量表（Local Variables）"></a>局部变量表（Local Variables）</h3><ol><li><strong>定义为一个数字数组，存储方法参数和局部变量</strong><ul><li>数据类型包括：基本数据类型、对象引用（reference）、returnAddress返回值类型</li></ul></li><li>线程的私有数据，<strong>不存在数据安全问题</strong></li><li><strong>容量大小在编译期就确定下来</strong>，保存在字节码中：方法的Code属性的<strong>maximum local variables</strong>数据项中</li><li>只在当前方法中有效</li></ol><h4 id="Slot的理解"><a href="#Slot的理解" class="headerlink" title="Slot的理解"></a>Slot的理解</h4><ol><li>局部变量表，最基础的存储单位是Slot</li><li>32位的变量占一个Slot，64位的占两个<ul><li>byte，char，short，boolean存储前都转换位int</li><li>long，double占两个slot</li></ul></li><li>局部变量表每个Slot都有一个索引（从0开始），通过索引即可访问变量值<ul><li>64位变量使用前一个索引访问即可</li></ul></li><li>方法被调用时，方法参数和局部变量，将会<strong>按照顺序被复制</strong>到局部变量表的每一个slot上</li><li>如果是构造方法或实例方法，<strong>this将被存放在index为0的slot处</strong></li></ol><h4 id="Slot的重复利用"><a href="#Slot的重复利用" class="headerlink" title="Slot的重复利用"></a>Slot的重复利用</h4><p>一个栈帧中的Slot可以重复利用。一个局部变量过了其作用域，新的局部变量可以使用之前的槽位</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> {</span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 使用之前的槽位</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><h3 id="操作数栈（Operand-Stack）"><a href="#操作数栈（Operand-Stack）" class="headerlink" title="操作数栈（Operand Stack）"></a>操作数栈（Operand Stack）</h3><p>也被称为：表达式栈</p><h4 id="操作数栈的作用"><a href="#操作数栈的作用" class="headerlink" title="操作数栈的作用"></a>操作数栈的作用</h4><ol><li>主要用于<strong>保存计算中间结果</strong>，同时作为变量临时存储的空间</li><li>可以视为JVM执行引擎的工作区。方法开始执行时，新的栈帧也随之创建，此时方法操作数栈是空的</li><li>操作数栈有明确的栈深度，所需最大深度在编译期就已定义好了，保存在字节码中方法的Code属性中（maxstack）</li><li>栈中的元素可以是任意Java类型<ul><li>32bit类型占一个栈深度</li><li>64bit类型占两个栈深度</li></ul></li><li>如果被调用函数有返回值，其返回值会被压入当前栈帧的操作数栈中<ul><li>然后更新PC寄存器中下一条要执行的指令</li></ul></li><li>操作数栈中的元素数据类型，必须与字节码指令的序列严格匹配<ul><li>在编译阶段，编译器验证</li><li>在类加载过程中，类检验阶段（Linking-检验）的数据流分析阶段再次检验</li></ul></li></ol><h4 id="举例说明-1"><a href="#举例说明-1" class="headerlink" title="举例说明"></a>举例说明</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + j;</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> 0 bipush 15</span><br><span class="line"> 2 istore_1</span><br><span class="line"> 3 bipush 8</span><br><span class="line"> 5 istore_2</span><br><span class="line"> 6 iload_1</span><br><span class="line"> 7 iload_2</span><br><span class="line"> 8 iadd</span><br><span class="line"> 9 istore_3</span><br><span class="line">10 return</span><br></pre></td></tr></table></figure></div><ol><li>第一条指令，PC寄存器指向0。使用bipush让操作数15入操作数栈</li></ol><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/09/18/WkVuarNAOTFi46q.png" alt="68747470733a2f2f6e706d2e656c656d6563646e2e636f6d2f796f7574686c716c40312e302e382f4a564d2f636861707465725f3030342f303032322e706e67" style="zoom:67%"><ol start="2"><li>PC寄存器+1，指向下一行代码。使用istore_1将操作数栈的元素存储到局部变量表1的位置（局部变量表0存的是this）</li></ol><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/09/18/o5JPf8XtK76edkB.png" alt="68747470733a2f2f6e706d2e656c656d6563646e2e636f6d2f796f7574686c716c40312e302e382f4a564d2f636861707465725f3030342f303032332e706e67" style="zoom:67%"><ol start="3"><li>同理，bipush将操作数8入栈，istore_2将操作数栈的元素存储到局部变量表2的位置</li></ol><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/09/18/dvxuT5UpEjiOtaR.png" alt="68747470733a2f2f6e706d2e656c656d6563646e2e636f6d2f796f7574686c716c40312e302e382f4a564d2f636861707465725f3030342f303032342e706e67" style="zoom:50%"><ol start="4"><li>使用iload_1，iload_2，从局部变量表中取出两个操作数，放入栈中</li></ol><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/09/18/9UFHTDfXl1zbEC5.png" alt="68747470733a2f2f6e706d2e656c656d6563646e2e636f6d2f796f7574686c716c40312e302e382f4a564d2f636861707465725f3030342f303032352e706e67" style="zoom:50%"><ol start="5"><li>使用iadd，将操作数栈顶端两个元素相加，然后入栈。再使用istore_3将其存储在变量表3的位置</li></ol><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/09/18/1NaniqC8JBv52DI.png" alt="68747470733a2f2f6e706d2e656c656d6563646e2e636f6d2f796f7574686c716c40312e302e382f4a564d2f636861707465725f3030342f303032362e706e67" style="zoom:50%"><h5 id="关于类型转换"><a href="#关于类型转换" class="headerlink" title="关于类型转换"></a>关于类型转换</h5><blockquote><p><code>int j = 8;</code></p><ul><li><p>8可以存储在byte类型中，所以压入栈的类型为byte（bipush 8）</p></li><li><p>存储为局部变量时，会转为int类型（istore_4）</p></li></ul><p><code>int j = 800;</code></p><ul><li>byte存储不了，改为short型（sipush 800）</li></ul></blockquote><h5 id="关于返回值的问题"><a href="#关于返回值的问题" class="headerlink" title="关于返回值的问题"></a>关于返回值的问题</h5><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetSum</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> getSum();</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><ul><li><code>getSum()</code>方法字节码指令，最后带着ireturn</li></ul><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/09/18/f3HB95QvzNMLxgo.png" alt="image-20230918140426188" style="zoom:50%"><ul><li><code>testGetSum()</code>方法字节码指令，一上来就加载<code>getSum()</code>方法的返回值</li></ul><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/09/18/IKbu7k8s4qladrz.png" alt="image-20230918140524097" style="zoom:50%"><h4 id="栈顶缓存技术"><a href="#栈顶缓存技术" class="headerlink" title="栈顶缓存技术"></a>栈顶缓存技术</h4><p>HotSpot JVM的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术</p><ul><li>将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率</li></ul><h3 id="动态链接（Dynamic-Linking）"><a href="#动态链接（Dynamic-Linking）" class="headerlink" title="动态链接（Dynamic Linking）"></a>动态链接（Dynamic Linking）</h3><ul><li>每个栈帧中都包含一个：指向常量池中，该方法的引用<ul><li>包含这个引用的目的，就是为了实现动态链接（Dynamic Linking）</li></ul></li><li>在字节码文件中，所有变量和方法的引用都作为符号引用（Symbolic Reference）保存在class文件的常量池中<ul><li>比如：调用一个方法，就是通过常量池中指向方法的符号引用来表示的</li><li>动态链接作用就是为了将这些<strong>符号引用</strong>转换为<strong>直接引用</strong></li></ul></li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> {</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"A"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"B"</span>);</span><br><span class="line">        methodA();</span><br><span class="line">        num++;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"># 字节码中的常量池</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #2.#3          // java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">   #2 = Class              #4             // java/lang/Object</span><br><span class="line">   #3 = NameAndType        #5:#6          // "&lt;init&gt;":()V</span><br><span class="line">   #4 = Utf8               java/lang/Object</span><br><span class="line">   #5 = Utf8               &lt;init&gt;</span><br><span class="line">   #6 = Utf8               ()V</span><br><span class="line">   #7 = Fieldref           #8.#9          // org/example/Test.num:I</span><br><span class="line">   #8 = Class              #10            // org/example/Test</span><br><span class="line">   #9 = NameAndType        #11:#12        // num:I</span><br><span class="line">  #10 = Utf8               org/example/Test</span><br><span class="line">  #11 = Utf8               num</span><br><span class="line">  #12 = Utf8               I</span><br><span class="line">  #13 = Methodref          #8.#3          // org/example/Test."&lt;init&gt;":()V</span><br><span class="line">  #14 = Methodref          #8.#15         // org/example/Test.methodB:()V</span><br><span class="line">  #15 = NameAndType        #16:#6         // methodB:()V</span><br><span class="line">  #16 = Utf8               methodB</span><br><span class="line">  #17 = Fieldref           #18.#19        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">  #18 = Class              #20            // java/lang/System</span><br><span class="line">  #19 = NameAndType        #21:#22        // out:Ljava/io/PrintStream;</span><br><span class="line">  #20 = Utf8               java/lang/System</span><br><span class="line">  #21 = Utf8               out</span><br><span class="line">  #22 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #23 = String             #24            // A</span><br><span class="line">  #24 = Utf8               A</span><br><span class="line">  #25 = Methodref          #26.#27        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">  #26 = Class              #28            // java/io/PrintStream</span><br><span class="line">  #27 = NameAndType        #29:#30        // println:(Ljava/lang/String;)V</span><br><span class="line">  #28 = Utf8               java/io/PrintStream</span><br><span class="line">  #29 = Utf8               println</span><br><span class="line">  #30 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">  #31 = String             #32            // B</span><br><span class="line">  #32 = Utf8               B</span><br><span class="line">  #33 = Methodref          #8.#34         // org/example/Test.methodA:()V</span><br><span class="line">  #34 = NameAndType        #35:#6         // methodA:()V</span><br><span class="line">  #35 = Utf8               methodA</span><br><span class="line">  #36 = Utf8               Code</span><br><span class="line">  #37 = Utf8               LineNumberTable</span><br><span class="line">  #38 = Utf8               LocalVariableTable</span><br><span class="line">  #39 = Utf8               this</span><br><span class="line">  #40 = Utf8               Lorg/example/Test;</span><br><span class="line">  #41 = Utf8               main</span><br><span class="line">  #42 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #43 = Utf8               args</span><br><span class="line">  #44 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #45 = Utf8               test</span><br><span class="line">  #46 = Utf8               SourceFile</span><br><span class="line">  #47 = Utf8               Test.java</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 字节码中methodB的Code</span><br><span class="line"></span><br><span class="line"> 0 getstatic #17		&lt;java/lang/System.out : Ljava/io/PrintStream;&gt;</span><br><span class="line"> 3 ldc #31 				&lt;B&gt;</span><br><span class="line"> 5 invokevirtual #25 	&lt;java/io/PrintStream.println : (Ljava/lang/String;)V&gt;</span><br><span class="line"> 8 aload_0</span><br><span class="line"> 9 invokevirtual #33 	&lt;org/example/Test.methodA : ()V&gt;</span><br><span class="line">12 aload_0</span><br><span class="line">13 dup</span><br><span class="line">14 getfield #7 			&lt;org/example/Test.num : I&gt;</span><br><span class="line">17 iconst_1</span><br><span class="line">18 iadd</span><br><span class="line">19 putfield #7 			&lt;org/example/Test.num : I&gt;</span><br><span class="line">22 return</span><br></pre></td></tr></table></figure></div><ol><li><p>methodB()方法通过<code>invokevirtual #33</code>调用了方法A</p></li><li><p>常量池中：<code>#33 = Methodref #8.#34</code></p><ul><li><code>#8 = Class #10</code><ul><li><code>#10 = Utf8 org/example/Test</code>，找到了类名</li></ul></li><li><code>#34 = NameAndType #35:#6</code><ul><li><code>#35 = Utf8 methodA</code>，找到了方法名</li><li><code>#6 = Utf8 ()V</code>，方法没有形参，返回值为void</li></ul></li></ul></li><li><p>结论：通过#33，我们找到了需要调用的methodA()方法，并进行调用</p></li></ol><h3 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h3><h4 id="方法绑定机制"><a href="#方法绑定机制" class="headerlink" title="方法绑定机制"></a>方法绑定机制</h4><p>在JVM中，将被调用方法的<strong>符号引用</strong>转换为<strong>直接引用</strong>，与方法的绑定机制相关</p><ul><li>静态链接（方法的绑定机制：早期绑定）<ul><li>被调用的目标方法在编译期可知，将调用方法的符号引用转换为直接引用</li></ul></li><li>动态链接（方法的绑定机制：晚期绑定）<ul><li>如果在编译器无法确定，只能在程序运行期，将符号引用转换为直接引用</li></ul></li></ul><h4 id="具体例子"><a href="#具体例子" class="headerlink" title="具体例子"></a>具体例子</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> <span class="keyword">implements</span> <span class="title class_">Huntable</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 1 invokespecial #1 &lt;org/example/Animal.&lt;init&gt; : ()V&gt;</span></span><br><span class="line">        <span class="comment">// 表现为：早期绑定</span></span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(String name)</span> {</span><br><span class="line">        <span class="comment">// 1 invokespecial #7 &lt;org/example/Cat.&lt;init&gt; : ()V&gt;</span></span><br><span class="line">        <span class="comment">// 表现为：早期绑定</span></span><br><span class="line">        <span class="built_in">this</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnimalTest</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showAnimal</span><span class="params">(Animal animal)</span> {</span><br><span class="line">        <span class="comment">// 1 invokevirtual #7 &lt;org/example/Animal.eat : ()V&gt;</span></span><br><span class="line">        <span class="comment">// 表现为：晚期绑定</span></span><br><span class="line">        animal.eat();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showHunt</span><span class="params">(Huntable h)</span> {</span><br><span class="line">        <span class="comment">// 1 invokeinterface #12 &lt;org/example/Huntable.hunt : ()V&gt; count 1</span></span><br><span class="line">        <span class="comment">// 表现为：晚期绑定</span></span><br><span class="line">        h.hunt();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><h4 id="虚方法与非虚方法"><a href="#虚方法与非虚方法" class="headerlink" title="虚方法与非虚方法"></a>虚方法与非虚方法</h4><p>多态使用的前提：① 类的继承； ② 方法的重写</p><ul><li>Java中任何一个方法都具备虚函数的特征<ul><li>相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）</li></ul></li><li>不希望方法拥有虚函数的特征时，可以使用关键字final来标记</li></ul><blockquote><p><strong>虚方法与非虚方法：</strong></p><p>非虚方法</p><ul><li>编译器就确定了具体的调用版本，运行时不可变</li><li>如：静态方法，私有方法，final方法，实例构造器，父类方法</li></ul><p>虚方法</p><ul><li>其他所有方法，都是虚方法</li></ul></blockquote><h4 id="普通指令与动态指令"><a href="#普通指令与动态指令" class="headerlink" title="普通指令与动态指令"></a>普通指令与动态指令</h4><p>普通指令</p><ul><li>invokestatic：调用静态方法，(早期绑定)</li><li>invokespecial：调用唯一确认的方法，(早期绑定)</li><li>invokevirtual：调用虚方法，(晚期绑定，但是final方法例外)</li><li>invokeinterface：调用接口方法，(晚期绑定)</li></ul><p>动态指令</p><ul><li>invokedynamic：动态解析出需要调用的方法<ul><li>Java7出现</li><li>Java8开始有用（Lambda表达式）</li></ul></li></ul><blockquote><p>动态类型语言 VS 静态类型语言</p><ul><li>静态类型：判断变量自身的类型</li><li>动态类型：变量没有类型信息，变量值才有类型信息</li></ul></blockquote><p><strong>体验动态指令</strong></p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Func</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">func</span><span class="params">(String str)</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lambda</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lambda</span><span class="params">(Func func)</span> {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Lambda</span> <span class="variable">lambda</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lambda</span>();</span><br><span class="line">        <span class="comment">// 根据值来确认类型</span></span><br><span class="line">        <span class="type">Func</span> <span class="variable">func</span> <span class="operator">=</span> s -&gt; {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        };</span><br><span class="line">        lambda.lambda(func);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/09/19/ndUfaDpItv5hVs4.png" alt="image-20230919152320322"></p><h4 id="方法重写的本质"><a href="#方法重写的本质" class="headerlink" title="方法重写的本质"></a>方法重写的本质</h4><p><strong>当我们执行对象的方法时（如果是虚方法）：</strong></p><ol><li>对象压入操作数栈</li><li>找到操作数栈顶元素的实际类型（记作C）</li><li>如果C中找到与常量池中相符的方法，则进行访问权限校验<ul><li>通过，返回方法的直接引用，查找结束</li><li>不通过，返回<code>java.lang.IllegalAccessError</code>异常</li></ul></li><li>如果找不到相符的方法，按照继承关系依次找</li><li>如果最终依然找不到，抛出<code>java.lang.AbstractMethodError</code>异常</li></ol><p><strong>提升性能：</strong></p><ul><li>如果每次都要向上层找（动态分派），十分影响效率</li><li>JVM会在类的方法区建立一个<strong>虚方法表</strong>（virtual method table）（非虚的方法不会在表中），使用索引表来代替查找。<ul><li>每个类都有一个虚方法表，存放虚方法的实际入口</li><li><strong>创建时间</strong>：类加载的Linking阶段。类变量初始值准备完成后，JVM会把类的方法表也初始化完毕</li></ul></li><li>虚方法表的例子：</li></ul><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/09/20/sv7q8N6G2zBOZDJ.png" alt="image-20230920165158276" style="zoom:50%"><h3 id="方法返回地址（return-address）"><a href="#方法返回地址（return-address）" class="headerlink" title="方法返回地址（return address）"></a>方法返回地址（return address）</h3><ol><li>存放<strong>调用方PC寄存器的值</strong></li><li>无论有无异常，方法退出后都返回到该方法被调用的位置<ul><li>方法正常退出：调用方PC寄存器的下一条指令的地址，作为返回地址</li><li>方法异常退出：返回地址通过异常表来确定，栈帧中不会有这部分信息</li></ul></li><li>方法退出其实就是当前栈帧出栈的过程<ul><li>需要恢复上层方法的：局部变量表，操作数栈</li><li>还需：将返回值压入调用者操作数栈，设置PC寄存器</li></ul></li><li>正常完成和异常完成的区别在于：异常完成不会给上级调用者产生任何返回值</li></ol><p><strong>只有两种方式可以退出方法：</strong></p><ol><li>正常完成出口：执行引擎遇到方法返回的字节码指令（return），会有返回值传递给上层的方法调用者<ul><li>返回不同类型的值，字节码指令不同：<ul><li>ireturn（boolean，byte，char，short，int）</li><li>lreturn</li><li>freturn</li><li>dreturn</li><li>areturn</li><li>return（void，实例初始化方法<init>，类和接口初始化方法<cinit>）</cinit></init></li></ul></li></ul></li><li>异常完成出口：方法执行过程中遇到了异常，且方法内无法处理<ul><li>异常处理，存储在一个异常处理表中，方便在发生异常的时候找到处理异常的代码</li></ul></li></ol><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/09/21/6LRU7jJXrSFzto8.png" alt="image-20230921192724180" style="zoom:50%"><blockquote><p>4-16行字节码出了异常，就按照19行字节码指令进行处理，针对任何异常类型</p></blockquote><h3 id="栈帧中的一些附加信息"><a href="#栈帧中的一些附加信息" class="headerlink" title="栈帧中的一些附加信息"></a>栈帧中的一些附加信息</h3><p>栈帧中允许携带与Java虚拟机实现相关的一些附加信息。如：对程序调试提供支持的信息</p><h3 id="虚拟机栈的5道面试题"><a href="#虚拟机栈的5道面试题" class="headerlink" title="虚拟机栈的5道面试题"></a>虚拟机栈的5道面试题</h3><p><strong>举例栈溢出的情况？</strong></p><ul><li>StackOverflowError，可以通过-Xss设置栈的大小</li></ul><p><strong>调整栈大小，就能保证不溢出吗？</strong></p><ul><li>不能，比如以前递归5000次StackOverflowError，现在调大栈的大小，可能7000次才会StackOverflowError。调大只会保证出现晚一些，无法一定保证不会溢出</li></ul><p><strong>分配的栈内存越大越好吗？</strong></p><ul><li>不是的，会挤占其他的内存空间（比如影响线程的数量）</li></ul><p><strong>垃圾回收是否会涉及到虚拟机栈？</strong></p><ul><li>不涉及</li></ul><p><strong>方法中定义的局部变量是否线程安全？</strong></p><ul><li>如果对象在方法内部产生，内部消亡，则是线程安全的；反之线程不安全</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s1是线程安全的（只在方法内部用了）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    s1.append(<span class="string">"a"</span>);</span><br><span class="line">    s1.append(<span class="string">"b"</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s1是线程不安全的（作为参数传进来，可能被其它线程操作）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(StringBuilder s1)</span>{</span><br><span class="line">    s1.append(<span class="string">"a"</span>);</span><br><span class="line">    s1.append(<span class="string">"b"</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s1是线程不安全的（有返回值，可能被其它线程操作）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title function_">method3</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    s1.append(<span class="string">"a"</span>);</span><br><span class="line">    s1.append(<span class="string">"b"</span>);</span><br><span class="line">    <span class="keyword">return</span> s1;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s1是线程安全的（s1自己消亡了，最后返回的只是s1.toString的一个新对象）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">method4</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    s1.append(<span class="string">"a"</span>);</span><br><span class="line">    s1.append(<span class="string">"b"</span>);</span><br><span class="line">    <span class="keyword">return</span> s1.toString();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><h2 id="本地方法接口"><a href="#本地方法接口" class="headerlink" title="本地方法接口"></a>本地方法接口</h2><h3 id="什么是本地方法"><a href="#什么是本地方法" class="headerlink" title="什么是本地方法"></a>什么是本地方法</h3><p>Native Method：Java调用非Java代码接口，初衷是融合C/C++程序</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IHaveNatives</span> {</span><br><span class="line">    <span class="comment">// 除了不能用abstract修饰，其他关键词都可以用</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">native1</span><span class="params">(<span class="type">int</span> x)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">native2</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">synchronized</span> <span class="type">float</span> <span class="title function_">native3</span><span class="params">(Object o)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">native4</span><span class="params">(<span class="type">int</span>[] ary)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><h3 id="为什么要使用本地方法"><a href="#为什么要使用本地方法" class="headerlink" title="为什么要使用本地方法"></a>为什么要使用本地方法</h3><ul><li><p><strong>与Java环境外的交互</strong></p><p>有时Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因</p></li><li><p><strong>与操作系统的交互</strong></p><p>通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用C写的</p></li><li><p><strong>Sun’s Java</strong></p><p>Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互</p></li></ul><blockquote><p>目前该方法使用越来越少了，除非是与硬件相关的应用。异构领域间通信很发达，可以使用Socket通信，也可以使用Web Service等</p></blockquote><h3 id="本地方法栈的理解"><a href="#本地方法栈的理解" class="headerlink" title="本地方法栈的理解"></a>本地方法栈的理解</h3><p><strong>本地方法栈：</strong></p><ul><li><p>管理本地方法的调用，也是线程私有的</p></li><li><p>允许被设为固定大小的或可动态扩展的</p><ul><li>固定大小，超过本地方法栈最大容量：StackOverflowError异常</li><li>动态扩展，创建或扩展时没有足够的内存：OutOfMemoryError异常</li></ul></li></ul><blockquote><p>假如我们调用一个Java方法，方法栈帧会被压入Java虚拟机栈中；</p><p>如果我们需要调用本地方法了，本地方法的栈帧会被压入到本地方法栈中，执行引擎通过动态链接的方式调用C的相关的库</p></blockquote><p><strong>当某一线程调用本地方法时，就进入了一个全新的不受虚拟机限制的世界。他和虚拟机有同样的权限</strong></p><ul><li>访问虚拟机内部的运行时数据</li><li>世界使用本地处理器的寄存器</li><li>直接从本地内存的堆中分配任意大小内存</li></ul><p><strong>并不是所有JVM都支持本地方法</strong></p><ul><li>Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构</li></ul><p><strong>在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一</strong></p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="堆的核心概念"><a href="#堆的核心概念" class="headerlink" title="堆的核心概念"></a>堆的核心概念</h3><ol><li>一个JVM实例（进程）只有一个堆内存，是Java内存管理的核心区域</li><li>在JVM启动时就被创建，空间大小就已确定<ul><li>堆空间大小可以调节</li></ul></li><li>堆可以处于物理上不连续的内存空间中，但逻辑上它被视作连续的</li><li>所有线程共享Java堆，还可以划分线程私有缓冲区（Thread Local Allocation Buffer，TLAB）</li><li>（几乎）所有的对象和数组，都分配在堆上</li><li>方法结束后，堆中的对象不会立刻移除，仅在垃圾回收时移除</li><li>堆，是GC（Garbage Collection，垃圾回收器）执行垃圾回收的重点区域</li></ol><h4 id="可视化工具"><a href="#可视化工具" class="headerlink" title="可视化工具"></a>可视化工具</h4><p>启动一个JVM实例</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 虚拟机参数：-Xms10m -Xmx10m</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapDemo1</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(<span class="string">"start"</span>);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Thread.sleep(<span class="number">100000000</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"end"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p>JDK14之后，已不再集成visualvm，<a class="link" target="_blank" rel="noopener" href="https://blog.csdn.net/LONG_Yi_1994/article/details/108730414">手动安装 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>Eden Space + Survivor 0 + Survivor 1 + Old Gen就是我们堆空间的大小</p><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/09/25/GqVrc8Ptl3NisBK.png" alt="image-20230925164220197"></p><h4 id="内存细分"><a href="#内存细分" class="headerlink" title="内存细分"></a>内存细分</h4><p><strong>Java7及之前：</strong></p><ul><li>新生代，老年代，永久代</li></ul><p><strong>Java8及以后</strong></p><ol><li><p>新生代（New Gen）</p><ul><li><p>Eden Space</p></li><li><p>Survivor 0</p></li><li><p>Survivor 1</p></li></ul></li><li><p>老年代（Old Gen）</p></li><li><p>元空间（MetaSpace）</p></li></ol><h3 id="设置堆内存大小与OOM"><a href="#设置堆内存大小与OOM" class="headerlink" title="设置堆内存大小与OOM"></a>设置堆内存大小与OOM</h3><h4 id="设置大小"><a href="#设置大小" class="headerlink" title="设置大小"></a>设置大小</h4><ul><li>-Xms：堆起始内存大小，等价于-XX:InitialHeapSize</li><li>-Xmx：堆最大内存大小，等价于-XX:MaxHeapSize<ul><li>堆超过此大小，会报OutOfMemoryError错误</li></ul></li></ul><blockquote><p>通常，会将这两个值设为一样。<strong>以便在GC完成后不需要重新分隔堆区的大小，提高性能</strong></p><p>默认情况下：初始内存大小=物理内存大小 / 64；最大内存大小=物理内存大小 / 4</p></blockquote><h4 id="查看大小"><a href="#查看大小" class="headerlink" title="查看大小"></a>查看大小</h4><p><strong>代码查看一下大小</strong></p><p>（我的电脑内存40GB）</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">initialMemory</span> <span class="operator">=</span> Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span>;	<span class="comment">// 初始大小</span></span><br><span class="line"><span class="type">long</span> <span class="variable">maxMemory</span> <span class="operator">=</span> Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span>;		<span class="comment">// 最大大小</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"-Xms : "</span> + initialMemory + <span class="string">"M"</span>);	<span class="comment">// 640M</span></span><br><span class="line">System.out.println(<span class="string">"-Xmx : "</span> + maxMemory + <span class="string">"M"</span>);		<span class="comment">// 10168M</span></span><br></pre></td></tr></table></figure></div><p><strong>命令行查看大小</strong></p><blockquote><p>jps：查看java进程</p><p>jstat -gc &lt;进程id&gt;：查看进程中内存使用情况</p></blockquote><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/09/25/r2udgtFBoKfnVvk.png" alt="image-20230925170955398"></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SOC: S0区总共容量</span><br><span class="line">S1C: S1区总共容量</span><br><span class="line">S0U: S0区使用的量</span><br><span class="line">S1U: S1区使用的量</span><br><span class="line">EC: 伊甸园区总共容量</span><br><span class="line">EU: 伊甸园区使用的量</span><br><span class="line">OC: 老年代总共容量</span><br><span class="line">OU: 老年代使用的量</span><br></pre></td></tr></table></figure></div><blockquote><p>有个细节：S0和S1之间只能二选一，算总量的时候应该：S0C（或者S1C） + EC + OC</p></blockquote><p><strong>虚拟机选项查看大小</strong></p><blockquote><p>-XX:+PrintGCDetails</p></blockquote><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/09/25/3jVtd8pPv4awZWE.png" alt="image-20230925200811004"></p><h4 id="OOM举例"><a href="#OOM举例" class="headerlink" title="OOM举例"></a>OOM举例</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapDemo1</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        ArrayList&lt;Picture&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">            Thread.sleep(<span class="number">5</span>);</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">Picture</span>(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">1024</span> * <span class="number">1024</span>)));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Picture</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] pixels;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Picture</span><span class="params">(<span class="type">int</span> length)</span> {</span><br><span class="line">        <span class="built_in">this</span>.pixels = <span class="keyword">new</span> <span class="title class_">byte</span>[length];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/09/25/954lQPLjt13IVCR.png" alt="image-20230925201428228"></p><h3 id="年轻代与老年代"><a href="#年轻代与老年代" class="headerlink" title="年轻代与老年代"></a>年轻代与老年代</h3><ul><li><p>存储在JVM中的数据分为两类：</p><ul><li><p>一类生命周期较短，创建和消亡都非常迅速</p></li><li><p>另一类生命周期非常长，甚至可能和JVM生命周期一致</p></li></ul></li><li><p>Java堆进一步细分，可以划分为：年轻代（YoungGen）和老年代（OldGen）</p><ul><li>年轻代可以继续细分为：Eden空间，Survivor0空间，Survivor1空间</li><li>年轻代内部比例：8 : 1 : 1</li></ul></li><li><p>（几乎）所有Java对象都在Eden区被new出来</p><ul><li>比如：Eden空间装不下…</li></ul></li><li><p>绝大多数Java对象都是在新生代销毁的（IBM研究80%都是）</p></li></ul><h4 id="相关虚拟机选项"><a href="#相关虚拟机选项" class="headerlink" title="相关虚拟机选项"></a>相关虚拟机选项</h4><blockquote><p>一般不会调整</p></blockquote><p><strong>设置新生代空间大小：</strong></p><ul><li><code>-Xmn50m</code>：如果和下面设置比例的选项冲突，还是优先使用它</li></ul><p><strong>年轻代与老年代比例：</strong></p><ul><li><p>默认：<code>-XX:NewRatio=2</code>，表示新生代占1，老年代占2（新生代占1/3）</p></li><li><p>可以修改：<code>-XX:NewRatio=2</code>，表示新生代占1，老年代占4（新生代占1/5）</p></li></ul><p><strong>年轻代内部比例：</strong></p><ul><li>默认：<code>-XX:SurvivorRatio=8</code>，表示8 : 1 : 1（但未必一定是这个比例，因为有自适应策略）</li></ul><p><strong>使用自适应的内存比例：</strong></p><ul><li>默认使用：<code>-XX:+UseAdaptiveSizePolicy</code></li><li>关闭策略：<code>-XX:-UseAdaptiveSizePolicy</code></li></ul><h3 id="图解对象分配过程"><a href="#图解对象分配过程" class="headerlink" title="图解对象分配过程"></a>图解对象分配过程</h3><h4 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h4><ol><li>new对象先放伊甸园区</li><li>如果伊甸园区满了，进行垃圾回收：<ul><li>将进行Minor GC，不被引用的对象将被销毁</li><li>幸存的对象移动到S0中</li></ul></li><li>下一次伊甸园满了，进行垃圾回收时：<ul><li>这一次幸存的对象移动到S1中</li><li>S0中也进行垃圾回收，幸存的也移动到S1中</li></ul></li><li>每进入一次垃圾回收，幸存者age加一</li><li>在从S0-&gt;S1或者S1-&gt;S0过程中，如果age达到阈值（默认15），会进入老年区（promotion，晋升）<ul><li>可以设置参数：<code>-XX:MaxTenuringThreshold=15</code></li></ul></li></ol><blockquote><p><strong>注意：</strong></p><p>伊甸园区满的时候：会触发伊甸园区和幸存者区的垃圾回收</p></blockquote><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/09/27/32L5XodfzYKEB8c.png" alt="image-20230927153227794"></p><h4 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h4><ul><li>伊甸园放得下：分配内存</li><li>伊甸园放不下：触发<strong>Minor GC</strong><ul><li>幸存者区放得下：放置在S0或S1，达到阈值的对象晋升老年代</li><li>幸存者区放不下：直接放到老年代</li></ul></li><li>伊甸园依然放不下（超大对象）：直接放到老年代<ul><li>老年代放不下：触发<strong>Major GC</strong></li><li>老年代依然放不下：<strong>OOM</strong></li></ul></li></ul><h3 id="Minor-GC、Major-GC、Full-GC"><a href="#Minor-GC、Major-GC、Full-GC" class="headerlink" title="Minor GC、Major GC、Full GC"></a>Minor GC、Major GC、Full GC</h3><h4 id="GC的分类"><a href="#GC的分类" class="headerlink" title="GC的分类"></a>GC的分类</h4><p>部分收集（Partial GC）：</p><ul><li><p>Minor GC：只是新生代（Eden，S0，S1）的垃圾回收</p></li><li><p>Major GC：只是老年代的垃圾回收</p><ul><li>目前，只有CMS GC会有单独收集老年代的行为</li><li>目前，很多时候Major GC会和Full GC混淆使用，需要具体区分是老年代回收还是整堆回收</li></ul></li><li><p>Mixed GC：整个新生代以及部分老年代的垃圾回收</p><ul><li>目前，只有G1 GC会有这种行为</li></ul></li></ul><p>整堆收集（Full GC）：</p><ul><li>Full GC：整个Java堆和方法区的垃圾收集</li></ul><h4 id="Minor-GC的触发机制"><a href="#Minor-GC的触发机制" class="headerlink" title="Minor GC的触发机制"></a>Minor GC的触发机制</h4><ul><li>Eden满了触发，Survivor满了不会引发GC</li><li>Minor GC触发频率非常高，回收速度也很快</li><li>Minor GC会引发STW（Stop The World），暂停其他用户的线程，等垃圾回收结束才会恢复</li></ul><h4 id="Major-GC的触发条件"><a href="#Major-GC的触发条件" class="headerlink" title="Major GC的触发条件"></a>Major GC的触发条件</h4><ul><li><p>指发生在老年代的GC，对象从老年代消失时，我们说”Major GC“或”Full GC“发生了</p></li><li><p>出现Major GC，经常伴随至少一次的Minor GC</p><ul><li>但并非绝对的，Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略<ul><li>也即：老年代空间不足时，先尝试触发Minor GC，空间还是不足才触发Major GC</li></ul></li></ul></li><li><p>Major GC的速度比Minor GC慢10倍以上，STW时间更长</p></li><li><p>Major GC后内存还是不足，报OOM</p></li></ul><h4 id="Full-GC的触发条件"><a href="#Full-GC的触发条件" class="headerlink" title="Full GC的触发条件"></a>Full GC的触发条件</h4><ul><li>调用<code>System.gc()</code>，系统建议执行Full GC，但不必然执行</li><li>老年代空间不足</li><li>方法区空间不足</li></ul><blockquote><p>由于暂停时间长，应当尽量避免Full GC / Major GC</p></blockquote><h3 id="GC举例与日志分析"><a href="#GC举例与日志分析" class="headerlink" title="GC举例与日志分析"></a>GC举例与日志分析</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -Xms9m -Xmx9m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment">// JDK17使用 -Xms9m -Xmx9m -XX:+UseParallelGC -Xlog:gc*</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCTest</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">"atguigu.com"</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">                list.add(a);</span><br><span class="line">                a = a + a;</span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">            t.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">"遍历次数为："</span> + i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">JDK17的结果</span></span><br><span class="line"></span><br><span class="line">GC(4) Pause Full (Allocation Failure)</span><br><span class="line">GC(4) PSYoungGen: 0K(2560K)-&gt;0K(2560K) Eden: 0K(2048K)-&gt;0K(2048K) From: 0K(512K)-&gt;0K(512K)</span><br><span class="line">GC(4) ParOldGen: 6498K(7168K)-&gt;6492K(7168K)</span><br><span class="line">GC(4) Metaspace: 523K(704K)-&gt;523K(704K) NonClass: 490K(576K)-&gt;490K(576K) Class: 33K(128K)-&gt;33K(128K)</span><br><span class="line">GC(4) Pause Full (Allocation Failure) 6M-&gt;6M(9M) 3.082ms</span><br><span class="line">GC(4) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">遍历次数为：18</span><br><span class="line">Heap</span><br><span class="line">PSYoungGen      total 2560K, used 339K</span><br><span class="line">eden space 2048K, 16% used</span><br><span class="line">from space 512K, 0% used</span><br><span class="line">to   space 512K, 0% used</span><br><span class="line">ParOldGen       total 7168K, used 6492K</span><br><span class="line">object space 7168K, 90% used</span><br><span class="line">Metaspace       used 778K, committed 896K, reserved 1056768K</span><br><span class="line">class space    used 63K, committed 128K, reserved 1048576K</span><br></pre></td></tr></table></figure></div><h3 id="堆空间分代思想"><a href="#堆空间分代思想" class="headerlink" title="堆空间分代思想"></a>堆空间分代思想</h3><p>为什么要把Java堆分代？</p><ul><li><p>分代的唯一理由就是优化GC性能</p></li><li><p>经研究，70%-99%的对象是临时对象</p><ul><li>将朝生夕死的对象进行回收，能腾出大量的空间</li></ul></li><li><p>如果没有分代，GC需要对堆的所有区域进行扫描</p></li></ul><h3 id="总结–内存分配策略"><a href="#总结–内存分配策略" class="headerlink" title="总结–内存分配策略"></a>总结–内存分配策略</h3><ol><li>如果对象在Eden出生并经过第一次Minor GC后仍然存活，且能被Survivor容纳，将被移动到Survivor空间中，年龄设为1。</li><li>对象在Survivor区中每熬过一次MinorGC，年龄就增加1。当它的年龄增加到一定程度（默认为15岁，其实每个JVM、每个GC都有所不同），就会被晋升到老年代</li><li>晋升老年代的阀值，可以通过选项**-XX:MaxTenuringThreshold**来设置</li></ol><p><strong>针对不同年龄段的对象分配原则：</strong></p><ul><li>优点分配到Eden</li><li>大对象直接分配到老年代<ul><li>Eden都放不下了</li></ul></li><li>长期存活的对象分配到老年代<ul><li>年龄超过阈值的对象</li></ul></li><li>动态年龄判断<strong>（特例）</strong><ul><li>如果Survivor区中相同年龄的对象大小的总和，大于Survivor空间的一半。年龄大于等于该年龄的对象可以直接进入老年代，无需达到阈值</li><li>避免S0和S1反复倒来倒去</li></ul></li><li>空间分配担保<ul><li>-XX:HandlePromptFailure（后面参数设置部分有讲）</li></ul></li></ul><h3 id="补充–为对象分配内存：TLAB"><a href="#补充–为对象分配内存：TLAB" class="headerlink" title="补充–为对象分配内存：TLAB"></a>补充–为对象分配内存：TLAB</h3><p>TLAB：Thread Local Allocation Buffer</p><p><strong>为什么有TLAB：</strong></p><ul><li>堆区是线程共享区域</li><li>为避免多个线程操作同一地址，需要使用<strong>加锁等机制</strong>，进而影响分配速度</li></ul><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/08/mxIDtbTOr98f4Zv.png" alt="image-20231008105930045" style="zoom:50%"><p><strong>什么是TLAB：</strong></p><ul><li><strong>JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内</strong></li><li>多线程分配内存时，可以避免一系列线程安全问题，还能提升内存分配吞吐量，这种内存分配方式称之为<strong>快速分配策略</strong></li><li>几乎所有OpenJDK衍生出来的JVM都提供了TLAB的设计</li><li>当一个线程TLAB存满时，可以使用公共（蓝色）区域</li></ul><p><strong>TLAB的一些说明：</strong></p><ul><li>不是所有的对象都能够在TLAB中成功分配内存，但<strong>JVM将TLAB作为内存分配的首选</strong></li><li><code>-XX:+UseTLAB</code>设置是否开启TLAB空间（默认开启）</li><li>默认仅占Eden空间的1%，可以通过选项<code>-XX:TLABWasteTargetPercent</code>设置百分比大小</li><li>如果在TLAB空间分配内存失败，JVM就会尝试着通过<strong>使用加锁机制确保数据操作的原子性</strong>，直接在Eden空间中分配内存</li></ul><p><strong>总结：TLAB分配过程</strong></p><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/08/7fa3OPGANyZhWEX.png" alt="image-20231008110539549"></p><h3 id="小结–参数设置"><a href="#小结–参数设置" class="headerlink" title="小结–参数设置"></a>小结–参数设置</h3><blockquote><p><strong>官方文档</strong>：<a class="link" target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></blockquote><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-XX:+PrintFlagsInitial</td><td>查看所有参数的默认值</td></tr><tr><td>-XX:+PrintFlagsFinal</td><td>查看所有参数的最终值</td></tr><tr><td>-Xms</td><td>初始堆空间大小（默认物理内存1/64）</td></tr><tr><td>-Xmx</td><td>最大堆空间大小（默认物理内存1/4）</td></tr><tr><td>-Xmn</td><td>新生代大小（初始和最大都是）</td></tr><tr><td>-XX:NewRatio</td><td>新生代大小的占比（默认值2，新生代占1/3）</td></tr><tr><td>-XX:SurvivorRatio</td><td>Eden和S0/S1空间的比例（默认8，8:1:1）</td></tr><tr><td>-XX:MaxTenuringThreshold</td><td>新生代最大年龄</td></tr><tr><td>-XX:+PrintGCDetails</td><td>输出详细的GC日志</td></tr><tr><td>-XX:+PrintGC 或 -verbose:gc</td><td>输出简化的GC日志</td></tr><tr><td>-XX:HandlePromotionFailure</td><td>是否设置<strong>空间分配担保</strong></td></tr></tbody></table><p><strong>什么是空间分配担保</strong></p><p>Minor GC之前，JVM会检查老年代<strong>最大可用的连续空间</strong>，是否大于<strong>新生代所有对象的总空间</strong></p><p>如果大于，此次GC是安全的</p><p>如果小于：</p><ul><li>如果<code>HandlePromotionFailure=true</code>，继续检查老年代<strong>最大可用连续空间</strong>是否大于<strong>历次晋升到老年代的平均大小</strong><ul><li>如果大于，则尝试进行一次Minor GC，这次GC仍然是有风险的</li><li>如果小于，则进行一次Full GC</li></ul></li><li>如果<code>HandlePromotionFailure=false</code>，则进行一次Full GC</li></ul><blockquote><p>jdk7之后，这个参数已经失效了</p><p>现在：只要老年代的<strong>连续空间</strong>大于新生代对象<strong>总大小</strong>或者<strong>历次晋升的平均大小</strong>就会进行Minor GC，否则将进行Full GC</p><p>也即默认为true</p></blockquote><p><strong>具体查看某个参数的指令：</strong></p><p><code>jps</code>：查看当前运行的进程</p><p><code>jinfo -flag SurvivorRatio 进程id</code>：查看某个参数的值</p><h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>堆是分配对象唯一选择吗？在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：</p><ol><li>随着JIT编译期的发展与<strong>逃逸分析技术</strong>逐渐成熟，<strong>栈上分配、标量替换</strong>优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</li><li>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是<strong>如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配</strong>。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</li><li>此外，前面提到的基于OpenJDK深度定制的TaoBao VM，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。</li></ol><h4 id="什么是逃逸分析"><a href="#什么是逃逸分析" class="headerlink" title="什么是逃逸分析"></a>什么是逃逸分析</h4><ol><li>将堆上的对象分配到栈，需要使用逃逸分析手段。</li><li>这是一种可以有效减少Java程序中，同步负载和内存堆分配压力的，跨函数全局数据流分析算法。</li><li>通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围，从而决定是否要将这个对象分配到堆上。</li><li>逃逸分析的基本行为就是分析对象动态作用域：<ul><li>当一个对象在方法中被定义后，<strong>对象只在方法内部使用</strong>，则认为没有发生逃逸。</li><li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</li></ul></li></ol><h4 id="逃逸举例"><a href="#逃逸举例" class="headerlink" title="逃逸举例"></a>逃逸举例</h4><ol><li>没有发生逃逸，可以分配到栈上。方法执行结束，栈空间就被移除（无需GC）</li></ol><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">my_method</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">V</span>();</span><br><span class="line">    <span class="comment">// use v</span></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    v = <span class="literal">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><ol start="2"><li>StringBuffer sb 发生了逃逸，不能在栈上分配</li></ol><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title function_">createStringBuffer</span><span class="params">(String s1, String s2)</span> {</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><ol start="3"><li>想要StringBuffer sb不发生逃逸，进行优化</li></ol><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createStringBuffer</span><span class="params">(String s1, String s2)</span> {</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p><strong>参数设置：</strong></p><ul><li><p>在JDK 1.7 版本之后，HotSpot中默认就已经开启了逃逸分析</p></li><li><p><code>-XX:+DoEscapeAnalysis</code>：显式开启逃逸分析</p></li><li><p><code>-XX:+PrintEscapeAnalysis</code>：查看逃逸分析的筛选结果</p></li></ul><blockquote><p>总结：能使用局部变量，就不要在方法外部定义</p></blockquote><h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><h5 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h5><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -Xmx128m -Xms128m -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackAllocation</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) {</span><br><span class="line">            alloc();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 查看执行时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"花费的时间为： "</span> + (end - start) + <span class="string">" ms"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 为了方便查看堆内存中对象个数，线程sleep</span></span><br><span class="line">        Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(); <span class="comment">// 未发生逃逸</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><ul><li><code>-XX:-DoEscapeAnalysis</code>关闭逃逸分析，进行了垃圾回收，速度较慢</li></ul><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 33280K-&gt;872K(38400K)] 33280K-&gt;880K(125952K), 0.0013246 secs]</span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 34152K-&gt;808K(38400K)] 34160K-&gt;816K(125952K), 0.0007481 secs]</span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 34088K-&gt;808K(38400K)] 34096K-&gt;816K(125952K), 0.0010414 secs]</span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 34088K-&gt;840K(38400K)] 34096K-&gt;848K(125952K), 0.0005889 secs]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">花费的时间为： 27 ms</span></span><br></pre></td></tr></table></figure></div><p><code>-XX:+DoEscapeAnalysis</code>开启逃逸分析，没有进行垃圾回收，速度快很多</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">花费的时间为： 2 ms</span></span><br></pre></td></tr></table></figure></div><h5 id="同步省略"><a href="#同步省略" class="headerlink" title="同步省略"></a>同步省略</h5><ul><li><p>如果一个对象被发现只能从一个线程中被访问到，那么对于这个对象的操作可以不考虑同步</p></li><li><p>在动态编译同步块的时候，JIT编译器可以<strong>借助逃逸分析</strong>来<strong>判断同步块所使用的锁对象是否只能够被一个线程访问</strong>而没有被发布到其他线程</p></li><li><p>如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个<strong>取消同步的过程就叫同步省略，也叫锁消除</strong></p></li></ul><p>例如，下面的代码</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void f() {</span><br><span class="line">    Object hollis = new Object();</span><br><span class="line">    synchronized(hollis) {</span><br><span class="line">        System.out.println(hollis);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p>但是hollis对象的生命周期只在方法中，并不会被其他线程所访问到。在<strong>JIT编译阶段</strong>会被优化掉，优化成：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void f() {</span><br><span class="line">    Object hellis = new Object();</span><br><span class="line">	System.out.println(hellis);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p>通过反编译字节码可以看到，依然有加锁（monitorenter，monitorexit），<strong>同步省略操作是在解释运行时发生的</strong></p><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/08/6prefdBtDQRchE3.png" alt="image-20231008173809164"></p><h5 id="标量替换"><a href="#标量替换" class="headerlink" title="标量替换"></a>标量替换</h5><ul><li><p>标量（scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量</p></li><li><p>相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量</p></li><li><p>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换</p></li></ul><p><strong>代码举例</strong></p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">Point</span> <span class="variable">point</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">"point.x"</span> + point.x + <span class="string">";point.y"</span> + point.y);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p>以上代码，经过标量替换后，就会变成</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">"point.x = "</span> + x + <span class="string">"; point.y="</span> + y);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p>Point经过逃逸分析后，发现他并没有逃逸，就被替换成两个聚合量了。不再需要分配堆内存，大大减少堆内存的占用。</p><p><strong>实际测试</strong></p><p><code>-XX:+ElimilnateAllocations</code>：是否开启标量替换（默认打开）</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:-EliminateAllocations</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScalarReplace</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> {</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line">        <span class="keyword">public</span> String name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(); <span class="comment">// 未发生逃逸</span></span><br><span class="line">        u.id = <span class="number">5</span>;</span><br><span class="line">        u.name = <span class="string">"www.atguigu.com"</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) {</span><br><span class="line">            alloc();</span><br><span class="line">        }</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"花费的时间为： "</span> + (end - start) + <span class="string">" ms"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><ul><li><code>-XX:-ElimilnateAllocations</code>：关闭标量替换，进行了垃圾回收</li></ul><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure)  25600K-&gt;944K(98304K), 0.0008014 secs]</span><br><span class="line">[GC (Allocation Failure)  26544K-&gt;864K(98304K), 0.0007089 secs]</span><br><span class="line">[GC (Allocation Failure)  26464K-&gt;848K(98304K), 0.0008019 secs]</span><br><span class="line">[GC (Allocation Failure)  26448K-&gt;912K(98304K), 0.0007006 secs]</span><br><span class="line">[GC (Allocation Failure)  26512K-&gt;864K(98304K), 0.0006461 secs]</span><br><span class="line">[GC (Allocation Failure)  26464K-&gt;816K(101376K), 0.0007875 secs]</span><br><span class="line">[GC (Allocation Failure)  32560K-&gt;712K(100864K), 0.0005971 secs]</span><br><span class="line">[GC (Allocation Failure)  32456K-&gt;712K(100864K), 0.0008559 secs]</span><br><span class="line">花费的时间为： 43 ms</span><br></pre></td></tr></table></figure></div><ul><li><code>-XX:+ElimilnateAllocations</code>：开启标量替换，未进行垃圾回收</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 花费的时间为： 3 ms</span><br></pre></td></tr></table></figure></div><h4 id="逃逸分析并不成熟"><a href="#逃逸分析并不成熟" class="headerlink" title="逃逸分析并不成熟"></a>逃逸分析并不成熟</h4><p>关于逃逸分析的论文在1999年就已经发表了，但直到JDK1.6才有实现，而且这项技术到如今也并不是十分成熟。</p><p>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。</p><p>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</p><p>虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段。</p><p>注意到有一些观点，认为通过逃逸分析，<strong>JVM会在栈上分配那些不会逃逸的对象（no）</strong>，这在理论上是可行的，但是取决于JVM设计者的选择。据我所知，<strong>Oracle Hotspot JVM中并未这么做</strong>，这一点在逃逸分析相关的文档里已经说明，<strong>所以可以明确所有的对象实例都是创建在堆上。</strong></p><p>目前很多书籍还是基于JDK7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：<strong>对象实例都是分配在堆上。</strong></p><h3 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h3><ul><li><p>年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。</p></li><li><p>老年代放置长生命周期的对象，通常都是从Survivor区域筛选拷贝过来的Java对象。当然，也有特殊情况，我们知道普通的对象可能会被分配在TLAB上；如果对象较大，无法分配在 TLAB 上，则JVM会试图直接分配在Eden其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。</p></li><li><p>当GC只发生在年轻代中，回收年轻代对象的行为被称为Minor GC。当GC发生在老年代时则被称为Major GC或者Full GC。一般的，Minor GC的发生频率要比Major GC高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。</p></li></ul><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><h3 id="栈-堆-方法区的交互关系"><a href="#栈-堆-方法区的交互关系" class="headerlink" title="栈-堆-方法区的交互关系"></a>栈-堆-方法区的交互关系</h3><p><strong>从线程共享与否来看</strong></p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/08/Kd7hzyTcmxQpI3w.png" alt="image-20231008195556409" style="zoom:50%"><p><strong>从代码角度来看</strong></p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/08/ux61nPp3ZWMyhBJ.png" alt="image-20231008195848376" style="zoom:25%"><h3 id="方法区的理解"><a href="#方法区的理解" class="headerlink" title="方法区的理解"></a>方法区的理解</h3><blockquote><p><strong>官方文档</strong>：<a class="link" target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></blockquote><ul><li><p>可以看作是，一块独立于Java堆的内存空间</p></li><li><p>方法区主要存放Class，堆主要存放实例化的对象</p></li><li><p>方法区在JVM启动的时候被创建，它的实际的物理内存和Java堆区一样，都可以是不连续的</p></li><li><p>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展</p></li><li><p>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，JVM同样会抛出OOM</p><ul><li><p>JDK8以前：<code>java.lang.OutofMemoryError:PermGen space</code></p></li><li><p>JDK8及以后：<code>java.lang.OutOfMemoryError:Metaspace</code></p></li><li><p>加载大量的第三方的jar包</p></li><li><p>Tomcat部署的工程过多（30~50个）</p></li><li><p>大量动态的生成反射类</p></li></ul></li><li><p>关闭JVM就会释放这个区域的内存</p></li></ul><h3 id="Hotspot中方法区的演进"><a href="#Hotspot中方法区的演进" class="headerlink" title="Hotspot中方法区的演进"></a>Hotspot中方法区的演进</h3><ul><li>JDK8之前，习惯上把方法区称为永久代。JDK8开始使用元空间取代了永久代<ul><li>现在来看，使用永久代并不是好的做法，容易导致程序OOM（超过XX:MaxPermSize上限）</li></ul></li><li>永久代/元空间，都是对JVM规范中方法区的实现。区别在于：<strong>元空间不在虚拟机设置的内存中，而是使用本地内存</strong></li></ul><h3 id="设置方法区大小与OOM"><a href="#设置方法区大小与OOM" class="headerlink" title="设置方法区大小与OOM"></a>设置方法区大小与OOM</h3><p>方法区的大小不必是固定的，JVM可以根据应用的需要动态调整</p><p><strong>JDK8及以后（元空间）</strong></p><ul><li>元空间大小由<code>-XX:MetaspaceSize</code>和<code>-XX:MaxMetaspaceSize</code>指定<ul><li>默认值依赖于平台，windows 64位下：</li><li>MetaspaceSize约为21MB</li><li>MaxMetaspaceSize值为-1，即没有限制</li></ul></li><li>默认情况下，JVM会耗尽所有的可用系统内存。如果元数据区发生溢出，JVM会抛出异常<code>OutOfMemoryError:Metaspace</code></li><li>对一个64位的服务器端JVM来说，元空间初始大小一般为21MB。<ul><li>一旦触及这个水位线，Full GC将触发并卸载没用的类。这个高水位线将被重置。</li><li>如果释放的空间不足，会适当提高该值</li><li>如果释放的空间过多，则适当降低改值</li></ul></li><li>为避免频繁GC，建议将<code>-XX:MetaspaceSize</code>设置为一个相对较高的值</li></ul><h4 id="方法区OOM代码举例"><a href="#方法区OOM代码举例" class="headerlink" title="方法区OOM代码举例"></a>方法区OOM代码举例</h4><p>方法一：借助CGLib使得方法区出现内存溢出</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -XX:MetaspaceSize=10m -XX:MaxMetaspaceSize=10m</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaMethodAreaOOM</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">            <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">            enhancer.setSuperclass(OOMObject.class);</span><br><span class="line">            enhancer.setUseCache(<span class="literal">false</span>);</span><br><span class="line">            enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">MethodInterceptor</span>() {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, </span></span><br><span class="line"><span class="params">                                        Method method, </span></span><br><span class="line"><span class="params">                                        Object[] args, </span></span><br><span class="line"><span class="params">                                        MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable {</span><br><span class="line">                    <span class="keyword">return</span> proxy.invokeSuper(obj, args);</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">            enhancer.create();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">OOMObject</span> {</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p>方法二：使用二进制字节码来定义类</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -XX:MetaspaceSize=10m -XX:MaxMetaspaceSize=10m</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OOMTest</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">OOMTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OOMTest</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) {</span><br><span class="line">                <span class="comment">//创建ClassWriter对象，用于生成类的二进制字节码</span></span><br><span class="line">                <span class="type">ClassWriter</span> <span class="variable">classWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(<span class="number">0</span>);</span><br><span class="line">                <span class="comment">//指明版本号，修饰符，类名，包名，父类，接口</span></span><br><span class="line">                classWriter.visit(Opcodes.V1_8, </span><br><span class="line">                                  Opcodes.ACC_PUBLIC, </span><br><span class="line">                                  <span class="string">"Class"</span> + i, </span><br><span class="line">                                  <span class="literal">null</span>, </span><br><span class="line">                                  <span class="string">"java/lang/Object"</span>, </span><br><span class="line">                                  <span class="literal">null</span>);</span><br><span class="line">                <span class="comment">//返回byte[]</span></span><br><span class="line">                <span class="type">byte</span>[] code = classWriter.toByteArray();</span><br><span class="line">                <span class="comment">//类的加载</span></span><br><span class="line">                test.defineClass(<span class="string">"Class"</span> + i, code, <span class="number">0</span>, code.length);<span class="comment">//Class对象</span></span><br><span class="line">                j++;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            System.out.println(j);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><h4 id="如何解决OOM"><a href="#如何解决OOM" class="headerlink" title="如何解决OOM"></a>如何解决OOM</h4><blockquote><p>这个属于调优的问题，这里先简单的说一下</p></blockquote><ol><li><p>要解决OOM异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如Eclipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）</p><ul><li><p>内存泄漏：大量的引用指向某些对象，但是这些对象以后不会使用了。但是因为它们还和GC ROOT有关联，所以导致以后这些对象也不会被回收</p></li><li><p>内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GC Roots引用链的信息，就可以比较准确地定位出泄漏代码的位置。</p></li><li><p>如果不存在内存泄漏（对象确实都还必须存活），那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大。从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</p></li></ul></li></ol><h3 id="方法区的内部结构"><a href="#方法区的内部结构" class="headerlink" title="方法区的内部结构"></a>方法区的内部结构</h3><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/11/glFuGkTKZNLrcRS.png" alt="image-20231011145650614" style="zoom:50%"><p>《深入理解Java虚拟机》书中对方法区（Method Area）存储内容描述如下：</p><ul><li>它用于存储已被虚拟机加载的<strong>类型信息、常量、静态变量、JIT编译器编译后的代码缓存</strong>等</li></ul><h4 id="类型-class-信息"><a href="#类型-class-信息" class="headerlink" title="类型(class)信息"></a>类型(class)信息</h4><p>对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储：</p><ol><li>完整名称（包名.类名）</li><li>直接父类的完整有效名（interface或java.lang.Object都没有父类）</li><li>类型的修饰符（public，abstract，final的某个子类）</li><li>实现接口的有序列表</li></ol><h4 id="域-Field-信息"><a href="#域-Field-信息" class="headerlink" title="域(Field)信息"></a>域(Field)信息</h4><blockquote><p>也即成员变量</p></blockquote><ol><li>所有域的相关信息<ul><li>名称</li><li>类型</li><li>修饰符（public，private，protected，static，final，volatile，transient的某个子集）</li></ul></li><li>域的声明顺序</li></ol><h4 id="方法-Method-信息"><a href="#方法-Method-信息" class="headerlink" title="方法(Method)信息"></a>方法(Method)信息</h4><ol><li>名称</li><li>返回类型（包括void，void.class）</li><li>参数的数量和类型（按顺序）</li><li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集）</li><li>方法的字节码，操作数栈大小，局部变量表（abstract和native方法除外）</li><li>异常表（abstract和native方法除外）<ul><li>记录每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li></ul></li></ol><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodInnerStrucTest</span> <span class="keyword">extends</span> <span class="title class_">Object</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;String&gt;, Serializable {</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">"测试方法的内部结构"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器（没有显示声明），方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        System.out.println(<span class="string">"count = "</span> + count);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test2</span><span class="params">(<span class="type">int</span> cal)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">            result = value / cal;</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(String o)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p><code>javap -v -p MethodInnerStrucTest.class &gt; test.txt</code></p><ul><li>反编译字节码文件，并输出值到文本文件中，便于查看。参数-p确保能查看private权限类型的字段或方法</li></ul><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br></pre></td><td class="code"><pre><span class="line">Classfile /C:/Users/xdy/Desktop/learn-jvm/target/classes/org/example/methodArea/MethodInnerStrucTest.class</span><br><span class="line">  Last modified 2023年10月11日; size 1638 bytes</span><br><span class="line">  SHA-256 checksum 411f5a2ceaa376e17b1e5b2e2102ccb64862c8356379cc9f5684cd6242c20cd9</span><br><span class="line">  Compiled from "MethodInnerStrucTest.java"</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">################################ 类型信息：修饰符，全类名，直接父类，实现的接口 #################################</span></span></span><br><span class="line">public class org.example.methodArea.MethodInnerStrucTest extends java.lang.Object implements java.lang.Comparable&lt;java.lang.String&gt;, java.io.Serializable</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: (0x0021) ACC_PUBLIC, ACC_SUPER</span><br><span class="line">  this_class: #17                         // org/example/methodArea/MethodInnerStrucTest</span><br><span class="line">  super_class: #18                        // java/lang/Object</span><br><span class="line">  interfaces: 2, fields: 2, methods: 6, attributes: 2</span><br><span class="line">Constant pool:</span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">1 = Methodref          <span class="comment">#18.#52        // java/lang/Object."&lt;init&gt;":()V</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">2 = Fieldref           <span class="comment">#17.#53        // org/example/methodArea/MethodInnerStrucTest.num:I</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">3 = Fieldref           <span class="comment">#54.#55        // java/lang/System.out:Ljava/io/PrintStream;</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">4 = Class              <span class="comment">#56            // java/lang/StringBuilder</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">5 = Methodref          <span class="comment">#4.#52         // java/lang/StringBuilder."&lt;init&gt;":()V</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">6 = String             <span class="comment">#57            // count =</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">7 = Methodref          <span class="comment">#4.#58         // java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">8 = Methodref          <span class="comment">#4.#59         // java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">9 = Methodref          <span class="comment">#4.#60         // java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">10 = Methodref          <span class="comment">#61.#62        // java/io/PrintStream.println:(Ljava/lang/String;)V</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">11 = Class              <span class="comment">#63            // java/lang/Exception</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">12 = Methodref          <span class="comment">#11.#64        // java/lang/Exception.printStackTrace:()V</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">13 = Class              <span class="comment">#65            // java/lang/String</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">14 = Methodref          <span class="comment">#17.#66        // org/example/methodArea/MethodInnerStrucTest.compareTo:(Ljava/lang/String;)I</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">15 = String             <span class="comment">#67            // 测试方法的内部结构</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">16 = Fieldref           <span class="comment">#17.#68        // org/example/methodArea/MethodInnerStrucTest.str:Ljava/lang/String;</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">17 = Class              <span class="comment">#69            // org/example/methodArea/MethodInnerStrucTest</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">18 = Class              <span class="comment">#70            // java/lang/Object</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">19 = Class              <span class="comment">#71            // java/lang/Comparable</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">20 = Class              <span class="comment">#72            // java/io/Serializable</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">21 = Utf8               num</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">22 = Utf8               I</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">23 = Utf8               str</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">24 = Utf8               Ljava/lang/String;</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">25 = Utf8               &lt;init&gt;</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">26 = Utf8               ()V</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">27 = Utf8               Code</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">28 = Utf8               LineNumberTable</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">29 = Utf8               LocalVariableTable</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">30 = Utf8               this</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">31 = Utf8               Lorg/example/methodArea/MethodInnerStrucTest;</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">32 = Utf8               test1</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">33 = Utf8               count</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">34 = Utf8               test2</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">35 = Utf8               (I)I</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">36 = Utf8               value</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">37 = Utf8               e</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">38 = Utf8               Ljava/lang/Exception;</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">39 = Utf8               cal</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">40 = Utf8               result</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">41 = Utf8               StackMapTable</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">42 = Class              <span class="comment">#63            // java/lang/Exception</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">43 = Utf8               compareTo</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">44 = Utf8               (Ljava/lang/String;)I</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">45 = Utf8               o</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">46 = Utf8               (Ljava/lang/Object;)I</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">47 = Utf8               &lt;clinit&gt;</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">48 = Utf8               Signature</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">49 = Utf8               Ljava/lang/Object;Ljava/lang/Comparable&lt;Ljava/lang/String;&gt;;Ljava/io/Serializable;</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">50 = Utf8               SourceFile</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">51 = Utf8               MethodInnerStrucTest.java</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">52 = NameAndType        <span class="comment">#25:#26        // "&lt;init&gt;":()V</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">53 = NameAndType        <span class="comment">#21:#22        // num:I</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">54 = Class              <span class="comment">#73            // java/lang/System</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">55 = NameAndType        <span class="comment">#74:#75        // out:Ljava/io/PrintStream;</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">56 = Utf8               java/lang/StringBuilder</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">57 = Utf8               count =</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">58 = NameAndType        <span class="comment">#76:#77        // append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">59 = NameAndType        <span class="comment">#76:#78        // append:(I)Ljava/lang/StringBuilder;</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">60 = NameAndType        <span class="comment">#79:#80        // toString:()Ljava/lang/String;</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">61 = Class              <span class="comment">#81            // java/io/PrintStream</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">62 = NameAndType        <span class="comment">#82:#83        // println:(Ljava/lang/String;)V</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">63 = Utf8               java/lang/Exception</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">64 = NameAndType        <span class="comment">#84:#26        // printStackTrace:()V</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">65 = Utf8               java/lang/String</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">66 = NameAndType        <span class="comment">#43:#44        // compareTo:(Ljava/lang/String;)I</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">67 = Utf8               测试方法的内部结构</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">68 = NameAndType        <span class="comment">#23:#24        // str:Ljava/lang/String;</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">69 = Utf8               org/example/methodArea/MethodInnerStrucTest</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">70 = Utf8               java/lang/Object</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">71 = Utf8               java/lang/Comparable</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">72 = Utf8               java/io/Serializable</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">73 = Utf8               java/lang/System</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">74 = Utf8               out</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">75 = Utf8               Ljava/io/PrintStream;</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">76 = Utf8               append</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">77 = Utf8               (Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">78 = Utf8               (I)Ljava/lang/StringBuilder;</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">79 = Utf8               toString</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">80 = Utf8               ()Ljava/lang/String;</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">81 = Utf8               java/io/PrintStream</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">82 = Utf8               println</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">83 = Utf8               (Ljava/lang/String;)V</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">84 = Utf8               printStackTrace</span></span><br><span class="line">{</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">################################ 域信息 #################################</span></span></span><br><span class="line">  public int num;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: (0x0001) ACC_PUBLIC</span><br><span class="line"></span><br><span class="line">  private static java.lang.String str;</span><br><span class="line">    descriptor: Ljava/lang/String;</span><br><span class="line">    flags: (0x000a) ACC_PRIVATE, ACC_STATIC</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">################### 方法信息（包括构造器），操作数栈大小，参数数量，局部变量表，异常表 ####################</span></span></span><br><span class="line">  public org.example.methodArea.MethodInnerStrucTest();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (0x0001) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">         4: aload_0</span><br><span class="line">         5: bipush        10</span><br><span class="line">         7: putfield      #2                  // Field num:I</span><br><span class="line">        10: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 13: 0</span><br><span class="line">        line 15: 4</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      11     0  this   Lorg/example/methodArea/MethodInnerStrucTest;</span><br><span class="line"></span><br><span class="line">  public void test1();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (0x0001) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=3, locals=2, args_size=1</span><br><span class="line">         0: bipush        20</span><br><span class="line">         2: istore_1</span><br><span class="line">         3: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         6: new           #4                  // class java/lang/StringBuilder</span><br><span class="line">         9: dup</span><br><span class="line">        10: invokespecial #5                  // Method java/lang/StringBuilder."&lt;init&gt;":()V</span><br><span class="line">        13: ldc           #6                  // String count =</span><br><span class="line">        15: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">        18: iload_1</span><br><span class="line">        19: invokevirtual #8                  // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span><br><span class="line">        22: invokevirtual #9                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">        25: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        28: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 20: 0</span><br><span class="line">        line 21: 3</span><br><span class="line">        line 22: 28</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      29     0  this   Lorg/example/methodArea/MethodInnerStrucTest;</span><br><span class="line">            3      26     1 count   I</span><br><span class="line"></span><br><span class="line">  public static int test2(int);</span><br><span class="line">    descriptor: (I)I</span><br><span class="line">    flags: (0x0009) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=3, args_size=1</span><br><span class="line">         0: iconst_0</span><br><span class="line">         1: istore_1</span><br><span class="line">         2: bipush        30</span><br><span class="line">         4: istore_2</span><br><span class="line">         5: iload_2</span><br><span class="line">         6: iload_0</span><br><span class="line">         7: idiv</span><br><span class="line">         8: istore_1</span><br><span class="line">         9: goto          17</span><br><span class="line">        12: astore_2</span><br><span class="line">        13: aload_2</span><br><span class="line">        14: invokevirtual #12                 // Method java/lang/Exception.printStackTrace:()V</span><br><span class="line">        17: iload_1</span><br><span class="line">        18: ireturn</span><br><span class="line">      Exception table:</span><br><span class="line">         from    to  target type</span><br><span class="line">             2     9    12   Class java/lang/Exception</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 25: 0</span><br><span class="line">        line 27: 2</span><br><span class="line">        line 28: 5</span><br><span class="line">        line 31: 9</span><br><span class="line">        line 29: 12</span><br><span class="line">        line 30: 13</span><br><span class="line">        line 32: 17</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            5       4     2 value   I</span><br><span class="line">           13       4     2     e   Ljava/lang/Exception;</span><br><span class="line">            0      19     0   cal   I</span><br><span class="line">            2      17     1 result   I</span><br><span class="line">      StackMapTable: number_of_entries = 2</span><br><span class="line">        frame_type = 255 /* full_frame */</span><br><span class="line">          offset_delta = 12</span><br><span class="line">          locals = [ int, int ]</span><br><span class="line">          stack = [ class java/lang/Exception ]</span><br><span class="line">        frame_type = 4 /* same */</span><br><span class="line"></span><br><span class="line">  public int compareTo(java.lang.String);</span><br><span class="line">    descriptor: (Ljava/lang/String;)I</span><br><span class="line">    flags: (0x0001) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=2, args_size=2</span><br><span class="line">         0: iconst_0</span><br><span class="line">         1: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 37: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       2     0  this   Lorg/example/methodArea/MethodInnerStrucTest;</span><br><span class="line">            0       2     1     o   Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">  public int compareTo(java.lang.Object);</span><br><span class="line">    descriptor: (Ljava/lang/Object;)I</span><br><span class="line">    flags: (0x1041) ACC_PUBLIC, ACC_BRIDGE, ACC_SYNTHETIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=2, args_size=2</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: aload_1</span><br><span class="line">         2: checkcast     #13                 // class java/lang/String</span><br><span class="line">         5: invokevirtual #14                 // Method compareTo:(Ljava/lang/String;)I</span><br><span class="line">         8: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 13: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       9     0  this   Lorg/example/methodArea/MethodInnerStrucTest;</span><br><span class="line"></span><br><span class="line">  static {};</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (0x0008) ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=0, args_size=0</span><br><span class="line">         0: ldc           #15                 // String 测试方法的内部结构</span><br><span class="line">         2: putstatic     #16                 // Field str:Ljava/lang/String;</span><br><span class="line">         5: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 16: 0</span><br><span class="line">}</span><br><span class="line">Signature: #49                          // Ljava/lang/Object;Ljava/lang/Comparable&lt;Ljava/lang/String;&gt;;Ljava/io/Serializable;</span><br><span class="line">SourceFile: "MethodInnerStrucTest.java"</span><br></pre></td></tr></table></figure></div><h4 id="final-static类变量"><a href="#final-static类变量" class="headerlink" title="final static类变量"></a>final static类变量</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><ul><li><p>静态类变量和类关联在一起，<strong>随着类的加载而加载</strong>（clinit赋值），被所有实例共享</p></li><li><p>全局常量：static final，<strong>在编译时就会被分配</strong></p></li></ul><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">clinit时才会被赋值</span></span><br><span class="line">public static int count;</span><br><span class="line">  descriptor: I</span><br><span class="line">  flags: (0x0009) ACC_PUBLIC, ACC_STATIC</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在编译时就被赋值</span></span><br><span class="line">public static final int number;</span><br><span class="line">  descriptor: I</span><br><span class="line">  flags: (0x0019) ACC_PUBLIC, ACC_STATIC, ACC_FINAL</span><br><span class="line">  ConstantValue: int 2 </span><br></pre></td></tr></table></figure></div><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">【<span class="comment">#5】就是在引用常量池</span></span></span><br><span class="line">10 invokespecial #5 &lt;java/lang/StringBuilder.&lt;init&gt;&gt;</span><br></pre></td></tr></table></figure></div><ul><li><p>方法区中，包含<strong>运行时常量池</strong></p></li><li><p>字节码文件中，包含<strong>常量池</strong></p></li></ul><p><strong>常量池</strong></p><ul><li>字节码文件中，包含常量池（Constant Pool Table），包含各种字面量、对类型的符号引用、对域的符号引用、对方法的符号引用</li></ul><p><strong>为什么需要常量池</strong></p><ul><li>如果不用常量池，就需要在所有地方全写一遍，造成臃肿</li><li>需要用到的结构信息记录在常量池中，并通过<strong>引用的方式</strong>，来加载、调用所需的结构（减少代码大小）</li></ul><p><strong>常量池中有什么</strong></p><ol><li>数量值</li><li>字符串值</li><li>类引用</li><li>字段引用</li><li>方法引用</li></ol><p><strong>运行时常量池</strong></p><ol><li><p>运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。</p></li><li><p>运行时常量池就是常量池在程序运行时的称呼</p></li><li><p>JVM为每个已加载的类型（类或接口）都维护一个常量池</p></li><li><p>运行时常量池，相对于常量池的另一重要特征是：具备动态性（<code>String.intern</code>）</p><ul><li><p>运行时常量池中包含多种不同的常量，包括：</p><ul><li><p>编译期就已经明确的数值字面量</p></li><li><p>运行期解析后才能够获得的方法或者字段引用<strong>（此时不再是常量池中的符号地址了，这里换为真实地址）</strong></p></li></ul></li></ul></li><li><p>当创建类或接口的运行时常量池时，如果所需的内存超过了方法区所能提供的最大值，JVM会抛OutofMemoryError异常。</p></li></ol><h3 id="方法区使用举例"><a href="#方法区使用举例" class="headerlink" title="方法区使用举例"></a>方法区使用举例</h3><ul><li>原始代码</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodAreaDemo</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> x / y;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">        System.out.println(a + b);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><ul><li>字节码文件（常量池部分）</li></ul><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">1 = Methodref          <span class="comment">#5.#24         // java/lang/Object."&lt;init&gt;":()V</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">2 = Fieldref           <span class="comment">#25.#26        // java/lang/System.out:Ljava/io/PrintStream;</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">3 = Methodref          <span class="comment">#27.#28        // java/io/PrintStream.println:(I)V</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">4 = Class              <span class="comment">#29            // org/example/methodArea/MethodAreaDemo</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">5 = Class              <span class="comment">#30            // java/lang/Object</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">6 = Utf8               &lt;init&gt;</span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">7 = Utf8               ()V</span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">8 = Utf8               Code</span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">9 = Utf8               LineNumberTable</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">10 = Utf8               LocalVariableTable</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">11 = Utf8               this</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">12 = Utf8               Lorg/example/methodArea/MethodAreaDemo;</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">13 = Utf8               main</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">14 = Utf8               ([Ljava/lang/String;)V</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">15 = Utf8               args</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">16 = Utf8               [Ljava/lang/String;</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">17 = Utf8               x</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">18 = Utf8               I</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">19 = Utf8               y</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">20 = Utf8               a</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">21 = Utf8               b</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">22 = Utf8               SourceFile</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">23 = Utf8               MethodAreaDemo.java</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">24 = NameAndType        <span class="comment">#6:#7          // "&lt;init&gt;":()V</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">25 = Class              <span class="comment">#31            // java/lang/System</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">26 = NameAndType        <span class="comment">#32:#33        // out:Ljava/io/PrintStream;</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">27 = Class              <span class="comment">#34            // java/io/PrintStream</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">28 = NameAndType        <span class="comment">#35:#36        // println:(I)V</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">29 = Utf8               org/example/methodArea/MethodAreaDemo</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">30 = Utf8               java/lang/Object</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">31 = Utf8               java/lang/System</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">32 = Utf8               out</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">33 = Utf8               Ljava/io/PrintStream;</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">34 = Utf8               java/io/PrintStream</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">35 = Utf8               println</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">36 = Utf8               (I)V</span></span><br></pre></td></tr></table></figure></div><ul><li>字节码文件（main函数部分）</li></ul><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">  descriptor: ([Ljava/lang/String;)V</span><br><span class="line">  flags: (0x0009) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=3, locals=5, args_size=1</span><br><span class="line">       0: sipush        500</span><br><span class="line">       3: istore_1</span><br><span class="line">       4: bipush        100</span><br><span class="line">       6: istore_2</span><br><span class="line">       7: iload_1</span><br><span class="line">       8: iload_2</span><br><span class="line">       9: idiv</span><br><span class="line">      10: istore_3</span><br><span class="line">      11: bipush        50</span><br><span class="line">      13: istore        4</span><br><span class="line">      15: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      18: iload_3</span><br><span class="line">      19: iload         4</span><br><span class="line">      21: iadd</span><br><span class="line">      22: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">      25: return</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line 14: 0</span><br><span class="line">      line 15: 4</span><br><span class="line">      line 16: 7</span><br><span class="line">      line 17: 11</span><br><span class="line">      line 18: 15</span><br><span class="line">      line 19: 25</span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          0      26     0  args   [Ljava/lang/String;</span><br><span class="line">          4      22     1     x   I</span><br><span class="line">          7      19     2     y   I</span><br><span class="line">         11      15     3     a   I</span><br><span class="line">         15      11     4     b   I</span><br></pre></td></tr></table></figure></div><ul><li>500放入操作数栈中</li></ul><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/11/xuVFpGjWPfREY7J.png" alt="image-20231011170048982" style="zoom:38%"><ul><li>弹出操作数栈顶，保存到本地变量表中：位置1（因为main是静态方法，所以没有this）</li></ul><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/11/gbFfota7AN4SXzV.png" alt="image-20231011170158483" style="zoom:38%"><ul><li>100放入操作数栈中</li></ul><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/11/paV3By1KgCwrAQM.png" alt="image-20231011170440658" style="zoom:50%"><ul><li>弹出操作数栈顶元素，存入本地变量表中：位置2</li></ul><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/11/7PQGbNJfLa6ymZl.png" alt="image-20231011170528373" style="zoom:50%"><ul><li>读取本地变量1，压入操作数栈</li></ul><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/11/Rgakb36Q4qv7wM1.png" alt="image-20231011170628102" style="zoom:50%"><ul><li>读取本地变量2，压入操作数栈</li></ul><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/11/WJnmV4Qwy1F95RO.png" alt="image-20231011170731102" style="zoom:50%"><ul><li>栈顶元素运算，再放回栈顶</li></ul><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/11/kfeOlbZzN9XH14t.png" alt="image-20231011170826400" style="zoom:50%"><ul><li>弹出操作数栈顶元素，存入本地变量表中：位置3</li><li>将50压入操作数栈</li></ul><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/11/YEBtrz2csCWRANy.png" alt="image-20231011171103267" style="zoom:50%"><ul><li>弹出操作数栈顶元素，存入本地变量表中：位置4</li></ul><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/11/tmi7p13ArLMThuV.png" alt="image-20231011171153663" style="zoom:50%"><ul><li>获取常量池中的变量，压入操作数栈中<ul><li><code>#2 = Fieldref #25.#26 // java/lang/System.out:Ljava/io/PrintStream;</code></li><li><code>#25 = Class #31 // java/lang/System</code></li><li><code>#26 = NameAndType #32:#33 // out:Ljava/io/PrintStream;</code></li></ul></li></ul><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/11/6CJ571c9pTbAvfW.png" alt="image-20231011171223405" style="zoom:50%"><ul><li>将本地变量表中：位置3，位置4的元素放入操作数栈中</li><li>栈顶元素运算，再放回栈顶</li><li>调用方法，方法中的参数会从操作数栈中弹出，压入虚拟机栈；虚拟机会开始执行虚拟机栈最上面的栈帧<ul><li><code>#3 = Methodref #27.#28 // java/io/PrintStream.println:(I)V</code></li></ul></li></ul><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/11/R5yLh9WcfbTJiCZ.png" alt="image-20231011171754077" style="zoom:50%"><h3 id="方法区的演进细节"><a href="#方法区的演进细节" class="headerlink" title="方法区的演进细节"></a>方法区的演进细节</h3><p><strong>JDK6</strong></p><ul><li><p>有永久代（permanent generation），静态变量存储在永久代上</p></li><li><p>方法区由永久代实现，使用 JVM 虚拟机内存（虚拟的内存）</p></li></ul><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/11/yR1Wpq6QZ5zVYEC.png" alt="image-20231011172408549" style="zoom:50%"><p><strong>JDK7</strong></p><ul><li><p>有永久代，但已经逐步 “去永久代”</p></li><li><p><strong>字符串常量池，静态变量移除。保存在堆中</strong></p></li><li><p>方法区由永久代实现，使用 JVM 虚拟机内存</p></li></ul><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/11/m8P9UdjxczCiqIH.png" alt="image-20231011172438599" style="zoom:50%"><p><strong>JDK8</strong></p><ul><li><p>无永久代，类型信息、字段、方法、常量保存在本地内存的元空间</p></li><li><p>字符串常量池、静态变量仍然在堆中</p></li><li><p>方法区由元空间实现，使用物理机本地内存</p></li></ul><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/11/OK8wAuV3GsRchdH.png" alt="image-20231011172558701" style="zoom:50%"><h4 id="永久代为什么要被元空间替代？"><a href="#永久代为什么要被元空间替代？" class="headerlink" title="永久代为什么要被元空间替代？"></a>永久代为什么要被元空间替代？</h4><blockquote><p><strong>官方文档</strong>：<a class="link" target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/122">http://openjdk.java.net/jeps/122 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></blockquote><ul><li>Java8中移除了永久代。其中的元数据被移到了堆之外，元空间（MetaSpace）中</li><li>元空间使用物理内存，最大可用空间就是系统可用空间</li><li>改动原因：<ul><li>永久代很难确定大小。在某些场景下，如果动态加载类过多，容易产生永久代的OOM、</li><li>永久代调优很困难<ul><li>方法区的垃圾收集主要有两部分，常量池中：废弃的常量，不再用的类型</li><li>一般来说，这个区域的回收效果难令人满意，尤其是类型的卸载，条件相当苛刻</li></ul></li></ul></li></ul><h4 id="字符串常量池为什么调整位置"><a href="#字符串常量池为什么调整位置" class="headerlink" title="字符串常量池为什么调整位置"></a>字符串常量池为什么调整位置</h4><ul><li>JDK7中将StringTable放到了堆空间中</li></ul><p>因为永久代的回收效率很低，<strong>在Full GC的时候才会执行永久代的垃圾回收</strong>。</p><p>而Full GC是老年代的空间不足、永久代不足时才会触发。</p><p>这就导致StringTable回收效率不高，而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。</p><p>放到堆里，能及时回收内存。</p><h4 id="静态变量放在哪里？"><a href="#静态变量放在哪里？" class="headerlink" title="静态变量放在哪里？"></a>静态变量放在哪里？</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JDK7：-Xms200m -Xmx200m -XX:PermSize=300m -XX:MaxPermSize=300m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> * JDK8：-Xms200m -Xmx200m -XX:MetaspaceSize=300m -XX:MaxMetaspaceSize=300m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticFieldTest</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] arr = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">100</span>]; <span class="comment">// 100MB</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><ul><li><p>对象实例（也就是这个<code>new byte[1024 * 1024 * 100]</code>）无论如何都存在堆空间</p></li><li><p>静态变量（这个对象）在JDK6，JDK7，JDK8存放位置中有所变化</p><ul><li>JDK6：方法区中（永久代实现）</li><li>JDK7：堆空间中</li><li>JDK8：堆空间（元空间中）</li></ul></li></ul><h3 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h3><ul><li>《Java虚拟机规范》对方法区的约束非常宽松，不要求JVM在方法区中实现GC。确实有未实现方法区<strong>类型卸载</strong>的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）。方法区GC效果难令人满意，尤其是类型的卸载，条件相当苛刻。</li><li>方法区的GC主要回收两部分，常量池中：<strong>废弃的常量</strong>、<strong>不再使用的类型</strong></li></ul><h4 id="常量的回收"><a href="#常量的回收" class="headerlink" title="常量的回收"></a>常量的回收</h4><ul><li><p>方法区内常量池之中主要存放的两大类常量：<strong>字面量</strong>和<strong>符号引用</strong></p><ul><li>字面量：如文本字符串、被声明为final的常量值等</li><li>符号引用：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符</li></ul></li><li><p>HotSpot虚拟机，对常量池的GC策略：<strong>常量没有被任何地方引用，就可以被回收</strong></p></li><li><p>回收废弃常量比较简单</p></li></ul><h4 id="类的卸载"><a href="#类的卸载" class="headerlink" title="类的卸载"></a>类的卸载</h4><ul><li>判断常量是否废弃很简单，判断类型是否不再使用很困难<ul><li>该类所有实例（包括派生类）都被回收</li><li>加载该类的类加载器已被回收（这个条件除非特殊设计，不然很难触发）</li><li>该类的java.lang.Class对象没有在任何地方被引用（无法在任何地方反射访问此类）</li></ul></li><li>JVM“被允许”对无用的类进行回收（不是必然被回收），HotSpot虚拟机<ul><li><code>-Xnoclassgc</code>：不对方法区进行垃圾回收</li><li><code>-verbose:class</code>：输出JVM载入类的相关信息</li><li><code>-XX:+TraceClassLoading</code>：同上，监控类的加载</li><li><code>-XX:+TraceClassUnLoading</code>：监控类的卸载</li></ul></li><li>在大量使用：反射、动态代理、CGLib等字节码框架；动态生成JSP和OSGi等，频繁自定义类加载器的场景中，通常都需要JVM具备类型卸载的能力，以保证不会对方法区造成过大的内存压力</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/12/beZrDIaKn2i8hqw.png" alt="image-20231012201219320" style="zoom:50%"><blockquote><p>栈帧中动态链接，指向常量池中当前方法的引用</p></blockquote><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><ol><li>百度<ul><li>三面：说一下JVM内存模型吧，有哪些区？分别干什么的？</li></ul></li><li>蚂蚁金服：<ul><li>Java8的内存分代改进</li><li>JVM内存分哪几个区，每个区的作用是什么？</li><li>一面：JVM内存分布/内存结构？栈和堆的区别？堆的结构？为什么两个survivor区？</li><li>二面：Eden和survior的比例分配</li></ul></li><li>小米：<ul><li>jvm内存分区，为什么要有新生代和老年代</li></ul></li><li>字节跳动：<ul><li>二面：Java的内存分区</li><li>二面：讲讲vm运行时数据库区</li><li>什么时候对象会进入老年代？</li></ul></li><li>京东：<ul><li>JVM的内存结构，Eden和Survivor比例。</li><li>JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和survivor。</li></ul></li><li>天猫：<ul><li>一面：Jvm内存模型以及分区，需要详细到每个区放什么。</li><li>一面：JVM的内存模型，Java8做了什么改</li></ul></li><li>拼多多：<ul><li>JVM内存分哪几个区，每个区的作用是什么？</li></ul></li><li>美团：<ul><li>java内存分配</li><li>jvm的永久代中会发生垃圾回收吗？</li><li>一面：jvm内存分区，为什么要有新生代和老年代？</li></ul></li></ol><h2 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h2><h3 id="对象的实例化"><a href="#对象的实例化" class="headerlink" title="对象的实例化"></a>对象的实例化</h3><p><strong>对象创建的方式：</strong></p><ol><li>new，最常见的方式<ul><li>变形1：单例类中调用静态类方法，getInstance()</li><li>变形2：XxxBuilder/XxxFactory的静态方法</li></ul></li><li>Class的newInstance()方法，使用反射<ul><li>必须空参，权限必须public</li></ul></li><li>Constructor的newInstance()方法，使用反射<ul><li>可以带参数，权限没有要求</li></ul></li><li>使用clone()，不调用任何构造器，当前类需要实现Cloneable接口</li><li>使用反序列化，从文件或网络中获取对象的二进制流</li><li>使用第三方库（Objenesis），动态生成对象</li></ol><p><strong>对象创建的步骤</strong></p><ol><li>判断对象对应的类是否：加载，链接，初始化<ul><li>虚拟机遇到new指令，检查能否在元空间的常量池中定位到此类的符号引用</li><li>并检查此类是否已被加载、解析、初始化（类的元信息是否存在）</li><li>如果没有，在双亲委派机制下，使用当前类加载器，用包名+类名为key查找对应class文件。找不到文件抛出ClassNotFoundException异常。找到了则进行类加载</li></ul></li><li>为对象分配内存<ul><li>如果内存规整：指针碰撞（Bump The Point）<ul><li>意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针往空闲内存那边挪动一段与对象大小相等的距离罢了</li><li>如果垃圾收集器选择的是Serial ，ParNew这种基于压缩算法的，虚拟机采用这种分配方式</li></ul></li><li>如果内存不规整：空闲列表（Free List）<ul><li>维护一个空闲列表，记录上哪些内存块是可用的</li><li>分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容</li></ul></li></ul></li><li>处理并发安全问题<ul><li>采用CAS+失败重试，保证更新的原子性（乐观锁）</li><li>每个线程预先分配TLAB，通过设置<code>-XX:+UseTLAB</code>参数来设置</li></ul></li><li>初始化分配到的空间（属性的默认初始化，零值）</li><li>设置对象的对象头<ul><li>将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息，等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。</li></ul></li><li>执行init方法进行初始化<ul><li>属性值初始化</li><li>代码块初始化</li><li>构造器初始化</li></ul></li></ol><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/15/ukJCfvYgxNbVZ7r.png" alt="image-20231015223936110"></p><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p><strong>对象头（Header）</strong></p><ol><li><p>运行时元数据</p><ul><li>哈希值（HashCode）：对象在堆空间中都有一个首地址值，引用根据这个地址指向堆中的对象，这就是哈希值起的作用</li><li>GC分代年龄</li><li>锁状态标志</li><li>线程持有的锁</li><li>偏向线程ID</li><li>偏向时间戳</li></ul></li><li><p>类型指针</p><ul><li>指向元空间中，对象所属的类型</li></ul></li><li><p>如果是数组对象，还会记录数组长度</p></li></ol><p><strong>实例数据（Instance Data）</strong></p><p>父类定义的变量、本身定义的变量</p><p>规则：</p><ul><li>父类变量，出现在子类变量之前</li><li>相同宽度的字段总是被分配在一起</li><li>如果CompactFields参数为true（默认true），子类窄变量，可能插入到父类变量的空隙</li></ul><p><strong>对齐填充（Padding）</strong></p><p>没作用，仅是占位符</p><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/15/BF2P874QxCtG3Kd.png" alt="image-20231015224856096"></p><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>JVM如何让通过<strong>栈帧中的对象引用</strong>，访问到<strong>堆空间中的对象实例</strong>的呢？</p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/16/iKB8jCFU4MmqGHp.png" alt="image-20231016112719345" style="zoom:67%"><h3 id="对象访问的方式"><a href="#对象访问的方式" class="headerlink" title="对象访问的方式"></a>对象访问的方式</h3><ul><li>使用直接指针</li></ul><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/16/9soSWhN2aedlUqc.png" alt="image-20231016113123346" style="zoom:67%"><ul><li><p>使用句柄访问（使用句柄池）</p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/16/e1PtFXqTQ56IELk.png" alt="屏幕截图 2023-10-16 112924" style="zoom:67%"></li></ul><h2 id="直接内存（了解）"><a href="#直接内存（了解）" class="headerlink" title="直接内存（了解）"></a>直接内存（了解）</h2><blockquote><p>JDK8引入元空间，就是使用的直接内存</p></blockquote><ul><li>不是虚拟运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域</li><li>直接内存是在Java堆外的、直接向系统申请的内存区间</li><li>来源于NIO，通过存储在堆中的DirectByteBuffer操作Native内存</li><li>读写性能更高<ul><li>出于性能考虑，<strong>读写频繁</strong>的场合考虑使用直接内存</li><li>Java的NIO库允许Java程序使用直接内存，用于数据缓存</li></ul></li><li>也可能导致<code>OutOfMemoryError: Direct buffer memory</code>异常<ul><li>大小受限于系统内存大小</li></ul></li><li>缺点：<ul><li>分配回收成本较高</li><li>不受JVM内存回收管理</li></ul></li><li>也可以设置直接内存的最大值<ul><li>可以通过<code>-XX:MaxDirectMemorySize=10m</code>设置</li><li>如果不指定，默认和堆最大值<code>-Xmx</code>一致</li></ul></li></ul><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferTest</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BUFFER</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 直接分配内存空间</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(BUFFER);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过任务管理器可以看到，内存被占用了1G</span></span><br><span class="line">        System.out.println(<span class="string">"直接内存分配完毕"</span>)</span><br><span class="line">        scanner.next();</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 通过任务管理器可以看到，内存被释放了1G</span></span><br><span class="line">        System.out.println(<span class="string">"直接内存开始释放"</span>);</span><br><span class="line">        byteBuffer = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        scanner.next();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><p>访问直接内存读写性能更高。使用JVM时，读取内存，应用需要从用户态切换到内核态。</p><ul><li><p>读内存时：应用需要，先从用户态的虚拟机内存中读取数据，而此数据需要从内核态的物理内存上获取</p></li><li><p>写内存时：应用需要，先写到用户态的虚拟机内存空间上，然后copy到内核态的本地物理内存上</p></li></ul><p>使用直接内存，则<strong>不会有用户态和内核态的copy</strong>，避免中间商赚差价，读写速度更快</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试：将一个文件复制三次</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferTest1</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_100Mb</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> <span class="string">"D:\\data.nsp"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) {</span><br><span class="line">            <span class="type">String</span> <span class="variable">dest</span> <span class="operator">=</span> <span class="string">"D:\\data"</span> + i + <span class="string">".nsp"</span>;</span><br><span class="line">            sum += directBuffer(src, dest);</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"总时间sum = "</span> + sum);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><ul><li>使用JVM内存做Buffer</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 总时间sum = 26416</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">io</span><span class="params">(String src, String dest)</span> {</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span> (</span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(src);</span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dest);</span><br><span class="line">    ) {</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[_100Mb];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(buffer)) != -<span class="number">1</span>) {</span><br><span class="line">            fos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    }</span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">return</span> end - start;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><ul><li>使用直接内存地址做Buffer</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 总时间sum = 11260</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">directBuffer</span><span class="params">(String src, String dest)</span> {</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span> (</span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(src);</span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dest);</span><br><span class="line"></span><br><span class="line">            <span class="type">FileChannel</span> <span class="variable">inChannel</span> <span class="operator">=</span> fis.getChannel();</span><br><span class="line">            <span class="type">FileChannel</span> <span class="variable">outChannel</span> <span class="operator">=</span> fos.getChannel();</span><br><span class="line">    ) {</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(_100Mb);</span><br><span class="line">        <span class="keyword">while</span> (inChannel.read(byteBuffer) != -<span class="number">1</span>) {</span><br><span class="line">            byteBuffer.flip(); <span class="comment">// 修改为读数据模式</span></span><br><span class="line">            outChannel.write(byteBuffer);</span><br><span class="line">            byteBuffer.clear(); <span class="comment">// 清空</span></span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    }</span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">return</span> end - start;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><h3 id="直接内存溢出实验"><a href="#直接内存溢出实验" class="headerlink" title="直接内存溢出实验"></a>直接内存溢出实验</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -Xmx20m -XX:MaxDirectMemorySize=10m</span></span><br><span class="line"><span class="comment">// 没有OOM：使用UnSafe API分配的内存不受-XX:MaxDirectMemorySize参数的控制</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxDirectMemorySizeTest</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException {</span><br><span class="line">        <span class="type">Field</span> <span class="variable">unsafeField</span> <span class="operator">=</span> Unsafe.class.getDeclaredFields()[<span class="number">0</span>];</span><br><span class="line">        unsafeField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe) unsafeField.get(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">            unsafe.allocateMemory(_1MB);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -Xmx20m -XX:MaxDirectMemorySize=10m</span></span><br><span class="line"><span class="comment">// Exception in thread "main" java.lang.OutOfMemoryError: Direct buffer memory</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxDirectMemorySizeTest</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException {</span><br><span class="line">        ByteBuffer.allocateDirect(<span class="number">128</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><h2 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h2><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/16/azHEeovJcZ7T8UC.png" alt="45792140-cf44-4732-be5b-fe310e7eeb4f" style="zoom:67%"><ul><li>执行引擎包括：解释器、即时编译器、垃圾回收器</li><li>执行引擎的任务：将字节码指令翻译/解释为对应平台上的本地机器指令</li></ul><h3 id="执行引擎的工作流程"><a href="#执行引擎的工作流程" class="headerlink" title="执行引擎的工作流程"></a>执行引擎的工作流程</h3><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/16/O1b7X2tqdnL5Wsv.png" alt="1b540604-7281-467c-b981-acecdbdb93d2" style="zoom:67%"><ul><li>执行什么字节码指令：依赖PC寄存器<ul><li>执行完成后，PC寄存器更新为下一条需要被执行的指令地址</li></ul></li><li>执行过程中，执行引擎会通过：<ul><li>局部变量表中的对象引用，准确定位存储在堆中的<strong>对象实例</strong></li><li>对象头中的元数据指针，准确定位存储在方法区的<strong>对象类型信息</strong></li></ul></li></ul><h3 id="代码编译和执行的过程"><a href="#代码编译和执行的过程" class="headerlink" title="代码编译和执行的过程"></a>代码编译和执行的过程</h3><ol><li>黄色部分：编译生成字节码的过程，javac编译器（前端编译器）完成，与JVM无关</li><li>后面绿色，蓝色部分：解释执行与即时编译，JVM完成</li></ol><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/17/SALcbsheNpGInHT.png" alt="image-20231017112501619" style="zoom:50%"><ol start="3"><li>javac编译器（前端编译器）流程：</li></ol><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/17/1AtecroJOXBxs5R.png" alt="image-20231017112659310" style="zoom:50%"><ol start="4"><li>java字节码执行由JVM执行引擎来完成，流程如下：</li></ol><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/17/UVxXyr5suYw8MAv.png" alt="image-20231017112750802" style="zoom:50%"><h4 id="什么是解释器？什么是JIT编译器？"><a href="#什么是解释器？什么是JIT编译器？" class="headerlink" title="什么是解释器？什么是JIT编译器？"></a>什么是解释器？什么是JIT编译器？</h4><ol><li>解释器：当JVM启动时，会根据预定义的规范对字节码采用<strong>逐行解释的方式执行</strong>，将字节码“翻译”为本地机器指令执行</li><li>JIT编译器：就是虚拟机将源代码<strong>一次性编译成机器语言</strong>，但并不是马上执行</li></ol><h4 id="为什么Java是半编译半解释语言？"><a href="#为什么Java是半编译半解释语言？" class="headerlink" title="为什么Java是半编译半解释语言？"></a>为什么Java是半编译半解释语言？</h4><ol><li>现在JVM在执行时，通常会将解释执行与编译执行结合起来进行</li><li>JIT编译器将字节码翻译成本地代码后，可以做缓存操作，存储在方法区的JIT代码缓存中（执行效率更高了），并且在翻译成本地代码的过程中可以做优化</li></ol><h3 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h3><p><strong>为什么要有解释器：</strong></p><ul><li>JVM设计者们的初衷：跨平台特性，避免由静态编译的方式生成本地机器指令，从而诞生了逐行解释的想法（不产生中间产品）</li></ul><p><strong>解释器的分类：</strong></p><ul><li>Java发展历史中，出现了<strong>字节码解释器</strong>和<strong>模板解释器</strong><ul><li>字节码解释器：通过纯软件代码，模拟字节码的执行，效率低下</li><li>模板解释器：将每一条字节码与一个模板函数关联，模板函数中直接产生执行的机器码，大幅度提高了性能</li></ul></li><li>HotSpot VM中，解释器主要由<strong>Interpreter模块</strong>和<strong>Code模块</strong>构成<ul><li>Interpreter模块：实现解释器的核心功能</li><li>Code模块：用于管理HotSpot VM在运行时生成的本地机器指令</li></ul></li></ul><p><strong>解释器的现状：</strong></p><ul><li>Python、Perl、Ruby等高级语言也是使用解释器的</li><li>为了解决低效的问题，JVM平台支持JIT技术<ul><li>避免函数被解释执行，将整个函数编译成机器码，效率大幅度提升</li></ul></li></ul><h3 id="JIT编译器"><a href="#JIT编译器" class="headerlink" title="JIT编译器"></a>JIT编译器</h3><ul><li>HotSpot VM是高性能虚拟机的代表作之一，<strong>它采用解释器与即时编译器并存的架构</strong></li></ul><blockquote><p>比如：JRockit只部署在服务器上，已经砍掉了解释器</p></blockquote><p><strong>为什么还需要解释器:</strong></p><ul><li>看重启动时间的场景，需要两者并存的架构，来换取一个平衡</li><li>此模式下，解释器可以首先发挥作用，省去编译时间；随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，提高执行效率</li><li>在编译器进行激进优化不成立的时候，作为编译器的“逃生门”（后备方案）</li></ul><p><strong>阿里的案例：</strong></p><ul><li>机器在热机状态（运行了一段时间）可以承受的负载要大于冷机状态</li><li>程序员分批发布时，误分为两批发布。本来热机状态一半的机器可以勉强承载流量。但由于刚启动的JVM均是解释执行，还没有进行热点代码统计和JIT动态编译，导致机器启动之后，当前1/2发布成功的服务器马上全部宕机，<strong>此故障说明了JIT的存在</strong></li></ul><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/17/Tqy54szQFxh7eKi.png" alt="image-20231017190532771" style="zoom:50%"><h4 id="编译器相关概念"><a href="#编译器相关概念" class="headerlink" title="编译器相关概念"></a>编译器相关概念</h4><ol><li>前端编译器：把.java文件转变为.class</li><li>JVM的后端运行期编译器（JIT编译器）：把字节码转变为机器码</li><li>静态提前编译器（AOT编译器）：直接把.java文件编译成本地机器码（后续发展的趋势）</li></ol><blockquote><p>典型的编译器：</p><ol><li>前端编译器：Sun的javac、Eclipse JDT的增量式编译器（ECJ）</li><li>JIT编译器：HotSpot VM的C1、C2编译器</li><li>AOT编译器：GNU Compiler for the Java（GCJ）、Excelsior JET</li></ol></blockquote><h4 id="热点代码及探测方式"><a href="#热点代码及探测方式" class="headerlink" title="热点代码及探测方式"></a>热点代码及探测方式</h4><ul><li><p>在运行时，JIT编译器针对<strong>频繁被调用的热点代码</strong>做出优化，直接编译为机器指令，以提升性能</p><ul><li>这种编译方式发生在方法的执行过程中，因此也被称之为栈上替换（OSR编译，On StackReplacement）</li></ul></li><li><p>目前HotSpot VM所采用的热点探测方式是<strong>基于计数器的热点探测</strong></p></li><li><p>每个函数都建立两个不同类型的计数器</p><ul><li>调用计数器：方法的调用次数</li><li>回边计数器：方法体中，循环体执行的次数</li></ul></li></ul><p><strong>方法调用计数器：</strong></p><ul><li><p>统计方法调用的次数，达到阈值触发JIT编译</p><ul><li>阈值可以用<code>-XX:CompileThreshold</code>来设定</li></ul></li><li><p>方法被调用时，会检查是否存在被JIT编译过的版本</p><ul><li>存在，执行编译后的本地代码</li><li>不存在，计数器加一<ul><li>超过阈值，向JIT编译器提交此方法的代码编译请求</li><li>未超过阈值，对字节码解释执行</li></ul></li></ul></li><li><p>存在<strong>热度衰减</strong>：超过一定的时间，如果调用次数不足以让它提交给JIT编译器编译，那此方法的调用计数器就会减少一半</p><ul><li>可以用<code>-XX:-UseCounterDecay</code>关闭热度衰减（这样绝大多数方法都会被编译成本地方法）</li><li>可以用<code>-XX:CounterHalfLifeTime</code>参数设置半衰期时间，单位是秒</li></ul></li></ul><p><strong>回边计数器：</strong></p><p>统计方法中循环体代码执行的次数，字节码中遇到控制流向后跳转的指令称为“回边”（Back Edge）。建立回边计数器统计的目的就是为了触发OSR编译</p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/18/tiG6rmZPBKqS7A3.png" alt="image-20231018131353630" style="zoom:67%"><h3 id="HotSpot中的程序执行"><a href="#HotSpot中的程序执行" class="headerlink" title="HotSpot中的程序执行"></a>HotSpot中的程序执行</h3><p><strong>设置程序执行的方式：</strong></p><ul><li><code>-Xint</code>：完全采用解释器模式执行</li><li><code>-Xcomp</code>：完全采用JIT编译器模式执行。编译出问题，解释器会介入</li><li><code>-Xmixed</code>：采用解释器+编译器混合的模式执行</li></ul><blockquote><p>-Xint : 6520ms	-Xcomp : 950ms	-Xmixed : 936ms</p><p>实验结论：只用解释器执行是真的慢</p></blockquote><p><strong>HotSpotVM JIT分类</strong>：</p><ol><li><code>-client</code>：Java虚拟机运行在Client模式下，并使用C1编译器<ul><li>C1编译器：对字节码进行简单可靠的优化，编译速度快</li></ul></li><li><code>-server</code>：Java虚拟机运行在Server模式下，并使用C2编译器<ul><li>C2编译器：进行较激进的优化，编译慢但执行效率高</li></ul></li></ol><p><strong>CI和C2编译器不同的优化策略：</strong></p><ul><li>C1编译器：<ul><li>方法内联：将引用函数代码，编译到引用处</li><li>去虚拟化：对唯一实现的方法进行内联</li><li>冗余消除：在运行期间，把一些不会执行的代码折叠掉</li></ul></li><li>C2编译器，优化主要是在全局层面，逃逸分析是优化的基础；基于逃逸分析的优化有：<ul><li>标量替换：用标量值代替聚合对象的属性值</li><li>栈上分配：未逃逸的对象，分配在栈上</li><li>同步消除：清除同步操作，通常指synchronized</li></ul></li></ul><blockquote><p>逃逸分析只有在C2（server）模式下才会触发</p></blockquote><p><strong>分层编译策略：</strong></p><p>不开启性能监控：程序解释执行可以触发C1编译，将字节码编译成机器码</p><p>开启性能监控：C2编译会根据性能监控信息进行激进优化</p><blockquote><p>Java7之后，<code>-server</code>会默认开启分层编译策略，C1和C2协作来完成编译任务</p></blockquote><p><strong>Graal编译器：</strong></p><ul><li>自JDK10起，HotSpot又加入了一个全新的即时编译器：Graal编译器</li><li>编译效果短短几年时间就追平了C2编译器，未来可期（对应还出现了Graal虚拟机，是有可能替代Hotspot的虚拟机的）</li><li>目前，带着实验状态标签，需要使用开关参数去激活才能使用<code>-XX:+UnlockExperimentalvMOptions -XX:+UseJVMCICompiler</code></li></ul><p><strong>AOT编译器：</strong></p><ul><li><p>JDK9引入了AOT编译器（静态提前编译器，Ahead of Time Compiler）</p><ul><li>AOT编译指的则是，<strong>在程序运行之前</strong>，将字节码转换为机器码</li></ul></li><li><p>JDK9引入了实验性AOT编译工具jaotc。借助Graal编译器，将输入的Java类文件转换为机器码，存放至生成的动态共享库之中</p><ul><li><code>.java</code> -&gt; <code>.class</code> - (使用jaotc) -&gt; <code>.so</code></li></ul></li><li><p>优点：</p><ol><li>已经预编译成二进制库，可以直接执行</li><li>不必等待JIT编译器预热，减少Java”第一次运行慢“的不良体验</li></ol></li><li><p>缺点：</p><ol><li>破坏Java”一次编译，到处运行“，必须为每个硬件和系统编译对应的包</li><li>降低了Java链接过程中的动态性，加载的代码在编译器就必须全部知道</li></ol></li></ul><h2 id="StringTable"><a href="#StringTable" class="headerlink" title="StringTable"></a>StringTable</h2><h3 id="String基本特性"><a href="#String基本特性" class="headerlink" title="String基本特性"></a>String基本特性</h3><ol><li>String被声明为final的，不可被继承</li><li>String实现了Serializable接口，表示是支持序列化的</li><li>String实现了Comparable接口，表示可以比大小</li><li>JDK8之前定义<code>final char[]</code>用于存储数据，JDK9改为<code>final byte[]</code></li><li>String具有不可变性，无论是修改还是赋值，都需要重新指定内存区域来赋值</li></ol><p><strong>为什么改为byte[]：</strong></p><blockquote><p>官方文档：<a class="link" target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/254">http://openjdk.java.net/jeps/254 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></blockquote><ol><li>每个char字符使用两个字节（16位），大量的拉丁字符只需要一个字节存储，浪费空间</li><li>之前使用UTF-16的char[]数组来存储，现在改为byte[]数组+编码标记字段来存储<ul><li>如果是ISO-8859-1/Latin-1，只需要一个字节存</li><li>如果是其它字符集，比如UTF-8，仍然用两个字节存</li></ul></li></ol><h4 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a>底层结构</h4><ol><li>String的String Pool（字符串常量池）是一个固定大小的HashTable。如果放进String Pool的String非常多，就会造成Hash冲突严重，导致链表会很长。而链表长了后，会导致调用<code>String.intern()</code>方法时性能下降</li><li><code>-XX:StringTablesize</code>可设置StringTable的长度<ul><li>JDK6中长度是固定的，就是1009</li><li>JDK7中默认长度60013，StringTablesize设置不做限制</li><li>JDK8中默认长度60013，StringTablesize最小为1009</li></ul></li></ol><h3 id="String内存分配"><a href="#String内存分配" class="headerlink" title="String内存分配"></a>String内存分配</h3><p>Java有8种基本类型+String类型，8种基本类型的常量池是系统协调的，而String的常量池比较特殊</p><ul><li>双引号声明的字符串会直接存储在常量池种：<code>String info = "xuedongyun"</code></li><li>不是使用双引号声明的字符串，可以使用<code>intern()</code>方法</li></ul><p>字符串常量池存储位置</p><ul><li><p>JDK6之前，存储在永久代</p></li><li><p>JDK7，存储在堆中</p></li><li><p>JDK8，依然存储在堆中，永久代变成元空间</p></li></ul><p><strong>StringTable为什么要调整位置？</strong></p><blockquote><p><strong>官方文档</strong>：<a class="link" target="_blank" rel="noopener" href="https://www.oracle.com/java/technologies/javase/jdk7-relnotes.html#jdk7changes">https://www.oracle.com/java/technologies/javase/jdk7-relnotes.html#jdk7changes <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></blockquote><ol><li>为什么要调整位置？<ul><li>永久代的默认空间大小较小</li><li>永久代垃圾回收频率较低，大量字符串无法及时回收。容易Full GC产生STW，或者OOM: PermGen Space</li><li>堆中空间足够大，字符串可被及时回收</li></ul></li><li>intern字符串在堆中分配，与其他被创建的对象一起分配，可能需要调整堆的大小</li></ol><p><strong>OOM实验：</strong></p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">	JDK8：-XX:MetaspaceSize=6m -XX:MaxMetaspaceSize=6m -Xms6m -Xmx6m</span></span><br><span class="line"><span class="comment">	Exception in thread "main" java.lang.OutOfMemoryError: Java heap space</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">short</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>){</span><br><span class="line">            set.add(String.valueOf(i++).intern());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><h3 id="String基本操作"><a href="#String基本操作" class="headerlink" title="String基本操作"></a>String基本操作</h3><p><strong>举例1：</strong></p><p>完全相同的字符串字面量，必须指向同一个String类实例</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"1"</span>);</span><br><span class="line">        System.out.println(<span class="string">"2"</span>);</span><br><span class="line">        System.out.println(<span class="string">"3"</span>);</span><br><span class="line">        System.out.println(<span class="string">"4"</span>);</span><br><span class="line">        System.out.println(<span class="string">"5"</span>);</span><br><span class="line">        System.out.println(<span class="string">"6"</span>);</span><br><span class="line">        System.out.println(<span class="string">"7"</span>);</span><br><span class="line">        System.out.println(<span class="string">"8"</span>);</span><br><span class="line">        System.out.println(<span class="string">"9"</span>);</span><br><span class="line">        System.out.println(<span class="string">"10"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如下的字符串"1" 到 "10"不会再次加载</span></span><br><span class="line">        System.out.println(<span class="string">"1"</span>);</span><br><span class="line">        System.out.println(<span class="string">"2"</span>);</span><br><span class="line">        System.out.println(<span class="string">"3"</span>);</span><br><span class="line">        System.out.println(<span class="string">"4"</span>);</span><br><span class="line">        System.out.println(<span class="string">"5"</span>);</span><br><span class="line">        System.out.println(<span class="string">"6"</span>);</span><br><span class="line">        System.out.println(<span class="string">"7"</span>);</span><br><span class="line">        System.out.println(<span class="string">"8"</span>);</span><br><span class="line">        System.out.println(<span class="string">"9"</span>);</span><br><span class="line">        System.out.println(<span class="string">"10"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p>程序启动时加载了2144个字符串常量</p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/18/YNU1cyWKZIuftka.png" alt="image-20231018203027571" style="zoom:40%"><p>程序结束时，加载了2155个字符串常量（多了”1”到”10”，以及回车符）</p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/18/IP3nVXCTx5H7ypK.png" alt="image-20231018211546309" style="zoom:40%"><p><strong>举例2：</strong></p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Memory</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">Memory</span> <span class="variable">mem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Memory</span>();</span><br><span class="line">        mem.foo(obj);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(Object param)</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> param.toString();</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/19/lNCEYiTM1c6g8QK.png" alt="image-20231019201153466" style="zoom:67%"><h3 id="字符串拼接操作"><a href="#字符串拼接操作" class="headerlink" title="字符串拼接操作"></a>字符串拼接操作</h3><ul><li>常量与常量的拼接，结果在常量池，原理是编译期优化</li><li>拼接前后，只要有一个是变量，结果就在堆中。变量拼接的原理是StringBuilder</li><li>对拼接的结果调用<code>intern()</code>方法<ul><li>常量池中存在，返回字符串在常量池中的地址</li><li>常量池中不存在，在常量池中创建一份，再返回地址</li></ul></li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">"a"</span> + <span class="string">"b"</span>;</span><br><span class="line"><span class="comment">// 最终编译成：String a = "ab";</span></span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">"a"</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> s1 + <span class="string">"b"</span>;</span><br><span class="line"><span class="comment">// 出现了变量，相当于堆空间中new String()。使用StringBuilder拼接，结果在堆中;</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> s.intern();</span><br><span class="line"><span class="comment">// 调用intern方法，如果常量池中存在则返回常量池中的地址；如果不存在则在常量池中创建一份，返回此对象地址</span></span><br></pre></td></tr></table></figure></div><blockquote><p>改进空间：</p><ul><li>在实际开发中，如果确定长度不高于highLevel，建议使用构造器实例化：<ul><li><code>StringBuilder s = new StringBuilder(highLevel);</code></li></ul></li><li>避免频繁扩容，提升性能</li></ul></blockquote><h3 id="intern-的使用"><a href="#intern-的使用" class="headerlink" title="intern()的使用"></a>intern()的使用</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title function_">intern</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></div><ul><li>intern是一个native方法，调用底层C的方法</li><li>StringTable最初是空的，由String类私有地维护，调用intern方法时：<ul><li>如果池中包含equals(object)方法确定相同的字符串：返回该字符串对象地址</li><li>否则：添加字符串对象到池中，返回该字符串对象地址</li></ul></li></ul><p><strong>new String(“ab”)会创建几个对象？</strong></p><ul><li>两个对象，一个对象是new关键词在堆空间创建的；另一个对象是字符串常量池中的对象”ab”</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringNewTest</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"ab"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0 new #2 &lt;java/lang/String&gt;						# 在堆中创建了一个String对象</span><br><span class="line">3 dup</span><br><span class="line">4 ldc #3 &lt;ab&gt;									# 在字符串常量池中放入"ab"（如果之前没有的话）</span><br><span class="line">6 invokespecial #4 &lt;java/lang/String.&lt;init&gt;&gt;</span><br><span class="line">9 astore_1</span><br><span class="line">10 return</span><br></pre></td></tr></table></figure></div><p><strong>new String(“a”) + new String(“b”)会创建几个对象？</strong></p><ul><li>对象1：new StringBuilder()</li><li>对象2：new String(“a”)</li><li>对象3：常量池中的”a”（如果之前没有的话）</li><li>对象4：new String(“b”)</li><li>对象5：常量池中的”b”（如果之前没有的话）</li><li>对象6：new String(“ab”)，<strong>由StringBuilder的toString()创建，但没有常量池中生成</strong></li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringNewTest</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"a"</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"b"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">0 new #2 &lt;java/lang/StringBuilder&gt;						# StringBuilder对象</span><br><span class="line">3 dup</span><br><span class="line">4 invokespecial #3 &lt;java/lang/StringBuilder.&lt;init&gt;&gt;</span><br><span class="line">7 new #4 &lt;java/lang/String&gt;								# String对象，"a"</span><br><span class="line">10 dup</span><br><span class="line">11 ldc #5 &lt;a&gt;											# 常量池中的对象，"a"</span><br><span class="line">13 invokespecial #6 &lt;java/lang/String.&lt;init&gt;&gt;</span><br><span class="line">16 invokevirtual #7 &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line">19 new #4 &lt;java/lang/String&gt;							# String对象，"b"</span><br><span class="line">22 dup</span><br><span class="line">23 ldc #8 &lt;b&gt;											# 常量池中的对象，"b"</span><br><span class="line">25 invokespecial #6 &lt;java/lang/String.&lt;init&gt;&gt;</span><br><span class="line">28 invokevirtual #7 &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line">31 invokevirtual #9 &lt;java/lang/StringBuilder.toString&gt;	# StringBuilder执行toString方法，创建了String对象</span><br><span class="line">34 astore_1							</span><br><span class="line">35 return</span><br></pre></td></tr></table></figure></div><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/19/4bcqXehA1gHUkYw.png" alt="image-20231019203253046"></p><p><strong>JDK7之后intern的变化：</strong></p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringIntern</span> {</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"1"</span>);		<span class="comment">// 堆空间中new了对象，常量池中也放入了"1"</span></span><br><span class="line">        s.intern();						<span class="comment">// 调用此方法之前，常量池中已经有"1"了</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">"1"</span>;				<span class="comment">// 直接返回常量池中的地址</span></span><br><span class="line">        System.out.println(s == s2);	<span class="comment">// JDK6:false, JDK7:false, JDK8:false</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"1"</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"1"</span>);	<span class="comment">// s3变量的地址为堆空间中的new String("11")，常量池中没有</span></span><br><span class="line">        s3.intern();									<span class="comment">// 字符串常量池中生成"11"</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">"11"</span>;								<span class="comment">// 直接返回常量池中的地址</span></span><br><span class="line">        System.out.println(s3 == s4);	<span class="comment">// JDK6:false, JDK7:true, JDK8:true</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><blockquote><p>JDK7以后，由于StringTable放到堆空间中了。调用s3.intern()方法时，如果常量池中没有，为了节省空间，会在常量池中直接记录s3的地址</p><p>JDK7以后，不用重新创建并放入一个”11”对象了</p></blockquote><p><strong>性能测试：</strong></p><p>直接<code>new String</code>：程序需要维护大量存放在堆空间中的String实例，内存占用高</p><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/19/AWfclNdPkVaezmU.png" alt="image-20231019205325275"></p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr[i] = <span class="keyword">new</span> <span class="title class_">String</span>(String.valueOf(data[i % data.length]));</span><br></pre></td></tr></table></figure></div><p>使用<code>intern()</code>：直接指向常量池中的字符串，内存占用也更低</p><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/19/nDlQmN3LJGgsVzw.png" alt="image-20231019205336938"></p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr[i] = <span class="keyword">new</span> <span class="title class_">String</span>(String.valueOf(data[i % data.length])).intern();</span><br></pre></td></tr></table></figure></div><h3 id="StringTable垃圾回收测试"><a href="#StringTable垃圾回收测试" class="headerlink" title="StringTable垃圾回收测试"></a>StringTable垃圾回收测试</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -Xms15m -Xmx15m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringGCTest</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) {</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(i).intern();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><ul><li>Number of entries 和 Number of literals 明显没有 100000</li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/20/2DOYdHKfJ1EeFvT.png" alt="image-20231020133405706"></p><ul><li>年轻代发生了垃圾回收</li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/20/rXp12GDmHdW8fsR.png" alt="image-20231020133529809"></p><h3 id="G1中的String去重操作（了解）"><a href="#G1中的String去重操作（了解）" class="headerlink" title="G1中的String去重操作（了解）"></a>G1中的String去重操作（了解）</h3><blockquote><p><strong>官方文档</strong>：<a class="link" target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/192">http://openjdk.java.net/jeps/192 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></blockquote><p><strong>String去重操作的背景：</strong></p><ul><li>注意：不是指字符串常量池的去重，常量池本身就没有重复的</li><li>背景：对很多Java程序做测试，结果：<ul><li>堆存活数据中，String对象占了25%</li><li>堆存活数据中重复的String对象占了13.5%</li><li>String对象平局长度45</li></ul></li><li>堆上存在重复的String对象，是一种内存的浪费</li></ul><p><strong>String去重操作的实现：</strong></p><ol><li>垃圾收集器工作时，会访问堆上存活的对象。每一个对象，都会检查是否是候选要去重的String对象</li><li>如果是，把对象的引用插入到队列中等待处理。一个去重线程在后台运行，处理这个队列</li><li>使用一个HashTable来记录所有的被String对象使用的不重复的char数组。去重时会查这个HashTable，看堆上是否存在一摸一样的char数组</li><li>如果存在，String对象会被调整引用那个数组，释放对原来数组的引用（最终被垃圾回收器回收掉）</li><li>如果不存在，char数组会被插入到Hashtable，以后就可以共享这个数组了</li></ol><p><strong>命令行选项：</strong></p><ul><li><p><code>-XX:+UseStringDeduplication</code>：开启String去重，默认是不开启的，需要手动开启</p></li><li><p><code>-XX:+PrintStringDeduplicationStatistics</code>：打印详细的去重统计信息</p></li><li><p><code>-XX:StringDeduplicationAgeThreshold=threshold</code> ：达到这个年龄的String对象被认为是去重的候选对象</p></li></ul><h2 id="垃圾回收概述"><a href="#垃圾回收概述" class="headerlink" title="垃圾回收概述"></a>垃圾回收概述</h2><p>垃圾收集和内存动态分配，是Java区别于C++的最大差异</p><p>下面是一些大厂面试题</p><p><strong>蚂蚁金服：</strong></p><ol><li>你知道哪几种垃圾回收器，各自的优缺点，重点讲一下CMS和G1？</li><li>JVM GC算法有哪些，目前的JDK版本采用什么回收算法？</li><li>G1回收器讲下回收过程GC是什么？为什么要有GC？</li><li>GC的两种判定方法？CMS收集器与G1收集器的特点</li></ol><p><strong>百度：</strong></p><ol><li>说一下GC算法，分代回收说下</li><li>垃圾收集策略和算法</li></ol><p><strong>天猫：</strong></p><ol><li>JVM GC原理，JVM怎么回收内存</li><li>CMS特点，垃圾回收算法有哪些？各自的优缺点，他们共同的缺点是什么？</li></ol><p><strong>滴滴：</strong></p><ol><li>Java的垃圾回收器都有哪些，说下G1的应用场景，平时你是如何搭配使用垃圾回收器的</li></ol><p><strong>京东：</strong></p><ol><li>你知道哪几种垃圾收集器，各自的优缺点，重点讲下CMS和G1，</li><li>包括原理，流程，优缺点。垃圾回收算法的实现原理</li></ol><p><strong>阿里：</strong></p><ol><li>讲一讲垃圾回收算法。</li><li>什么情况下触发垃圾回收？</li><li>如何选择合适的垃圾收集算法？</li><li>JVM有哪三种垃圾回收器？</li></ol><p><strong>字节跳动：</strong></p><ol><li>常见的垃圾回收器算法有哪些，各有什么优劣？</li><li>System.gc()和Runtime.gc()会做什么事情？</li><li>Java GC机制？GC Roots有哪些？</li><li>Java对象的回收方式，回收算法。</li><li>CMS和G1了解么，CMS解决什么问题，说一下回收的过程。</li><li>CMS回收停顿了几次，为什么要停顿两次?</li></ol><h3 id="什么是垃圾"><a href="#什么是垃圾" class="headerlink" title="什么是垃圾"></a>什么是垃圾</h3><p>程序中，没有任何指针指向的对象。如果不及时清理，可能导致内存溢出。</p><h3 id="为什么需要GC"><a href="#为什么需要GC" class="headerlink" title="为什么需要GC"></a>为什么需要GC</h3><ul><li>如果不进行垃圾回收，<strong>内存迟早都会被消耗完</strong></li><li>垃圾回收也可以清除内存里的碎片。碎片整理将所占用的堆内存移到堆的一端，<strong>以便JVM将整理出的内存分配给新的对象</strong></li></ul><blockquote><p>没有GC不能保证程序的正常进行，经常GC导致STW影响性能，所以才需尝试对GC进行优化</p></blockquote><h3 id="Java垃圾回收机制"><a href="#Java垃圾回收机制" class="headerlink" title="Java垃圾回收机制"></a>Java垃圾回收机制</h3><blockquote><p><strong>官网介绍</strong>：<a class="link" target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></blockquote><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/23/AtSfeUuDVc1yzBG.png" alt="68747470733a2f2f6e706d2e656c656d6563646e2e636f6d2f796f7574686c716c40312e302e382f4a564d2f636861707465725f3031302f303030332e706e67" style="zoom:67%"><ul><li>垃圾回收可以对年轻代回收，也可以对老年代回收，甚至是全栈和方法区的回收</li><li>频繁收集You区</li><li>较少收集Old区</li><li>基本不收集Perm区/元空间</li></ul><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="标记阶段"><a href="#标记阶段" class="headerlink" title="标记阶段"></a>标记阶段</h3><p>目的：判断对象是否存活</p><p>方法：引用计数算法，可达性算法</p><p><strong>引用技术算法：</strong></p><ul><li>每个对象保存一个整型引用计数器，用于记录被引用的情况</li><li>任何对象引用了A，则A的计数器就加1；引用失效时，引用计数器就减1。计数器为0表示对象可回收</li><li>优点：<ul><li>实现简单，效率高</li></ul></li><li>缺点：<ul><li>增加存储开销</li><li>需要更新计数器，增加时间开销</li><li>严重问题：无法处理循环引用</li></ul></li></ul><blockquote><p>可以证明，Java没有使用这一类算法</p></blockquote><p><strong>可达性分析算法：</strong></p><ul><li>也称为根搜索算法、追踪性垃圾收集</li><li>有效解决循环引用问题</li><li>以根对象集合（GCRoots）为起始点，搜索对象是否可达，搜索路径称为引用链<ul><li>只有能被访问的对象才是存活对象</li></ul></li></ul><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/24/Uot7YIvLjPGEVZX.png" alt="image-20231024163134602" style="zoom:50%"><p><strong>GCRoots可以是哪些元素：</strong></p><blockquote><p><strong>总结：</strong>虚拟机栈、本地方法栈、方法区、字符串常量池等地方对堆空间进行引用的，都可以作为GC Roots进行可达性分析</p><p><strong>小技巧：</strong>一个指针保存了堆中的对象，但自己不在堆中，那它就是Root</p></blockquote><ol><li>虚拟机栈中引用的对象</li><li>本地方法栈中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象<ul><li>比如StringTable里的引用</li></ul></li><li>所有被同步锁synchronized持有的对象</li><li>JVM内部的引用<ul><li>基本数据类型对应的Class对象，一些常驻的异常对象（如：NullPointerException、OutofMemoryError），系统类加载器</li></ul></li><li>反映JVM内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等</li></ol><p>其他：根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。比如：<strong>分代收集</strong>和局部回收（PartialGC）。如果只针对Java堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入GC Roots集合中去考虑，才能保证可达性分析的准确性。</p><h3 id="对象finalization机制"><a href="#对象finalization机制" class="headerlink" title="对象finalization机制"></a>对象finalization机制</h3><ul><li>Java语言提供了对象终止（finalization）机制，允许自定义<strong>对象销毁前的处理逻辑</strong><ul><li>垃圾回收对象前，总会先调用这个对象的finalization方法</li></ul></li><li>finalization方法允许在子类被重写，<strong>用于对象在被回收时释放资源</strong></li><li>永远不要主动调用某个对象的finalization方法，应交由垃圾回收机制调用</li></ul><p><strong>对象的三种状态：</strong></p><ol><li>可触及：从根节点开始可达</li><li>可复活：对象的所有引用都被释放，但是对象可能在finalize中复活</li><li>不可触及的：对象finalize被调用，没有复活；不可触及的对象不可能被复活，因为finalize只会被调用一次</li></ol><p><strong>判断对象是否可回收：</strong></p><ol><li>从对象到GCRoot没有引用链条</li><li>判断是否有必要执行finalization方法<ul><li>没有重写，或者已经被调用了：判定为不可触及</li><li>重写了，没执行。对象被插到F-Queue队列中。JVM创建的低优先级的Finalizer线程触发其执行</li><li>GC会对F-Queue队列中的对象进行二次标记<ul><li>如果对象与引用链上的任何对象建立了联系，会被移出“即将回收”集合</li><li>不然，变成不可触及的状态</li></ul></li></ul></li></ol><p><strong>JVisual VM查看Finalizer线程：</strong></p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/24/2nNLcQ615BagPAd.png" alt="image-20231024172944511" style="zoom:50%"><p><strong>对象复活代码演示：</strong></p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CanReliveObj</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CanReliveObj obj; <span class="comment">// 类变量，属于GC Root</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此方法只能被调用一次</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable {</span><br><span class="line">        <span class="built_in">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">"调用finalize()"</span>);</span><br><span class="line">        obj = <span class="built_in">this</span>; <span class="comment">// 当前待回收的对象在finalize()方法中与引用链上的一个对象obj建立了联系</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    obj = <span class="keyword">new</span> <span class="title class_">GCTest</span>();</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 第一次，由于调用了finalize，复活</span></span><br><span class="line">    System.out.println(<span class="string">"第1次 gc"</span>);</span><br><span class="line">    obj = <span class="literal">null</span>;</span><br><span class="line">    System.gc();</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">null</span>) {</span><br><span class="line">        System.out.println(<span class="string">"obj is dead"</span>);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        System.out.println(<span class="string">"obj is still alive"</span>);</span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 第二次，代码一摸一样，但是自救失败（finalize方法只会执行一次）</span></span><br><span class="line">    System.out.println(<span class="string">"第2次 gc"</span>);</span><br><span class="line">    obj = <span class="literal">null</span>;</span><br><span class="line">    System.gc();</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">null</span>) {</span><br><span class="line">        System.out.println(<span class="string">"obj is dead"</span>);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        System.out.println(<span class="string">"obj is still alive"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><blockquote><p>第一次自救成功，第二次自救失败（finalize方法只会执行一次）</p></blockquote><h3 id="MAT进行GCRoots溯源"><a href="#MAT进行GCRoots溯源" class="headerlink" title="MAT进行GCRoots溯源"></a>MAT进行GCRoots溯源</h3><ul><li>MAT是Memory Analyzer的简称，是一款功能强大的Java堆内存分析器，用于查找内存泄露、查看内存消耗情况</li><li>MAT是基于Eclipse开发的</li><li>下载地址：<a class="link" target="_blank" rel="noopener" href="http://www.eclipse.org/mat/">http://www.eclipse.org/mat/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li></ul><blockquote><p>在内存分析方面，MAT更好用一些</p></blockquote><p><strong>实验代码：</strong></p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCRootsTest</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        List&lt;Object&gt; numList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Date</span> <span class="variable">birth</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) {</span><br><span class="line">            numList.add(String.valueOf(i));</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"数据添加完毕，请操作："</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in).next();</span><br><span class="line">        numList = <span class="literal">null</span>;</span><br><span class="line">        birth = <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"numList、birth已置空，请操作："</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in).next();</span><br><span class="line">        System.out.println(<span class="string">"结束"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p><strong>命令行jmap获取dump文件：</strong></p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\xdy&gt;jps</span><br><span class="line">13920 RemoteMavenServer36</span><br><span class="line">28416 Jps</span><br><span class="line">16052 GCRootsTest</span><br><span class="line">28780 Launcher</span><br><span class="line"></span><br><span class="line">C:\Users\xdy&gt;jmap -dump:format=b,live,file=test1.bin 16052</span><br><span class="line">Heap dump file created</span><br></pre></td></tr></table></figure></div><p><strong>JVisualVM获取dump文件：</strong></p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/26/JyOk9jx1CX5lpP6.png" alt="image-20231026163527959" style="zoom:40%"> <img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/26/MKv3B2o6yQJdVqN.png" alt="image-20231026163638438" style="zoom:40%"><p><strong>使用MAT打开文件：</strong></p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/26/ke7POxUfMLDmNKG.png" alt="image-20231026193544460" style="zoom:45%"> <img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/26/AmL9tOXfsJC3pWR.png" alt="image-20231026193559037" style="zoom:45%"><p>MAT中划分GCRoot的方式不太一样，不过可以在Thread中找到main线程，可以看到里面有两个ArrayList和Date类型的GCRoot。如果执行完代码后，就会看到已经找不到他们两个了。</p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/26/Lomg4TA1pP2xeYz.png" alt="image-20231026194243965" style="zoom:40%"><h3 id="JProfiler进行GCRoots溯源"><a href="#JProfiler进行GCRoots溯源" class="headerlink" title="JProfiler进行GCRoots溯源"></a>JProfiler进行GCRoots溯源</h3><ul><li>点击“标记当前值”，可以看到从此刻开始某类型的对象增多/减少的量，如果某个对象疯狂增多，肯定有问题</li></ul><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/26/vYELQsnKUFiAC1j.png" alt="image-20231026200652397" style="zoom:40%"><ul><li>右键，“在堆遍历器中显示所选”，可以看到一些详细信息</li></ul><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/26/2tmyzqCWJI3Vvef.png" alt="image-20231026200817738" style="zoom:40%"><ul><li>最常用的是“引用中的“Incoming references”（从哪来的）和“Outcoming references”（到哪去的）</li></ul><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/26/7vZj5X1zJ8mUyDk.png" alt="image-20231026201108547" style="zoom:40%"><ul><li>可以看到，此字符串是从System类的out静态类变量来的</li></ul><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/26/QujZR6AtqzHFmLX.png" alt="image-20231026201437138" style="zoom:40%"><h3 id="JProfiler分析OOM"><a href="#JProfiler分析OOM" class="headerlink" title="JProfiler分析OOM"></a>JProfiler分析OOM</h3><ul><li>让OOM时生成dump文件</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-Xms8m -Xmx8m -XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapOOM</span> {</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>]; <span class="comment">// 1MB</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        ArrayList&lt;HeapOOM&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">                list.add(<span class="keyword">new</span> <span class="title class_">HeapOOM</span>());</span><br><span class="line">                count++;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (Throwable e) {</span><br><span class="line">            System.out.println(<span class="string">"count = "</span> + count);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><ul><li>生成了dump文件，可以直接打开</li></ul><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">Dumping heap to java_pid13508.hprof ...</span><br><span class="line">Heap dump file created [7775055 bytes in 0.011 secs]</span><br><span class="line">count = 6</span><br><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at org.example.gc.HeapOOM.&lt;init&gt;(HeapOOM.java:16)</span><br><span class="line">	at org.example.gc.HeapOOM.main(HeapOOM.java:24)</span><br></pre></td></tr></table></figure></div><ul><li>可以从最大对象中看到，是ArrayList最大</li></ul><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/26/fAmPekZrRJycgzH.png" alt="image-20231026210649196" style="zoom:40%"><ul><li>也可以从线程中，看到是main线程出现的OOM异常，以及出问题的代码行数</li></ul><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/26/ik8XPCcheQvxlDN.png" alt="image-20231026211033994" style="zoom:40%"><h3 id="清除阶段"><a href="#清除阶段" class="headerlink" title="清除阶段"></a>清除阶段</h3><p><strong>标记清除算法：</strong></p><p>当堆空间耗尽时STW时：</p><ul><li>标记：从根节点遍历，标记所有被引用的对象</li><li>清除：对堆从头到尾进行线性的遍历，清除所有不可达对象</li></ul><blockquote><p>缺点：</p><ul><li>效率低</li><li>需要停止整个应用</li><li>清理出来的空间不是连续的，产生碎片，需要维护一个空闲列表</li></ul></blockquote><blockquote><p>何为清除：</p><ul><li>不是真的置空，而是把地址保存在空闲地址列表里</li><li>如果内存规整<ul><li>采用指针碰撞的方式，进行内存分配</li></ul></li><li>如果内存不规整<ul><li>虚拟机需要维护一个空闲列表</li></ul></li></ul></blockquote><p><strong>复制算法：</strong></p><ul><li><p>活着的内存空间分为两块，每次只使用其中一块</p></li><li><p>将存活的对象复制到未使用的内存块中，清空正在使用的内存块</p></li><li><p>新生代就用到了复制算法，Eden区和S0区存活的对象整体复制到S1区</p></li></ul><blockquote><p>优点：</p><ul><li>没有标记清除的过程，简单高效</li><li>不会出现碎片问题</li></ul><p>缺点：</p><ul><li>需要两倍空间</li><li>GC需要维护区域之间对象引用的关系，内存占用和时间开销都较大（参考：对象句柄访问）</li></ul></blockquote><blockquote><p>应用场景：</p><ul><li>垃圾对象多，存活对象少，复制算法的效率将会很高</li></ul></blockquote><p><strong>标记压缩算法：</strong></p><ul><li>第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象</li><li>第二阶段将所有存活对象压到内存的一端，之后清理边界外的空间</li><li>老年代使用的垃圾回收策略</li></ul><blockquote><p>优点：</p><ul><li><p>没有内存碎片问题</p></li><li><p>没有内存减半的问题</p></li></ul><p>缺点：</p><ul><li>效率低</li><li>需要调整对象的引用地址（HotSpot虚拟机采用的不是句柄池的方式，而是直接指针）</li><li>移动过程中需要STW</li></ul></blockquote><p><strong>对比三种清除算法：</strong></p><table><thead><tr><th></th><th>标记清除</th><th>标记整理</th><th>复制</th></tr></thead><tbody><tr><td><strong>速率</strong></td><td>中等</td><td>最慢</td><td>最快</td></tr><tr><td><strong>空间开销</strong></td><td>少（但会堆积碎片）</td><td>少（不堆积碎片）</td><td>通常需要活对象的2倍空间（不堆积碎片）</td></tr><tr><td><strong>移动对象</strong></td><td>否</td><td>是</td><td>是</td></tr></tbody></table><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p><strong>为什么使用分代收集算法：</strong></p><ul><li>不同的对象的生命周期是不一样的，可以采取不同的收集方式，以便提高回收效率。一般是分为新生代和老年代</li><li>在Java程序运行的过程中，会产生大量的对象:<ul><li>比如Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，生命周期比较长。</li><li>但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：String对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</li></ul></li></ul><p><strong>几乎所有的GC都采用分代收集算法：</strong></p><p>在HotSpot中:</p><ul><li><p>年轻代（Young Gen）</p><ul><li><p>区域小，对象生命周期短，存活率低，回收频繁。</p></li><li><p>适合使用复制算法，空间问题，通过HotSpot中的两个survivor的设计得到缓解。</p></li></ul></li><li><p>老年代（Tenured Gen）</p><ul><li>区域较大，对象生命周期长，存活率高，回收不频繁。</li></ul></li><li><p>标记-清除，标记-整理，混合实现。</p><ul><li>标记阶段（Mark）的开销，与存活对象的数量成正比。</li><li>清除阶段（Sweep）的开销，与管理区域的大小成正相关。</li><li>压缩阶段（Compact）的开销，与存活对象的数据成正比。</li></ul></li></ul><blockquote><p>以HotSpot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。</p><p>对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old回收器作为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用Serial Old执行Full GC以达到对老年代内存的整理。</p></blockquote><h3 id="增量收集算法"><a href="#增量收集算法" class="headerlink" title="增量收集算法"></a>增量收集算法</h3><p>STW会导致所有线程都被挂起，等待一段时间</p><p><strong>增量收集算法思想：</strong></p><ul><li>每次垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成</li><li>依然是传统标记-清除算法，但是允许GC以分阶段的方式完成标记、清除、复制等工作</li></ul><blockquote><p>优点：</p><ul><li>减少了系统停顿的时间</li></ul><p>缺点：</p><ul><li>线程切换和上下文转换有消耗，造成系统整体吞吐量下降</li></ul></blockquote><h3 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h3><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/27/jqSdclmYVkCJrn9.png" alt="image-20231027121035582" style="zoom:50%"><p>主要针对G1收集器来说</p><ul><li>堆空间越大，一次GC时所需要的时间就越长</li><li>将大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，从而减少一次GC所产生的停顿</li><li>分代算法按照生命周期划分成两个部分，而分区算法将堆空间划分成连续的不同小区间<ul><li>每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间</li></ul></li></ul><h2 id="垃圾回收相关概念说明"><a href="#垃圾回收相关概念说明" class="headerlink" title="垃圾回收相关概念说明"></a>垃圾回收相关概念说明</h2><h3 id="System-gc-的理解"><a href="#System-gc-的理解" class="headerlink" title="System.gc()的理解"></a>System.gc()的理解</h3><ul><li><code>System.gc()</code>或者<code>Runtime.getRuntime().gc()</code>，会显示触发Full GC，同时对老年代和新生代进行回收</li><li>但是，不能确保立即执行</li><li>一般情况下，无需手动调用</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemGCTest</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SystemGCTest</span>();</span><br><span class="line">        System.gc(); <span class="comment">// 只有他，未必保证能看到输出的字符串</span></span><br><span class="line">        </span><br><span class="line">        System.runFinalization(); <span class="comment">// 会强制调用，失去引用的对象的finalize方法</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable {</span><br><span class="line">        <span class="built_in">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">"finalize执行了"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p><strong>一些例子分析：</strong></p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -Xms256m -Xmx256m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalVarGC</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localvarGC1</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];<span class="comment">//10MB</span></span><br><span class="line">        System.gc();</span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localvarGC2</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        buffer = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localvarGC3</span><span class="params">()</span> {</span><br><span class="line">        {</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        }</span><br><span class="line">        System.gc();</span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localvarGC4</span><span class="params">()</span> {</span><br><span class="line">        {</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localvarGC5</span><span class="params">()</span> {</span><br><span class="line">        localvarGC1();</span><br><span class="line">        System.gc();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><ul><li><code>localvarGC1()</code>：没回收</li></ul><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先进行了YoungGC，对象并没有被回收掉</span></span><br><span class="line">[GC (System.gc()) [PSYoungGen: 15516K-&gt;10744K(76288K)]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进行了FullGC，buffer对象被放到老年代了</span></span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 10744K-&gt;0K(76288K)] [ParOldGen: 220K-&gt;10885K(175104K)]</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><ul><li><code>localvarGC2()</code>：回收了</li></ul><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先进行了YoungGC，buffer对象直接被回收了</span></span><br><span class="line">[GC (System.gc()) [PSYoungGen: 15516K-&gt;824K(76288K)]</span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 824K-&gt;0K(76288K)] [ParOldGen: 8K-&gt;645K(175104K)]</span><br></pre></td></tr></table></figure></div><ul><li><code>localvarGC3()</code>：没回收</li></ul><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先进行了YoungGC，对象并没有被回收掉</span></span><br><span class="line">[GC (System.gc()) [PSYoungGen: 15516K-&gt;10736K(76288K)]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进行了FullGC，buffer对象被放到老年代了</span></span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 10736K-&gt;0K(76288K)] [ParOldGen: 276K-&gt;10885K(175104K)]</span><br></pre></td></tr></table></figure></div><blockquote><p>原因：从字节码可以看到，局部变量表槽数为2。但是实际去看发现只有一个槽位存储了this。GC时，buffer其实还占用着槽位，所以没有回收</p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/30/BerY3QaS7TXfiD4.png" alt="image-20231030162454073" style="zoom:67%"> <img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/30/d7lkpP46vU5uRM8.png" alt="image-20231030162508690" style="zoom:55%"></blockquote><ul><li><code>localvarGC4()</code>：回收了</li></ul><blockquote><p>原因：新创建了局部变量<code>int value</code>，槽位复用，buffer无法再占用原本的槽位了</p></blockquote><ul><li><code>localvarGC5()</code>：回收了</li></ul><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[GC (System.gc()) [PSYoungGen: 15516K-&gt;10744K(76288K)]</span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 10744K-&gt;0K(76288K)] [ParOldGen: 248K-&gt;10885K(175104K)]</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 0K-&gt;0K(76288K)]</span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 0K-&gt;0K(76288K)] [ParOldGen: 10885K-&gt;645K(175104K)] </span><br></pre></td></tr></table></figure></div><h3 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h3><p>内存溢出（OOM）：没有空闲内存，且垃圾回收也无法提供更多内存</p><p><strong>原因分析：</strong></p><ol><li>JVM堆内存设置不够<ul><li>通过参数<code>-Xms</code> 、<code>-Xmx</code>来调整</li></ul></li><li>代码创建了大量的大对象，且长时间不能被回收<ul><li>潜台词：在抛出<code>OutOfMemoryError</code>之前，会触发GC，尽可能清理出空间</li><li>也不是一定会触发GC：如果分配一个超大对象，比堆的最大值都大，将直接抛出错误</li></ul></li></ol><h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h3><ul><li>对象不会被程序用到了，但GC又不能回收它们</li><li>广泛意义上的内存泄露：不需要的对象，但是生命周期很长</li></ul><p><strong>常见例子：</strong></p><ol><li>单例模式：单例模式的对象的生命周期和应用程序一样长，如果单例对象持有对外部对象的引用，这个外部对象将不能回收</li><li>外部资源未close()：数据库连接，网络连接，io操作等资源，如果不手动close会导致无法回收</li></ol><h3 id="Stop-The-World"><a href="#Stop-The-World" class="headerlink" title="Stop The World"></a>Stop The World</h3><p>GC事件发生过程中，整个应用程序线程都会被暂停</p><ul><li>枚举根节点（GC Roots），会导致所有Java执行线程停顿<ul><li>系统冻结在某个时间点上</li></ul></li><li>任何GC都会有STW</li></ul><h3 id="垃圾回收的并行与并发"><a href="#垃圾回收的并行与并发" class="headerlink" title="垃圾回收的并行与并发"></a>垃圾回收的并行与并发</h3><p><strong>GC中的并行：</strong></p><ol><li>并行：多条GC线程并行工作，但此时用户线程处于等待状态<ul><li>如：ParNew、Parallel Scavenge、Parallel Old</li></ul></li><li>串行：相较于并行的概念，GC单线程执行</li></ol><p><strong>GC中的并发：</strong></p><ul><li>用户线程与GC线程同时执行，GC执行时不会停止用户程序的运行<ul><li>用户程序继续运行，垃圾回收线程运行于另一个CPU核心</li><li>如：CMS、G1</li></ul></li></ul><h3 id="安全点与安全区域（了解）"><a href="#安全点与安全区域（了解）" class="headerlink" title="安全点与安全区域（了解）"></a>安全点与安全区域（了解）</h3><p><strong>安全点（Safepoint）：</strong></p><ol><li><p>程序执行时，在特定位置才能停下来开始GC，这些位置称为安全点</p></li><li><p>安全点的选择很重要：</p><ul><li><p>太少可能导致GC等待的时间太长，</p></li><li><p>太频繁可能导致运行时的性能问题</p></li><li><p>大部分指令的执行时间都非常短暂，通常会根据是否具有<strong>让程序长时间执行</strong>的特征为标准。比如：选择一些执行时间较长的指令作为Safe Point，<strong>如方法调用、循环跳转和异常跳转等</strong></p></li></ul></li></ol><p><strong>安全区域（Safe Region）：</strong></p><ol><li>安全点机制保证程序执行时，一小段时间就能遇到可进入GC的点。但是如果程序不执行呢？<ul><li>列如：线程处于Sleep或Blocked状态</li></ul></li><li>安全区域指，<strong>一段代码片段中，对象的引用状态不会变化</strong>，此区域任何位置GC都是安全的</li></ol><p><strong>安全区域的执行流程：</strong></p><ol><li>当线程运行到安全区时，首先标识已经进入了安全区。如果这段时间内发生GC，JVM会忽略标识为Safe Region状态的线程</li><li>当线程即将离开Safe Region时，会检查JVM是否已经完成根节点枚举（即GC Roots的枚举）。如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开Safe Region的信号为止</li></ol><h3 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h3><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/31/eOJAiW1FEuoDyBs.png" alt="image-20231031201937203" style="zoom:67%"><h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><ul><li>99%都是强引用，也是默认的引用类型</li><li>只要强引用的对象是可达的，JVM宁可OOM也不回收它<ul><li>强引用是造成内存泄露的主要原因</li></ul></li></ul><h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><blockquote><p>内存不足即回收</p></blockquote><ul><li>内存足够，不会回收软引用可达的对象；内存不够，才会回收</li><li>将要OOM前，会将此类对象列入回收范围中二次回收，空间还不够才会OOM</li><li>构造软引用时，会指定一个引用队列，以跟踪对象的回收情况</li><li>软引用常用来实现缓存</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SoftReference&lt;User&gt; userSoftRef = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;User&gt;(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">"songhk"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上等价于</span></span><br><span class="line"><span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>,<span class="string">"songhk"</span>);</span><br><span class="line">SoftReference&lt;User&gt; userSoftRef = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;User&gt;(u1);</span><br><span class="line">u1 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存紧张时，会得到null</span></span><br><span class="line">userSoftRef.get()</span><br></pre></td></tr></table></figure></div><h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><blockquote><p>发现即回收</p></blockquote><ul><li>在GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象<ul><li>比起软引用，GC回收时无需检查是否需要回收，弱引用对象更容易、更快被GC回收</li></ul></li><li>GC线程通常优先级较低，有时弱引用还是会存在一段时间的</li><li>同样的，构造软引用时，会指定一个引用队列，以跟踪对象的回收情况</li><li>适合保存可有可无的缓存数据，内存不足缓存数据会被回收；内存充足时又可以存在相当长的时间</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 声明强引用</span></span><br><span class="line">WeakReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>; <span class="comment">// 销毁强引用</span></span><br></pre></td></tr></table></figure></div><h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><ul><li>也称“幽灵引用”或“幻影引用”，是最弱的引用</li><li>如果对象仅持有虚引用，那么和没有引用几乎是一样的，随时都可能被GC回收</li><li>不能单独使用，也无法通过虚引用来获取被引用的对象，get()总是null</li><li>唯一目的在于跟踪垃圾回收过程，比如：能在这个对象被收集器回收时收到一个系统通知</li><li>虚引用必须和引用队列一起使用<ul><li>虚引用在创建时必须提供一个引用队列作为参数</li><li>当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况</li></ul></li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 声明强引用</span></span><br><span class="line"><span class="type">ReferenceQueue</span> <span class="variable">phantomQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>(); <span class="comment">// 声明引用队列</span></span><br><span class="line">PhantomReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(obj, phantomQueue); <span class="comment">// 声明虚引用（还需要传入引用队列）</span></span><br><span class="line">obj = <span class="literal">null</span>; </span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceTest</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReferenceTest obj;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReferenceQueue&lt;ReferenceTest&gt; phantomQueue = <span class="literal">null</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 用于检测队列中有无值（也即是否被GC）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CheckRefQueue</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">                <span class="keyword">if</span> (phantomQueue != <span class="literal">null</span>) {</span><br><span class="line">                    PhantomReference&lt;ReferenceTest&gt; ref = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        ref = (PhantomReference&lt;ReferenceTest&gt;) phantomQueue.remove();</span><br><span class="line">                    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">if</span> (ref != <span class="literal">null</span>) {</span><br><span class="line">                        System.out.println(<span class="string">"ReferenceTest被GC了"</span>);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        <span class="type">CheckRefQueue</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CheckRefQueue</span>();</span><br><span class="line">        t.setDaemon(<span class="literal">true</span>);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        obj = <span class="keyword">new</span> <span class="title class_">ReferenceTest</span>();</span><br><span class="line">        phantomQueue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line">        PhantomReference&lt;ReferenceTest&gt; phantomRef = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(obj, phantomQueue);</span><br><span class="line"></span><br><span class="line">        System.out.println(phantomRef.get()); <span class="comment">// 为null，虚引用无法获取值</span></span><br><span class="line"></span><br><span class="line">        obj = <span class="literal">null</span>;</span><br><span class="line">        System.gc(); <span class="comment">// 一旦obj对象被GC，就会将虚引用存放到引用队列中。</span></span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><h4 id="终结器引用"><a href="#终结器引用" class="headerlink" title="终结器引用"></a>终结器引用</h4><ul><li><p>用于实现对象的finalize()方法，也可以称为终结器引用</p></li><li><p>无需手动编码，其内部配合引用队列使用</p></li><li><p>在GC时，终结器引用入队。由Finalizer线程通过终结器引用找到被引用对象调用它的finalize()方法，第二次GC时把他进行回收</p></li></ul><h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><h3 id="垃圾回收器分类"><a href="#垃圾回收器分类" class="headerlink" title="垃圾回收器分类"></a>垃圾回收器分类</h3><p><strong>按GC线程数分：</strong></p><ol><li><p>串行回收：只有一个CPU用于执行GC操作，会有STW</p></li><li><p>并行回收：多个CPU同时执行GC操作，会有STW</p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/10/31/MlWrj1HiQIXCLUJ.png" alt="image-20231031210255409" style="zoom:50%"></li></ol><p><strong>按工作模式分：</strong></p><ol><li>并发式：与应用程序线程交替工作，以减少停顿时间</li><li>独占式：一旦运行，就停止所有用户线程，直至垃圾回收结束</li></ol><p><strong>按碎片处理方式分：</strong></p><ol><li>压缩式：回收完成后，对存活对象进行压缩整理；分配空间时使用指针碰撞</li><li>非压缩式：不进行压缩；分配空间时使用空闲列表</li></ol><p><strong>按工作的区间：</strong></p><ol><li>年轻代垃圾回收器</li><li>老年代垃圾回收器</li></ol><h3 id="评估性能指标"><a href="#评估性能指标" class="headerlink" title="评估性能指标"></a>评估性能指标</h3><p><strong>吞吐量（throughout）：</strong></p><ul><li>吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾回收时间)</li></ul><p><strong>暂停时间（pause time）：</strong></p><ul><li>执行垃圾回收时，程序工作线程被暂停的时间</li></ul><blockquote><p>吞吐量 VS 暂停时间</p><ul><li>吞吐量越高越好，暂停时间越低越好</li><li>这两者矛盾<ul><li>如果选择高吞吐量，则需要降低内存回收的执行频率</li><li>如果选择低暂停时间，则需要频繁执行内存回收</li></ul></li><li>现在的标准：最大吞吐量优先情况下，降低暂停时间</li></ul></blockquote><h3 id="不同垃圾回收器"><a href="#不同垃圾回收器" class="headerlink" title="不同垃圾回收器"></a>不同垃圾回收器</h3><ol><li>1999年随JDK1.3.1一起来的是串行方式的<strong>Serial GC</strong>，它是第一款GC。<strong>ParNew</strong>垃圾收集器是Serial收集器的多线程版本</li><li>2002年2月26日，<strong>Parallel GC</strong>和<strong>Concurrent Mark Sweep GC</strong>跟随JDK1.4.2一起发布·</li><li>Parallel GC在JDK6之后成为HotSpot默认GC。</li><li>2012年，在JDK1.7u4版本中，<strong>G1</strong>可用。</li><li>2017年，JDK9中G1变成默认的垃圾收集器，以替代CMS。</li><li>2018年3月，JDK10中G1垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。</li><li>2018年9月，JDK11发布。引入Epsilon 垃圾回收器，又被称为 “No-Op(无操作)“ 回收器。同时，引入ZGC：可伸缩的低延迟垃圾回收器（Experimental）</li><li>2019年3月，JDK12发布。增强G1，自动返回未用堆内存给操作系统。同时，引入Shenandoah GC：低停顿时间的GC（Experimental）。</li><li>2019年9月，JDK13发布。增强ZGC，自动返回未用堆内存给操作系统。</li><li>2020年3月，JDK14发布。删除CMS垃圾回收器。扩展ZGC在macOS和Windows上的应用</li></ol><p><strong>7款经典的垃圾回收器：</strong></p><ul><li>串行回收器：Serial，Serial Old</li><li>并行回收器：ParNew，Parallel Scavenge，Parallel Old</li><li>并发回收器：CMS，G1</li></ul><p><strong>垃圾回收器的组合关系:</strong></p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/11/01/vepsqJWNY3K8u2U.png" alt="image-20231101163507605" style="zoom:50%"> <img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/11/01/3gjYQCdN2tZs6L8.png" alt="image-20231101163812869" style="zoom:67%"><ul><li>两个收集器之间有连线，表明可以搭配使用<ul><li>Serial Old作为CMS出现“Concurrent Mode Failure”失败的后备方案</li><li>红色虚线：JDK8声明为废弃；JDK9完全移除</li><li>绿色虚线：JDK14完全启用</li><li>青色虚线：JDK14删除CMS垃圾回收器</li></ul></li><li>为什么有很多垃圾收集器？<ul><li>Java应用场景很多，移动端、服务端等等</li><li>没有完美的收集器，只有最适合场景的收集器</li></ul></li></ul><p><strong>查看默认的垃圾收集器：</strong></p><ol><li><code>-XX:+PrintCommandLineFlags</code>：查看命令行相关参数（包含使用的垃圾收集器）</li><li><code>jinfo -flag &lt;相关垃圾回收器参数&gt; &lt;进程ID&gt;</code>：使用命令行参数</li></ol><ul><li>JDK8下，使用JVM参数查看：看到有<code>-XX:+UseParallelGC</code>，说明使用了 ParallelGC（默认和Parallel Old绑定使用）</li></ul><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">XX:InitialHeapSize=666046592 </span><br><span class="line">-XX:MaxHeapSize=10656745472 </span><br><span class="line">-XX:+PrintCommandLineFlags </span><br><span class="line">-XX:+UseCompressedClassPointers </span><br><span class="line">-XX:+UseCompressedOops </span><br><span class="line">-XX:-UseLargePagesIndividualAllocation </span><br><span class="line">-XX:+UseParallelGC </span><br></pre></td></tr></table></figure></div><ul><li>JDK8下，使用命令行查看</li></ul><div class="highlight-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\<span class="title">xdy</span>&gt;<span class="title">jps</span></span></span><br><span class="line"><span class="function">29720 <span class="title">Main</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Users</span>\<span class="title">xdy</span>&gt;<span class="title">jinfo</span> -<span class="title">flag</span> <span class="title">UseParallelGC</span> 29720</span></span><br><span class="line"><span class="function">-<span class="title">XX</span>:+<span class="title">UseParallelGC</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Users</span>\<span class="title">xdy</span>&gt;<span class="title">jinfo</span> -<span class="title">flag</span> <span class="title">UseParallelOldGC</span> 29720</span></span><br><span class="line"><span class="function">-<span class="title">XX</span>:+<span class="title">UseParallelOldGC</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Users</span>\<span class="title">xdy</span>&gt;<span class="title">jinfo</span> -<span class="title">flag</span> <span class="title">UseG1GC</span> 29720</span></span><br><span class="line"><span class="function">-<span class="title">XX</span>:-<span class="title">UseG1GC</span></span></span><br></pre></td></tr></table></figure></div><h4 id="Serial回收器：串行回收"><a href="#Serial回收器：串行回收" class="headerlink" title="Serial回收器：串行回收"></a>Serial回收器：串行回收</h4><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/11/01/fpykVz61MOhWqtH.png" alt="image-20231101210108510" style="zoom:50%"><ul><li><p>最简单最基本的垃圾回收器，JDK1.3之前新生代的唯一选择</p></li><li><p>HotSpot虚拟机中，使用<code>-XX:+UseSerialGC</code>参数可以指定年轻代和老年代都使用串行收集器</p><ul><li>新生代用Serial GC，老年代用Serial Old GC</li></ul></li><li><p><strong>Serial</strong>是HotSpot中，Client模式下，默认的新生代垃圾收集器</p><ul><li>采用复制算法，串行回收，STW机制</li></ul></li><li><p><strong>Serial Old</strong>是HotSpot中，Client模式下，默认的老年代垃圾收集器</p><ul><li>唯一的不同是使用标记-压缩算法</li></ul></li><li><p><strong>Serial Old</strong>在HotSpot中，Server模式下，有两个作用</p><ul><li>与新生代的Parallel Scavenge配合使用</li><li>作为老年代CMS收集器的后备方案</li></ul></li></ul><blockquote><p>这个垃圾收集器是一个“单线程”的：只使用一个线程完成垃圾收集工作，且垃圾收集的过程中必须停止其他工作线程（STW）</p></blockquote><p><strong>优势：</strong></p><ul><li>简单高效，没有额外线程开销</li><li>用户桌面应用中，可用内存一般不大，可以在较短时间完成垃圾收集，使用串行收集器是可以接受的</li></ul><h4 id="ParNew回收器：并行回收"><a href="#ParNew回收器：并行回收" class="headerlink" title="ParNew回收器：并行回收"></a>ParNew回收器：并行回收</h4><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/11/01/YjsaSKqbJ2Qihg3.png" alt="image-20231101210200257" style="zoom:50%"><ul><li>Serial收集器的多线程版本，用于年轻代<ul><li>唯一的区别：并行回收</li></ul></li><li>是很多JVM在server模式下，新生代的默认垃圾收集器</li><li><code>-XX:+UseParNewGC</code>使用ParNew收集器，仅年轻代使用并行收集器，不影响老年代</li><li><code>-XX:ParallelGCThreads</code>限制线程数量，默认和CPU核心数相同</li></ul><blockquote><ul><li><p>对于新生代，回收频繁，使用并行的方式高效</p></li><li><p>对于老年代，回收次数少，使用串行方式节省资源</p></li></ul></blockquote><h4 id="Parallel-Scavenge回收器：吞吐量优先"><a href="#Parallel-Scavenge回收器：吞吐量优先" class="headerlink" title="Parallel Scavenge回收器：吞吐量优先"></a>Parallel Scavenge回收器：吞吐量优先</h4><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/11/01/ARS3vOQZTyJs6oU.png" alt="image-20231101211115565" style="zoom:50%"><ul><li>Java8默认垃圾收集器</li><li>与ParNew收集器使用几乎一样的算法（并行回收，复制算法，STW）</li><li>它存在的意义：<ul><li>目标：达到一个可控制的吞吐量（吞吐量优先）</li><li>自适应调节策略：动态调整内存分配，以达到最优的吞吐量</li></ul></li><li>JDK1.6时提供了Parrallel Old收集器，代替Serial Old收集器<ul><li>Parrallel Old采用标记-压缩算法，并行回收，STW机制</li></ul></li><li>高吞吐量可以高效利用CPU时间，适合在后台运算而不需要太多交互的任务，例如服务器中<ul><li>Parallel和Parallel Old组合，在server模式下的性能很不错</li></ul></li></ul><p><strong>相关参数：</strong></p><ul><li><code>-XX:+UseParallelGC</code>：手动指定年轻代使用Parallel GC</li><li><code>-XX:+UseParallelOldGC</code>：手动指定老年代使用ParallelOld GC<ul><li>Java8默认使用，以上两个参数会互相激活，一个开启都会开启</li></ul></li><li><code>-XX:ParallelGCThreads</code>：年轻代并行收集器的线程数<ul><li>默认情况下，CPU数量小于等于8个，值等于CPU核心数；CPU数量大于8个，值等于3 + (5 * CPU_COUNT) / 8</li></ul></li><li><code>-XX:MaxGCPauseMillis</code>：设置STW的最大时间，单位毫秒<ul><li>为了控制时间，，收集器在工作时会调整Java堆大小或者其他一些参数</li><li>该参数使用需谨慎</li></ul></li><li><code>-XX:GCTimeRatio</code>：设置垃圾收集时间占总时间的比例，即目标吞吐量<ul><li>范围(0, 100)，默认99</li><li>与前一个参数矛盾，STW时间越长，Ratio参数就越容易超</li></ul></li><li><code>-XX:+UseAdaptiveSizePolicy</code>：设置开启自适应调节策略<ul><li>会自动调整：年轻代大小、Eden和Survivor比例、晋升老年代对象的年龄等参数。以达到堆大小、吞吐量、停顿时间之间的平衡</li><li>手动调优困难的场合，使用此模式，仅需指定虚拟机最大堆，目标吞吐量、停顿时间，让虚拟机自己完成工作</li></ul></li></ul><h4 id="CMS回收器：低延迟"><a href="#CMS回收器：低延迟" class="headerlink" title="CMS回收器：低延迟"></a>CMS回收器：低延迟</h4><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/11/02/ayJxUN4t19u8Qsz.png" alt="image-20231102152747567" style="zoom:50%"><ul><li>CMS关注点：尽可能缩短用户停顿时间<ul><li>低延时，适合与用户交互的程序，比如B/S系统的服务器</li></ul></li><li>采用标记-清除算法，也会STW</li><li>是老年代收集器，新生代只能选择使用ParNew或者Serial</li><li>G1出现之前，CMS使用还是很广泛的</li></ul><p><strong>CMS工作原理：</strong></p><ol><li>初始标记（Initial Mark）：所有工作线程都会STW，主要任务仅仅是标记出GC Root能直接关联的对象，非常快</li><li>并发标记（Concurrent Mark）：从能直接关联的对象开始遍历整个图，不需要停顿用户线程</li><li>重新标记（Remark）：正并发期间，程序继续运行，导致的一部分对象标记变动，对此进行修正，会STW但是非常快</li><li>并发清除阶段（Concurrent Sweep）：清除已经死亡的对象，由于不需要移动对象，所以可以和用户线程并发</li></ol><p><strong>CMS分析：</strong></p><ol><li>并非完全没有STW，而是尽可能减少STW</li><li>最耗时的<strong>并发标记</strong>、<strong>并发清除</strong>，都不需要暂停工作，整体的回收是低停顿的</li><li>由于垃圾收集阶段用户线程没有中断，所以CMS过程中需要保证有足够的内存<ul><li>CMS不能等到老年代完全被填满再收集，<strong>而是当堆内存使用达到阈值时，便开始进行回收</strong></li><li>要是CMS运行期间内存无法满足程序需要，会出现“Concurrent Mode Failure”失败</li><li>后备方案：临时启用Serial old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了</li></ul></li><li>CMS采用标记-清除算法，使用空闲链表，不可避免地将会产生一些内存碎片</li></ol><p><strong>优缺点：</strong></p><ul><li>优点：<ul><li>并发收集</li><li>低延迟</li></ul></li><li>缺点：<ul><li>会产生内存碎片</li><li>CMS收集器对CPU资源敏感，因为收集期间占用一部分线程，导致程序变慢</li><li>CMS收集器无法处理浮动垃圾，标记阶段如果产生新的对象，需要等下一次GC执行时才能回收</li></ul></li></ul><p><strong>CMS参数配置：</strong></p><ul><li><code>-XX:+UseConcMarkSweepGC</code>：指定使用CMS收集器<ul><li>会自动将<code>-XX:+UseParNewGC</code>打开，也即：ParNew（Young区）+CMS（Old区）+Serial Old（Old区备选方案）</li></ul></li><li><code>-XX:CMSInitiatingOccupanyFraction</code>：设置使用率阈值，一旦达到阈值，便开始收集<ul><li>JDK5之前默认68，JDK6以上默认92</li><li>如果内存增长缓慢，大的阈值可以降低CMS触发频率；如果内存增长很快，则应该降低这个阈值，避免触发Serial Old</li></ul></li><li><code>-XX:+UseCMSCompactAtFullCollection</code>：指定在Full GC后对内存空间进行压缩整理，避免内存碎片，不过停顿时间会变长</li><li><code>-XX:CMSFullGCsBeforeCompaction</code>：多少次Full GC，执行一次内存压缩</li><li><code>-XX:ParallelCMSThreads</code>：设置CMS的线程数量<ul><li>默认启动线程数是：(ParallelGCThreads + 3) / 4。（ParallelGCThreads默认值是核心数）</li></ul></li></ul><p><strong>前四种回收器小结：</strong></p><ol><li>最小化内存和并行开销，选择Serial GC</li><li>最大化吞吐量，选择Parallel GC</li><li>最小化中断时间，选择CMS GC</li></ol><p><strong>后续版本中CMS的变化：</strong></p><ul><li>JDK9新特性：CMS被标记为Deprecate了</li><li>JDK14新特性：删除CMS垃圾回收器</li></ul><h4 id="G1回收器：区域化分代式"><a href="#G1回收器：区域化分代式" class="headerlink" title="G1回收器：区域化分代式"></a>G1回收器：区域化分代式</h4><p><strong>为什么需要G1：</strong></p><ul><li><p>为了适应：不断扩大的内存和不断增加的处理器数量，进一步降低暂停时间，同时兼顾良好的吞吐量</p></li><li><p>目标：延迟可控情况下，获得尽可能高的吞吐量</p></li></ul><p><strong>为什么叫Garbage First：</strong></p><ol><li>把堆内存分割为很多不相关的区域（Region），物理上未必连续<ul><li>使用不同Region来表示Eden，S0，S1，老年代等</li></ul></li><li>有计划的避免全区域垃圾收集<ul><li>跟踪各个区域垃圾堆积的价值大小（回收获得的空间大小，回收所需时间的经验值）</li><li>每次根据允许的收集时间，优先回收价值最大的Region</li></ul></li><li>侧重点：回收垃圾最大量的区间，所以叫垃圾优先（Garbage First）</li><li>JDK1.7正式启用，JDK9成为默认垃圾回收器，取代了CMS，以及Parallel+Parallel Old<ul><li>在JDK8中，需要手动开启：<code>-XX:+UseG1GC</code></li></ul></li></ol><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/11/02/wtjNTX2L1mb7pyU.png" alt="image-20231102211544254" style="zoom:50%"><p><strong>G1优势：</strong></p><ol><li>并行与并发兼备<ul><li>并行：G1在回收期间，可以有多个GC线程同时工作。用户线程STW</li><li>并发：G1拥有与用户线程交替执行的能力，部分工作可以和应用线程同时执行</li></ul></li><li>分代收集<ul><li>依然区分Eden，Survivor，老年代。但从堆的结构来看，不要求连续，也不再坚持固定大小和数量</li><li>G1兼顾年轻代和老年代</li></ul></li><li>空间整合<ul><li>CMS：标记-清除，若干次GC后进行一次碎片整理</li><li>G1：内存回收以region为单位，Region之间是复制算法，整体是标记-压缩算法，能避免碎片化</li></ul></li><li>可预测的停顿时间模型<ul><li>G1跟踪各Region垃圾堆积的价值（回收所得空间大小，回收所需时间，的经验值），在后台维护一个优先列表</li><li>根据允许的收集时间，优先回收价值最大的Region</li></ul></li></ol><p><strong>G1缺点：</strong></p><ol><li>相较于CMS，G1还不具有压倒性的优势<ul><li>比如：G1为垃圾收集产生的内存占用（Footprint），程序运行时的额外执行负载（overload）都要比CMS要高</li></ul></li><li>小内存上CMS表现大概率优于G1，平衡点大约在6-8G之间</li></ol><p><strong>G1参数设置：</strong></p><ul><li><code>-XX:+UseG1GC</code>：指定使用G1垃圾收集器</li><li><code>-XX:G1HeapRegionSize</code>：每个Region的大小。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000。</li><li><code>-XX:MaxGCPauseMillis</code>：设置期望达到的最大GC停顿时间指标，不保证达到，默认200ms</li><li><code>-XX:+ParallelGCThread</code>：设置STW时，GC线程数的值。最多设置为8</li><li><code>-XX:ConcGCThreads</code>：设置并发标记的线程数。设置为ParallelGcThreads的1/4左右</li><li><code>-XX:InitiatingHeapOccupancyPercent</code>：触发并发GC的占用率阈值。超过此值，就触发GC。默认45</li></ul><p><strong>G1收集器常见设置步骤：</strong></p><ol><li>开启G1</li><li>设置堆最大内存</li><li>设置最大停顿时间</li></ol><p><strong>G1的适用场景：</strong></p><ol><li>面向服务端应用（大内存，多处理器）</li><li>应用需求：低GC延时</li><li>用来替换JDK1.5中的CMS，在以下情况使用G1可能比CMS更好<ul><li>超过50%的堆空间，都被活动数据占用</li><li>对象分配或年代提升变化很快</li><li>GC停顿时间过长（长于0.5至1秒）</li></ul></li><li>HotSpot中，除了G1外，其他垃圾回收器均使用内置的JVM线程执行GC多线程。<ul><li>G1可以采用应用线程承担后台GC工作</li><li>即：JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收</li></ul></li></ol><h3 id="分区Region思想"><a href="#分区Region思想" class="headerlink" title="分区Region思想"></a>分区Region思想</h3><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/11/03/vNDnkIRYG6zLmTp.png" alt="image-20231103151007387"></p><p><strong>基本思想：</strong></p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/11/03/O2I8TwJe5WRZnMb.png" alt="image-20231103153327882" style="zoom:50%"><ol><li>使用G1时，将堆划分为约2048个大小相同的独立Region块，每个块大约控制在1MB到32MB之间（2的n次幂）<ul><li><code>-XX:G1HeapRegionSize</code>来设定</li></ul></li><li>新生代，老年代不再物理隔离，而是一部分Region的集合<ul><li>Region可能属于E，S，O，H</li><li>H是一种新的内存区域（Humongous），用于存放大对象</li><li>H是一组连续的区域，如果超过0.5个Region就放到H</li></ul></li><li>每个Region都是通过指针碰撞来分配空间的<ul><li>每个Region都有两个名为TAMS（Top at Mask Start）的指针</li></ul></li><li>Region同样可以使用TLAB来保证并发性</li></ol><p><strong>设置H区的原因：</strong></p><ul><li>之前：大对象直接被分配到老年区，但如果是一个短期对象的话，会有负面影响</li><li>现在：G1直接寻找连续的H区来存储，为了找到连续区域，有时会不得不启动Full GC<ul><li>G1大多数行为，都把H区作为老年代的一部分</li></ul></li></ul><h3 id="G1垃圾回收流程"><a href="#G1垃圾回收流程" class="headerlink" title="G1垃圾回收流程"></a>G1垃圾回收流程</h3><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/11/07/YkLVPRH1WrCuqxG.png" alt="image-20231107154636980" style="zoom:50%"><p><strong>主要包括三个环节：</strong></p><ul><li>年轻代GC（Young GC）</li><li>老年代并发标记（Concurrent Marking）</li><li>混合回收（Mixed GC）</li><li>（如果需要）单线程、独占式、高强度的Full GC，作为一种失败的后备选项</li></ul><p><strong>回收流程：</strong></p><ol><li>当Eden区用尽，开始年轻代GC<ul><li>并行独占式收集器</li><li>存活对象移动到Survivor区，或者老年区</li></ul></li><li>当堆内存达到一定值（默认45%），开始老年代并发标记</li><li>标记完成后，开始混合回收过程<ul><li>从老年区移动存活对象到空闲区间，空闲区间成为了老年代的一部分</li><li>不需要整个老年代被回收，只需要回收一部分Region</li></ul></li></ol><h4 id="年轻代GC"><a href="#年轻代GC" class="headerlink" title="年轻代GC"></a>年轻代GC</h4><ul><li>JVM启动时，G1先准备好Eden区，程序运行过程中不断创建对象到Eden区中；Eden区耗尽会启动一次Young GC</li><li>Young GC只回收Eden和Survivor区</li><li>先STW，再创建回收集（需要被回收的Region的集合，Young GC的回收集包括年轻代的所有分段）</li></ul><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/11/07/Fypx8QE74DhNPXW.png" alt="image-20231107205205079" style="zoom:50%"><p><strong>图片的意思：</strong></p><ol><li>回收完E和S区，存活对象复制到新的S区</li><li>S区达到阈值可以晋升为O区</li></ol><p><strong>细致过程：</strong></p><ol><li>第一阶段，扫描根：<ul><li>扫描GC Root，会连同RSet记录的外部引用一起，作为存活对象的入口</li></ul></li><li>第二阶段，更新RSet</li><li>第三阶段，处理RSet：<ul><li>识别被老年代对象指向的Eden中的对象</li></ul></li><li>第四阶段，复制对象：<ul><li>E区和S区中存活的对象，复制到新S区中空的内存分段</li><li>年龄未达阈值，年龄加一，达到阈值会被复制到Old区中空的内存分段去</li><li>如果S区空间不够，E区的部分数据会直接晋升到Old区</li></ul></li><li>第五阶段，处理引用：<ul><li>处理Soft，Weak，Phantom，Final，JNI Weak 等引用</li><li>最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</li></ul></li></ol><p><strong>备注：</strong></p><ol><li>对于应用程序的引用赋值语句 oldObject.field（这个是老年代）=object（这个是新生代），JVM会在之前和之后执行特殊的操作以在dirty card queue中入队一个保存了对象引用信息的card。在年轻代回收的时候，G1会对Dirty Card Queue中所有的card进行处理，以更新RSet，保证RSet实时准确的反映引用关系。</li><li>为什么不在引用赋值语句处直接更新RSet？这是为了性能的需要，RSet的处理需要线程同步，开销会很大，使用队列性能会好很多。</li></ol><h4 id="并发标记"><a href="#并发标记" class="headerlink" title="并发标记"></a>并发标记</h4><ol><li><p>初始标记：标记从根节点直接可达的对象</p><ul><li>只扫描直接可达对象，节省时间</li><li>这个阶段是STW的</li><li>会触发一次Young GC</li></ul></li><li><p>根区域扫描：</p><ul><li>扫描S区直接可达的老年代对象，并标记被引用的对象</li><li>必须在Young GC之前完成，因为Young GC会使用复制算法对Survivor区进行GC</li></ul></li><li><p>并发标记：</p><ul><li>在整个堆中进行并发标记），可能会被Young GC中断</li><li>若区域对象都是垃圾，此区域会被立即回收</li><li>并发标记过程中，会计算每个区域的对象活性（存活对象的比例）</li></ul></li><li><p>再次标记：</p><ul><li>由于应用程序持续进行，需要修正上一次的标记结果</li><li>是STW的</li><li>G1中采用了比CMS更快的原始快照算法：Snapshot-At-The-Beginning（SATB）</li></ul></li><li><p>独占清理：</p><ul><li>计算各个区域的存活对象和GC回收比例，并进行排序</li><li>识别可以混合回收的区域，为下阶段做铺垫</li><li>是STW的</li></ul></li><li><p>并发清理阶段：</p><ul><li>识别并清理完全空闲的区域</li></ul></li></ol><h4 id="混合回收"><a href="#混合回收" class="headerlink" title="混合回收"></a>混合回收</h4><ul><li><p>当越来越多对象晋升到老年代时，为避免内存耗尽，会触发混合回收（Mixed GC）</p></li><li><p>除了回收整个Young Region，还会回收部分Old Region</p></li><li><p>Mixed GC不等于Full GC</p></li></ul><p><strong>混合回收的细节：</strong></p><ul><li>并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来<ul><li>默认情况下，这些老年代的内存分段会分8次（可以通过-XX:G1MixedGCCountTarget设置）被回收</li><li>意思就是一个Region会被分为8个内存段</li></ul></li><li>混合回收的回收集（Collection Set）包括八分之一的老年代内存分段，Eden区内存分段，Survivor区内存分段<ul><li>和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段</li></ul></li><li>由于老年代中的内存分段默认分8次回收，G1会优先回收垃圾多的内存分段。<ul><li>垃圾占内存分段比例越高的，越会被先回收</li><li>阈值会决定内存分段是否被回收。XX:G1MixedGCLiveThresholdPercent，默认为65%，意思是垃圾占内存分段比例要达到65%才会被回收</li><li>如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间</li></ul></li><li>混合回收并不一定要进行8次。有一个阈值-XX:G1HeapWastePercent，默认值为10%，意思是允许整个堆内存中有10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于10%，则不再进行混合回收。因为GC会花费很多的时间但是回收到的内存却很少。</li></ul><h4 id="可选：Full-GC"><a href="#可选：Full-GC" class="headerlink" title="可选：Full GC"></a>可选：Full GC</h4><ol><li>G1的初衷就是要避免Full GC的出现。<strong>STW+单线程</strong>，性能非常差</li><li>要避免Full GC的发生，一旦发生Full GC，需要对JVM参数进行调整<ul><li>堆内存太小，复制存活对象时空间不够，增大内存来解决</li></ul></li></ol><p>导致G1 Full GC的原因可能有两个：</p><ol><li>Evacuation的时候没有足够的to-space来存放晋升的对象；</li><li>并发处理过程完成之前空间耗尽。</li></ol><h4 id="G1优化建议"><a href="#G1优化建议" class="headerlink" title="G1优化建议"></a>G1优化建议</h4><ol><li>年轻代的大小<ul><li>避免使用-Xmn或-XX:NewRatio等选项显式设置年轻代大小。默认使用可预测的暂停时间目标，让G1自己去调整</li></ul></li><li>暂停时间目标不要太苛刻<ul><li>G1的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间</li><li>评估G1吞吐量时，暂停时间目标不要太严苛。目标太严苛，表明你愿意承受更多的垃圾回收开销，这会影响吞吐量</li></ul></li></ol><h3 id="Remembered-Set（记忆集）"><a href="#Remembered-Set（记忆集）" class="headerlink" title="Remembered Set（记忆集）"></a>Remembered Set（记忆集）</h3><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/11/07/8rpNf4e2wSJInAU.png" alt="image-20231107162256120" style="zoom:50%"><p>问题：一个Region中的对象，可能被任意其他Region中的对象引用，判断对象存活是否需要扫描整个Java堆？</p><ul><li>其他分代收集器也有这个问题，回收新生代时需不需要扫描老年代？</li></ul><p><strong>解决方法：</strong></p><ul><li>所有分代收集器，JVM都会使用Remembered Set（记忆集）来避免全堆扫描</li><li>每个Region都有一个Remembered Set</li><li>每次Reference类型数据进行写操作时，都会产生一个Write Barrier暂时中断操作</li><li>检查将要写入的引用指向的对象，是否与该Reference类型数据在不同的Region<ul><li>如果是其他收集器，那就检查老年代对象是否引用了新生代对象</li></ul></li><li>如果不同，通过CardTable将相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中</li><li>当垃圾回收时，在GC根节点范围内加入Remembered Set即可</li></ul><h3 id="垃圾回收器总结"><a href="#垃圾回收器总结" class="headerlink" title="垃圾回收器总结"></a>垃圾回收器总结</h3><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/11/14/t7nJif8ACqB3SKe.png" alt="image-20231114152942124" style="zoom:67%"><p><strong>GC发展阶段：</strong></p><p>Serial =&gt; Parallel（并行）=&gt; CMS（并发）=&gt; G1 =&gt; ZGC</p><p><strong>如何选择垃圾回收器：</strong></p><ol><li>调整堆的大小，让JVM自适应完成</li><li>如果内存小于100M，使用<strong>串行</strong>收集器</li><li>如果是单核单机程序，没有停顿时间的要求，<strong>串行</strong>收集器</li><li>如果是多CPU，需要高吞吐量，允许停顿时间超过1秒，选择<strong>并行</strong>或者JVM自己选择</li><li>如果是多CPU，追求低停顿时间，使用<strong>并发</strong>收集器</li><li>官方推荐G1，性能高</li></ol><p><strong>面试：</strong></p><ul><li>如何判断一个对象能不能回收</li><li>垃圾回收算法有哪些</li><li>垃圾回收工作流程</li><li>多多关注垃圾回收器这一章的各种参数</li></ul><h3 id="GC日志分析"><a href="#GC日志分析" class="headerlink" title="GC日志分析"></a>GC日志分析</h3><p><strong>内存分配与垃圾回收的参数列表：</strong></p><ul><li><p>-XX:+PrintGC ：输出GC日志。类似：-verbose:gc</p></li><li><p>-XX:+PrintGCDetails ：输出GC的详细日志</p></li><li><p>-XX:+PrintGCTimestamps ：输出GC的时间戳（以基准时间的形式）</p></li><li><p>-XX:+PrintGCDatestamps ：输出GC的时间戳（以日期的形式，如2013-05-04T21: 53: 59.234 +0800）</p></li><li><p>-XX:+PrintHeapAtGC ：在进行GC的前后打印出堆的信息</p></li><li><p>-Xloggc:…/logs/gc.log ：日志文件的输出路径</p></li></ul><h4 id="verbose-gc"><a href="#verbose-gc" class="headerlink" title="-verbose:gc"></a>-verbose:gc</h4><p>是一个JVM参数，只会显示总的GC堆的变化，如下：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/11/14/BMIa8icgs3fStZK.png" alt="img"></p><ul><li><p><strong>GC，Full GC</strong>：GC的类型，GC只在新生代进行，Full GC包括永久代，新生代，老年代</p></li><li><p><strong>Allocation Failure</strong>：GC发生的原因</p></li><li><p><strong>80832K-&gt;19298K：</strong>堆在GC前的大小和GC后的大小</p></li><li><p><strong>228840K：</strong>堆现在的大小</p></li><li><p><strong>0.0084018 secs</strong>：GC持续的时间</p></li></ul><h4 id="PrintGCDetails"><a href="#PrintGCDetails" class="headerlink" title="PrintGCDetails"></a>PrintGCDetails</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/11/14/GSg2NiQ8WDMbfaF.png" alt="img"></p><ul><li><strong>GC，Full GC</strong>：同样是GC的类型</li><li><strong>Allocation Failure</strong>：GC发生的原因</li><li><strong>PSYoungGen</strong>：使用了Parallel Scavenge并行垃圾收集器，新生代前后的大小变化</li><li><strong>ParOldGen</strong>：使用了Parallel Old并行垃圾收集器，老年代前后的大小变化</li><li><strong>MetaSpace</strong>：元数据区GC前后大小的变化，JDK1.8引入了元数据区以替代永久代</li><li><strong>0.02 secs</strong>：GC花费的时间</li><li><strong>Times</strong>：user-垃圾回收花费的所有CPU时间，sys-花费在等待系统调用或系统事件的时间，real-GC从开始到结束的时间，包括阔其他进程占用时间片的实际时间</li></ul><h4 id="PrintGCTimestamps"><a href="#PrintGCTimestamps" class="headerlink" title="PrintGCTimestamps"></a>PrintGCTimestamps</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/11/14/nGRCh9rwX6ysNUu.png" alt="image-20231114165705194"></p><ul><li><strong>GC，Full GC</strong>：GC的类型</li><li>收集器的名字<ul><li>**[DefNew]**：使用Serial收集器，默认新生代收集器</li><li>**[ParNew]**：使用ParNew收集器</li><li>**[PSYoungGen]**：使用Parallel scavenge收集器</li><li>G1会显示<strong>garbage-first heap</strong></li></ul></li><li>Allocation Failure：引起GC的原因（年轻代中没有足够的空间能够存储新的数据）</li><li>[ PSYoungGen: 5986K-&gt;696K(8704K) ] 5986K-&gt;704K (9216K)<ul><li>中括号内：年轻代，回收前大小，回收后大小，（年轻代总大小）</li><li>括号外：年轻代和老年代，回收前大小，回收后大小，（年轻代和老年代总大小）</li></ul></li><li>user代表用户态回收耗时，sys内核态回收耗时，real实际耗时<ul><li>由于多核线程切换的原因，时间总和可能会超过real时间</li></ul></li></ul></div><div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8"><div class="article-copyright-info-container"><ul><li><strong>标题:</strong> JVM系列：尚硅谷JVM笔记总和</li><li><strong>作者:</strong> 布鸽不鸽</li><li><strong>创建于 :</strong> 2024-01-10 14:57:32</li><li><strong>更新于 :</strong> 2024-01-10 14:58:17</li><li><strong>链接:</strong> https://xuedongyun.cn//post/58683/</li><li><strong>版权声明: </strong>本文章采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a> 进行许可。</li></ul></div></div><ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden"><li class="tag-item mx-0.5"><a href="/tags/jvm/">#jvm</a>&nbsp;</li></ul><div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8"><div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2"><a class="prev" rel="prev" href="/post/0/"><span class="left arrow-icon flex justify-center items-center"><i class="fa-solid fa-chevron-left"></i> </span><span class="title flex justify-center items-center"><span class="post-nav-title-item"></span> <span class="post-nav-item">上一篇</span></span></a></div><div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2"><a class="next" rel="next" href="/post/1126/"><span class="title flex justify-center items-center"><span class="post-nav-title-item">JUC系列：（七）同步器</span> <span class="post-nav-item">下一篇</span> </span><span class="right arrow-icon flex justify-center items-center"><i class="fa-solid fa-chevron-right"></i></span></a></div></div><div class="comment-container px-2 sm:px-6 md:px-8 pb-8"><div class="comments-container mt-10 w-full"><div id="comment-anchor" class="w-full h-2.5"></div><div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">评论</div><div id="waline"></div><script type="module" data-swup-reload-script>import { init } from '/js/libs/waline.mjs';

      function loadWaline() {
        init({
          el: '#waline',
          serverURL: 'https://comment.xuedongyun.cn/',
          lang: 'zh-CN',
          dark: 'body[class~="dark-mode"]',
          requiredMeta: ['nick', 'mail'],
          emoji: [],
          recaptchaV3Key: "wasd",
          
        });
      }

      if (typeof swup !== 'undefined') {
        loadWaline();
      } else {
        window.addEventListener('DOMContentLoaded', loadWaline);
      }</script></div></div></div><div class="toc-content-container"><div class="post-toc-wrap"><div class="post-toc"><div class="toc-title">此页目录</div><div class="page-title">JVM系列：尚硅谷JVM笔记总和</div><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM%E5%92%8CJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-text">JVM和Java体系结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="nav-text">Java虚拟机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E4%BB%A3%E7%A0%81%E6%89%A7%E6%B5%81%E7%A8%8B"><span class="nav-text">Java代码执流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM%E4%BD%8D%E7%BD%AE"><span class="nav-text">JVM位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84"><span class="nav-text">JVM整体结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%9E%8B"><span class="nav-text">JVM架构模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-text">JVM生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B"><span class="nav-text">JVM发展历程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF"><span class="nav-text">课程学习路线</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="nav-text">类加载子系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ClassLoader%E4%BD%9C%E7%94%A8"><span class="nav-text">ClassLoader作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ClassLoader%E8%A7%92%E8%89%B2"><span class="nav-text">ClassLoader角色</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="nav-text">类加载过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ClassLoader%E5%88%86%E7%B1%BB"><span class="nav-text">ClassLoader分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ClassLoader%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-text">ClassLoader常用方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="nav-text">双亲委派机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-text">其他</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA"><span class="nav-text">运行时数据区</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%83%85%E5%86%B5"><span class="nav-text">基本情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B"><span class="nav-text">线程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="nav-text">程序计数器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#PC-Register%E4%BB%8B%E7%BB%8D"><span class="nav-text">PC Register介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="nav-text">举例说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E4%B8%AA%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98"><span class="nav-text">两个面试问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="nav-text">虚拟机栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AE%B9"><span class="nav-text">基本内容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-text">虚拟机栈的特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="nav-text">虚拟机栈的异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E6%A0%88%E5%A4%A7%E5%B0%8F"><span class="nav-text">设置栈大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83"><span class="nav-text">栈的存储单元</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8%EF%BC%88Local-Variables%EF%BC%89"><span class="nav-text">局部变量表（Local Variables）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%EF%BC%88Operand-Stack%EF%BC%89"><span class="nav-text">操作数栈（Operand Stack）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%EF%BC%88Dynamic-Linking%EF%BC%89"><span class="nav-text">动态链接（Dynamic Linking）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8"><span class="nav-text">方法的调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80%EF%BC%88return-address%EF%BC%89"><span class="nav-text">方法返回地址（return address）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E5%B8%A7%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E9%99%84%E5%8A%A0%E4%BF%A1%E6%81%AF"><span class="nav-text">栈帧中的一些附加信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E7%9A%845%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-text">虚拟机栈的5道面试题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3"><span class="nav-text">本地方法接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95"><span class="nav-text">什么是本地方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95"><span class="nav-text">为什么要使用本地方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-text">本地方法栈的理解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86"><span class="nav-text">堆</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="nav-text">堆的核心概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E5%A0%86%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F%E4%B8%8EOOM"><span class="nav-text">设置堆内存大小与OOM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B4%E8%BD%BB%E4%BB%A3%E4%B8%8E%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="nav-text">年轻代与老年代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E8%A7%A3%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B"><span class="nav-text">图解对象分配过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Minor-GC%E3%80%81Major-GC%E3%80%81Full-GC"><span class="nav-text">Minor GC、Major GC、Full GC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GC%E4%B8%BE%E4%BE%8B%E4%B8%8E%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90"><span class="nav-text">GC举例与日志分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E7%A9%BA%E9%97%B4%E5%88%86%E4%BB%A3%E6%80%9D%E6%83%B3"><span class="nav-text">堆空间分代思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%E2%80%93%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="nav-text">总结–内存分配策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A5%E5%85%85%E2%80%93%E4%B8%BA%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%EF%BC%9ATLAB"><span class="nav-text">补充–为对象分配内存：TLAB</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93%E2%80%93%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE"><span class="nav-text">小结–参数设置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90"><span class="nav-text">逃逸分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93"><span class="nav-text">本章小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="nav-text">方法区</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88-%E5%A0%86-%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E4%BA%A4%E4%BA%92%E5%85%B3%E7%B3%BB"><span class="nav-text">栈-堆-方法区的交互关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-text">方法区的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hotspot%E4%B8%AD%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E6%BC%94%E8%BF%9B"><span class="nav-text">Hotspot中方法区的演进</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95%E5%8C%BA%E5%A4%A7%E5%B0%8F%E4%B8%8EOOM"><span class="nav-text">设置方法区大小与OOM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="nav-text">方法区的内部结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E4%BD%BF%E7%94%A8%E4%B8%BE%E4%BE%8B"><span class="nav-text">方法区使用举例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E6%BC%94%E8%BF%9B%E7%BB%86%E8%8A%82"><span class="nav-text">方法区的演进细节</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-text">方法区的垃圾回收</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-text">总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-text">面试题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-text">实例化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-text">对象的实例化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="nav-text">对象的内存布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D"><span class="nav-text">对象的访问定位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-text">对象访问的方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="nav-text">直接内存（了解）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8"><span class="nav-text">简单使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95"><span class="nav-text">性能测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%AE%9E%E9%AA%8C"><span class="nav-text">直接内存溢出实验</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E"><span class="nav-text">执行引擎</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-text">执行引擎的工作流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91%E5%92%8C%E6%89%A7%E8%A1%8C%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-text">代码编译和执行的过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A%E5%99%A8"><span class="nav-text">解释器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JIT%E7%BC%96%E8%AF%91%E5%99%A8"><span class="nav-text">JIT编译器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HotSpot%E4%B8%AD%E7%9A%84%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C"><span class="nav-text">HotSpot中的程序执行</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#StringTable"><span class="nav-text">StringTable</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#String%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7"><span class="nav-text">String基本特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-text">String内存分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-text">String基本操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E6%93%8D%E4%BD%9C"><span class="nav-text">字符串拼接操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#intern-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">intern()的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#StringTable%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%B5%8B%E8%AF%95"><span class="nav-text">StringTable垃圾回收测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#G1%E4%B8%AD%E7%9A%84String%E5%8E%BB%E9%87%8D%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="nav-text">G1中的String去重操作（了解）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0"><span class="nav-text">垃圾回收概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9E%83%E5%9C%BE"><span class="nav-text">什么是垃圾</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81GC"><span class="nav-text">为什么需要GC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="nav-text">Java垃圾回收机制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="nav-text">垃圾回收算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5"><span class="nav-text">标记阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1finalization%E6%9C%BA%E5%88%B6"><span class="nav-text">对象finalization机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MAT%E8%BF%9B%E8%A1%8CGCRoots%E6%BA%AF%E6%BA%90"><span class="nav-text">MAT进行GCRoots溯源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JProfiler%E8%BF%9B%E8%A1%8CGCRoots%E6%BA%AF%E6%BA%90"><span class="nav-text">JProfiler进行GCRoots溯源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JProfiler%E5%88%86%E6%9E%90OOM"><span class="nav-text">JProfiler分析OOM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B8%85%E9%99%A4%E9%98%B6%E6%AE%B5"><span class="nav-text">清除阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="nav-text">分代收集算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A2%9E%E9%87%8F%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="nav-text">增量收集算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E7%AE%97%E6%B3%95"><span class="nav-text">分区算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E8%AF%B4%E6%98%8E"><span class="nav-text">垃圾回收相关概念说明</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#System-gc-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-text">System.gc()的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="nav-text">内存溢出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="nav-text">内存泄露</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Stop-The-World"><span class="nav-text">Stop The World</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91"><span class="nav-text">垃圾回收的并行与并发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E7%82%B9%E4%B8%8E%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="nav-text">安全点与安全区域（了解）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%8D%E8%B0%88%E5%BC%95%E7%94%A8"><span class="nav-text">再谈引用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-text">垃圾回收器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%88%86%E7%B1%BB"><span class="nav-text">垃圾回收器分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%84%E4%BC%B0%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="nav-text">评估性能指标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-text">不同垃圾回收器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%8C%BARegion%E6%80%9D%E6%83%B3"><span class="nav-text">分区Region思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%B5%81%E7%A8%8B"><span class="nav-text">G1垃圾回收流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Remembered-Set%EF%BC%88%E8%AE%B0%E5%BF%86%E9%9B%86%EF%BC%89"><span class="nav-text">Remembered Set（记忆集）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%80%BB%E7%BB%93"><span class="nav-text">垃圾回收器总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GC%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90"><span class="nav-text">GC日志分析</span></a></li></ol></li></ol></div></div></div></div></div></div><div class="main-content-footer"><footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color"><div class="info-container py-3 text-center"><div class="text-center">&copy; <span>2022</span> - 2024&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration:0.5s;color:#f54545"></i>&nbsp;&nbsp;<a href="/">布鸽不鸽</a></div><script data-swup-reload-script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right"><span id="busuanzi_container_site_uv" class="lg:!block"><span class="text-sm">访问人数</span> <span id="busuanzi_value_site_uv"></span> </span><span id="busuanzi_container_site_pv" class="lg:!block"><span class="text-sm">总访问量</span> <span id="busuanzi_value_site_pv"></span></span></div><div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left"><span class="lg:block text-sm">由 <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a> 驱动</span> <span class="text-sm lg:block">主题&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.6.0</a></span></div><div>博客已运行 <span class="odometer" id="runtime_days"></span> 天 <span class="odometer" id="runtime_hours"></span> 小时 <span class="odometer" id="runtime_minutes"></span> 分钟 <span class="odometer" id="runtime_seconds"></span> 秒</div><script data-swup-reload-script>try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}</script></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="article-tools-list"><li class="right-bottom-tools page-aside-toggle"><i class="fa-regular fa-outdent"></i></li><li class="go-comment"><i class="fa-regular fa-comments"></i></li></ul></div></div><div class="right-side-tools-container"><div class="side-tools-container"><ul class="hidden-tools-list"><li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center"><i class="fa-regular fa-magnifying-glass-plus"></i></li><li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center"><i class="fa-regular fa-magnifying-glass-minus"></i></li><li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center"><i class="fa-regular fa-moon"></i></li><li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center"><i class="fa-regular fa-arrow-down"></i></li></ul><ul class="visible-tools-list"><li class="right-bottom-tools toggle-tools-list flex justify-center items-center"><i class="fa-regular fa-cog fa-spin"></i></li><li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center"><i class="arrow-up fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><div class="image-viewer-container"><img src=""></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fa-solid fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa-solid fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.0/source/js/libs/Swup.min.js"></script><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.0/source/js/libs/SwupSlideTheme.min.js"></script><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.0/source/js/libs/SwupScriptsPlugin.min.js"></script><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.0/source/js/libs/SwupProgressPlugin.min.js"></script><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.0/source/js/libs/SwupScrollPlugin.min.js"></script><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.0/source/js/libs/SwupPreloadPlugin.min.js"></script><script>const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });</script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.0/source/js/tools/imageViewer.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.0/source/js/utils.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.0/source/js/main.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.0/source/js/layouts/navbarShrink.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.0/source/js/tools/scrollTopBottom.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.0/source/js/tools/lightDarkSwitch.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.0/source/js/layouts/categoryList.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.0/source/js/tools/localSearch.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.0/source/js/tools/codeBlock.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.0/source/js/layouts/lazyload.js"></script><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.0/source/js/tools/runtime.js"></script><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.0/source/js/libs/odometer.min.js"></script><link rel="stylesheet" href="//evan.beee.top/projects/hexo-theme-redefine@2.6.0/source/assets/odometer-theme-minimal.css"><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.0/source/js/libs/Typed.min.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.0/source/js/plugins/typed.js"></script><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.0/source/js/libs/mermaid.min.js"></script><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.0/source/js/plugins/mermaid.js"></script><div class="post-scripts" data-swup-reload-script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.0/source/js/tools/tocToggle.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.0/source/js/layouts/toc.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.0/source/js/plugins/tabs.js"></script></div><div id="aplayer"></div><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.0/source/js/libs/APlayer.min.js"></script><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.0/source/js/plugins/aplayer.js"></script></body></html>