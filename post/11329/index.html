<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="keywords" content="java,前端,python,AI"><meta name="author" content="布鸽不鸽"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://evan.beee.top" crossorigin><link rel="canonical" href="https://xuedongyun.cn/post/11329/"><meta name="robots" content="index,follow"><meta name="googlebot" content="index,follow"><meta name="revisit-after" content="1 days"><meta name="description" content="基本概述线程池作用：线程复用  降低资源消耗：减少了创建和销毁线程的次数 提高响应速度：任务到达，如果有线程可以直接用 提高可管理性：使用线程池可以进行统一的分配，管理  阻塞队列基本介绍阻塞队列的实现（java.util.concurrent.BlockingQueue接口）：  ArrayBlockQueue：数组结构，有界阻塞队列 LinkedBlockingQueue：链表结构，无界阻塞队"><meta property="og:type" content="article"><meta property="og:title" content="JUC系列：（六）线程池"><meta property="og:url" content="https://xuedongyun.cn/post/11329/index.html"><meta property="og:site_name" content="冬云的博客"><meta property="og:description" content="基本概述线程池作用：线程复用  降低资源消耗：减少了创建和销毁线程的次数 提高响应速度：任务到达，如果有线程可以直接用 提高可管理性：使用线程池可以进行统一的分配，管理  阻塞队列基本介绍阻塞队列的实现（java.util.concurrent.BlockingQueue接口）：  ArrayBlockQueue：数组结构，有界阻塞队列 LinkedBlockingQueue：链表结构，无界阻塞队"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://s2.loli.net/2023/12/12/Jh4oZpkV9UujBdg.png"><meta property="og:image" content="https://s2.loli.net/2023/12/12/x2PObXwSkBfMpR7.png"><meta property="og:image" content="https://s2.loli.net/2023/12/12/9LCDTNU7OjPwJQx.png"><meta property="og:image" content="https://s2.loli.net/2023/12/23/tM2C1UuoJHlNfbD.png"><meta property="article:published_time" content="2024-04-10T12:34:10.650Z"><meta property="article:modified_time" content="2024-01-10T06:58:18.000Z"><meta property="article:author" content="布鸽不鸽"><meta property="article:tag" content="juc"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://s2.loli.net/2023/12/12/Jh4oZpkV9UujBdg.png"><link rel="icon" type="image/png" href="/image/favicon.ico" sizes="192x192"><link rel="apple-touch-icon" sizes="180x180" href="/image/favicon.ico"><meta name="theme-color" content="#A31F34"><link rel="shortcut icon" href="/image/favicon.ico"><title>JUC系列：（六）线程池 | 冬云的博客</title><link rel="stylesheet" href="https://evan.beee.top/projects/hexo-theme-redefine@2.7.2/source/fonts/Chillax/chillax.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="https://evan.beee.top/projects/hexo-theme-redefine@2.7.2/source/assets/build/styles.css"><link rel="stylesheet" href="https://evan.beee.top/projects/hexo-theme-redefine@2.7.2/source/fonts/GeistMono/geist-mono.css"><link rel="stylesheet" href="https://evan.beee.top/projects/hexo-theme-redefine@2.7.2/source/fonts/Geist/geist.css"><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.7.2/source/js/libs/anime.min.js"></script><script id="hexo-configurations">window.config={hostname:"xuedongyun.cn",root:"/",language:"zh-CN",path:"search.xml"},window.theme={articles:{style:{font_size:"16px",line_height:1.5,image_border_radius:"14px",image_alignment:"center",image_caption:!1,link_icon:!0,title_alignment:"left",headings_top_spacing:{h1:"3.2rem",h2:"2.4rem",h3:"1.9rem",h4:"1.6rem",h5:"1.4rem",h6:"1.3rem"}},word_count:{enable:!0,count:!0,min2read:!0},author_label:{enable:!0,auto:!1,list:[]},code_block:{copy:!0,style:"mac",highlight_theme:{light:"github",dark:"vs2015"},font:{enable:!1,family:null,url:null}},toc:{enable:!0,max_depth:3,number:!1,expand:!0,init_open:!0},copyright:{enable:!0,default:"cc_by_nc_sa"},lazyload:!0,recommendation:{enable:!0,title:"推荐阅读",limit:3,mobile_limit:2,placeholder:"/images/wallhaven-wqery6-light.webp",skip_dirs:[]}},colors:{primary:"#A31F34",secondary:null,default_mode:"light"},global:{fonts:{chinese:{enable:!1,family:null,url:null},english:{enable:!1,family:null,url:null},title:{enable:!1,family:null,url:null}},content_max_width:"1000px",sidebar_width:"210px",hover:{shadow:!0,scale:!0},scroll_progress:{bar:!0,percentage:!0},website_counter:{url:"https://cn.vercount.one/js",enable:!0,site_pv:!0,site_uv:!0,post_pv:!0},single_page:!0,preloader:{enable:!0,custom_message:null},open_graph:!0,google_analytics:{enable:!1,id:null}},home_banner:{enable:!0,style:"fixed",image:{light:"https://s2.loli.net/2023/04/26/5keLlFDntNaz81Z.webp",dark:"https://s2.loli.net/2023/04/26/5keLlFDntNaz81Z.webp"},title:"程序员的个人修养",subtitle:{text:["Hello World!","Across the Great Wall we can reach every corner in the world"],hitokoto:{enable:!1,show_author:!1,api:"https://v1.hitokoto.cn"},typing_speed:50,backing_speed:80,starting_delay:500,backing_delay:1500,loop:!0,smart_backspace:!0},text_color:{light:"#fff",dark:"#d1d1b6"},text_style:{title_size:"2.8rem",subtitle_size:"1.5rem",line_height:1.2},custom_font:{enable:!1,family:null,url:null},social_links:{enable:!1,style:"default",links:{github:null,instagram:null,zhihu:null,twitter:null,email:null},qrs:{weixin:null}}},plugins:{feed:{enable:!1},aplayer:{enable:!0,type:"fixed",audios:[{name:"One Last Kiss",artist:"宇多田ヒカル",url:"/music/OneLastKiss.mp3",cover:"/image/OneLastKiss.webp",lrc:null},{name:"水星记",artist:"郭顶",cover:"/image/水星记.webp",url:"/music/水星记.mp3"},{name:"平凡之路",artist:"朴树",cover:"/image/平凡之路.webp",url:"/music/平凡之路.mp3"}]},mermaid:{enable:!0,version:"9.3.0"}},version:"2.7.2",navbar:{auto_hide:!1,color:{left:"#f78736",right:"#367df7",transparency:50},width:{home:"1200px",pages:"1000px"},links:{Home:{path:"/",icon:"fa-regular fa-house"},java:{path:"/categories/java/",icon:"fa-regular fa-server"},MySQL:{path:"/categories/MySQL/",icon:"fa-regular fa-hard-drive"},Redis:{path:"/categories/Redis/",icon:"fa-regular fa-memory"},MQ:{path:"/categories/MQ/",icon:"fa-regular fa-pipe-circle-check"},"算法题":{path:"/categories/算法题/",icon:"fa-regular fa-laptop-code"},"工具和应用":{path:"/categories/工具和应用/",icon:"fa-regular fa-toolbox"}},search:{enable:!0,preload:!0}},page_templates:{friends_column:2,tags_style:"blur"},home:{sidebar:{enable:!0,position:"left",first_item:"menu",announcement:"Fly Me To The Moon",show_on_mobile:!0,links:{"博客搭建系列":{path:"/tags/博客搭建系列"},"SpringBoot源码系列":{path:"/tags/SpringBoot源码系列"},"Java设计模式系列":{path:"/tags/java设计模式系列"},"Redis实战系列":{path:"/tags/Redis实战系列"}}},article_date_format:"auto",excerpt_length:200,categories:{enable:!0,limit:3},tags:{enable:!0,limit:3}},footerStart:"2022/4/19 20:56:00"},window.lang_ago={second:"%s 秒前",minute:"%s 分钟前",hour:"%s 小时前",day:"%s 天前",week:"%s 周前",month:"%s 个月前",year:"%s 年前"},window.data={masonry:!1}</script><link rel="stylesheet" href="https://evan.beee.top/projects/hexo-theme-redefine@2.7.2/source/fontawesome/fontawesome.min.css"><link rel="stylesheet" href="https://evan.beee.top/projects/hexo-theme-redefine@2.7.2/source/fontawesome/brands.min.css"><link rel="stylesheet" href="https://evan.beee.top/projects/hexo-theme-redefine@2.7.2/source/fontawesome/solid.min.css"><link rel="stylesheet" href="https://evan.beee.top/projects/hexo-theme-redefine@2.7.2/source/fontawesome/regular.min.css"><meta name="generator" content="Hexo 6.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head><body><div class="progress-bar-container"><span class="scroll-progress-bar"></span> <span class="pjax-progress-bar"></span></div><style>:root{--preloader-background-color:#fff;--preloader-text-color:#000}@media (prefers-color-scheme:dark){:root{--preloader-background-color:#202124;--preloader-text-color:#fff}}@media (prefers-color-scheme:light){:root{--preloader-background-color:#fff;--preloader-text-color:#000}}@media (max-width:600px){.ml13{font-size:2.6rem!important}}.preloader{display:flex;flex-direction:column;gap:1rem;align-items:center;justify-content:center;position:fixed;padding:12px;top:0;right:0;bottom:0;left:0;width:100vw;height:100vh;background-color:var(--preloader-background-color);z-index:1100;transition:opacity .2s ease-in-out}.ml13{font-size:3.2rem;color:var(--preloader-text-color);letter-spacing:-1px;font-weight:500;font-family:Chillax-Variable,sans-serif;text-align:center}.ml13 .word{display:inline-flex;flex-wrap:wrap;white-space:nowrap}.ml13 .letter{display:inline-block;line-height:1em}</style><div class="preloader"><h2 class="ml13">冬云的博客</h2><script>var textWrapper = document.querySelector('.ml13');
        // Split text into words
        var words = textWrapper.textContent.trim().split(' ');

        // Clear the existing content
        textWrapper.innerHTML = '';

        // Wrap each word and its letters in spans
        words.forEach(function(word) {
            var wordSpan = document.createElement('span');
            wordSpan.classList.add('word');
            wordSpan.innerHTML = word.replace(/\S/g, "<span class='letter'>$&</span>");
            textWrapper.appendChild(wordSpan);
            textWrapper.appendChild(document.createTextNode(' ')); // Add space between words
        });

        var animation = anime.timeline({ loop: true })
            .add({
                targets: '.ml13 .letter',
                translateY: [20, 0],
                translateZ: 0,
                opacity: [0, 1],
                filter: ['blur(5px)', 'blur(0px)'],
                easing: "easeOutExpo",
                duration: 1200,
                delay: (el, i) => 300 + 20 * i,
            })
            .add({
                targets: '.ml13 .letter',
                translateY: [0, -20],
                opacity: [1, 0],
                filter: ['blur(0px)', 'blur(5px)'],
                easing: "easeInExpo",
                duration: 1000,
                delay: (el, i) => 15 * i,
                complete: function() {
                    hidePreloader();
                }
            }, '-=700');


        let themeStatus = JSON.parse(localStorage.getItem('REDEFINE-THEME-STATUS'))?.isDark;

        // If the theme status is not found in local storage, check the preferred color scheme
        if (themeStatus === undefined || themeStatus === null) {
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                themeStatus = 'dark';
            } else {
                themeStatus = 'light';
            }
        }

        // Now you can use the themeStatus variable in your code
        if (themeStatus) {
            document.documentElement.style.setProperty('--preloader-background-color', '#202124');
            document.documentElement.style.setProperty('--preloader-text-color', '#fff');
        } else {
            document.documentElement.style.setProperty('--preloader-background-color', '#fff');
            document.documentElement.style.setProperty('--preloader-text-color', '#000');
        }

        window.addEventListener('load', function () {
            setTimeout(hidePreloader, 5000); // Call hidePreloader after 5000 milliseconds if not already called by animation
        });

        function hidePreloader() {
            var preloader = document.querySelector('.preloader');
            preloader.style.opacity = '0';
            setTimeout(function () {
                preloader.style.display = 'none';
            }, 200);
        }</script></div><main class="page-container" id="swup"><div class="main-content-container flex flex-col justify-between min-h-dvh"><div class="main-content-header"><header class="navbar-container px-6 md:px-12"><div class="navbar-content transition-navbar"><div class="left"><a class="logo-title" href="/">冬云的博客</a></div><div class="right"><div class="desktop"><ul class="navbar-list"><li class="navbar-item"><a href="/"><i class="fa-regular fa-house fa-fw"></i> 首页</a></li><li class="navbar-item"><a href="/categories/java/"><i class="fa-regular fa-server fa-fw"></i> JAVA</a></li><li class="navbar-item"><a href="/categories/MySQL/"><i class="fa-regular fa-hard-drive fa-fw"></i> MYSQL</a></li><li class="navbar-item"><a href="/categories/Redis/"><i class="fa-regular fa-memory fa-fw"></i> REDIS</a></li><li class="navbar-item"><a href="/categories/MQ/"><i class="fa-regular fa-pipe-circle-check fa-fw"></i> MQ</a></li><li class="navbar-item"><a href="/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"><i class="fa-regular fa-laptop-code fa-fw"></i> 算法题</a></li><li class="navbar-item"><a href="/categories/%E5%B7%A5%E5%85%B7%E5%92%8C%E5%BA%94%E7%94%A8/"><i class="fa-regular fa-toolbox fa-fw"></i> 工具和应用</a></li><li class="navbar-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></div><div class="icon-item navbar-bar"><div class="navbar-bar-middle"></div></div></div></div></div><div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between"><ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start"><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/"><span>首页 </span><i class="fa-regular fa-house fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/categories/java/"><span>JAVA </span><i class="fa-regular fa-server fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/categories/MySQL/"><span>MYSQL </span><i class="fa-regular fa-hard-drive fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/categories/Redis/"><span>REDIS </span><i class="fa-regular fa-memory fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/categories/MQ/"><span>MQ </span><i class="fa-regular fa-pipe-circle-check fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"><span>算法题 </span><i class="fa-regular fa-laptop-code fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/categories/%E5%B7%A5%E5%85%B7%E5%92%8C%E5%BA%94%E7%94%A8/"><span>工具和应用 </span><i class="fa-regular fa-toolbox fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active" href="/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%B3%BB%E5%88%97"><span>博客搭建系列</span> <i class="fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active" href="/tags/SpringBoot%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97"><span>SpringBoot源码系列</span> <i class="fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active" href="/tags/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97"><span>Java设计模式系列</span> <i class="fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active" href="/tags/Redis%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97"><span>Redis实战系列</span> <i class="fa-sm fa-fw"></i></a></li></ul><div class="statistics flex justify-around my-2.5"><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">11</div><div class="label text-third-text-color text-sm">标签</div></a><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">17</div><div class="label text-third-text-color text-sm">分类</div></a><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">49</div><div class="label text-third-text-color text-sm">文章</div></a></div></div><div class="window-mask"></div></header></div><div class="main-content-body"><div class="main-content"><div class="post-page-container flex relative justify-between box-border w-full h-full"><div class="article-content-container"><div class="article-title relative w-full"><div class="w-full flex items-center pt-6 justify-start"><h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">JUC系列：（六）线程池</h1></div></div><div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8"><div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]"><img src="https://s2.loli.net/2023/04/20/q9CpkwWALQae6Mj.jpg"></div><div class="info flex flex-col justify-between"><div class="author flex items-center"><span class="name text-default-text-color text-lg font-semibold">布鸽不鸽</span> <span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">Lv4</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fa-regular fa-pen-fancy"></i>&nbsp; <span class="desktop">2024-04-10 20:34:10</span> <span class="mobile">2024-04-10 20:34:10</span> <span class="hover-info">创建</span> </span><span class="article-date article-meta-item"><i class="fa-regular fa-wrench"></i>&nbsp; <span class="desktop">2024-01-10 14:58:18</span> <span class="mobile">2024-01-10 14:58:18</span> <span class="hover-info">更新</span> </span><span class="article-categories article-meta-item"><i class="fa-regular fa-folders"></i>&nbsp;<ul><li><a href="/categories/java/">java</a>&nbsp;</li></ul></span><span class="article-tags article-meta-item"><i class="fa-regular fa-tags"></i>&nbsp;<ul><li><a href="/tags/juc/">juc</a>&nbsp;</li></ul></span><span class="article-wordcount article-meta-item"><i class="fa-regular fa-typewriter"></i>&nbsp;<span>10.6k 字</span> </span><span class="article-min2read article-meta-item"><i class="fa-regular fa-clock"></i>&nbsp;<span>46 分钟</span> </span><span class="article-pv article-meta-item"><i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8"><h2 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h2><p>线程池作用：<strong>线程复用</strong></p><ul><li>降低资源消耗：减少了创建和销毁线程的次数</li><li>提高响应速度：任务到达，如果有线程可以直接用</li><li>提高可管理性：使用线程池可以进行统一的分配，管理</li></ul><h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>阻塞队列的实现（<code>java.util.concurrent.BlockingQueue</code>接口）：</p><ul><li><code>ArrayBlockQueue</code>：数组结构，有界阻塞队列</li><li><code>LinkedBlockingQueue</code>：链表结构，无界阻塞队列（有界，默认大小<code>Integer.MAX_VALUE</code>）</li><li><code>PriorityBlockQueue</code>：支持优先级排序的，无界阻塞队列</li><li><code>DelayedWorkQueue</code>：使用优先级队列实现的，延迟无界阻塞队列</li><li><code>SynchronousQueue</code>：不存储元素的阻塞队列，每一个生产线程会阻塞到有一个put的线程放入元素为止</li><li><code>LinkedTransferQueue</code>：链表结构，无界阻塞队列</li><li><code>LinkedBlockingDeque</code>：链表结构，双向阻塞队列</li></ul><p>阻塞队列：</p><ul><li>阻塞添加<code>put()</code>：队列已满时，添加元素的线程会被阻塞</li><li>阻塞删除<code>take()</code>：队列为空时，删除元素的线程会被阻塞</li></ul><h3 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h3><table><thead><tr><th>方法类型</th><th>抛出异常</th><th>特殊值（boolean或者null）</th><th>阻塞</th><th>超时（抛出错误）</th></tr></thead><tbody><tr><td>插入（尾）</td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e,time,unit)</td></tr><tr><td>移除（头）</td><td>remove()</td><td>poll()</td><td>take()</td><td>poll(time,unit)</td></tr><tr><td>检查（队首元素）</td><td>element()</td><td>peek()</td><td>不可用</td><td>不可用</td></tr></tbody></table><h3 id="链表阻塞队列"><a href="#链表阻塞队列" class="headerlink" title="链表阻塞队列"></a>链表阻塞队列</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedBlockingQueue</span>&lt;E&gt; </span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractQueue</span>&lt;E&gt; </span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">BlockingQueue</span>&lt;E&gt;, java.io.Serializable {</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; {</span><br><span class="line">        E item;</span><br><span class="line">        <span class="comment">// 真正的后继节点</span></span><br><span class="line">        <span class="comment">// null，表示队尾</span></span><br><span class="line">        <span class="comment">// 自己，发生在出队时</span></span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        Node(E x) { item = x; }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><h4 id="入队出队"><a href="#入队出队" class="headerlink" title="入队出队"></a>入队出队</h4><ul><li>有一个Dummy节点用来占位，item为null</li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/12/12/Jh4oZpkV9UujBdg.png" alt="image-20231212195823591"></p><ul><li>初始化链表，<code>last = head = new Node&lt;E&gt;(null)</code></li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedBlockingQueue</span><span class="params">(<span class="type">int</span> capacity)</span> {</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    last = head = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(<span class="literal">null</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><ul><li>节点入队（尾节点入队），<code>last = last.next = node</code></li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(Node&lt;E&gt; node)</span> {</span><br><span class="line">    last = last.next = node;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><ul><li>节点出队（头节点出队）</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> E <span class="title function_">dequeue</span><span class="params">()</span> {</span><br><span class="line">    Node&lt;E&gt; h = head;</span><br><span class="line">    Node&lt;E&gt; first = h.next;		<span class="comment">// 头节点的后继节点</span></span><br><span class="line">    h.next = h;					<span class="comment">// 旧头节点GC</span></span><br><span class="line">    head = first;				<span class="comment">// 设置新的头节点</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> first.item;			<span class="comment">// 返回的值</span></span><br><span class="line">    first.item = <span class="literal">null</span>;			<span class="comment">// 当前head节点变为Dummy节点</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/12/12/x2PObXwSkBfMpR7.png" alt="image-20231212200606216" style="zoom:67%"> <img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/12/12/9LCDTNU7OjPwJQx.png" alt="image-20231212200611933" style="zoom:67%"><blockquote><p>总结：无论如何，head节点总是Dummy节点（item为null）</p></blockquote><h4 id="加锁分析"><a href="#加锁分析" class="headerlink" title="加锁分析"></a>加锁分析</h4><p>用了两把锁 + dummy节点</p><p><strong>线程安全分析：</strong></p><ul><li>节点总数大于2时（包括dummy节点），<code>putLock</code>保证last节点的线程安全，<code>takeLock</code>保证head节点的安全</li><li>节点总数等于2时（一个dummy节点，一个正常节点），仍然是两把锁，不会竞争</li><li>节点总数等于1时（一个dummy节点），take线程被<code>noEmpty</code>条件阻塞，有竞争，会阻塞</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于put（阻塞），没满才能put</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notFull</span> <span class="operator">=</span> putLock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于take（阻塞），不为空才能take</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notEmpty</span> <span class="operator">=</span> takeLock.newCondition();</span><br></pre></td></tr></table></figure></div><h5 id="put入队"><a href="#put入队" class="headerlink" title="put入队"></a>put入队</h5><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LinkedBlockingQueue类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();	<span class="comment">// 空指针异常</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(e);						<span class="comment">// 把待添加元素封装为node节点</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="built_in">this</span>.putLock;			<span class="comment">// 获取全局putLock</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.count;				<span class="comment">// count维护元素计数</span></span><br><span class="line">    putLock.lockInterruptibly();						<span class="comment">// putLock加锁</span></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) {</span><br><span class="line">            notFull.await();							<span class="comment">// 队满了等待</span></span><br><span class="line">        }</span><br><span class="line">        enqueue(node);									<span class="comment">// 有空位，尾插法入队</span></span><br><span class="line">        c = count.getAndIncrement();					<span class="comment">// count自增</span></span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();							<span class="comment">// put完，发现队列还有空位，唤醒一个其他put线程</span></span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        putLock.unlock();								<span class="comment">// putLock解锁</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();								<span class="comment">// 自增前是0，说明生产了一个元素，唤醒一个take线程</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LinkedBlockingQueue类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">signalNotEmpty</span><span class="params">()</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="built_in">this</span>.takeLock;</span><br><span class="line">    takeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        notEmpty.signal();	<span class="comment">// 调用signal而不是signalAll，是为了减少竞争</span></span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><h5 id="take出队"><a href="#take出队" class="headerlink" title="take出队"></a>take出队</h5><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    E x;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.count;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="built_in">this</span>.takeLock;</span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) {</span><br><span class="line">            notEmpty.await();			<span class="comment">// 没有元素可以出队，则阻塞</span></span><br><span class="line">        }</span><br><span class="line">        x = dequeue();					<span class="comment">// 出队</span></span><br><span class="line">        c = count.getAndDecrement();	<span class="comment">// count自减</span></span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">            notEmpty.signal();			<span class="comment">// 如果队列还有元素，唤醒一个take线程</span></span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        takeLock.unlock();				<span class="comment">// takeLock解锁</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();				<span class="comment">// 自减前是满的，说明消费了一个元素，唤醒一个put线程</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">signalNotFull</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="built_in">this</span>.putLock;</span><br><span class="line">    putLock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        notFull.signal();</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><h3 id="同步阻塞队列"><a href="#同步阻塞队列" class="headerlink" title="同步阻塞队列"></a>同步阻塞队列</h3><p><code>SynchronousQueue</code> 是一个不存储元素的<code>BlockingQueue</code>，<strong>每一个生产者必须阻塞匹配到一个消费者</strong></p><h4 id="成员属性"><a href="#成员属性" class="headerlink" title="成员属性"></a>成员属性</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronousQueue</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractQueue</span>&lt;E&gt; {</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前平台CPU数量</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NCPUS</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指定超时时间，当前线程最大自旋数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">maxTimedSpins</span> <span class="operator">=</span> (NCPUS &lt; <span class="number">2</span>) ? <span class="number">0</span> : <span class="number">32</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 未指定超时时间，当前线程最大自旋数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">maxUntimedSpins</span> <span class="operator">=</span> maxTimedSpins * <span class="number">16</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指定超时限制的阈值，小于该值的线程不会被挂起</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">spinForTimeoutThreshold</span> <span class="operator">=</span> <span class="number">1000L</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><ul><li>转换器</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Transferer&lt;E&gt; transferer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Transferer</span>&lt;E&gt; {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 参数一：可以为null，表示这个是一个REQUEST类型的请求；反之是一个DATA类型的请求</span></span><br><span class="line"><span class="comment">    * 参数二：true表示指定了超时时间；false表示不支持超时，会一直阻塞到匹配或者被打断</span></span><br><span class="line"><span class="comment">    * 参数三：超时时间限制，单位是纳秒</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * 返回值：返回值不为null，表示匹配成功。DATA类型的请求，会返回当前线程put的数据。</span></span><br><span class="line"><span class="comment">    *		 返回值为null，表示请求超时或者被中断。</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="keyword">abstract</span> E <span class="title function_">transfer</span><span class="params">(E e, <span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><ul><li>构造方法</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">SynchronousQueue</span><span class="params">(<span class="type">boolean</span> fair)</span> {</span><br><span class="line">    <span class="comment">// 非公平同步队列：TransferStack</span></span><br><span class="line">    <span class="comment">// 公平同步队列：TransferQueue</span></span><br><span class="line">    transferer = fair ? <span class="keyword">new</span> <span class="title class_">TransferQueue</span>&lt;E&gt;() : <span class="keyword">new</span> <span class="title class_">TransferStack</span>&lt;E&gt;();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><ul><li>成员方法</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> {</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="keyword">return</span> transferer.transfer(e, <span class="literal">true</span>, <span class="number">0</span>) != <span class="literal">null</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> transferer.transfer(<span class="literal">null</span>, <span class="literal">true</span>, <span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><h4 id="非公平（TransferStack）"><a href="#非公平（TransferStack）" class="headerlink" title="非公平（TransferStack）"></a>非公平（TransferStack）</h4><p><code>TransferStack</code>是非公平同步队列</p><p>所有请求都被压入栈中，栈顶元素最先匹配，栈底元素存在饥饿的问题</p><h5 id="TransferStack类成员变量"><a href="#TransferStack类成员变量" class="headerlink" title="TransferStack类成员变量"></a>TransferStack类成员变量</h5><ul><li>请求类型</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">REQUEST</span>    <span class="operator">=</span> <span class="number">0</span>;	<span class="comment">// 表示Node类型为请求类型</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DATA</span>       <span class="operator">=</span> <span class="number">1</span>;	<span class="comment">// 表示Node类型为数据类型</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">FULFILLING</span> <span class="operator">=</span> <span class="number">2</span>;	<span class="comment">// 表示Node类型为匹配中类型</span></span><br><span class="line">									<span class="comment">// 假如栈顶元素为REQUEST，当前请求类型为DATA，入栈会修改为FULFILLING</span></span><br><span class="line">									<span class="comment">// 假如栈顶元素为DATA，当前请求类型为REQUEST，入栈会修改为FULFILLING</span></span><br></pre></td></tr></table></figure></div><ul><li>栈顶元素</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> SNode head;</span><br></pre></td></tr></table></figure></div><h5 id="SNode内部类"><a href="#SNode内部类" class="headerlink" title="SNode内部类"></a>SNode内部类</h5><ul><li>成员变量</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SNode</span> {</span><br><span class="line">    <span class="keyword">volatile</span> SNode next;        <span class="comment">// 下一个栈帧</span></span><br><span class="line">    <span class="keyword">volatile</span> SNode match;       <span class="comment">// 与当前node匹配的节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread waiter;     <span class="comment">// 挂起前，需要保存线程引用，以便唤醒</span></span><br><span class="line">    Object item;                <span class="comment">// 数据域，不为null表示请求类型为DATA；为null表示请求类型为REQUEST</span></span><br><span class="line">    <span class="type">int</span> mode;					<span class="comment">// 表示当前Node的模式【REQUEST / DATA / FULFILLING】</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><ul><li>构造方法</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SNode(Object item) {</span><br><span class="line">    <span class="built_in">this</span>.item = item;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><ul><li>设置方法：设置Node对象的next字段，此处使用了CAS</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">casNext</span><span class="params">(SNode cmp, SNode val)</span> {</span><br><span class="line">    <span class="comment">// cmp != next，就已经不需要CAS了</span></span><br><span class="line">    <span class="comment">// cmp == next，开始CAS修改Node对象的next字段</span></span><br><span class="line">    <span class="keyword">return</span> cmp == next &amp;&amp; UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, nextOffset, cmp, val);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><ul><li>匹配方法：为当前Node匹配一个其他Node</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">tryMatch</span><span class="params">(SNode s)</span> {</span><br><span class="line">    <span class="comment">// 当前match为null，使用CAS设置match字段为s</span></span><br><span class="line">    <span class="keyword">if</span> (match == <span class="literal">null</span> &amp;&amp; UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, matchOffset, <span class="literal">null</span>, s)) {</span><br><span class="line">        </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">w</span> <span class="operator">=</span> waiter;			<span class="comment">// 匹配上了，会获取当前Node对应的线程</span></span><br><span class="line">        <span class="keyword">if</span> (w != <span class="literal">null</span>) {			<span class="comment">// 条件成立，说明Node对应，Thread正在阻塞</span></span><br><span class="line">            waiter = <span class="literal">null</span>;</span><br><span class="line">            LockSupport.unpark(w);	<span class="comment">// 使用unpark方式唤醒线程</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> match == s;				<span class="comment">// 匹配成功返回true</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><ul><li>取消方法：取消节点</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">tryCancel</span><span class="params">()</span> {</span><br><span class="line">    UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, matchOffset, <span class="literal">null</span>, <span class="built_in">this</span>);		<span class="comment">// 通过CAS将match指向自己，表示取消</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> match == <span class="built_in">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><h5 id="TransferStack类成员方法"><a href="#TransferStack类成员方法" class="headerlink" title="TransferStack类成员方法"></a>TransferStack类成员方法</h5><ul><li>snode方法：填充节点方法</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> SNode <span class="title function_">snode</span><span class="params">(SNode s, Object e, SNode next, <span class="type">int</span> mode)</span> {</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span>) s = <span class="keyword">new</span> <span class="title class_">SNode</span>(e);	<span class="comment">// 引用指向空时，snode方法创建一个SNode对象</span></span><br><span class="line">    s.mode = mode;</span><br><span class="line">    s.next = next;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><ul><li>transfer方法：核心方法，请求匹配出栈，不匹配则阻塞</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">E <span class="title function_">transfer</span><span class="params">(E e, <span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span> {</span><br><span class="line"></span><br><span class="line">    <span class="type">SNode</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mode</span> <span class="operator">=</span> (e == <span class="literal">null</span>) ? REQUEST : DATA;		<span class="comment">// 判断当前请求类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="type">SNode</span> <span class="variable">h</span> <span class="operator">=</span> head;								<span class="comment">// 栈顶指针</span></span><br><span class="line">        <span class="keyword">if</span> (h == <span class="literal">null</span> || h.mode == mode) {			<span class="comment">// 【case1】：栈顶为空，或者与当前请求无法匹配，入栈</span></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>) {				<span class="comment">// 支持超时，但是超时时间小于0，说明不支持“阻塞等待”</span></span><br><span class="line">                <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.isCancelled())	<span class="comment">// 栈顶是取消状态，则栈顶出栈，设置新的栈顶</span></span><br><span class="line">                    casHead(h, h.next);</span><br><span class="line">                <span class="keyword">else</span>								<span class="comment">// 匹配失败，直接返回null</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (casHead(h, s = snode(s, e, h, mode))) {	<span class="comment">// 入栈</span></span><br><span class="line">                <span class="type">SNode</span> <span class="variable">m</span> <span class="operator">=</span> awaitFulfill(s, timed, nanos);		<span class="comment">// 阻塞等待被匹配，成功返回匹配的节点，失败返回自己</span></span><br><span class="line">                <span class="keyword">if</span> (m == s) {</span><br><span class="line">                    clean(s);									<span class="comment">// 失败出栈</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> ((h = head) != <span class="literal">null</span> &amp;&amp; h.next == s)			<span class="comment">// 协助与之匹配的节点，出栈</span></span><br><span class="line">                    casHead(h, s.next);</span><br><span class="line">                <span class="comment">// 当前node模式为REQUEST类型：返回匹配节点的m.item数据域</span></span><br><span class="line">                <span class="comment">// 当前node模式为DATA类型：返回node.item数据域，当前请求提交的数据e</span></span><br><span class="line">                <span class="keyword">return</span> (E) ((mode == REQUEST) ? m.item : s.item);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (!isFulfilling(h.mode)) {	<span class="comment">// 【case2】：栈顶不是FULFILLING说明没被匹配，当前可以匹配</span></span><br><span class="line">            <span class="keyword">if</span> (h.isCancelled())			<span class="comment">// 头节点是取消节点，协助出栈</span></span><br><span class="line">                casHead(h, h.next);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (casHead(h, s=snode(s, e, h, FULFILLING|mode))) {	<span class="comment">// 入栈当前请求的节点</span></span><br><span class="line">                <span class="keyword">for</span> (;;) {</span><br><span class="line">                    <span class="type">SNode</span> <span class="variable">m</span> <span class="operator">=</span> s.next;			<span class="comment">// m是s的匹配节点</span></span><br><span class="line">                    <span class="keyword">if</span> (m == <span class="literal">null</span>) {			<span class="comment">// 可能m在await过程中被中断，clean了自己</span></span><br><span class="line">                        casHead(s, <span class="literal">null</span>);		<span class="comment">// 清空栈并返回外层自旋</span></span><br><span class="line">                        s = <span class="literal">null</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="type">SNode</span> <span class="variable">mn</span> <span class="operator">=</span> m.next;			<span class="comment">// 获取匹配节点的下一个节点</span></span><br><span class="line">                    <span class="keyword">if</span> (m.tryMatch(s)) {		<span class="comment">// 尝试匹配，匹配成功则将FULLFILLING和m出栈，并唤醒被匹配节点的线程</span></span><br><span class="line">                        casHead(s, mn);</span><br><span class="line">                        <span class="keyword">return</span> (E) ((mode == REQUEST) ? m.item : s.item);</span><br><span class="line">                    } <span class="keyword">else</span></span><br><span class="line">                        s.casNext(m, mn);		<span class="comment">// 匹配失败，出栈m</span></span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> {						<span class="comment">// 【case3】：栈顶是FULFILLING，栈顶和其下节点正在匹配，当前请求需要做协助</span></span><br><span class="line">            <span class="type">SNode</span> <span class="variable">m</span> <span class="operator">=</span> h.next;			<span class="comment">// h和m都是FULFILLING节点</span></span><br><span class="line">            <span class="keyword">if</span> (m == <span class="literal">null</span>)</span><br><span class="line">                casHead(h, <span class="literal">null</span>);		<span class="comment">// 清空栈</span></span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                <span class="type">SNode</span> <span class="variable">mn</span> <span class="operator">=</span> m.next;</span><br><span class="line">                <span class="keyword">if</span> (m.tryMatch(h))		<span class="comment">// m和h匹配，唤醒m中的线程</span></span><br><span class="line">                    casHead(h, mn);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    h.casNext(m, mn);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><ul><li><code>awaitFulfill</code>方法：阻塞当前线程，等待被匹配，或者取消当前节点</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">SNode <span class="title function_">awaitFulfill</span><span class="params">(SNode s, <span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> timed ? System.nanoTime() + nanos : <span class="number">0L</span>;	<span class="comment">// 等待的截止时间</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">w</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">spins</span> <span class="operator">=</span> (shouldSpin(s) ?									<span class="comment">// for自旋检查的次数</span></span><br><span class="line">                 (timed ? maxTimedSpins : maxUntimedSpins) : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="keyword">if</span> (w.isInterrupted())										<span class="comment">// 当前线程收到中断信号，设置node状态为取消</span></span><br><span class="line">            s.tryCancel();</span><br><span class="line">        <span class="type">SNode</span> <span class="variable">m</span> <span class="operator">=</span> s.match;											<span class="comment">// 获取与当前s匹配的节点</span></span><br><span class="line">        <span class="keyword">if</span> (m != <span class="literal">null</span>)												<span class="comment">// 可能是正常的匹配，也可能是取消的</span></span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        <span class="keyword">if</span> (timed) {												<span class="comment">// 如果超时就取消节点</span></span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) {</span><br><span class="line">                s.tryCancel();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (spins &gt; <span class="number">0</span>)												<span class="comment">// 如果当前线程可以自旋检查，就自旋并减1</span></span><br><span class="line">            spins = shouldSpin(s) ? (spins-<span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s.waiter == <span class="literal">null</span>)									<span class="comment">// 说明没有自旋次数了，保存线程，准备阻塞</span></span><br><span class="line">            s.waiter = w;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!timed)											<span class="comment">// 没有超时限制，直接阻塞</span></span><br><span class="line">            LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; spinForTimeoutThreshold)					<span class="comment">// nanos &gt; 1000纳秒的情况下，才允许挂起</span></span><br><span class="line">            LockSupport.parkNanos(<span class="built_in">this</span>, nanos);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><h4 id="公平（TransferQueue）"><a href="#公平（TransferQueue）" class="headerlink" title="公平（TransferQueue）"></a>公平（TransferQueue）</h4><p>TransferQueue是公平的同步队列，采用FIFO的队列实现，请求节点与队尾模式不同，需要与队头发生匹配</p><h5 id="TransferQueue类成员变量"><a href="#TransferQueue类成员变量" class="headerlink" title="TransferQueue类成员变量"></a>TransferQueue类成员变量</h5><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> QNode head;		<span class="comment">// 指向队列的dummy节点</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> QNode tail;		<span class="comment">// 指向队列的尾节点</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> QNode cleanMe;	<span class="comment">// 被清理节点的前驱节点</span></span><br></pre></td></tr></table></figure></div><h5 id="QNode内部类"><a href="#QNode内部类" class="headerlink" title="QNode内部类"></a>QNode内部类</h5><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">QNode</span> {</span><br><span class="line">    <span class="keyword">volatile</span> QNode next;	<span class="comment">// 当前节点的下一个节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Object item;	<span class="comment">// 数据域，为null代表是REQUEST类型，不为null表示为DATA类型</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread waiter;	<span class="comment">// 保存对应的线程引用</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> isData;	<span class="comment">// 是否是DATA类型</span></span><br><span class="line"></span><br><span class="line">    QNode(Object item, <span class="type">boolean</span> isData) {	<span class="comment">// 构造方法</span></span><br><span class="line">        <span class="built_in">this</span>.item = item;</span><br><span class="line">        <span class="built_in">this</span>.isData = isData;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">tryCancel</span><span class="params">(Object cmp)</span> {			<span class="comment">// 尝试取消当前node，取消的node的item指向自己</span></span><br><span class="line">        UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, itemOffset, cmp, <span class="built_in">this</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span> {					<span class="comment">// 判断当前node是否被取消</span></span><br><span class="line">        <span class="keyword">return</span> item == <span class="built_in">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isOffList</span><span class="params">()</span> {					<span class="comment">// 判断当前节点是否不在队列中（next指向自己）</span></span><br><span class="line">        <span class="keyword">return</span> next == <span class="built_in">this</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><h5 id="TransferQueue类成员方法"><a href="#TransferQueue类成员方法" class="headerlink" title="TransferQueue类成员方法"></a>TransferQueue类成员方法</h5><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">advanceHead</span><span class="params">(QNode h, QNode nh)</span> {</span><br><span class="line">    <span class="comment">// 设置头指针指向新的节点</span></span><br><span class="line">    <span class="keyword">if</span> (h == head &amp;&amp; UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, headOffset, h, nh))</span><br><span class="line">        h.next = h;	<span class="comment">// 老头节点出队</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">advanceTail</span><span class="params">(QNode t, QNode nt)</span> {</span><br><span class="line">    <span class="keyword">if</span> (tail == t)</span><br><span class="line">        <span class="comment">// 更新队尾节点指针</span></span><br><span class="line">        UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, tailOffset, t, nt);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><ul><li>transfer核心方法</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">E <span class="title function_">transfer</span><span class="params">(E e, <span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="type">QNode</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;					<span class="comment">// s指向当前请求对应的node</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isData</span> <span class="operator">=</span> (e != <span class="literal">null</span>);	<span class="comment">// 是否是Data类型的请求</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="type">QNode</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="type">QNode</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span> || h == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (h == t || t.isData == isData) {		<span class="comment">// 空队列，或者队尾类型和当前一样（说明无法匹配）</span></span><br><span class="line">            <span class="type">QNode</span> <span class="variable">tn</span> <span class="operator">=</span> t.next;					<span class="comment">// 获取队尾t的next节点</span></span><br><span class="line">            <span class="keyword">if</span> (t != tail)						<span class="comment">// 多线程情况下，其他线程可能修改队尾节点</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (tn != <span class="literal">null</span>) {					<span class="comment">// 已经有线程入队了，更新tail</span></span><br><span class="line">                advanceTail(t, tn);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>)			<span class="comment">// 如果允许超时，超时时间小于0，这种方法不支持阻塞等待</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="literal">null</span>)						<span class="comment">// 创建当前Node</span></span><br><span class="line">                s = <span class="keyword">new</span> <span class="title class_">QNode</span>(e, isData);</span><br><span class="line">            <span class="keyword">if</span> (!t.casNext(<span class="literal">null</span>, s))			<span class="comment">// 当前Node添加到队尾</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            advanceTail(t, s);					<span class="comment">// 更新队尾指针</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">x</span> <span class="operator">=</span> awaitFulfill(s, e, timed, nanos);	<span class="comment">// 阻塞等待</span></span><br><span class="line">            <span class="keyword">if</span> (x == s) {						<span class="comment">// 当前node为取消状态，需要出队</span></span><br><span class="line">                clean(t, s);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!s.isOffList()) {				<span class="comment">// 当前node仍在队列中，匹配成功，需要做出队逻辑</span></span><br><span class="line">                advanceHead(t, s);</span><br><span class="line">                <span class="keyword">if</span> (x != <span class="literal">null</span>)</span><br><span class="line">                    s.item = s;</span><br><span class="line">                s.waiter = <span class="literal">null</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> (x != <span class="literal">null</span>) ? (E)x : e;</span><br><span class="line"></span><br><span class="line">        } <span class="keyword">else</span> {										<span class="comment">// 队尾节点与当前请求节点互补匹配</span></span><br><span class="line">            <span class="type">QNode</span> <span class="variable">m</span> <span class="operator">=</span> h.next;							<span class="comment">// 需要和队头进行匹配</span></span><br><span class="line">            <span class="keyword">if</span> (t != tail || m == <span class="literal">null</span> || h != head)	<span class="comment">// 其他线程修改了队尾节点，或者已经把head.next匹配走了</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">Object</span> <span class="variable">x</span> <span class="operator">=</span> m.item;							<span class="comment">// 获取匹配节点的数据保存到x</span></span><br><span class="line">            <span class="keyword">if</span> (isData == (x != <span class="literal">null</span>) ||				<span class="comment">// 判断是否匹配成功</span></span><br><span class="line">                x == m ||</span><br><span class="line">                !m.casItem(x, e)) {</span><br><span class="line">                advanceHead(h, m);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            advanceHead(h, m);							<span class="comment">// 匹配完成，将头节点出队，让这个新的头节点成为dummy节点</span></span><br><span class="line">            LockSupport.unpark(m.waiter);				<span class="comment">// 唤醒该匹配节点的线程</span></span><br><span class="line">            <span class="keyword">return</span> (x != <span class="literal">null</span>) ? (E)x : e;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><ul><li>awaitFulfill</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Object <span class="title function_">awaitFulfill</span><span class="params">(QNode s, E e, <span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> timed ? System.nanoTime() + nanos : <span class="number">0L</span>;	<span class="comment">// 等待截止时间</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">w</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">spins</span> <span class="operator">=</span> ((head.next == s) ?									<span class="comment">// 自旋次数</span></span><br><span class="line">                 (timed ? maxTimedSpins : maxUntimedSpins) : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="keyword">if</span> (w.isInterrupted())		<span class="comment">// 被打断就取消</span></span><br><span class="line">            s.tryCancel(e);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">x</span> <span class="operator">=</span> s.item;			<span class="comment">// 获取当前Node数据域</span></span><br><span class="line">        <span class="keyword">if</span> (x != e)</span><br><span class="line">            <span class="keyword">return</span> x;				<span class="comment">// 当前请求为REQUEST类型，返回数据</span></span><br><span class="line">        <span class="keyword">if</span> (timed) {				<span class="comment">// 超时检查</span></span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) {</span><br><span class="line">                s.tryCancel(e);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (spins &gt; <span class="number">0</span>)				<span class="comment">// 自旋次数减1</span></span><br><span class="line">            --spins;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s.waiter == <span class="literal">null</span>)	<span class="comment">// 没有自旋次数了，把当前线程封装进waiter</span></span><br><span class="line">            s.waiter = w;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!timed)			<span class="comment">// 阻塞</span></span><br><span class="line">            LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; spinForTimeoutThreshold)</span><br><span class="line">            LockSupport.parkNanos(<span class="built_in">this</span>, nanos);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><h2 id="操作Pool"><a href="#操作Pool" class="headerlink" title="操作Pool"></a>操作Pool</h2><h3 id="创建方法"><a href="#创建方法" class="headerlink" title="创建方法"></a>创建方法</h3><h4 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h4><p><strong>Executor构造方法：</strong></p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,						// 核心线程数，即最小线程数</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,					// 最大线程数</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,					// 存活时间，核心线程数外的线程超时销毁</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,	// 阻塞队列，存放提交的任务</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,			// 线程工厂，创建线程时用到</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span>		<span class="comment">// 拒绝策略（线程达到最大，仍有新任务）</span></span><br></pre></td></tr></table></figure></div><p>拒绝策略有四个实现类：</p><ul><li><code>ThreadPoolExecutor.AbortPolicy</code>：让调用者抛出<code>RejectedExecutionException</code>异常（默认策略）</li><li><code>ThreadPoolExecutor.CallerRunsPolicy</code>：将某些任务回退到调用者，让调用者运行</li><li><code>ThreadPoolExecutor.DiscardPolicy</code>：直接丢弃任务</li><li><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：放弃队列中最早的任务，把当前任务加入队列中尝试再次提交</li></ul><p>其他框架的拒绝策略：</p><ul><li>Dubbo：抛出异常前记录日志，并dump线程栈信息，方便定位问题</li><li>Netty：创建一个新线程来执行任务</li><li>ActiveMQ：超时等待（60s），尝试放入队列</li><li>PinPoint：使用一个拒绝链，逐一尝试每种拒绝策略</li></ul><p><strong>工作原理：</strong></p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/12/23/tM2C1UuoJHlNfbD.png" alt="image-20231223173100161" style="zoom:50%"><ol><li><p>创建线程池（此时还没有创建线程）</p></li><li><p>当调用execute()方法添加一个任务时：</p><ul><li><p>如果当前线程数少于corePoolSize，马上创建线程运行任务</p></li><li><p>如果当前线程数大于等于corePoolSize，将这个任务放入队列</p></li><li><p>如果队列满了，但运行线程数还小于maximumPoolSize，<strong>创建非核心线程</strong>立即运行这个任务（对阻塞队列的任务来说不公平）</p></li><li><p>如果队列满了，且运行线程数大于等于maximumPoolSize，线程池会启动拒绝策略</p></li></ul></li><li><p>当一个线程完成任务，会从队列中取下一个任务来执行</p></li><li><p>当线程空闲时间超过keepAliveTime，会销毁线程（令线程数量收缩到corePoolSize大小）</p></li></ol><h4 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h4><p>提供了四种线程池的创建：</p><ul><li><code>newFixedThreadPool</code>：创建具有n个线程的线程池<ul><li>核心线程数 = 最大线程数（所以无需超时时间）</li><li>单向链表实现阻塞队列，默认大小<code>Integer.MAX_VALUE</code>（无界的），任务较多可能OOM</li><li>适用于任务量已知，相对耗时的长期任务</li></ul></li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><ul><li><code>newCachedThreadPool</code>：创建一个可扩容的线程池<ul><li>核心线程数是0，最大线程数是29个1，全是救急线程（60s后可以回收）</li><li><code>SynchronousQueue</code>作为阻塞队列，没有容量</li><li>适合任务数较密集，但每个任务执行时间较短的情况</li></ul></li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><ul><li><code>newSingleThreadExecutor</code>：创建只有一个线程的线程池<ul><li>保证所有任务按照指定顺序执行</li></ul></li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><h4 id="开发要求"><a href="#开发要求" class="headerlink" title="开发要求"></a>开发要求</h4><p><strong>阿里巴巴开发手册：</strong></p><ul><li>线程必须通过线程池提供<ul><li>减少内存消耗，避免过度切换</li></ul></li><li>线程池不允许使用Executors去创建，而是通过<code>ThreadPoolExecutor</code>的方式<ul><li>更明确线程池的运行规则</li><li>避免无界队列导致的OOM</li></ul></li></ul><p><strong>线程池多大合适：</strong></p><ul><li>总线程数是核心线程池数量的两倍<ul><li>过小不能充分利用系统资源</li><li>过大导致更多上下文切换</li></ul></li><li>核心线程数常用公式<ul><li>CPU密集型任务：N+1</li><li>IO密集型任务：2N 或者 N/(1-阻塞系数)，阻塞系数在0.8-0.9之间</li></ul></li></ul><h3 id="提交方法"><a href="#提交方法" class="headerlink" title="提交方法"></a>提交方法</h3><p><code>ExecutorService</code>类API：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>void execute(Runnable command)</code></td><td>执行任务（Executor 类 API）</td></tr><tr><td><code>Future&lt;?&gt; submit(Runnable task)</code></td><td>提交任务 task()</td></tr><tr><td><code>Future submit(Callable&lt;T&gt; task)</code></td><td>提交任务 task，用返回值 Future 获得任务执行结果</td></tr><tr><td><code>List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</code></td><td>提交 tasks 中所有任务</td></tr><tr><td><code>List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit)</code></td><td>提交 tasks 中所有任务，超时时间针对所有task，超时会取消没有执行完的任务，并抛出超时异常</td></tr><tr><td><code>T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</code></td><td>提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消</td></tr></tbody></table><ul><li>execute只能执行Runnable类型的任务，没有返回值</li><li>submit既能提交Runnable类型任务，也能提交Callable类型任务<ul><li>底层封装成FutureTask，然后调用execute执行</li></ul></li><li>execute直接抛出任务执行时的异常</li><li>submit会吞掉异常，可通过Future的get方法将任务执行时的异常重新抛出</li></ul><h3 id="关闭方法"><a href="#关闭方法" class="headerlink" title="关闭方法"></a>关闭方法</h3><p><code>ExecutorService</code>类API：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>void shutdown()</code></td><td>线程池状态变为SHUTDOWN，等待任务执行完后关闭线程池，不会接收新任务，但已提交任务会执行完，而且也可以添加线程（不绑定任务）</td></tr><tr><td><code>List&lt;Runnable&gt; shutdownNow()</code></td><td>线程池状态变为 STOP，用 interrupt 中断正在执行的任务，直接关闭线程池，不会接收新任务，会将队列中的任务返回</td></tr><tr><td><code>boolean isShutdown()</code></td><td>不在RUNNING状态的线程池，此执行者已被关闭，方法返回 true</td></tr><tr><td><code>boolean isTerminated()</code></td><td>线程池状态是否是TERMINATED，如果所有任务在关闭后完成，返回 true</td></tr><tr><td><code>boolean awaitTermination(long timeout, TimeUnit unit)</code></td><td>调用shutdown后，由于调用线程不会等待所有任务运行结束，如果它想在线程池 TERMINATED 后做些事情，可以利用此方法等待</td></tr></tbody></table><h3 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h3><p>execute会直接抛出任务执行时的异常，submit会吞掉异常</p><p><strong>方法一：主动捕获异常</strong></p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">executorService.submit(() -&gt; {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    }</span><br><span class="line">});</span><br></pre></td></tr></table></figure></div><p><strong>方法二：使用Future对象</strong></p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">Future&lt;?&gt; future = executorService.submit(() -&gt; {</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    future.get();</span><br><span class="line">} <span class="keyword">catch</span> (ExecutionException e) {</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><h3 id="状态信息"><a href="#状态信息" class="headerlink" title="状态信息"></a>状态信息</h3><p><code>ThreadPoolExecutor</code>使用int的<strong>高3位来表示线程池状态，低29位表示线程数量</strong>。</p><p>存储在原子变量<code>ctl</code>中，可以用一次CAS原子操作修改</p><ul><li>状态表示</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">ctl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BITS</span> <span class="operator">=</span> Integer.SIZE - <span class="number">3</span>;			<span class="comment">// 等于29，表示低29位</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CAPACITY</span>   <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;	<span class="comment">// 29位能装下的最大容量</span></span><br></pre></td></tr></table></figure></div><ul><li>四种状态</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RUNNING</span>    <span class="operator">=</span> -<span class="number">1</span> &lt;&lt; COUNT_BITS;		<span class="comment">// 111</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHUTDOWN</span>   <span class="operator">=</span>  <span class="number">0</span> &lt;&lt; COUNT_BITS;		<span class="comment">// 000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STOP</span>       <span class="operator">=</span>  <span class="number">1</span> &lt;&lt; COUNT_BITS;		<span class="comment">// 001</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TIDYING</span>    <span class="operator">=</span>  <span class="number">2</span> &lt;&lt; COUNT_BITS;		<span class="comment">// 010</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TERMINATED</span> <span class="operator">=</span>  <span class="number">3</span> &lt;&lt; COUNT_BITS;		<span class="comment">// 011</span></span><br></pre></td></tr></table></figure></div><table><thead><tr><th>状态</th><th>高3位</th><th>接收新任务</th><th>处理阻塞任务队列</th><th>说明</th></tr></thead><tbody><tr><td>RUNNING</td><td>111</td><td>Y</td><td>Y</td><td></td></tr><tr><td>SHUTDOWN</td><td>000</td><td>N</td><td>Y</td><td>不接收新任务，但处理阻塞队列剩余任务</td></tr><tr><td>STOP</td><td>001</td><td>N</td><td>N</td><td>中断正在执行的任务，并抛弃阻塞队列任务</td></tr><tr><td>TIDYING</td><td>010</td><td>-</td><td>-</td><td>任务全执行完毕，活动线程为 0 即将进入终结</td></tr><tr><td>TERMINATED</td><td>011</td><td>-</td><td>-</td><td>终止状态</td></tr></tbody></table><ul><li>获取当前线程数量</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">workerCountOf</span><span class="params">(<span class="type">int</span> c)</span>  { <span class="keyword">return</span> c &amp; CAPACITY; }</span><br></pre></td></tr></table></figure></div><ul><li>构建ctl</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rs：线程池状态；wc：线程数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ctlOf</span><span class="params">(<span class="type">int</span> rs, <span class="type">int</span> wc)</span> { <span class="keyword">return</span> rs | wc; }</span><br></pre></td></tr></table></figure></div><ul><li>比较线程池ctl</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RUNNING &lt; SHUTDOWN &lt; STOP &lt; TIDYING &lt; TERMINATED</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">runStateLessThan</span><span class="params">(<span class="type">int</span> c, <span class="type">int</span> s)</span> {	<span class="comment">// 当前状态是否小于某个状态</span></span><br><span class="line">    <span class="keyword">return</span> c &lt; s;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">runStateAtLeast</span><span class="params">(<span class="type">int</span> c, <span class="type">int</span> s)</span> {	<span class="comment">// 当前状态是否大于等于某个状态</span></span><br><span class="line">    <span class="keyword">return</span> c &gt;= s;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isRunning</span><span class="params">(<span class="type">int</span> c)</span> {				<span class="comment">// 当前状态是否是Running</span></span><br><span class="line">    <span class="keyword">return</span> c &lt; SHUTDOWN;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><ul><li>设置ctl</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ctl值加1，返回true或false</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">compareAndIncrementWorkerCount</span><span class="params">(<span class="type">int</span> expect)</span> {</span><br><span class="line">    <span class="keyword">return</span> ctl.compareAndSet(expect, expect + <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// ctl值减1，返回true或false</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">compareAndDecrementWorkerCount</span><span class="params">(<span class="type">int</span> expect)</span> {</span><br><span class="line">    <span class="keyword">return</span> ctl.compareAndSet(expect, expect - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自旋，将ctl值减1，直至成功</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">decrementWorkerCount</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">do</span> {} <span class="keyword">while</span> (! compareAndDecrementWorkerCount(ctl.get()));</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><h3 id="成员属性-1"><a href="#成员属性-1" class="headerlink" title="成员属性"></a>成员属性</h3><p><strong>成员变量：</strong></p><ul><li>线程池中存放Worker的容器</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Worker&gt;();</span><br></pre></td></tr></table></figure></div><ul><li>线程全局锁</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增减worker，或者修改线程池状态，需要持有锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br></pre></td></tr></table></figure></div><ul><li>可重入锁的条件变量</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外部调用awaitTermination时，会等待当前线程池状态位Terminatation为止</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">termination</span> <span class="operator">=</span> mainLock.newCondition();</span><br></pre></td></tr></table></figure></div><ul><li>相关参数</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> corePoolSize;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> maximumPoolSize;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> keepAliveTime;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;		<span class="comment">// 创建线程时的线程工厂</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;	<span class="comment">// 超过核心线程数，放入阻塞队列</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;	<span class="comment">// 拒绝策略</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">RejectedExecutionHandler</span> <span class="variable">defaultHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AbortPolicy</span>();	<span class="comment">// 默认策略</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> largestPoolSize;						<span class="comment">// 记录生命周期内线程数最大值</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> completedTaskCount;					<span class="comment">// 记录生命周期内完成任务的总数</span></span><br></pre></td></tr></table></figure></div><ul><li>控制核心线程数量内的线程是否可以回收</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> allowCoreThreadTimeOut;	<span class="comment">// 为true时，即使是核心线程，空闲时间超时也可以回收</span></span><br></pre></td></tr></table></figure></div><p><strong>内部类：</strong></p><ul><li>Worker类<ul><li>每个Worker会绑定一个初始任务，启动Worker时优先执行。</li><li>Worker继承自AQS，本身具有锁的特性，采用独占锁模式<ul><li>（state=0未占用，state&gt;0被占用，state&lt;0表示初始状态，不能被抢锁）</li></ul></li></ul></li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> {</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">final</span> Thread thread;			<span class="comment">// worker内部封装的工作线程</span></span><br><span class="line">    Runnable firstTask;				<span class="comment">// worker第一个执行的任务</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> completedTasks;	<span class="comment">// 记录当前worker完成的任务数量</span></span><br><span class="line"></span><br><span class="line">    Worker(Runnable firstTask) {	<span class="comment">// 构造方法</span></span><br><span class="line">        setState(-<span class="number">1</span>);				<span class="comment">// 设置AQS独占模式为初始化中状态，不能被抢占锁</span></span><br><span class="line">        <span class="built_in">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="built_in">this</span>.thread = getThreadFactory().newThread(<span class="built_in">this</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> unused)</span> {	<span class="comment">// 不可重入锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) {</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Executor.DefaultThreadFactory类</span></span><br><span class="line"><span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> {</span><br><span class="line">    <span class="comment">// 将当前worker指定为thread的指定方法，线程调用start()会调用r.run()</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(group, r,</span><br><span class="line">                          namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">                          <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">        t.setDaemon(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">        t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><ul><li>拒绝策略相关的内部类</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CallerRunsPolicy</span><br><span class="line">AbortPolicy</span><br><span class="line">DiscardPolicy</span><br><span class="line">DiscardOldestPolicy</span><br></pre></td></tr></table></figure></div><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><h4 id="提交方法-1"><a href="#提交方法-1" class="headerlink" title="提交方法"></a>提交方法</h4><p><code>ThreadPoolExecutor</code>=&gt;<code>AbstractExecutorService</code>=&gt;<code>ExecutorService</code>=&gt;<code>Executor</code></p><ul><li><code>submit()</code>方法，将提交的Runnable或者Callable封装为FutureTask执行。会返回任务对象，通过get阻塞获取结果</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractExecutorService类</span></span><br><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) {</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();		<span class="comment">// 空指针判断</span></span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="literal">null</span>);	<span class="comment">// Runnable对象封装为未来任务对象</span></span><br><span class="line">    execute(ftask);											<span class="comment">// 执行方法</span></span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span> {</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();	<span class="comment">// 空指针判断</span></span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);			<span class="comment">// Callable对象封装为未来任务对象</span></span><br><span class="line">    execute(ftask);										<span class="comment">// 执行方法</span></span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractExecutorService类</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="title function_">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;T&gt;(runnable, value);	<span class="comment">// Runnable封装成FutureTask，并指定返回值</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="title function_">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;T&gt;(callable);			<span class="comment">// Callable直接封装成FutureTask</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><ul><li><code>execute()</code>方法，执行任务，但是没有返回值。出现异常会直接抛出<ul><li>只能提交Runnable，或者FutureTask</li><li>有担保机制，保证线程池至少有一个worker</li></ul></li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ThreadPoolExecutor类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span>)						<span class="comment">// 非空判断</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();							<span class="comment">// 获取ctl最新值</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) {		<span class="comment">// 【case1】当前线程数少于核心线程数</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))			<span class="comment">// 直接创建一个新的worker，当前任务作为firstTask</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();							<span class="comment">// 添加worker失败（存在并发或者线程池状态改变了），重新获取ctl</span></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    												<span class="comment">// 【case2】线程数已达核心线程数，或者addWorker失败</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) {	<span class="comment">// 【case2】线程池是否处于Running状态，成立就将任务放入队列</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get()</span><br><span class="line">        <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))	<span class="comment">// 如果线程池状态被外部修改了，则要把提交的任务删除</span></span><br><span class="line">            reject(command);						<span class="comment">// 任务出队成功，走拒绝策略</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)		<span class="comment">// （担保机制）线程池是running状态，判断线程池中线程数量是否为0</span></span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);					<span class="comment">// （担保机制）保证线程池在running状态，至少有一个worker</span></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))		<span class="comment">// 【case3】offer失败，说明queue满了</span></span><br><span class="line">        reject(command);						<span class="comment">// 走拒绝策略</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><h4 id="添加线程"><a href="#添加线程" class="headerlink" title="添加线程"></a>添加线程</h4><ul><li><code>prestartAllCoreThreads()</code>方法，提前预热，创建所有的核心线程</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ThreadPoolExecutor类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">prestartAllCoreThreads</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (addWorker(<span class="literal">null</span>, <span class="literal">true</span>))</span><br><span class="line">        ++n;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><ul><li><code>addWorker()</code>方法：添加线程到线程池，返回true表示成功，且线程启动。<ul><li>首先判断线程池是否允许添加线程，允许线程数量+1，然后创建Worker加入线程池</li><li>SHUTDOWN状态也能添加线程，但是要求新的Worker没有<code>firstTask</code>，且当前queue不为空，来帮助执行队列中的任务</li></ul></li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ThreadPoolExecutor类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">addWorker</span><span class="params">(Runnable firstTask, <span class="type">boolean</span> core)</span> {</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();							<span class="comment">// 线程池ctl</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);						<span class="comment">// 线程池状态</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; !(rs == SHUTDOWN &amp;&amp; firstTask == <span class="literal">null</span> &amp;&amp; !workQueue.isEmpty()))	<span class="comment">// 如上条件</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);				<span class="comment">// 线程数量</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize))	<span class="comment">// 超过数量上限</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))	<span class="comment">// CAS线程数+1</span></span><br><span class="line">                <span class="keyword">break</span> retry;						<span class="comment">// 成功跳出循环</span></span><br><span class="line">            c = ctl.get();</span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)				<span class="comment">// 失败判断状态有无变化</span></span><br><span class="line">                <span class="keyword">continue</span> retry;						<span class="comment">// 有变化返回外层循环，重新判断</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    												<span class="comment">// 【令牌申请成功】开始创建线程</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerStarted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerAdded</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">Worker</span> <span class="variable">w</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        w = <span class="keyword">new</span> <span class="title class_">Worker</span>(firstTask);					<span class="comment">// 创建Worker（底层使用传入工厂的newTread方法）</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> w.thread;					<span class="comment">// 拿到其中的thread</span></span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span>) {							<span class="comment">// 确保工厂创建Thread没BUG</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();						<span class="comment">// 加互斥锁，要添加worker了</span></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(ctl.get());		<span class="comment">// 获取最新状态</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == <span class="literal">null</span>)) {	<span class="comment">// 确保满足条件</span></span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive())				<span class="comment">// 此时如果线程已经启动了，应该报错</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line">                    workers.add(w);					<span class="comment">// 添加到线程池</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;		<span class="comment">// 更新largestPoolSize</span></span><br><span class="line">                    workerAdded = <span class="literal">true</span>;</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) {						<span class="comment">// 如果已经成功添加到线程池，启动线程</span></span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">if</span> (!workerStarted)							<span class="comment">// 如果启动失败，做清理工作</span></span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> workerStarted;							<span class="comment">// 返回启动是否成功</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ThreadPoolExecutor类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addWorkerFailed</span><span class="params">(Worker w)</span> {</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();			<span class="comment">// 操作线程池，需要先获取全局锁</span></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">if</span> (w != <span class="literal">null</span>)</span><br><span class="line">            workers.remove(w);	<span class="comment">// 移除指定worker</span></span><br><span class="line">        decrementWorkerCount();	<span class="comment">// 线程池计数-1，相当于归还令牌</span></span><br><span class="line">        tryTerminate();			<span class="comment">// 尝试停止线程池</span></span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        mainLock.unlock();		<span class="comment">// 释放全局锁</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><h4 id="运行方法"><a href="#运行方法" class="headerlink" title="运行方法"></a>运行方法</h4><p><code>Worker</code>=&gt;<code>Runnable &amp; AQS</code></p><ul><li>Worker实现了Runnable接口，线程启动时会调用Worker的run方法</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ThreadPoolExecutor.Worker类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">    runWorker(<span class="built_in">this</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><ul><li>runWorker方法，会一直while循环获取任务并执行</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ThreadPoolExecutor类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runWorker</span><span class="params">(Worker w)</span> {</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> w.firstTask;		<span class="comment">// 获取worker的firstTask</span></span><br><span class="line">    w.firstTask = <span class="literal">null</span>;					<span class="comment">// 引用置空</span></span><br><span class="line">    w.unlock();							<span class="comment">// 初始化worker时设置state=-1，表示不允许抢占锁</span></span><br><span class="line">    									<span class="comment">// 设置state=0，exclusiveOwnerThread=null，开始独占模式强锁</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">completedAbruptly</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) {	<span class="comment">// firstTask不是null直接运行，否则去queue获取</span></span><br><span class="line">            w.lock();											<span class="comment">// worker加锁（表示不空闲）</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 说明线程处于STOP/TIDYING/TERMINATION，需要给线程一个中断信号</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) || </span><br><span class="line">                 <span class="comment">// 说明线程处于RUNNING或者SHUTDOWN状态，清除打断标记</span></span><br><span class="line">                 (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted())</span><br><span class="line">                <span class="comment">// 中断线程，标志位为true</span></span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                beforeExecute(wt, task);	<span class="comment">// 钩子方法，任务执行前的前置处理</span></span><br><span class="line">                <span class="type">Throwable</span> <span class="variable">thrown</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    task.run();				<span class="comment">// 执行任务</span></span><br><span class="line">                } <span class="keyword">catch</span> (RuntimeException x) {</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                } <span class="keyword">catch</span> (Error x) {</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                } <span class="keyword">catch</span> (Throwable x) {</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(x);</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    afterExecute(task, thrown);	<span class="comment">// 钩子方法，任务执行的后置处理</span></span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                task = <span class="literal">null</span>;					<span class="comment">// 局部变量task设为null，表示执行完成</span></span><br><span class="line">                w.completedTasks++;				<span class="comment">// 更新worker完成任务数量</span></span><br><span class="line">                w.unlock();						<span class="comment">// 解锁</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        completedAbruptly = <span class="literal">false</span>;				<span class="comment">// 正常退出，completedAbruptly=false</span></span><br><span class="line">        										<span class="comment">// 异常退出，completedAbruptly=true</span></span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        processWorkerExit(w, completedAbruptly);	<span class="comment">// 根据情况，向线程池中添加线程</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><ul><li>unlock()方法，重置锁</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ThreadPoolExecutor类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> { </span><br><span class="line">    release(<span class="number">1</span>); </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// AQS类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> {</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// ThreadPoolExecutor类</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> unused)</span> {</span><br><span class="line">    setExclusiveOwnerThread(<span class="literal">null</span>);	<span class="comment">// 设置持有者为 null</span></span><br><span class="line">    setState(<span class="number">0</span>);					<span class="comment">// 设置 state = 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><ul><li><code>getTask()</code>：获取任务，线程空闲时间超过keepAliveTime就会回收，判断依据时当前线程<strong>阻塞获取任务超过保活时间</strong><ul><li>方法返回null，代表当前线程要被回收了，进入退出逻辑</li></ul></li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ThreadPoolExecutor类</span></span><br><span class="line"><span class="keyword">private</span> Runnable <span class="title function_">getTask</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">timedOut</span> <span class="operator">=</span> <span class="literal">false</span>;	<span class="comment">// 超时标记</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();		<span class="comment">// 当前ctl</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);	<span class="comment">// 当前状态</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment">// RUNNING &lt; SHUTDOWN &lt; STOP &lt; TIDYING &lt; TERMINATED</span></span><br><span class="line">        <span class="comment">// 状态为SHUTDOWN且队列为空，或者状态为STOP之后，可以直接返回null了</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) {</span><br><span class="line">            decrementWorkerCount();			<span class="comment">// 自旋的方式让ctl值-1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);			<span class="comment">// 线程池中的线程数量</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 条件一：允许回收核心线程，那就无所谓了，都支持超时回收</span></span><br><span class="line">        <span class="comment">// 条件二：线程数大于核心线程数，有保活时间，去超时获取任务</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">timed</span> <span class="operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 条件一：如果线程数大于最大线程数，直接回收</span></span><br><span class="line">        <span class="comment">// 条件二：允许超时，且已经超时了，直接回收</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) {</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))	<span class="comment">// CAS将ctl减1，返回null，失败继续循环</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 根据是否需要超时回收，workQueue使用带超时的poll，或者take</span></span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">            	workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;			<span class="comment">// 成功直接返回</span></span><br><span class="line">            timedOut = <span class="literal">true</span>;		<span class="comment">// r为null，说明超时了</span></span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException retry) {</span><br><span class="line">            timedOut = <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><ul><li><code>processWorkerExit()</code>方法：线程退出线程池，也有担保机制</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ThreadPoolExecutor类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processWorkerExit</span><span class="params">(Worker w, <span class="type">boolean</span> completedAbruptly)</span> {</span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly)		<span class="comment">// 如果是异常退出的</span></span><br><span class="line">        decrementWorkerCount();	<span class="comment">// 发生了异常ctl还没有减1，ctl需要减1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        completedTaskCount += w.completedTasks;	<span class="comment">// 完成的任务数量加1</span></span><br><span class="line">        workers.remove(w);						<span class="comment">// worker从线程池移出</span></span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    tryTerminate();								<span class="comment">// 尝试停止线程池，唤醒下一个线程</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) {			<span class="comment">// 如果是RUNNING或者SHUTDOWN状态【担保机制】</span></span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) {				<span class="comment">// 不是异常退出，是对空闲线程回收</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())	<span class="comment">// 最小允许线程可以是0，但是队列又不为空，需要一个线程完成任务担保</span></span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)			<span class="comment">// 线程池中的线程数量大于min，可以直接返回，不需要添加worker</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        addWorker(<span class="literal">null</span>, <span class="literal">false</span>);						<span class="comment">// 是异常退出，需要添加worker</span></span><br><span class="line">        											<span class="comment">// 不是异常退出，但是线程池中线程不够，需要添加worker</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><h4 id="停止方法"><a href="#停止方法" class="headerlink" title="停止方法"></a>停止方法</h4><ul><li><code>shutdown()</code>方法：停止线程池，会等待执行完成</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ThreadPoolExecutor类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        advanceRunState(SHUTDOWN);	<span class="comment">// 设置状态为SHUTDOWN，如果已经大于SHUTDOWN了则直接返回</span></span><br><span class="line">        interruptIdleWorkers();		<span class="comment">// 中断空闲线程</span></span><br><span class="line">        onShutdown();				<span class="comment">// 空方法，留给子类用</span></span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    }</span><br><span class="line">    tryTerminate();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><ul><li><code>shutdownNow()</code>方法：直接关闭线程池，不会等待执行完成<ul><li>会返回没完成的任务列表</li></ul></li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ThreadPoolExecutor类</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span> {</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        advanceRunState(STOP);	<span class="comment">// 设置状态为STOP</span></span><br><span class="line">        interruptWorkers();		<span class="comment">// 中断所有线程</span></span><br><span class="line">        tasks = drainQueue();	<span class="comment">// 从阻塞队列中取出未处理的task</span></span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    }</span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;				<span class="comment">// 返回未处理的任务</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><ul><li><code>tryTerminate()</code>方法：设置为TERMINATED状态</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ThreadPoolExecutor类</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">tryTerminate</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();		<span class="comment">// 获取ctl的值</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) ||											<span class="comment">// 条件一，RUNNING状态</span></span><br><span class="line">            runStateAtLeast(c, TIDYING) ||							<span class="comment">// 条件二，TIDYING/TERMINATED状态</span></span><br><span class="line">            (runStateOf(c) == SHUTDOWN &amp;&amp; !workQueue.isEmpty()))	<span class="comment">// 条件三，SHUTDOWN状态，阻塞队列不为空</span></span><br><span class="line">            <span class="keyword">return</span>;								<span class="comment">// 直接返回</span></span><br><span class="line">        										</span><br><span class="line">        										<span class="comment">// 执行到这里，说明线程池状态为STOP，或者SHUTDOWN且队列为空</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) {			<span class="comment">// 线程池中线程数量不为0</span></span><br><span class="line">            <span class="comment">// 中断一个空闲线程，将导致阻塞在queue.take/queue.poll处的线程唤醒，最终getTask返回null。</span></span><br><span class="line">            <span class="comment">// 后面执行processWorkerExit退出逻辑时，会再次调用tryTerminate()，唤醒下一个空闲线程</span></span><br><span class="line">            interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">		</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 池中的线程数量为0时，来到这里</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) {	<span class="comment">// 设置状态为TIDYING，线程数为0</span></span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    terminated();							<span class="comment">// 结束线程池</span></span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));			<span class="comment">// 设置线程池状态为TERMINATED，线程数为0</span></span><br><span class="line">                    termination.signalAll();				<span class="comment">// 唤醒所有调用awaitTermination()方法的线程</span></span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><h3 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>FutureTask是未来任务对象，继承Runnable、Future接口，用于包装Callable对象，实现任务的提交</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Callable&lt;String&gt; stringCallable = () -&gt; <span class="string">"Hello"</span>;</span><br><span class="line">FutureTask&lt;String&gt; task = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(stringCallable);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> task.get();</span><br></pre></td></tr></table></figure></div><p>构造方法：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> {</span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="built_in">this</span>.callable = callable;				<span class="comment">// 属性注入</span></span><br><span class="line">    <span class="built_in">this</span>.state = NEW;						<span class="comment">// 状态设为NEW</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FutureTask</span><span class="params">(Runnable runnable, V result)</span> {</span><br><span class="line">    <span class="built_in">this</span>.callable = Executors.callable(runnable, result);	<span class="comment">// 适配器模式</span></span><br><span class="line">    <span class="built_in">this</span>.state = NEW;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Executors类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Callable&lt;T&gt; <span class="title function_">callable</span><span class="params">(Runnable task, T result)</span> {</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RunnableAdapter</span>&lt;T&gt;(task, result);			<span class="comment">// 适配器模式，将Runnable转换为Callable</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Executors类内部类</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">RunnableAdapter</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;T&gt; {</span><br><span class="line">    <span class="keyword">final</span> Runnable task;</span><br><span class="line">    <span class="keyword">final</span> T result;</span><br><span class="line">    </span><br><span class="line">    RunnableAdapter(Runnable task, T result) {				<span class="comment">// 适配器模式，将Runnable转换为Callable</span></span><br><span class="line">        <span class="built_in">this</span>.task = task;</span><br><span class="line">        <span class="built_in">this</span>.result = result;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">call</span><span class="params">()</span> {</span><br><span class="line">        task.run();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><h4 id="成员属性-2"><a href="#成员属性-2" class="headerlink" title="成员属性"></a>成员属性</h4><p>FutureTask类的成员属性</p><ul><li>任务状态</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;						<span class="comment">// 当前状态</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NEW</span>          <span class="operator">=</span> <span class="number">0</span>;		<span class="comment">// 任务创建，尚未执行</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COMPLETING</span>   <span class="operator">=</span> <span class="number">1</span>;		<span class="comment">// 任务正在结束，尚未完全结束</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NORMAL</span>       <span class="operator">=</span> <span class="number">2</span>;		<span class="comment">// 任务正常结束</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">EXCEPTIONAL</span>  <span class="operator">=</span> <span class="number">3</span>;		<span class="comment">// 任务执行发生异常</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span>    <span class="operator">=</span> <span class="number">4</span>;		<span class="comment">// 任务被取消</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INTERRUPTING</span> <span class="operator">=</span> <span class="number">5</span>;		<span class="comment">// 任务中断中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INTERRUPTED</span>  <span class="operator">=</span> <span class="number">6</span>;		<span class="comment">// 任务已中断</span></span><br></pre></td></tr></table></figure></div><ul><li>任务对象</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Callable&lt;V&gt; callable;</span><br></pre></td></tr></table></figure></div><ul><li>存储任务执行的结果</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Object outcome;</span><br></pre></td></tr></table></figure></div><ul><li>执行任务的线程对象</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Thread runner;</span><br></pre></td></tr></table></figure></div><ul><li>线程阻塞队列的头节点</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> WaitNode waiters;</span><br></pre></td></tr></table></figure></div><ul><li>内部类</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">WaitNode</span> {</span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">    <span class="keyword">volatile</span> WaitNode next;</span><br><span class="line">    WaitNode() { thread = Thread.currentThread(); }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><h4 id="成员方法-1"><a href="#成员方法-1" class="headerlink" title="成员方法"></a>成员方法</h4><p><strong>任务执行：</strong></p><ul><li><code>FutureTask::run()</code>方法</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// 条件一：状态不是NEW，说明任务已经被别人执行过了。直接返回</span></span><br><span class="line">    <span class="comment">// 条件二：尝试将runner设为自己的线程，失败说明被别人抢去了。直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">        !UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, runnerOffset,</span><br><span class="line">                                     <span class="literal">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="literal">null</span> &amp;&amp; state == NEW) {</span><br><span class="line">            V result;</span><br><span class="line">            <span class="type">boolean</span> ran;				<span class="comment">// 表示是否抛出过异常</span></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = <span class="literal">true</span>;				<span class="comment">// 没有异常</span></span><br><span class="line">            } <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">                result = <span class="literal">null</span>;</span><br><span class="line">                ran = <span class="literal">false</span>;			<span class="comment">// 有异常</span></span><br><span class="line">                setException(ex);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (ran)</span><br><span class="line">                set(result);			<span class="comment">// 设置返回值</span></span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        runner = <span class="literal">null</span>;					<span class="comment">// 任务执行完成，取消线程引用</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)			<span class="comment">// 判断任务是否被中断</span></span><br><span class="line">            handlePossibleCancellationInterrupt(s);	<span class="comment">// 执行中断处理方法，见后面</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><ul><li><code>FutureTask::run()</code>方法，设置返回值</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(V v)</span> {</span><br><span class="line">    <span class="comment">// CAS设置当前状态为COMPLETING，失败说明任务被其他线程取消了</span></span><br><span class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, NEW, COMPLETING)) {</span><br><span class="line">        outcome = v;										<span class="comment">// 将值赋给outcome</span></span><br><span class="line">        UNSAFE.putOrderedInt(<span class="built_in">this</span>, stateOffset, NORMAL);	<span class="comment">// 当前任务状态修改为NORMAL</span></span><br><span class="line">        finishCompletion();									<span class="comment">// 见后面</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><ul><li><code>FutureTask::setException()</code>方法，设置异常返回值</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">setException</span><span class="params">(Throwable t)</span> {</span><br><span class="line">    <span class="comment">// CAS设置当前状态为COMPLETING</span></span><br><span class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, NEW, COMPLETING)) {</span><br><span class="line">        outcome = t;											<span class="comment">// 异常值赋给outcome，用来往外抛</span></span><br><span class="line">        UNSAFE.putOrderedInt(<span class="built_in">this</span>, stateOffset, EXCEPTIONAL);	<span class="comment">// 当前任务状态修改为EXCEPTIONAL</span></span><br><span class="line">        finishCompletion();										<span class="comment">// 见后面</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><ul><li><code>FutureTask::finishCompletion()</code>方法，唤醒get阻塞线程</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">finishCompletion</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="literal">null</span>;) {		<span class="comment">// 遍历所有等待的节点</span></span><br><span class="line">        <span class="comment">// 使用CAS设置waiter为null，防止外部线程使用cancel取消当前任务，触发finishCompletion重复执行</span></span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, waitersOffset, q, <span class="literal">null</span>)) {</span><br><span class="line">            <span class="keyword">for</span> (;;) {</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> q.thread;		<span class="comment">// 获取当前waitNode节点封装的thread</span></span><br><span class="line">                <span class="keyword">if</span> (t != <span class="literal">null</span>) {			<span class="comment">// 当前线程不为null，唤醒get等待获取数据的线程</span></span><br><span class="line">                    q.thread = <span class="literal">null</span>;</span><br><span class="line">                    LockSupport.unpark(t);</span><br><span class="line">                }</span><br><span class="line">                <span class="type">WaitNode</span> <span class="variable">next</span> <span class="operator">=</span> q.next;		<span class="comment">// 获取下一个节点</span></span><br><span class="line">                <span class="keyword">if</span> (next == <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                q.next = <span class="literal">null</span>;				<span class="comment">// 断开链表</span></span><br><span class="line">                q = next;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    done();</span><br><span class="line">    callable = <span class="literal">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><ul><li><code>FutureTask::handlePossibleCancellationInterrupt()</code>方法，任务中断处理</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handlePossibleCancellationInterrupt</span><span class="params">(<span class="type">int</span> s)</span> {</span><br><span class="line">    <span class="keyword">if</span> (s == INTERRUPTING)</span><br><span class="line">        <span class="keyword">while</span> (state == INTERRUPTING)</span><br><span class="line">            Thread.<span class="keyword">yield</span>();		<span class="comment">// 需要一直等待中断完成</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p><strong>结果获取：</strong></p><ul><li><code>FutureTask::get()</code>方法，获取线程执行的返回值。可以有多个线程get</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException {</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> state;			<span class="comment">// 获取当前任务状态</span></span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING)	<span class="comment">// 条件成立，说明还没执行完成</span></span><br><span class="line">        s = awaitDone(<span class="literal">false</span>, <span class="number">0L</span>);	<span class="comment">// 等待完成，最终返回状态</span></span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><ul><li><code>FutureTask::awaitDone()</code>方法，get线程封装成<code>WaitNode</code>对象，进入阻塞队列等待</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">awaitDone</span><span class="params">(<span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> timed ? System.nanoTime() + nanos : <span class="number">0L</span>;	<span class="comment">// 等候的DDL</span></span><br><span class="line">    <span class="type">WaitNode</span> <span class="variable">q</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">queued</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) {				<span class="comment">// 返回true说明被打断，会清除打断标记</span></span><br><span class="line">            removeWaiter(q);					<span class="comment">// 当前waitNode出队</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();	<span class="comment">// 抛出错误</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> state;						<span class="comment">// 获取任务状态</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt; COMPLETING) {				<span class="comment">// 条件成立，说明已经有结果了</span></span><br><span class="line">            <span class="keyword">if</span> (q != <span class="literal">null</span>)</span><br><span class="line">                q.thread = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING)			<span class="comment">// 条件成立，说明任务接近完成，这里让线程释放一下cpu，下一次再抢占</span></span><br><span class="line">            Thread.<span class="keyword">yield</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="literal">null</span>)					<span class="comment">// 【第一次自旋】创建WaitNode对象</span></span><br><span class="line">            q = <span class="keyword">new</span> <span class="title class_">WaitNode</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!queued)					<span class="comment">// 【第二次自旋】创建了WaitNode对象，但还没入队</span></span><br><span class="line">            <span class="comment">// waiters指向队首，CAS让waiters指向当前WaitNode（头插法）</span></span><br><span class="line">            queued = UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, waitersOffset, q.next = waiters, q);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (timed) {</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) {</span><br><span class="line">                removeWaiter(q);</span><br><span class="line">                <span class="keyword">return</span> state;</span><br><span class="line">            }</span><br><span class="line">            LockSupport.parkNanos(<span class="built_in">this</span>, nanos);	<span class="comment">// 超时阻塞等待</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            LockSupport.park(<span class="built_in">this</span>);				<span class="comment">// 阻塞等待</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><ul><li><code>FutureTask::report()</code>方法，封装运行结果（成员变量outcome）</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> V <span class="title function_">report</span><span class="params">(<span class="type">int</span> s)</span> <span class="keyword">throws</span> ExecutionException {</span><br><span class="line">    <span class="type">Object</span> <span class="variable">x</span> <span class="operator">=</span> outcome;</span><br><span class="line">    <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">        <span class="keyword">return</span> (V)x;							<span class="comment">// 正常结束，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CancellationException</span>();		<span class="comment">// 被取消或中断，抛出异常</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExecutionException</span>((Throwable)x);	<span class="comment">// 说明自定义的Callable方法有异常，抛出outcome异常</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><ul><li><code>FutureTask::cancel()</code>方法，任务取消，打断正在执行该任务的线程</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span> {</span><br><span class="line">    <span class="comment">// 条件一：表示当前任务处于运行中，或者队列中</span></span><br><span class="line">    <span class="comment">// 条件二：修改状态，成功才能继续执行，否则返回false</span></span><br><span class="line">    <span class="keyword">if</span> (!(state == NEW &amp;&amp;</span><br><span class="line">          UNSAFE.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, NEW,</span><br><span class="line">                                   mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">if</span> (mayInterruptIfRunning) {		<span class="comment">// 如果任务已经运行允许被打断</span></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> runner;			<span class="comment">// 获取当前FutureTask的thread</span></span><br><span class="line">                <span class="keyword">if</span> (t != <span class="literal">null</span>)</span><br><span class="line">                    t.interrupt();			<span class="comment">// 打断</span></span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                UNSAFE.putOrderedInt(<span class="built_in">this</span>, stateOffset, INTERRUPTED);	<span class="comment">// 设置状态为打断完成</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        finishCompletion();					<span class="comment">// 唤醒所有get阻塞的线程</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><h2 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h2><h3 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h3><p>Timer实现定时任务</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">TimerTask</span> <span class="variable">task1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimerTask</span>() {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"task1"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">TimerTask</span> <span class="variable">task2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimerTask</span>() {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"task2"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用timer添加两个任务，都是延时1s后执行</span></span><br><span class="line"><span class="comment">// 但由于timer内，只有一个线程来顺序执行任务，因此task1的延时会影响task2的执行</span></span><br><span class="line">timer.schedule(task1, <span class="number">1000</span>);</span><br><span class="line">timer.schedule(task2, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure></div><h3 id="Scheduled"><a href="#Scheduled" class="headerlink" title="Scheduled"></a>Scheduled</h3><p>任务调度线程池<code>ScheduledThreadPoolExecutor</code>，继承<code>ThreadPoolExecutor</code></p><ul><li>使用内部类<code>ScheduledFutureTask</code>，封装任务</li><li>使用内部类<code>DelayedWorkQueue</code>，作为线程池队列</li><li>重写<code>onShutdown</code>方法，去处理shutdown后的任务</li><li>提供<code>decorateTask</code>方法，作为<code>ScheduledFutureTask</code> 的修饰方法，以便开发者进行扩展</li></ul><p><strong>构造方法：</strong></p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">10</span>);</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Executors类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newScheduledThreadPool</span><span class="params">(<span class="type">int</span> corePoolSize)</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(corePoolSize);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// ScheduledThreadPoolExecutor类</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ScheduledThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize)</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最大线程数固定为MAX_VALUE，保活时间keepAliveTime固定为0</span></span><br><span class="line">    <span class="built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS, <span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>());</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p><strong>常用API：</strong></p><ul><li>返回值都是<code>ScheduledFuture&lt;?&gt;</code></li></ul><table><thead><tr><th>API</th><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>schedule</code></td><td><code>Runnable command, long delay, TimeUnit unit</code></td><td>执行延时任务</td></tr><tr><td><code>schedule</code></td><td><code>Callable&lt;V&gt; callable, long delay, TimeUnit unit</code></td><td>执行延时任务</td></tr><tr><td><code>scheduleAtFixedRate</code></td><td><code>Runnable command, long initialDelay, long period, TimeUnit unit</code></td><td>定时执行周期任务（不考虑执行的耗时）</td></tr><tr><td><code>scheduleWithFixedDelay</code></td><td><code>Runnable command, long initialDelay, long delay, TimeUnit unit</code></td><td>定时执行周期任务（要考虑执行的耗时）</td></tr></tbody></table><p><strong>基本使用：</strong></p><ul><li>延迟任务</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">executor.schedule(() -&gt; {</span><br><span class="line">    System.out.println(<span class="string">"task1"</span>);</span><br><span class="line">}, <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure></div><ul><li>周期任务<code>scheduleAtFixedRate</code>，<strong>一次任务启动到下一次任务启动之间</strong>，只要大于间隔时间，抢占到CPU就会立即执行</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">executor.scheduleAtFixedRate(() -&gt; {</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">}, <span class="number">1000</span>, <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两次打印间隔2s</span></span><br></pre></td></tr></table></figure></div><ul><li>周期任务<code>scheduleWithFixedDelay</code>，<strong>一次任务结束到下一次任务开始间隔</strong>，严格等于<code>initialDelay</code></li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">executor.scheduleWithFixedDelay(() -&gt; {</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">}, <span class="number">1000</span>, <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两次打印间隔3s</span></span><br></pre></td></tr></table></figure></div><h2 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h2><p>ForkJoin：线程池的实现，体现的是分治思想，用于并行计算。</p><p>任务拆分：将一个大任务拆分为算法上相同的小任务，直至不能拆分，可以直接求解。</p><p>跟递归相关的一些计算，比如归并排序，斐波那契数列都可以用分治思想。</p><ul><li>ForkJoin在分治基础上，加入了多线程，把每个任务的分解和合并交给不同线程来完成，提高了运算效率</li><li>ForkJoin使用ForkJoinPool来启动，是一个特殊的线程池，默认创建与CPU核心数大小相同的线程池</li><li>任务有返回值继承<code>RecursiveTask</code>，没有返回值继承<code>RecursiveAction</code></li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line"><span class="type">MyTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(<span class="number">100</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> pool.invoke(task);</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyTask</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将任务进行拆分</span></span><br><span class="line">        <span class="type">MyTask</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(n - <span class="number">1</span>);</span><br><span class="line">        t1.fork();</span><br><span class="line">        <span class="keyword">return</span> n + t1.join();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><ul><li>上一个拆分不是很合理，优化一下</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line"><span class="type">MyTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> pool.invoke(task);</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> begin;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> end;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyTask</span><span class="params">(<span class="type">int</span> begin, <span class="type">int</span> end)</span> {</span><br><span class="line">        <span class="built_in">this</span>.begin = begin;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (begin == end) {</span><br><span class="line">            <span class="keyword">return</span> begin;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (end - begin == <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">return</span> begin + end;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (begin + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">MyTask</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(begin, mid);</span><br><span class="line">        <span class="type">MyTask</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(mid + <span class="number">1</span>, end);</span><br><span class="line">        t1.fork();</span><br><span class="line">        t2.fork();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> t1.join() + t2.join();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p>ForkJoinPool实现了工作窃取算法，来提高CPU利用率</p><ul><li>每个线程都维护了一个双端队列，用来存储需要执行的任务</li><li>工作窃取算法：允许空闲的线程，从其他线程双端队列中窃取任务来执行<ul><li>窃取的必须是最晚的任务，避免和队列所属线程发生竞争（但是队列中只有一个任务时，还是会发生竞争）</li></ul></li></ul><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p><strong>享元模式</strong>：用于减少创建对象的数量，以减少内存占用和提高性能。</p><p><strong>异步模式</strong>：让有限的工作线程，轮流异步处理无限多的任务（典型实现：线程池）</p><p><strong>工作机制</strong>：享元模式，尝试重用现有的同类对象，如果未匹配才创建新对象</p><ul><li>自定义连接池：</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></div></div><div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8"><div class="article-copyright-info-container"><ul><li><strong>标题:</strong> JUC系列：（六）线程池</li><li><strong>作者:</strong> 布鸽不鸽</li><li><strong>创建于 :</strong> 2024-04-10 20:34:10</li><li><strong>更新于 :</strong> 2024-01-10 14:58:18</li><li><strong>链接:</strong> https://xuedongyun.cn//post/11329/</li><li><strong>版权声明: </strong>本文章采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a> 进行许可。</li></ul></div></div><ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden"><li class="tag-item mx-0.5"><a href="/tags/juc/">#juc</a>&nbsp;</li></ul><div class="recommended-article px-2 sm:px-6 md:px-8"><div class="recommended-desktop"><div class="recommended-article-header text-xl md:text-3xl font-bold mt-10"><i aria-hidden="true"></i><span>推荐阅读</span></div><div class="recommended-article-group"><a class="recommended-article-item" target="_blank" href="//post/1126/" title="JUC系列：（七）同步器" rel="bookmark noopener"><img src="/images/wallhaven-wqery6-light.webp" alt="JUC系列：（七）同步器" class="!max-w-none"> <span class="title">JUC系列：（七）同步器</span> </a><a class="recommended-article-item" target="_blank" href="//post/19310/" title="JUC系列：（二）线程" rel="bookmark noopener"><img src="/images/wallhaven-wqery6-light.webp" alt="JUC系列：（二）线程" class="!max-w-none"> <span class="title">JUC系列：（二）线程</span> </a><a class="recommended-article-item" target="_blank" href="//post/4016/" title="JUC系列：（三）同步" rel="bookmark noopener"><img src="/images/wallhaven-wqery6-light.webp" alt="JUC系列：（三）同步" class="!max-w-none"> <span class="title">JUC系列：（三）同步</span></a></div></div><div class="recommended-mobile"><div class="recommended-article-header text-xl md:text-3xl font-bold mt-10"><i aria-hidden="true"></i><span>推荐阅读</span></div><div class="recommended-article-group"><a class="recommended-article-item" target="_blank" href="//post/1126/" title="JUC系列：（七）同步器" rel="bookmark noopener"><img src="/images/wallhaven-wqery6-light.webp" alt="JUC系列：（七）同步器" class="!max-w-none"> <span class="title">JUC系列：（七）同步器</span> </a><a class="recommended-article-item" target="_blank" href="//post/19310/" title="JUC系列：（二）线程" rel="bookmark noopener"><img src="/images/wallhaven-wqery6-light.webp" alt="JUC系列：（二）线程" class="!max-w-none"> <span class="title">JUC系列：（二）线程</span></a></div></div></div><div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8"><div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2"><a class="prev" rel="prev" href="/post/62388/"><span class="left arrow-icon flex justify-center items-center"><i class="fa-solid fa-chevron-left"></i> </span><span class="title flex justify-center items-center"><span class="post-nav-title-item">JUC系列：（五）无锁</span> <span class="post-nav-item">上一篇</span></span></a></div><div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2"><a class="next" rel="next" href="/post/50019/"><span class="title flex justify-center items-center"><span class="post-nav-title-item">JUC系列：（一）进程</span> <span class="post-nav-item">下一篇</span> </span><span class="right arrow-icon flex justify-center items-center"><i class="fa-solid fa-chevron-right"></i></span></a></div></div><div class="comment-container px-2 sm:px-6 md:px-8 pb-8"><div class="comments-container mt-10 w-full"><div id="comment-anchor" class="w-full h-2.5"></div><div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">评论</div><div id="waline"></div><script type="module" data-swup-reload-script>import { init } from '/js/libs/waline.mjs';

      function loadWaline() {
        init({
          el: '#waline',
          serverURL: 'https://comment.xuedongyun.cn/',
          lang: 'zh-CN',
          dark: 'body[class~="dark-mode"]',
          reaction: false,
          requiredMeta: ['nick', 'mail'],
          emoji: [],
          recaptchaV3Key: "wasd",
          
        });
      }

      if (typeof swup !== 'undefined') {
        loadWaline();
      } else {
        window.addEventListener('DOMContentLoaded', loadWaline);
      }</script></div></div></div><div class="toc-content-container"><div class="post-toc-wrap"><div class="post-toc"><div class="toc-title">目录</div><div class="page-title">JUC系列：（六）线程池</div><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%BF%B0"><span class="nav-text">基本概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="nav-text">阻塞队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-text">基本介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95"><span class="nav-text">核心方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="nav-text">链表阻塞队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="nav-text">同步阻塞队列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9CPool"><span class="nav-text">操作Pool</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%96%B9%E6%B3%95"><span class="nav-text">创建方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%90%E4%BA%A4%E6%96%B9%E6%B3%95"><span class="nav-text">提交方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%97%AD%E6%96%B9%E6%B3%95"><span class="nav-text">关闭方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8"><span class="nav-text">处理异常</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-text">工作原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E4%BF%A1%E6%81%AF"><span class="nav-text">状态信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%B1%9E%E6%80%A7-1"><span class="nav-text">成员属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="nav-text">成员方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FutureTask"><span class="nav-text">FutureTask</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6"><span class="nav-text">任务调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Timer"><span class="nav-text">Timer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Scheduled"><span class="nav-text">Scheduled</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ForkJoin"><span class="nav-text">ForkJoin</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F"><span class="nav-text">享元模式</span></a></li></ol></div></div></div></div></div></div><div class="main-content-footer"><footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color"><div class="info-container py-3 text-center"><div class="text-center">&copy; <span>2022</span> - 2024&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration:0.5s;color:#f54545"></i>&nbsp;&nbsp;<a href="/">布鸽不鸽</a><p class="post-count space-x-0.5"><span>共撰写了 49 篇文章 </span><span>共 159k 字</span></p></div><script data-swup-reload-script src="https://cn.vercount.one/js"></script><div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right"><span id="busuanzi_container_site_uv" class="lg:!block"><span class="text-sm">访问人数</span> <span id="busuanzi_value_site_uv"></span> </span><span id="busuanzi_container_site_pv" class="lg:!block"><span class="text-sm">总访问量</span> <span id="busuanzi_value_site_pv"></span></span></div><div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left"><span class="lg:block text-sm">由 <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a> 驱动</span> <span class="text-sm lg:block">主题&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.7.2</a></span></div><div>博客已运行 <span class="odometer" id="runtime_days"></span> 天 <span class="odometer" id="runtime_hours"></span> 小时 <span class="odometer" id="runtime_minutes"></span> 分钟 <span class="odometer" id="runtime_seconds"></span> 秒</div><script data-swup-reload-script>try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}</script></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="article-tools-list"><li class="right-bottom-tools page-aside-toggle"><i class="fa-regular fa-outdent"></i></li><li class="go-comment"><i class="fa-regular fa-comments"></i></li></ul></div></div><div class="right-side-tools-container"><div class="side-tools-container"><ul class="hidden-tools-list"><li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center"><i class="fa-regular fa-magnifying-glass-plus"></i></li><li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center"><i class="fa-regular fa-magnifying-glass-minus"></i></li><li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center"><i class="fa-regular fa-moon"></i></li><li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center"><i class="fa-regular fa-arrow-down"></i></li></ul><ul class="visible-tools-list"><li class="right-bottom-tools toggle-tools-list flex justify-center items-center"><i class="fa-regular fa-cog fa-spin"></i></li><li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center"><i class="arrow-up fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><div class="image-viewer-container"><img src=""></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fa-solid fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="站内搜索您需要的内容..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa-solid fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.7.2/source/js/libs/Swup.min.js"></script><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.7.2/source/js/libs/SwupSlideTheme.min.js"></script><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.7.2/source/js/libs/SwupScriptsPlugin.min.js"></script><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.7.2/source/js/libs/SwupProgressPlugin.min.js"></script><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.7.2/source/js/libs/SwupScrollPlugin.min.js"></script><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.7.2/source/js/libs/SwupPreloadPlugin.min.js"></script><script>const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });</script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.7.2/source/js/tools/imageViewer.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.7.2/source/js/utils.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.7.2/source/js/main.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.7.2/source/js/layouts/navbarShrink.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.7.2/source/js/tools/scrollTopBottom.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.7.2/source/js/tools/lightDarkSwitch.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.7.2/source/js/layouts/categoryList.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.7.2/source/js/tools/localSearch.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.7.2/source/js/tools/codeBlock.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.7.2/source/js/layouts/lazyload.js"></script><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.7.2/source/js/tools/runtime.js"></script><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.7.2/source/js/libs/odometer.min.js"></script><link rel="stylesheet" href="https://evan.beee.top/projects/hexo-theme-redefine@2.7.2/source/assets/odometer-theme-minimal.css"><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.7.2/source/js/libs/Typed.min.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.7.2/source/js/plugins/typed.js"></script><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.7.2/source/js/libs/mermaid.min.js"></script><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.7.2/source/js/plugins/mermaid.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.7.2/source/js/tools/tocToggle.js" data-swup-reload-script></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.7.2/source/js/layouts/toc.js" data-swup-reload-script></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.7.2/source/js/plugins/tabs.js" data-swup-reload-script></script><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.7.2/source/js/libs/moment-with-locales.min.js" data-swup-reload-script></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.7.2/source/js/layouts/essays.js" data-swup-reload-script></script><div id="aplayer"></div><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.7.2/source/js/libs/APlayer.min.js"></script><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.7.2/source/js/plugins/aplayer.js"></script></body></html>